[
  {
    "id": 1,
    "question": "What is the primary result of using strict equality (`===`) versus loose equality (`==`) in JavaScript?",
    "options": [
      "Strict equality checks both value and type without coercion",
      "Loose equality is faster because it skips type checking",
      "Strict equality converts operands to strings before comparison",
      "Loose equality always returns false if the operands are different types"
    ],
    "answer": "Strict equality checks both value and type without coercion",
    "explanation": "The `===` operator returns `true` only if both operands are of the same type and have the same value. The `==` operator performs type coercion before comparing values.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which keyword declares a variable that cannot be reassigned but is mutable if it holds an object?",
    "options": [
      "var",
      "let",
      "const",
      "static"
    ],
    "answer": "const",
    "explanation": "`const` creates a read-only reference to a value, meaning the variable identifier cannot be reassigned. However, if the reference is to an object, the object's contents can still be modified.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the output of `console.log(typeof null)` in JavaScript?",
    "options": [
      "'null'",
      "'undefined'",
      "'object'",
      "'number'"
    ],
    "answer": "'object'",
    "explanation": "This is a historical bug in JavaScript. `typeof null` returns 'object' instead of 'null' for legacy reasons related to how values were stored in early V1 engines.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which concept describes a function retaining access to its lexical scope, even when executed outside that scope?",
    "options": [
      "Hoisting",
      "Closure",
      "Recursion",
      "Callback"
    ],
    "answer": "Closure",
    "explanation": "A closure occurs when a function remembers the variables from the scope in which it was defined, allowing it to access them later even after the outer function has returned.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What value does `Array.prototype.map()` return?",
    "options": [
      "The original array modified in place",
      "A new array with the results of calling a function on every element",
      "A boolean indicating if the array was modified",
      "undefined"
    ],
    "answer": "A new array with the results of calling a function on every element",
    "explanation": "`map()` is a pure functional method that creates a new array populated with the results of the callback function on every element in the calling array.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What happens when you add a number to a string in JavaScript (e.g., `1 + '1'`)?",
    "options": [
      "A SyntaxError is thrown",
      "The number is coerced into a string and concatenation occurs",
      "The string is coerced into a number and addition occurs",
      "The result is NaN"
    ],
    "answer": "The number is coerced into a string and concatenation occurs",
    "explanation": "JavaScript uses the `+` operator for both addition and concatenation. If one operand is a string, the other is converted to a string, and they are concatenated.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which of the following is NOT a valid JavaScript primitive data type?",
    "options": [
      "Symbol",
      "Boolean",
      "Array",
      "BigInt"
    ],
    "answer": "Array",
    "explanation": "Primitives are data that is not an object and has no methods. Arrays are objects in JavaScript, while Symbol, Boolean, and BigInt are primitives.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "How does the `this` keyword behave in an arrow function compared to a regular function?",
    "options": [
      "It binds to the object that owns the arrow function",
      "It always refers to the global window object",
      "It lexically inherits `this` from the enclosing parent scope",
      "It is undefined in arrow functions"
    ],
    "answer": "It lexically inherits `this` from the enclosing parent scope",
    "explanation": "Arrow functions do not have their own `this` context; instead, they capture the `this` value of the surrounding lexical context, making them ideal for callbacks.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the purpose of the `async` keyword before a function declaration?",
    "options": [
      "To make the function run on a separate thread immediately",
      "To allow the function to return an implicit Promise",
      "To prevent the function from throwing errors",
      "To automatically cache the return value of the function"
    ],
    "answer": "To allow the function to return an implicit Promise",
    "explanation": "Declaring a function as `async` ensures it returns a Promise. If a non-Promise value is returned, JavaScript automatically wraps it in a resolved Promise.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which method is used to parse a JSON string into a JavaScript object?",
    "options": [
      "JSON.stringify()",
      "JSON.parse()",
      "JSON.toObject()",
      "JSON.convert()"
    ],
    "answer": "JSON.parse()",
    "explanation": "`JSON.parse()` analyzes a JSON string and constructs the JavaScript value or object described by the string. `JSON.stringify()` does the opposite.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the result of the Boolean conversion of the following values: `0`, `''`, `null`, `undefined`, `NaN`?",
    "options": [
      "All evaluate to `true`",
      "All evaluate to `false`",
      "Only `0` and `null` evaluate to `false`",
      "Only `''` and `NaN` evaluate to `false`"
    ],
    "answer": "All evaluate to `false`",
    "explanation": "These are the only falsy values in JavaScript. All other values, including empty arrays `[]` and empty objects `{}`, evaluate to `true` in a boolean context.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the difference between `let` and `var` regarding scope?",
    "options": [
      "`let` is scoped to the function, while `var` is scoped to the block",
      "`var` is scoped to the block, while `let` is scoped to the function",
      "`let` is block-scoped, while `var` is function-scoped",
      "There is no difference; they are interchangeable"
    ],
    "answer": "`let` is block-scoped, while `var` is function-scoped",
    "explanation": "`var` declarations are function-scoped (visible throughout the function), whereas `let` declarations are block-scoped (visible only within the `{}` block).",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the default value of a function parameter if no argument is passed to it?",
    "options": [
      "null",
      "undefined",
      "0",
      "\"\""
    ],
    "answer": "undefined",
    "explanation": "If a function is called without arguments for a specific parameter, that parameter is initialized to `undefined` unless a default value is explicitly defined in the function signature.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which Array method changes the content of an array in place and returns the new length?",
    "options": [
      "slice()",
      "map()",
      "push()",
      "filter()"
    ],
    "answer": "push()",
    "explanation": "`push()` mutates the original array by adding elements to the end and returns the new length. `slice`, `map`, and `filter` do not mutate the original array.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the behavior of the `delete` operator on an object property?",
    "options": [
      "It removes the property from the object and sets the memory to null",
      "It removes the property from the object but leaves the array length unchanged",
      "It converts the property value to undefined",
      "It throws an error if the property does not exist"
    ],
    "answer": "It removes the property from the object but leaves the array length unchanged",
    "explanation": "The `delete` operator removes a given property from an object. On arrays, it removes the element, creating a 'hole' (empty slot), but does not update the `length` property.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What will `console.log(2 + '2' - 1)` output?",
    "options": [
      "21",
      "3",
      "NaN",
      "Error"
    ],
    "answer": "21",
    "explanation": "The `+` triggers string concatenation (`'22'`). The `-` operator triggers numeric conversion, treating `'22'` as a number. Therefore, `22 - 1` equals `21`.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which of the following best describes 'hoisting' in JavaScript?",
    "options": [
      "Moving declarations to the top of the current scope (file or function)",
      "Moving function calls to the bottom of the script",
      "Optimizing memory usage by deleting unused variables",
      "Delaying the execution of asynchronous code"
    ],
    "answer": "Moving declarations to the top of the current scope (file or function)",
    "explanation": "Hoisting is a behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the purpose of the `arguments` object inside a function?",
    "options": [
      "To store the return value of the function",
      "To access all passed arguments regardless of the number of parameters defined",
      "To define default values for the function parameters",
      "To reference the global scope variables"
    ],
    "answer": "To access all passed arguments regardless of the number of parameters defined",
    "explanation": "The `arguments` object is an array-like object accessible inside functions that contains the values of the arguments passed to that function.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which operator is used for optional chaining to safely access nested object properties?",
    "options": [
      "?.",
      "?.?",
      "??",
      "&&."
    ],
    "answer": "?.",
    "explanation": "The optional chaining operator (`?.`) allows you to safely access nested properties by short-circuiting if a reference is `null` or `undefined`, returning `undefined` instead of throwing an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the difference between `undefined` and `null`?",
    "options": [
      "`undefined` means a variable is declared but not defined; `null` is an intentional absence of value",
      "`null` means a variable does not exist; `undefined` means the value is zero",
      "They are exactly the same in value and type",
      "`undefined` is a boolean, `null` is an object"
    ],
    "answer": "`undefined` means a variable is declared but not defined; `null` is an intentional absence of value",
    "explanation": "`undefined` is the default value of uninitialized variables. `null` is a deliberate assignment representing 'no value' or 'empty'.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the output of `typeof NaN`?",
    "options": [
      "'NaN'",
      "'number'",
      "'undefined'",
      "'object'"
    ],
    "answer": "'number'",
    "explanation": "`NaN` stands for 'Not-a-Number', but in JavaScript's type system, it is technically a numeric value type, hence `typeof NaN` returns 'number'.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which method creates a new array with all sub-array elements concatenated into it recursively?",
    "options": [
      "flat()",
      "join()",
      "concat()",
      "reduce()"
    ],
    "answer": "flat()",
    "explanation": "`Array.prototype.flat()` creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "In the V8 engine, what mechanism handles the execution of callbacks after the Call Stack is empty?",
    "options": [
      "The Event Loop",
      "The DOM API",
      "The Callback Queue",
      "The Thread Pool"
    ],
    "answer": "The Event Loop",
    "explanation": "The Event Loop constantly monitors the Call Stack and the Callback Queue; if the Call Stack is empty, it pushes the first item from the Callback Queue onto the stack.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the result of `[1, 2, 3] + [4, 5, 6]`?",
    "options": [
      "[1, 2, 3, 4, 5, 6]",
      "1,2,34,5,6",
      "[[1, 2, 3], [4, 5, 6]]",
      "NaN"
    ],
    "answer": "1,2,34,5,6",
    "explanation": "When using the `+` operator on arrays, JavaScript converts them to strings using `.toString()` (comma-separated) and then concatenates the strings.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What does the `finally` block do in a `try...catch` statement?",
    "options": [
      "It executes only if the `try` block succeeds",
      "It executes only if the `catch` block runs",
      "It executes regardless of whether an exception was thrown or caught",
      "It stops the propagation of the error to the global scope"
    ],
    "answer": "It executes regardless of whether an exception was thrown or caught",
    "explanation": "The `finally` block contains code that runs after the `try` and `catch` blocks finish, regardless of the result, making it ideal for cleanup.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which operator returns the first 'truthy' value or the last 'falsy' value?",
    "options": [
      "|| (Logical OR)",
      "&& (Logical AND)",
      "?? (Nullish Coalescing)",
      "! (Logical NOT)"
    ],
    "answer": "|| (Logical OR)",
    "explanation": "The logical OR (`||`) operator checks from left to right and returns the first operand that can be converted to `true`, or the last operand if all are falsy.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which construct creates a private, block-scoped variable that can be reassigned but not accessed outside the block?",
    "options": [
      "private variable",
      "let",
      "var",
      "const"
    ],
    "answer": "let",
    "explanation": "`let` allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used, unlike `var` which scopes to the function.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is a Temporal Dead Zone (TDZ) related to `let` and `const`?",
    "options": [
      "The time before a variable is declared where it cannot be accessed",
      "The time after a variable is garbage collected",
      "The period where the V8 engine optimizes the variable",
      "A zone where `setTimeout` callbacks cannot access variables"
    ],
    "answer": "The time before a variable is declared where it cannot be accessed",
    "explanation": "The TDZ starts at the beginning of the block and ends when the variable is declared. Accessing the variable in this zone throws a `ReferenceError`.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which statement correctly exports a function from a module in ES6?",
    "options": [
      "module.exports = myFunc;",
      "export default myFunc;",
      "exports.myFunc = myFunc;",
      "provide myFunc;"
    ],
    "answer": "export default myFunc;",
    "explanation": "ES6 modules use the `export` keyword. `export default` is used to export a single value as the primary export from the module.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the difference between `call` and `apply`?",
    "options": [
      "`call` accepts an array of arguments; `apply` accepts a list of arguments",
      "`apply` accepts an array of arguments; `call` accepts a list of arguments",
      "`call` modifies the original function; `apply` creates a new one",
      "`apply` is used for classes, `call` is for objects"
    ],
    "answer": "`apply` accepts an array of arguments; `call` accepts a list of arguments",
    "explanation": "Both methods invoke a function with a specific `this` value. `call()` takes arguments individually, while `apply()` takes them as a single array.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which feature allows importing only specific parts of a module?",
    "options": [
      "Named imports",
      "Namespace imports",
      "Default imports",
      "Dynamic imports"
    ],
    "answer": "Named imports",
    "explanation": "Named imports allow you to selectively load specific exported members from a module using the syntax `import { name } from 'module'`.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the result of the `!!` operator on a value?",
    "options": [
      "It inverts the boolean value of the operand",
      "It converts the operand to its boolean equivalent (true or false)",
      "It performs a logical AND operation",
      "It checks if the variable is defined"
    ],
    "answer": "It converts the operand to its boolean equivalent (true or false)",
    "explanation": "The double negation (`!!`) operator is a common idiom to explicitly coerce any value to its corresponding boolean primitive (`true` or `false`).",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "How do you write a multi-line string in modern JavaScript (ES6+)?",
    "options": [
      "Using backticks (` `)",
      "Using single quotes with a newline escape (`\\n`)",
      "Using double quotes",
      "Using the <string> tag"
    ],
    "answer": "Using backticks (` `)",
    "explanation": "Template literals, enclosed by backticks, allow strings to span multiple lines and embed expressions using `${variable}` syntax.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of `Symbol` in JavaScript?",
    "options": [
      "To create immutable, unique identifiers for object properties",
      "To replace the `typeof` operator",
      "To define constants for configuration",
      "To encrypt data stored in objects"
    ],
    "answer": "To create immutable, unique identifiers for object properties",
    "explanation": "A Symbol is a primitive data type that represents a unique token, guaranteed never to clash with other Symbol keys, often used for hidden object properties.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which method iterates over the enumerable properties of an object?",
    "options": [
      "Object.keys()",
      "for...of",
      "for...in",
      "Object.values()"
    ],
    "answer": "for...in",
    "explanation": "The `for...in` loop iterates over all enumerable string properties of an object (including inherited ones), unlike `Object.keys` which only returns own properties.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In the context of the JavaScript Event Loop, what distinguishes Microtasks from Macrotasks?",
    "options": [
      "Microtasks run after every macrotask in the queue, while macrotasks run only when the call stack is empty",
      "Microtasks have higher priority and are processed completely after the current operation finishes, before the next macrotask",
      "Macrotasks are handled by the browser API while microtasks are handled exclusively by the V8 garbage collector",
      "Microtasks are asynchronous operations like setTimeout, whereas macrotasks are Promise callbacks"
    ],
    "answer": "Microtasks have higher priority and are processed completely after the current operation finishes, before the next macrotask",
    "explanation": "After the call stack is empty, the event loop processes the microtask queue (e.g., Promises) until it is empty, then picks one macrotask (e.g., setTimeout) from the macrotask queue.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary impact of 'Hidden Classes' on V8 engine performance?",
    "options": [
      "They provide a way to hide properties from the garbage collector to reduce memory pressure",
      "They allow V8 to inline function calls regardless of the object type passed to them",
      "They enable V8 to optimize property access by assuming objects with the same structure share the same memory layout",
      "They prevent JavaScript objects from being modified during runtime to ensure thread safety"
    ],
    "answer": "They enable V8 to optimize property access by assuming objects with the same structure share the same memory layout",
    "explanation": "V8 creates hidden classes (maps) to track the shape of objects. If objects share the same hidden class, V8 can use inline caching to access properties faster without expensive lookups.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which of the following code patterns will most likely cause V8 to 'deoptimize' a function?",
    "options": [
      "Using a `for` loop instead of a `while` loop for iteration",
      "Defining a function inside another function (closure)",
      "Assigning different types of data to the same variable over time (e.g., number, then string, then object)",
      "Using the `const` keyword to declare a variable"
    ],
    "answer": "Assigning different types of data to the same variable over time (e.g., number, then string, then object)",
    "explanation": "V8 optimizes code based on type feedback. If a variable or property changes its type frequently (polymorphism), the assumptions made by the optimizing compiler (TurboFan) become invalid, triggering deoptimization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Why does JavaScript's `setTimeout` often have a minimum delay (e.g., 4ms) even when set to 0ms?",
    "options": [
      "The V8 engine requires at least 4ms to compile the callback function",
      "The browser throttles nested timers to prevent CPU starvation and improve battery life",
      "The Event Loop enforces a mandatory 4ms sleep state for every iteration",
      "JavaScript execution is single-threaded and cannot process callbacks faster than 4ms"
    ],
    "answer": "The browser throttles nested timers to prevent CPU starvation and improve battery life",
    "explanation": "HTML5 standards specify that browsers should clamp timeouts to a minimum value (often 4ms) for timers nested a certain depth. This is a browser API constraint, not strictly V8, but affects execution timing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the technical behavior of the `await` keyword regarding the Promise returned by an async function?",
    "options": [
      "It blocks the main thread until the Promise resolves, preventing any other code execution",
      "It unwraps the Promise, returning the fulfillment value, and suspends the async function without blocking the main thread",
      "It converts the Promise into a synchronous callback using the Generator function prototype",
      "It forces the Promise to resolve immediately, cancelling any pending network requests"
    ],
    "answer": "It unwraps the Promise, returning the fulfillment value, and suspends the async function without blocking the main thread",
    "explanation": "`await` yields control back to the event loop, pausing the execution of the async function. It creates a microtask to resume the function when the Promise settles, allowing other code to run in the meantime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When comparing `Object.freeze()` with `const` declarations, what is the key difference regarding immutability?",
    "options": [
      "`Object.freeze()` prevents reassignment of the variable, while `const` prevents modification of object properties",
      "`const` creates a deep immutable object, whereas `Object.freeze()` only creates a shallow immutable object",
      "`Object.freeze()` prevents modification of object properties (shallow immutability), while `const` only prevents variable reassignment",
      "There is no difference; they both prevent changes to the object's memory address"
    ],
    "answer": "`Object.freeze()` prevents modification of object properties (shallow immutability), while `const` only prevents variable reassignment",
    "explanation": "`const` creates a read-only reference to the value, but if the value is an object, its properties can be changed. `Object.freeze()` makes the object's properties non-writable and non-configurable (shallowly).",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In V8's compilation pipeline, what is the specific role of 'On-Stack Replacement' (OSR)?",
    "options": [
      "To replace the entire V8 engine with a WebAssembly module for better performance",
      "To swap optimized machine code into a currently running function that has not yet returned (e.g., a long loop)",
      "To replace old garbage collected objects on the stack with new compressed pointers",
      "To dynamically convert a stack trace into a human-readable error message"
    ],
    "answer": "To swap optimized machine code into a currently running function that has not yet returned (e.g., a long loop)",
    "explanation": "OSR allows V8 to switch a function from unoptimized bytecode to optimized machine code in the middle of execution. This is crucial for optimizing long-running loops that never exit to be re-compiled.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the specific technical consequence of modifying the prototype of a built-in JavaScript object (e.g., `Array.prototype`)?",
    "options": [
      "It immediately triggers a runtime error because built-in prototypes are frozen",
      "It forces all V8 optimizations to be discarded globally, slowing down the entire application",
      "It can lead to 'prototype pollution' and breaks the assumption of 'hidden classes' for optimized property access on those objects",
      "It has no performance impact but violates the ESLint style guide"
    ],
    "answer": "It can lead to 'prototype pollution' and breaks the assumption of 'hidden classes' for optimized property access on those objects",
    "explanation": "Modifying built-in prototypes changes the shape of objects. This causes V8 to invalidate optimized code that assumed the original structure (Inline Caching misses) and creates compatibility issues across the global environment.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the V8 engine, what is 'Inline Caching' (IC) intended to optimize?",
    "options": [
      "The speed of network requests made via the `fetch` API",
      "The lookup time for object properties by caching the lookup result at the call site",
      "The compilation time of large JavaScript files by inlining CSS",
      "The memory usage of closures by freeing variables early"
    ],
    "answer": "The lookup time for object properties by caching the lookup result at the call site",
    "explanation": "Inline Caching relies on the observation that objects of the same type often share the same structure. V8 caches the location of a property access directly in the generated machine code to skip repeated lookups.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the primary function of the `finally` block in a `try...catch...finally` structure?",
    "options": [
      "To execute code only if no error was thrown in the `try` block",
      "To override the return value of the `catch` block if an error occurred",
      "To execute code regardless of whether an exception was thrown or caught, cleaning up resources",
      "To catch errors that were missed by the `catch` block"
    ],
    "answer": "To execute code regardless of whether an exception was thrown or caught, cleaning up resources",
    "explanation": "The `finally` block executes after the `try` and `catch` blocks complete, regardless of the result (return, throw, or normal completion). It is typically used for resource cleanup.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the output order of `console.log` statements in the following code? \n`setTimeout(() => console.log('A'), 0); \nPromise.resolve().then(() => console.log('B')); \nconsole.log('C');`",
    "options": [
      "A, B, C",
      "C, A, B",
      "C, B, A",
      "B, C, A"
    ],
    "answer": "C, B, A",
    "explanation": "Synchronous code ('C') runs first. Microtasks (Promise 'B') run immediately after the stack clears. Macrotasks (setTimeout 'A') run after the microtask queue is empty.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the 'Temporal Dead Zone' (TDZ) in the context of `let` and `const`?",
    "options": [
      "The period after a variable is declared but before it is garbage collected",
      "The time window where the variable is in scope but cannot be accessed, starting from the beginning of the block until the declaration line is reached",
      "A debug state in V8 where variables are frozen to prevent race conditions",
      "The delay caused by the JIT compiler when hoisting variables to the top of the function"
    ],
    "answer": "The time window where the variable is in scope but cannot be accessed, starting from the beginning of the block until the declaration line is reached",
    "explanation": "The TDZ creates a safety buffer where accessing the variable throws a `ReferenceError`. It enforces the rule that variables cannot be used until the declaration has been evaluated.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What distinguishes a Web Worker from the main thread in a browser environment?",
    "options": [
      "Web Workers have access to the DOM and can manipulate HTML elements directly",
      "Web Workers run in a completely separate global context (scope) and do not have access to the DOM",
      "Web Workers are synchronous by default and must be awaited using the `await` keyword",
      "Web Workers share the same memory heap as the main thread, allowing for lock-free concurrency"
    ],
    "answer": "Web Workers run in a completely separate global context (scope) and do not have access to the DOM",
    "explanation": "Web Workers execute in a background thread with a distinct global scope. This prevents blocking the UI thread, but it also restricts access to the DOM and `window` object for safety and concurrency reasons.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "When using `Object.assign()` to merge objects, what is the behavior regarding property descriptors like getters and setters?",
    "options": [
      "It invokes the getter on the source object and assigns the returned value to the target as a data property",
      "It copies the getter/setter functions by reference, maintaining the dynamic behavior on the target",
      "It throws a `TypeError` if the source object contains accessor properties",
      "It deep clones the getters and setters to prevent shared state"
    ],
    "answer": "It invokes the getter on the source object and assigns the returned value to the target as a data property",
    "explanation": "`Object.assign` performs a shallow copy by invoking the `[[Get]]` slot on the source and `[[Set]]` on the target. It does not copy accessor properties (getters/setters) as accessors; it copies the *value* they return.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How does V8's 'TurboFan' compiler differ from its 'Ignition' interpreter?",
    "options": [
      "Ignition parses the AST, while TurboFan performs garbage collection",
      "Ignition executes bytecode quickly, while TurboFan optimizes hot code into efficient machine code",
      "Ignition is used for WebAssembly, while TurboFan is used for standard JavaScript",
      "Ignition handles the DOM, while TurboFan handles the Network requests"
    ],
    "answer": "Ignition executes bytecode quickly, while TurboFan optimizes hot code into efficient machine code",
    "explanation": "V8 uses a pipeline: Ignition is the baseline interpreter generating bytecode. When code is identified as 'hot', TurboFan compiles it into optimized machine code for superior performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the specific behavior of `Promise.all` if one of the input promises rejects?",
    "options": [
      "It waits for all other promises to settle before returning an array of values and the rejection error",
      "It immediately rejects with the reason of the first rejected promise, discarding the results of other pending promises",
      "It catches the error internally and returns a resolved Promise with `null` in place of the failed promise",
      "It retries the rejected promise up to 3 times before finally rejecting"
    ],
    "answer": "It immediately rejects with the reason of the first rejected promise, discarding the results of other pending promises",
    "explanation": "`Promise.all` is fail-fast. As soon as any input promise rejects, `Promise.all` immediately rejects with that error, ignoring the status of other pending promises.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is 'hoisting' in JavaScript, specifically regarding `function` declarations versus `function` expressions?",
    "options": [
      "Both declarations and expressions are hoisted to the top of their scope, but expressions throw an error if called before definition",
      "Only function expressions are hoisted, whereas declarations remain in place until execution reaches them",
      "Function declarations are hoisted (moved to the top) and can be called before they appear in the code, unlike expressions",
      "Hoisting only applies to variables declared with `let`, not functions"
    ],
    "answer": "Function declarations are hoisted (moved to the top) and can be called before they appear in the code, unlike expressions",
    "explanation": "During the creation phase, function declarations are placed into memory before code execution. Function expressions assigned to variables are only hoisted as the variable declaration (e.g., `let x`), not the function assignment.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the value of `this` inside a standard function (non-arrow) called as a method on an object?",
    "options": [
      "It refers to the global object (window in browsers)",
      "It refers to the object the method is called on (the receiver)",
      "It is `undefined` because methods do not have a `this` context",
      "It refers to the function's own internal prototype"
    ],
    "answer": "It refers to the object the method is called on (the receiver)",
    "explanation": "The value of `this` in a function call depends on the call-site. When a function is called as a method (e.g., `obj.method()`), `this` is bound to the object `obj`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What mechanism allows JavaScript engines like V8 to optimize 'Tail Call Optimization' (TCO)?",
    "options": [
      "Converting recursive calls into a loop structure to avoid growing the call stack",
      "Allocating new stack frames for every recursive call to preserve the call history",
      "Automatically converting tail calls into WebAssembly modules",
      "Using the Web Workers API to offload recursive calls to a background thread"
    ],
    "answer": "Converting recursive calls into a loop structure to avoid growing the call stack",
    "explanation": "TCO allows a recursive function to be executed in constant stack space. The engine reuses the current stack frame for the next function call instead of adding a new one, effectively turning recursion into a loop.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "In the context of memory management, what creates a 'Closure'?",
    "options": [
      "Any function defined inside another function",
      "A function that retains access to variables in its lexical scope, even after that scope has finished executing",
      "A function that takes another function as an argument",
      "A function that explicitly returns a `this` context"
    ],
    "answer": "A function that retains access to variables in its lexical scope, even after that scope has finished executing",
    "explanation": "A closure is created when a function is defined inside another function and the inner function references variables of the outer function. The outer function's variables stay in memory as long as the inner function exists.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the `[[Prototype]]` in JavaScript's object model?",
    "options": [
      "A hidden property on every object pointing to the object it inherited from (its prototype)",
      "A property on the `Object` constructor that stores all class definitions",
      "A metadata field used by the garbage collector to track object age",
      "The explicit `__proto__` accessor which is deprecated in favor of `prototype`"
    ],
    "answer": "A hidden property on every object pointing to the object it inherited from (its prototype)",
    "explanation": "Objects have an internal slot `[[Prototype]]` (accessed via `Object.getPrototypeOf` or `__proto__`) which points to the prototype object. This forms the chain used for property lookup.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What happens when you use `Object.create(null)`?",
    "options": [
      "It creates an object that cannot have properties added to it",
      "It creates a truly empty object with no prototype chain (null prototype)",
      "It triggers an immediate garbage collection of the `Object` constructor",
      "It creates a singleton instance that throws an error if cloned"
    ],
    "answer": "It creates a truly empty object with no prototype chain (null prototype)",
    "explanation": "Passing `null` creates an object with `[[Prototype]]` set to `null`. It inherits no default methods (like `toString` or `hasOwnProperty`), making it useful for simple dictionaries/maps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which feature of the V8 engine allows it to reduce memory overhead for small integers?",
    "options": [
      "Smi (Small Integer) tagging, which stores small integers directly as pointers to avoid full object allocation",
      "The Compressed Pointer scheme, which halves the size of all variables",
      "The BigInt optimization, which converts small integers to floats",
      "Inline Caching for arithmetic operations"
    ],
    "answer": "Smi (Small Integer) tagging, which stores small integers directly as pointers to avoid full object allocation",
    "explanation": "V8 uses SMI tagging to represent 31-bit signed integers as raw values within pointers. This avoids the memory cost of allocating a full HeapObject for every number.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the purpose of the `static` keyword in JavaScript Classes?",
    "options": [
      "To define a method that cannot be overwritten by subclasses",
      "To define a method or property that belongs to the class constructor itself, not instances of the class",
      "To make a property private and inaccessible from outside the class",
      "To freeze the class definition so no new methods can be added later"
    ],
    "answer": "To define a method or property that belongs to the class constructor itself, not instances of the class",
    "explanation": "Static members are called on the class (e.g., `Math.random()`), not on an instance (`new Math()`). They are used for utility functions or class-level constants.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In the V8 engine, what specific runtime behavior occurs when a property is added to an object after its initial instantiation, assuming other objects share the same initial structure?",
    "options": [
      "V8 immediately promotes the object to a dictionary-based storage mode to handle dynamic keys.",
      "A new 'hidden class' (or map) transition is created, potentially causing inline cache (IC) misses and deoptimization.",
      "The object is moved to the 'old space' of the heap to prevent frequent garbage collection scans.",
      "The property is stored as a 'named property' while existing properties are converted to 'indexed elements' for faster access."
    ],
    "answer": "A new 'hidden class' (or map) transition is created, potentially causing inline cache (IC) misses and deoptimization.",
    "explanation": "V8 relies on hidden classes to optimize property access. Adding properties out of order changes the object's shape, creating a transition tree that prevents the monomorphic inline caching required for fastest execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 61,
    "question": "What is the specific role of 'On-Stack Replacement' (OSR) in the V8 optimization pipeline?",
    "options": [
      "It allows V8 to replace a running bytecode loop with an optimized machine code version mid-execution.",
      "It enables the garbage collector to relocate objects on the stack while the function is paused.",
      "It provides a mechanism to swap the current execution context from the main thread to a Web Worker.",
      "It detects when a function has become 'cold' and reverts it to the Ignition bytecode interpreter."
    ],
    "answer": "It allows V8 to replace a running bytecode loop with an optimized machine code version mid-execution.",
    "explanation": "OSR is critical for long-running loops. It allows the engine to switch from the slower Ignition interpreter to the optimized TurboFan code without waiting for the function to restart.",
    "difficulty": "Advanced"
  },
  {
    "id": 62,
    "question": "Considering JavaScript's event loop and microtask queue, what is the guaranteed behavior regarding the execution of `Promise.then()` callbacks versus `setTimeout()` callbacks?",
    "options": [
      "The event loop processes the entire macro-task queue before processing a single micro-task.",
      "`setTimeout` callbacks always execute before microtasks if the timeout delay is set to 0.",
      "Microtasks are processed after the current script completes but before the next macro-task is rendered.",
      "The order of execution is non-deterministic and depends entirely on the browser's thread scheduler."
    ],
    "answer": "Microtasks are processed after the current script completes but before the next macro-task is rendered.",
    "explanation": "The event loop drains the microtask queue (Promises, queueMicrotask) after every callback in the macrotask queue (setTimeout, I/O) finishes, ensuring high-priority async operations run sooner.",
    "difficulty": "Advanced"
  },
  {
    "id": 63,
    "question": "What is the result of the abstract equality comparison `[] == ![]` in JavaScript, and why?",
    "options": [
      "true, because an empty array is falsy and ![] is also falsy.",
      "false, because an array is an object and objects cannot be equal to booleans.",
      "true, because [] is converted to 0 (number) and ![] is converted to false, which is then converted to 0.",
      "false, because the strict type checking prevents the coercion of the array."
    ],
    "answer": "true, because [] is converted to 0 (number) and ![] is converted to false, which is then converted to 0.",
    "explanation": "According to ES spec, ![] becomes false. When comparing [] == false, the array is converted to a primitive (empty string \"\"), then to a number 0. The false is also converted to 0. Therefore, 0 == 0 is true.",
    "difficulty": "Advanced"
  },
  {
    "id": 64,
    "question": "In the context of Closures and the Execution Context, what happens to variables in the outer scope when a function is returned and invoked later?",
    "options": [
      "They are garbage collected immediately after the outer function returns unless marked as 'global'.",
      "They are serialized and stored in the heap, accessible only via the prototype chain.",
      "A closure is formed, maintaining a reference to the variable environment, keeping the variables in memory.",
      "They are copied by value into the function's local scope at the moment the function is returned."
    ],
    "answer": "A closure is formed, maintaining a reference to the variable environment, keeping the variables in memory.",
    "explanation": "Closures preserve the scope chain of the function in which they were defined. The variables remain in the heap (V8 \"Context\") because the inner function maintains a reference to its lexical environment.",
    "difficulty": "Advanced"
  },
  {
    "id": 65,
    "question": "What is the purpose of the `[[HomeObject]]` internal slot in ES6 classes regarding super calls?",
    "options": [
      "It stores the prototype of the current class to facilitate static property access.",
      "It holds a reference to the object that the method is bound to, allowing `super` to find the parent prototype dynamically.",
      "It creates a circular reference between the child and parent instances to enable inheritance.",
      "It ensures that `super` properties are prioritized in the garbage collection cycle."
    ],
    "answer": "It holds a reference to the object that the method is bound to, allowing `super` to find the parent prototype dynamically.",
    "explanation": "Super properties rely on `[[HomeObject]]` to know which object's prototype they should search. This is why arrow functions cannot have `super` methods, as they have no binding of their own.",
    "difficulty": "Advanced"
  },
  {
    "id": 66,
    "question": "Which statement accurately describes the behavior of the `delete` operator against properties that have the `configurable` attribute set to `false`?",
    "options": [
      "The property is removed from the object, but the memory is retained until garbage collection.",
      "The operation returns false in non-strict mode and throws a TypeError in strict mode.",
      "The property is copied to the prototype chain before being removed from the instance.",
      "The operation automatically converts the property to a temporary 'writable' state before deletion."
    ],
    "answer": "The operation returns false in non-strict mode and throws a TypeError in strict mode.",
    "explanation": "The `configurable` attribute prevents a property from being deleted or having its attributes changed. Attempting to `delete` a non-configurable property fails silently in sloppy mode or throws in strict mode.",
    "difficulty": "Advanced"
  },
  {
    "id": 67,
    "question": "When using `Object.freeze()` on a JavaScript object, what is the depth of the immutability it enforces?",
    "options": [
      "Deep freeze: it recursively traverses the object graph and freezes all nested objects and arrays.",
      "Shallow freeze: it prevents changes to the object's own properties, but nested objects remain mutable.",
      "It only prevents the addition of new properties but allows modification of existing property values.",
      "It converts the object into a primitive value, rendering it permanently read-only."
    ],
    "answer": "Shallow freeze: it prevents changes to the object's own properties, but nested objects remain mutable.",
    "explanation": "`Object.freeze` sets the `writable`, `configurable` attributes to false for *own* properties. It does not traverse the object graph, so references to other objects (like arrays or inner objects) within the frozen object can still be modified.",
    "difficulty": "Advanced"
  },
  {
    "id": 68,
    "question": "What is the primary technical distinction between a `Set` and a `WeakSet` in JavaScript regarding object storage?",
    "options": [
      "`WeakSet` can only store primitive values, whereas `Set` can store objects.",
      "`WeakSet` holds weak references to its objects, allowing garbage collection if no other references exist, while `Set` holds strong references.",
      "`Set` is synchronous while `WeakSet` is asynchronous and requires a callback for data retrieval.",
      "`WeakSet` automatically iterates over its members to remove duplicates, while `Set` relies on the `SameValueZero` algorithm."
    ],
    "answer": "`WeakSet` holds weak references to its objects, allowing garbage collection if no other references exist, while `Set` holds strong references.",
    "explanation": "Weak references in `WeakSet` (and `WeakMap`) do not prevent the garbage collector from destroying the object if there are no other strong references to it. This makes them ideal for keeping track of object associations without memory leaks.",
    "difficulty": "Advanced"
  },
  {
    "id": 69,
    "question": "How does the `temporal Dead Zone (TDZ)` specifically affect variables declared with `let` and `const`?",
    "options": [
      "It prevents the variable from being accessed or initialized from the start of the block until the declaration line is executed.",
      "It delays the allocation of memory for the variable until the runtime reaches the specific line of code.",
      "It sets the variable to `undefined` for the entire scope, updating the value only when the declaration is reached.",
      "It makes the variable accessible globally but restricts modifications within the block scope."
    ],
    "answer": "It prevents the variable from being accessed or initialized from the start of the block until the declaration line is executed.",
    "explanation": "The TDZ is the time window between entering a scope (where the variable is bound) and the actual declaration. Accessing the variable within this zone results in a ReferenceError.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "In JavaScript engines like V8, what is 'Speculative Optimization' based on?",
    "options": [
      "Static analysis of the source code text before execution begins.",
      "Assumptions made about object types and shapes based on previous executions (runtime profiling).",
      "Random optimization strategies applied to ensure no single execution path becomes a bottleneck.",
      "Developer annotations added to the code in the form of JSDoc comments."
    ],
    "answer": "Assumptions made about object types and shapes based on previous executions (runtime profiling).",
    "explanation": "V8 collects type feedback during execution. If a function is called with integers multiple times, it speculatively optimizes the machine code for integers. If this assumption later fails (e.g., a string is passed), the engine deoptimizes.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the output behavior of `Promise.race()` when the iterable passed to it contains a mixture of settled promises and pending promises?",
    "options": [
      "It returns the first promise in the iterable array, regardless of its state.",
      "It waits for all promises to settle and returns an array of their values.",
      "It settles immediately with the value or rejection reason of the first promise that settles among the iterables.",
      "It rejects immediately if the iterable contains any previously rejected promise."
    ],
    "answer": "It settles immediately with the value or rejection reason of the first promise that settles among the iterables.",
    "explanation": "`Promise.race` returns a promise that resolves or rejects as soon as one of the promises in the iterable settles (fulfills or rejects). It effectively races the promises against each other.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What mechanism allows JavaScript generators (function*) to pause and resume execution while maintaining their local state?",
    "options": [
      "Coroutines managed by the operating system kernel.",
      "A segmented stack implementation that is swapped on every yield.",
      "A suspended execution context saved in the generator's internal `[[GeneratorState]]` slot.",
      "Serializing the local variables into a JSON string on every `yield` expression."
    ],
    "answer": "A suspended execution context saved in the generator's internal `[[GeneratorState]]` slot.",
    "explanation": "When a generator yields, the current execution context (scope, variables, instruction pointer) is suspended. On the next `.next()`, this context is restored, allowing execution to resume exactly where it left off.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which statement correctly describes the resolution mechanism of the `this` keyword in an arrow function?",
    "options": [
      "It creates a new binding to the object on which the method was called.",
      "It lexically binds `this` to the value of `this` in the enclosing scope where the arrow function was defined.",
      "It defaults to the `window` object in strict mode and `undefined` in non-strict mode.",
      "It uses the `call()` or `apply()` methods to dynamically determine the `this` value at runtime."
    ],
    "answer": "It lexically binds `this` to the value of `this` in the enclosing scope where the arrow function was defined.",
    "explanation": "Unlike regular functions, arrow functions do not have their own `this` argument. They capture the `this` value of the surrounding parent scope at creation time.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the output of `console.log(typeof null)` in JavaScript, and what is the historical reason for it?",
    "options": [
      "'null', because null is a primitive type.",
      "'undefined', because null is coerced to undefined in type checks.",
      "'object', due to a legacy bug in the initial JavaScript implementation where type tags were represented.",
      "'number', because null is represented internally as a pointer value 0x00."
    ],
    "answer": "'object', due to a legacy bug in the initial JavaScript implementation where type tags were represented.",
    "explanation": "In early JavaScript, values were stored as type tags (32-bit) and values. The tag for objects was 000, and null (the null pointer) was also 000. This error is now permanently enshrined in the web standard.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "How does `Symbol.asyncIterator` enable `for await...of` loops to function with custom objects?",
    "options": [
      "It converts the object into a Promise that resolves to an array of values.",
      "It provides a global registry that automatically maps object properties to async keys.",
      "It defines a method that returns an iterator object with a `next()` method returning a Promise for the result.",
      "It allows the object to inherit from the AsyncGenerator prototype automatically."
    ],
    "answer": "It defines a method that returns an iterator object with a `next()` method returning a Promise for the result.",
    "explanation": "The `Symbol.asyncIterator` specifies that the object is async iterable. The protocol requires a `next()` method that returns a Promise which resolves to `{ value, done }`, enabling the loop to wait for async data.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the specific behavior of `Function.length` regarding default parameters and rest parameters?",
    "options": [
      "It returns the count of all declared arguments, including default and rest parameters.",
      "It returns the count of arguments *before* the first default parameter or rest parameter.",
      "It returns 0 for all arrow functions regardless of their parameter list.",
      "It counts the number of arguments actually passed during the last function invocation."
    ],
    "answer": "It returns the count of arguments *before* the first default parameter or rest parameter.",
    "explanation": "The `length` property reflects the function's arity. It stops counting once it encounters a default parameter or a rest parameter because they effectively make the remaining arguments optional or variadic.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of the V8 engine, what is 'Inline Caching' (IC) intended to optimize?",
    "options": [
      "The loading of JavaScript source files from the network cache.",
      "The speed of property access by caching the lookup result based on the object's hidden class.",
      "The memory footprint of closure variables by inlining them into the stack frame.",
      "The rendering pipeline of the browser by caching inline CSS styles."
    ],
    "answer": "The speed of property access by caching the lookup result based on the object's hidden class.",
    "explanation": "ICs assume that objects of the same class have the same property layout. It caches the memory offset of a property lookup. If the object's hidden class matches the cache, the property access is a single machine instruction.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the result of `console.log(1 + \"2\" + \"2\")` and why?",
    "options": [
      "\"122\", because addition is left-to-right and string conversion propagates.",
      "5, because the `+` operator prefers numeric addition.",
      "\"14\", because the first string concatenation results in 12, which is then converted to a number.",
      "NaN, because you cannot mathematically add a number to a string."
    ],
    "answer": "\"122\", because addition is left-to-right and string conversion propagates.",
    "explanation": "Operations are evaluated left-to-right. `1 + \"2\"` results in \"12\" (string concatenation). Then `\"12\" + \"2\"` results in \"122\". Once a string is introduced, the rest of the chain becomes string concatenation.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "When using `Proxy` objects, what is the impact of returning `false` from the `has` trap?",
    "options": [
      "It signals that the target object is empty.",
      "It breaks the iteration loop used by `for...in`.",
      "It indicates that the property does not exist on the target, causing the `in` operator to return false.",
      "It triggers a TypeError in strict mode preventing property deletion."
    ],
    "answer": "It indicates that the property does not exist on the target, causing the `in` operator to return false.",
    "explanation": "The `has` trap intercepts the `in` operator. Returning `false` tells the program that the property is not present on the proxied object, effectively hiding properties even if they physically exist on the target.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What does the `Finally` method of a JavaScript Promise do compared to `.then()` and `.catch()`?",
    "options": [
      "It intercepts the return value and converts it to a resolved Promise.",
      "It executes a callback regardless of the promise's fulfillment or rejection, without receiving any arguments.",
      "It runs only after all promises in a Promise.all group have settled.",
      "It acts as a catch-all for synchronous errors thrown within the promise executor."
    ],
    "answer": "It executes a callback regardless of the promise's fulfillment or rejection, without receiving any arguments.",
    "explanation": "The `.finally()` method is useful for cleanup code. It runs when the promise settles (either resolved or rejected) and receives no arguments, ensuring it doesn't need to know the specific outcome.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which ES6 feature allows you to export values while importing them, facilitating 'live' bindings?",
    "options": [
      "Re-exports using `export { default } from './module.js'`",
      "Named exports and imports: `export { foo }` and `import { foo }`",
      "Namespace imports using `import * as ns`",
      "Default exports using `export default`"
    ],
    "answer": "Named exports and imports: `export { foo }` and `import { foo }`",
    "explanation": "Named exports provide live bindings. If the exported variable changes in the exporting module, the value is immediately updated in the importing module. Default exports are values (or copies) and do not support this live behavior in the same way.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the primary distinction between `Reflect.apply` and `Function.prototype.apply`?",
    "options": [
      "`Reflect.apply` does not perform a `ToObject` coercion on the first argument (the target), whereas `Function.prototype.apply` does.",
      "`Reflect.apply` runs in the global scope, while `Function.prototype.apply` runs in the function's local scope.",
      "`Reflect.apply` can only be used on Arrow functions.",
      "There is no functional difference; `Reflect` is just a cleaner API."
    ],
    "answer": "`Reflect.apply` does not perform a `ToObject` coercion on the first argument (the target), whereas `Function.prototype.apply` does.",
    "explanation": "The `Reflect` API uses a `thisArg` and arguments array. Critically, if the target is not a function or is null/undefined, `Reflect` throws a TypeError, while `Function.prototype.apply` would attempt to coerce primitive types to objects (or throw differently) depending on the context.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In the `WeakRef` API, what is the technical purpose of the `deref()` method?",
    "options": [
      "To create a hard reference to the object, preventing it from being garbage collected.",
      "To return the target object if it is still in memory, or undefined if it has been collected.",
      "To disconnect the WeakRef from the object, effectively clearing the reference.",
      "To dereference a proxy object and return its underlying target."
    ],
    "answer": "To return the target object if it is still in memory, or undefined if it has been collected.",
    "explanation": "WeakRefs hold weak references. `deref()` allows you to check if the object still exists. Since the GC can reclaim the object at any time, `deref()` is the only way to safely attempt to access it.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does V8's 'Shallow Dive' garbage collection strategy differ for 'Young' vs 'Old' generations?",
    "options": [
      "The Old Generation is collected using a stop-the-world Mark-Sweep-Compact, while the Young Generation uses Scavenge (Copy).",
      "The Young Generation is collected infrequently, while the Old Generation is collected on every memory allocation.",
      "The Young Generation uses reference counting, while the Old Generation uses mark-and-sweep.",
      "The Old Generation is optimized for large object allocation, bypassing the garbage collector entirely."
    ],
    "answer": "The Old Generation is collected using a stop-the-world Mark-Sweep-Compact, while the Young Generation uses Scavenge (Copy).",
    "explanation": "New objects (Young) die quickly, making copying (Scavenge) efficient. Old objects (Old) are long-lived, so V8 uses Mark-Sweep-Compact (or parallel/concurrent marking) to manage fragmentation and reclaim memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the `new.target` meta-property used for in JavaScript functions?",
    "options": [
      "To override the constructor function's prototype at runtime.",
      "To detect whether a function was called as a constructor using `new` or as a regular function call.",
      "To change the `this` binding inside a class constructor.",
      "To access the global `new` operator configuration settings."
    ],
    "answer": "To detect whether a function was called as a constructor using `new` or as a regular function call.",
    "explanation": "`new.target` is undefined if the function is called normally. If called via `new`, it evaluates to the constructor or the class that was directly initialized. This allows abstract classes to throw errors if instantiated without `new`.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the result of `Object.prototype.toString.call(null)`?",
    "options": [
      "\"null\"",
      "\"undefined\"",
      "\"[object Null]\"",
      "\"[object Object]\""
    ],
    "answer": "\"[object Null]\"",
    "explanation": "The internal `[[Class]]` slot (now part of the internal species) for `null` is defined as \"Null\". While `typeof null` is 'object', `toString.call` correctly identifies its internal class tag.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Which feature of 'Private Class Fields' (using `#`) makes them distinct from standard properties prefixed with an underscore (`_this.isPrivate`)?",
    "options": [
      "They are strictly typed and cannot hold object references.",
      "They are scoped to the class body and are inaccessible via standard bracket notation or dot notation from outside.",
      "They are serialized automatically when using `JSON.stringify`.",
      "They are inherited by all child classes without explicit declaration."
    ],
    "answer": "They are scoped to the class body and are inaccessible via standard bracket notation or dot notation from outside.",
    "explanation": "Hard private fields (`#name`) are lexically scoped to the class block. They are not accessible on the instance object via reflection, proxy, or property access outside the class that defined them.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the significance of the `coercion` rules in JavaScript abstract relational comparisons (e.g., `a < b`)?",
    "options": [
      "Both arguments are always converted to Strings.",
      "If both arguments are Strings, lexicographical comparison is used; otherwise, they are converted to Numbers.",
      "The first argument is always converted to a Number, and the second to a String.",
      "Arguments are compared based on their valueOf() method only, ignoring toString()."
    ],
    "answer": "If both arguments are Strings, lexicographical comparison is used; otherwise, they are converted to Numbers.",
    "explanation": "For `<`, `>`, `<=`, `>=`, if either operand is not a string, both are converted to numbers. If both are strings, a simple lexicographical (alphabetical) comparison is performed.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "In V8, what is the primary trigger for 'deoptimization' (bailing out from TurboFan back to Ignition)?",
    "options": [
      "The execution of a `try...catch` block.",
      "A failure of the speculative assumptions made during optimization (e.g., an object shape changing).",
      "The function executing for longer than 10 milliseconds.",
      "A global variable being accessed inside the function."
    ],
    "answer": "A failure of the speculative assumptions made during optimization (e.g., an object shape changing).",
    "explanation": "V8 optimizes based on observed behavior (e.g., 'this function always receives an integer'). If a future execution violates this assumption (e.g., receiving a string), the assumption is invalidated, and the code 'deoptimizes' to the safe, slower interpreter path.",
    "difficulty": "Advanced"
  }
]