[
  {
    "id": 1,
    "question": "Which SQL clause is used to retrieve specific columns of data from a database table?",
    "options": [
      "FROM",
      "SELECT",
      "WHERE",
      "GET"
    ],
    "answer": "SELECT",
    "explanation": "The SELECT clause specifies which columns you want to retrieve in the result set. FROM identifies the table, and WHERE filters the rows.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the function of the WHERE clause in a SQL query?",
    "options": [
      "To group rows based on a specific value",
      "To filter records that meet a specified condition",
      "To sort the result set in ascending order",
      "To join two tables together"
    ],
    "answer": "To filter records that meet a specified condition",
    "explanation": "The WHERE clause is used to extract only those records that fulfill a specified criterion, reducing the result set.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which operator is used to search for a specified pattern in a column?",
    "options": [
      "BETWEEN",
      "LIKE",
      "IN",
      "PATTERN"
    ],
    "answer": "LIKE",
    "explanation": "The LIKE operator is used in a WHERE clause to search for a specified pattern in a column, often utilizing wildcards such as % and _.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In the context of the LIKE operator, which wildcard matches any number of characters?",
    "options": [
      "_",
      "*",
      "%",
      "#"
    ],
    "answer": "%",
    "explanation": "The percent sign (%) matches any number of characters (including zero), while the underscore (_) matches exactly one character.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which SQL keyword is used to sort the result-set in ascending or descending order?",
    "options": [
      "SORT BY",
      "ARRANGE BY",
      "GROUP BY",
      "ORDER BY"
    ],
    "answer": "ORDER BY",
    "explanation": "ORDER BY is used to sort the records in your result set. By default, it sorts in ascending order, but DESC can be used for descending.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the default sorting order of the ORDER BY clause when no direction is specified?",
    "options": [
      "Descending",
      "Random",
      "Ascending",
      "Alphabetical only"
    ],
    "answer": "Ascending",
    "explanation": "The ORDER BY keyword sorts the records in ascending order by default. To sort in descending order, use the DESC keyword.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which clause is used to return only distinct (different) values in a result set?",
    "options": [
      "DIFFERENT",
      "SINGLE",
      "DISTINCT",
      "UNIQUE"
    ],
    "answer": "DISTINCT",
    "explanation": "The DISTINCT keyword is used in a SELECT statement to remove duplicates and return only unique values from the specified column.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which logical operator is used to include records where ANY of the conditions are true?",
    "options": [
      "AND",
      "OR",
      "NOT",
      "XOR"
    ],
    "answer": "OR",
    "explanation": "The OR operator displays a record if any of the conditions separated by OR is TRUE. AND requires all conditions to be true.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which SQL operator is used to specify multiple possible values for a column?",
    "options": [
      "WITHIN",
      "CONTAINS",
      "RANGE",
      "IN"
    ],
    "answer": "IN",
    "explanation": "The IN operator allows you to specify multiple values in a WHERE clause, functioning as a shorthand for multiple OR conditions.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "How do you select all columns from a table named Employees?",
    "options": [
      "SELECT Employees",
      "SELECT * FROM Employees",
      "SELECT ALL FROM Employees",
      "SELECT every_column FROM Employees"
    ],
    "answer": "SELECT * FROM Employees",
    "explanation": "The asterisk (*) character is a wildcard in SQL that selects all columns in the table.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which aggregate function returns the number of rows that matches a specified criterion?",
    "options": [
      "SUM()",
      "COUNT()",
      "TOTAL()",
      "NUMBER()"
    ],
    "answer": "COUNT()",
    "explanation": "COUNT() returns the number of rows that matches a specified criteria. SUM() adds up the values in a numeric column.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the purpose of the AS keyword in a SQL query?",
    "options": [
      "To add a new table to the database",
      "To create an alias for a column or table",
      "To filter the results of a query",
      "To sort the query results"
    ],
    "answer": "To create an alias for a column or table",
    "explanation": "AS is used to rename a column or table temporarily, often to make the output more readable or to simplify complex table names.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which SQL statement is used to insert new data into a database?",
    "options": [
      "ADD NEW",
      "INSERT INTO",
      "UPDATE",
      "CREATE RECORD"
    ],
    "answer": "INSERT INTO",
    "explanation": "The INSERT INTO statement is used to insert new records in a table. UPDATE is used to modify existing records.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which SQL statement is used to update existing data in a table?",
    "options": [
      "SAVE",
      "MODIFY",
      "UPDATE",
      "CHANGE"
    ],
    "answer": "UPDATE",
    "explanation": "The UPDATE statement is used to modify the existing records in a table. It is usually used in conjunction with the WHERE clause.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which SQL statement is used to delete data from a database?",
    "options": [
      "REMOVE",
      "DROP",
      "DELETE",
      "TRUNCATE"
    ],
    "answer": "DELETE",
    "explanation": "The DELETE statement is used to delete existing records from a table. DROP removes the entire table structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What happens if you use the DELETE statement without a WHERE clause?",
    "options": [
      "Only the first row is deleted",
      "The table structure is removed",
      "All rows in the table are deleted",
      "An error is generated"
    ],
    "answer": "All rows in the table are deleted",
    "explanation": "Without a WHERE clause, the DELETE statement applies to every row in the table, effectively emptying the table while preserving its structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which join type returns all rows when there is a match in either table (left or right)?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "FULL OUTER JOIN",
    "explanation": "FULL OUTER JOIN combines the results of both LEFT and RIGHT joins, returning all records from both tables regardless of matches.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which join returns all records from the left table, and the matched records from the right table?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "CROSS JOIN"
    ],
    "answer": "LEFT JOIN",
    "explanation": "LEFT JOIN returns all rows from the left table, even if there are no matches in the right table. Unmatched rows from the right side return NULL.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which keyword is used to combine the results of two or more SELECT statements?",
    "options": [
      "COMBINE",
      "JOIN",
      "GROUP",
      "UNION"
    ],
    "answer": "UNION",
    "explanation": "UNION combines the result sets of two or more SELECT statements (removing duplicates). JOIN combines columns from different tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which aggregate function is used to calculate the average value of a numeric column?",
    "options": [
      "AVERAGE()",
      "AVG()",
      "MEAN()",
      "MEDIAN()"
    ],
    "answer": "AVG()",
    "explanation": "The AVG() function returns the average value of a numeric column. There is no standard AVERAGE() or MEAN() function in SQL.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What does the GROUP BY clause do in a SQL query?",
    "options": [
      "Sorts the data by the specified column",
      "Groups rows that have the same values into summary rows",
      "Filters the grouped records based on a condition",
      "Joins tables based on a common column"
    ],
    "answer": "Groups rows that have the same values into summary rows",
    "explanation": "GROUP BY arranges identical data into groups, often used in conjunction with aggregate functions like COUNT() or SUM() to perform calculations on each group.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which clause is used to filter records after they have been grouped?",
    "options": [
      "WHERE",
      "FILTER",
      "HAVING",
      "CHECK"
    ],
    "answer": "HAVING",
    "explanation": "The HAVING clause was added to SQL because the WHERE keyword could not be used with aggregate functions. It filters records after the GROUP BY operation.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which constraint ensures that all values in a column are unique and not NULL?",
    "options": [
      "UNIQUE",
      "PRIMARY KEY",
      "DISTINCT",
      "FOREIGN KEY"
    ],
    "answer": "PRIMARY KEY",
    "explanation": "A PRIMARY KEY constraint uniquely identifies each record in a table and must contain unique values and cannot contain NULL values.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which constraint allows inserting NULL values but ensures all non-NULL values are unique?",
    "options": [
      "PRIMARY KEY",
      "UNIQUE",
      "FOREIGN KEY",
      "CHECK"
    ],
    "answer": "UNIQUE",
    "explanation": "The UNIQUE constraint ensures that all values in a column are different, but unlike PRIMARY KEY, it allows one NULL value (depending on the database).",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the purpose of the IS NULL operator?",
    "options": [
      "To check if a column contains zero",
      "To check if a column contains an empty string",
      "To check if a column value is missing",
      "To check if a column is unique"
    ],
    "answer": "To check if a column value is missing",
    "explanation": "The IS NULL operator is used to test for empty values (NULL). You cannot use comparison operators like = or <> with NULL.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which constraint is used to link two tables together based on a common column?",
    "options": [
      "LINK KEY",
      "ASSOCIATION KEY",
      "PRIMARY KEY",
      "FOREIGN KEY"
    ],
    "answer": "FOREIGN KEY",
    "explanation": "A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which function returns the lowest value in a column?",
    "options": [
      "LOWEST()",
      "MIN()",
      "BOTTOM()",
      "SMALLEST()"
    ],
    "answer": "MIN()",
    "explanation": "The MIN() function returns the smallest value of the selected column. MAX() returns the largest value.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which SQL statement is used to create a new table in a database?",
    "options": [
      "NEW TABLE",
      "CREATE TABLE",
      "INSERT TABLE",
      "BUILD TABLE"
    ],
    "answer": "CREATE TABLE",
    "explanation": "CREATE TABLE is the standard DDL statement used to create a new table in a database.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which SQL statement is used to remove a table definition and all its data?",
    "options": [
      "DELETE TABLE",
      "REMOVE TABLE",
      "DROP TABLE",
      "TRUNCATE TABLE"
    ],
    "answer": "DROP TABLE",
    "explanation": "DROP TABLE removes the table definition and all data, indexes, triggers, and constraints related to that table. TRUNCATE removes data but keeps the structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "In a SELECT statement, which clause is executed first?",
    "options": [
      "SELECT",
      "WHERE",
      "FROM",
      "ORDER BY"
    ],
    "answer": "FROM",
    "explanation": "Logically, the FROM clause is evaluated first to determine the source of the data, followed by WHERE, GROUP BY, HAVING, SELECT, and finally ORDER BY.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which operator selects values within a given range?",
    "options": [
      "WITHIN",
      "RANGE",
      "BETWEEN",
      "CONTAINS"
    ],
    "answer": "BETWEEN",
    "explanation": "The BETWEEN operator selects values within a given range and is inclusive of both the start and end values.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What does the NOT NULL constraint enforce?",
    "options": [
      "The column must have a unique value",
      "The column cannot be left empty",
      "The column must be a number",
      "The column must be a primary key"
    ],
    "answer": "The column cannot be left empty",
    "explanation": "The NOT NULL constraint enforces a column to NOT accept NULL values, ensuring that a field must always contain a value.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which keyword is used to return only the first n number of records (in MySQL/PostgreSQL)?",
    "options": [
      "TOP",
      "FIRST",
      "LIMIT",
      "MAX"
    ],
    "answer": "LIMIT",
    "explanation": "LIMIT is used to specify the number of records to return in MySQL and PostgreSQL. SQL Server uses TOP, Oracle uses ROWNUM.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which aggregate function ignores NULL values when calculating?",
    "options": [
      "COUNT(*)",
      "SUM(column)",
      "COUNT(column)",
      "All aggregate functions ignore NULLs"
    ],
    "answer": "All aggregate functions ignore NULLs",
    "explanation": "With the exception of COUNT(*), which counts rows, aggregate functions like SUM, AVG, and COUNT(column) ignore NULL values in their calculations.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which JOIN returns records that have matching values in both tables?",
    "options": [
      "LEFT JOIN",
      "RIGHT JOIN",
      "INNER JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "INNER JOIN",
    "explanation": "INNER JOIN selects records that have matching values in both tables, effectively the intersection of the two sets of data.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which clause defines the set of rows over which a window function operates, independently of any grouping?",
    "options": [
      "GROUP BY",
      "PARTITION BY",
      "ORDER BY",
      "HAVING"
    ],
    "answer": "PARTITION BY",
    "explanation": "The PARTITION BY clause divides the result set into partitions to which the window function is applied separately. GROUP BY collapses rows, whereas PARTITION BY retains individual rows while calculating aggregates over the partition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary difference between the RANK() and DENSE_RANK() window functions?",
    "options": [
      "RANK() returns a unique integer for each row; DENSE_RANK() can return duplicates",
      "RANK() skips numbers in its sequence after ties; DENSE_RANK() does not skip numbers",
      "DENSE_RANK() only works with numeric columns; RANK() works with all data types",
      "RANK() sorts in ascending order; DENSE_RANK() sorts in descending order"
    ],
    "answer": "RANK() skips numbers in its sequence after ties; DENSE_RANK() does not skip numbers",
    "explanation": "When there are ties, RANK() leaves a gap in the sequence (e.g., 1, 2, 2, 4). DENSE_RANK() assigns consecutive ranks (e.g., 1, 2, 2, 3) without gaps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the context of SQL logical query processing, which clause is evaluated immediately after the FROM and JOIN clauses?",
    "options": [
      "SELECT",
      "WHERE",
      "GROUP BY",
      "ORDER BY"
    ],
    "answer": "WHERE",
    "explanation": "The logical order of operations is FROM > ON > JOIN > WHERE > GROUP BY > HAVING > SELECT > ORDER BY. The WHERE clause filters rows before any aggregation or windowing occurs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the default frame clause if an ORDER BY is specified but no explicit frame (ROWS/RANGE) is defined for a window function?",
    "options": [
      "RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING"
    ],
    "answer": "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "If ORDER BY is used without a frame specification, the default scope is the partition starting from the first row up to the current row (RANGE UNBOUNDED PRECEDING).",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which set operator returns all distinct rows from the first query that do not appear in the results of the second query?",
    "options": [
      "INTERSECT",
      "UNION",
      "EXCEPT (or MINUS)",
      "JOIN"
    ],
    "answer": "EXCEPT (or MINUS)",
    "explanation": "EXCEPT (or MINUS in Oracle) performs a set difference, returning rows from the left input that are not present in the right input, effectively subtracting the second set from the first.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When using a LEFT JOIN, where must you place filter conditions on the right-hand table to ensure that all left-hand table rows are retained?",
    "options": [
      "In the ON clause",
      "In the WHERE clause",
      "In the HAVING clause",
      "In the GROUP BY clause"
    ],
    "answer": "In the ON clause",
    "explanation": "Placing a filter on the right table in the ON clause preserves rows from the left table even if the join condition fails (resulting in NULLs). Placing it in the WHERE clause converts the join effectively to an INNER JOIN by filtering out non-matches.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the impact of using the 'WITH (NOLOCK)' hint in SQL Server (or equivalent Read Uncommitted isolation level)?",
    "options": [
      "It prevents deadlocks by escalating to a table lock",
      "It allows reading of uncommitted data, risking dirty reads",
      "It speeds up queries by ignoring syntax errors",
      "It ensures that only committed data is read, preventing anomalies"
    ],
    "answer": "It allows reading of uncommitted data, risking dirty reads",
    "explanation": "Reading uncommitted data bypasses locking, allowing a transaction to see data modifications that have not yet been committed. This improves concurrency but can read 'dirty' data that might be rolled back.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which index type is best suited for columns that frequently undergo range queries (e.g., searching for prices between 10 and 50)?",
    "options": [
      "Hash Index",
      "B-Tree Index",
      "Bitmap Index",
      "Full-Text Index"
    ],
    "answer": "B-Tree Index",
    "explanation": "B-Tree indexes store data in a sorted structure, making them efficient for range scans and equality checks. Hash indexes are typically only effective for equality predicates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "How does the execution plan typically change when comparing EXISTS (SELECT 1 ...) vs EXISTS (SELECT * ...) for a correlated subquery?",
    "options": [
      "SELECT 1 is significantly faster because it stops column lookups",
      "SELECT * is slower because it retrieves all column data",
      "The optimizer treats them identically",
      "SELECT * causes a table scan, while SELECT 1 uses an index"
    ],
    "answer": "The optimizer treats them identically",
    "explanation": "Modern SQL optimizers ignore the select list in an EXISTS subquery. They only check for the existence of a row, so 'SELECT 1' and 'SELECT *' result in the same execution plan.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In the context of GROUP BY extensions, which clause generates subtotals for each grouping combination specified in the GROUP BY list?",
    "options": [
      "HAVING",
      "ROLLUP",
      "CUBE",
      "PARTITION BY"
    ],
    "answer": "ROLLUP",
    "explanation": "ROLLUP generates hierarchical subtotals (aggregates) from the most detailed level to a grand total. CUBE generates subtotals for all possible combinations of the grouping columns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What distinguishes a correlated subquery from a non-correlated (simple) subquery?",
    "options": [
      "Correlated subqueries are executed once for the entire result set",
      "Correlated subqueries reference columns from the outer query",
      "Non-correlated subqueries cannot be used in the WHERE clause",
      "Correlated subqueries must always return a single value"
    ],
    "answer": "Correlated subqueries reference columns from the outer query",
    "explanation": "A correlated subquery depends on values from the outer query and executes once per row processed by the outer query. A non-correlated subquery is independent and executes only once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Why is using SELECT * generally discouraged in production code, especially in the context of views or ORMs?",
    "options": [
      "It retrieves data in an unordered format",
      "It causes excessive network usage and column breakage if schema changes",
      "It prevents the use of WHERE clauses",
      "It locks the entire table for the duration of the transaction"
    ],
    "answer": "It causes excessive network usage and column breakage if schema changes",
    "explanation": "SELECT * retrieves unnecessary columns (wasting I/O and network) and breaks application code if column orders change or columns are added/removed, breaking schema dependency contracts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which aggregate function ignores NULL values by default?",
    "options": [
      "COUNT(*)",
      "COUNT(column_name)",
      "SUM(column_name)",
      "AVG(column_name)"
    ],
    "answer": "COUNT(column_name)",
    "explanation": "While SUM and AVG also technically ignore NULLs during the mathematical operation, COUNT(column_name) specifically counts only non-null values. COUNT(*) counts rows regardless of NULL values. This is a common trick question; the most precise distinction is that column-specific aggregates exclude NULLs, while row-counters do not.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the result of a CROSS JOIN between Table A (5 rows) and Table B (3 rows)?",
    "options": [
      "8 rows",
      "3 rows",
      "15 rows",
      "0 rows"
    ],
    "answer": "15 rows",
    "explanation": "A CROSS JOIN returns the Cartesian product of the two tables. It multiplies the rows of the first table by the rows of the second table (5 * 3 = 15).",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which SQL clause is used to restrict the results of a GROUP BY query based on a specific aggregate condition?",
    "options": [
      "WHERE",
      "HAVING",
      "LIMIT",
      "ORDER BY"
    ],
    "answer": "HAVING",
    "explanation": "The WHERE clause filters rows before aggregation. The HAVING clause filters groups after aggregation has been performed by the GROUP BY clause.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the primary purpose of the COALESCE() function?",
    "options": [
      "To merge two tables into one result set",
      "To convert a value to a different data type",
      "To return the first non-NULL value from a list of arguments",
      "To calculate the mathematical coalescence of a set"
    ],
    "answer": "To return the first non-NULL value from a list of arguments",
    "explanation": "COALESCE takes a list of arguments and returns the first one that evaluates to a non-NULL value. If all arguments are NULL, it returns NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "When a Clustered Index is created on a table, how is the physical data organized?",
    "options": [
      "The data remains in heap order, and the index points to it",
      "The data is sorted and stored physically based on the index key",
      "A copy of the data is created and sorted separately",
      "The data is compressed to reduce storage space"
    ],
    "answer": "The data is sorted and stored physically based on the index key",
    "explanation": "A clustered index sorts and stores the data rows of the table or view in order based on the clustered index key. The table is the clustered index.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which keyword is used in a CASE statement to handle values that do not match any of the explicit WHEN conditions?",
    "options": [
      "ELSE",
      "DEFAULT",
      "OR",
      "THEN"
    ],
    "answer": "ELSE",
    "explanation": "The ELSE clause specifies the result to return if no Boolean expression evaluates to TRUE. If ELSE is omitted and no condition is met, the result is NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is a 'SARGable' predicate?",
    "options": [
      "A query that utilizes Searchable ARGuments to optimize index usage",
      "A query that contains syntax errors preventing execution",
      "A query that uses dynamic SQL",
      "A query that forces a full table scan"
    ],
    "answer": "A query that utilizes Searchable ARGuments to optimize index usage",
    "explanation": "SARGable stands for Search ARGument ABLE. It refers to a predicate in the WHERE clause that can leverage an index seek (e.g., `WHERE col = 1`), as opposed to a function on the column (e.g., `WHERE YEAR(date) = 2023`) which forces a scan.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What does the ACID property 'Atomicity' guarantee in a database transaction?",
    "options": [
      "Data is valid according to all defined rules",
      "Transactions are isolated from each other",
      "All operations in a transaction succeed or none do",
      "Once committed, data remains permanent even in power loss"
    ],
    "answer": "All operations in a transaction succeed or none do",
    "explanation": "Atomicity ensures that a series of database operations are treated as a single unit. If any part fails, the entire transaction is rolled back, preventing partial data updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which function returns the difference between two dates expressed in a specified part of the date (e.g., month, year)?",
    "options": [
      "TIMESTAMPDIFF",
      "DATEDIFF",
      "DATEADD",
      "DATE_PART"
    ],
    "answer": "DATEDIFF",
    "explanation": "DATEDIFF is the standard function across most SQL dialects to calculate the difference between two date expressions based on a specific datepart (boundary). Syntax varies slightly by vendor (e.g., MySQL vs SQL Server).",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In a normalized database, what issue does a 'Many-to-Many' relationship resolve that a 'One-to-Many' relationship cannot?",
    "options": [
      "Data redundancy",
      "Complex join requirements",
      "The need to store multiple child records for multiple parents",
      "Foreign key constraints"
    ],
    "answer": "The need to store multiple child records for multiple parents",
    "explanation": "A Many-to-Many relationship (implemented via a junction/bridge table) allows many records in Table A to relate to many records in Table B, which a direct One-to-Many link cannot represent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which statement regarding the NULL value is correct?",
    "options": [
      "NULL represents the value zero (0) or an empty string",
      "NULL is equal to NULL",
      "NULL indicates the absence of a value and is not comparable via standard operators",
      "COUNT(NULL) returns the number of rows with missing values"
    ],
    "answer": "NULL indicates the absence of a value and is not comparable via standard operators",
    "explanation": "NULL is a marker for missing data. Comparisons like `NULL = NULL` return UNKNOWN (False), not True. `COUNT(NULL)` typically returns 0 because aggregates ignore NULLs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the effect of using the 'RECURSIVE' keyword in a Common Table Expression (CTE)?",
    "options": [
      "It forces the CTE to recalculate if the underlying data changes",
      "It allows the CTE to reference itself to query hierarchical data",
      "It creates an index on the CTE results",
      "It prevents the CTE from being used in a JOIN"
    ],
    "answer": "It allows the CTE to reference itself to query hierarchical data",
    "explanation": "Recursive CTEs allow a query to repeatedly execute a subquery that refers to the CTE itself. This is the standard method for traversing hierarchies (like organizational charts) or graphs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the primary difference between DELETE and TRUNCATE?",
    "options": [
      "DELETE can be rolled back, TRUNCATE cannot",
      "DELETE removes the table structure, TRUNCATE removes only data",
      "DELETE scans every row and logs individual row deletions; TRUNCATE de-allocates data pages",
      "DELETE can be used with a WHERE clause; TRUNCATE can also use a WHERE clause"
    ],
    "answer": "DELETE scans every row and logs individual row deletions; TRUNCATE de-allocates data pages",
    "explanation": "TRUNCATE is a DDL operation that is faster and uses fewer system and transaction logs because it de-allocates data pages rather than deleting rows one by one. DELETE is a DML operation that logs every row.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which constraint ensures that a column (or group of columns) uniquely identifies each row in a table?",
    "options": [
      "Foreign Key",
      "Unique Key",
      "Primary Key",
      "Check Constraint"
    ],
    "answer": "Primary Key",
    "explanation": "A Primary Key constraint uniquely identifies each record in a database table. While a Unique Key also enforces uniqueness, the Primary Key specifically disallows NULLs and defines the row's address.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the 'Lost Update' problem in database concurrency?",
    "options": [
      "Two transactions read the same data, and the second update overwrites the first",
      "Data is modified by a transaction that has not yet committed",
      "A transaction reads a range of rows twice and gets a different list",
      "The database server fails and loses the most recent transaction log"
    ],
    "answer": "Two transactions read the same data, and the second update overwrites the first",
    "explanation": "A Lost Update occurs when two transactions read the same value and then update it. The second transaction overwrites the update made by the first, causing the first update to be 'lost'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which window function is used to assign a unique sequential integer to rows within a partition, regardless of ties?",
    "options": [
      "RANK()",
      "DENSE_RANK()",
      "ROW_NUMBER()",
      "NTILE()"
    ],
    "answer": "ROW_NUMBER()",
    "explanation": "ROW_NUMBER() returns a unique number for every row, resetting only on the PARTITION BY boundary. Even if rows have identical values, they will receive different, arbitrary numbers (1, 2, 3).",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the definition of a 'Covering Index'?",
    "options": [
      "An index that contains all columns of the table",
      "An index that includes all columns referenced in a SELECT, JOIN, and WHERE clause",
      "An index created on a view",
      "An index used to enforce a Foreign Key constraint"
    ],
    "answer": "An index that includes all columns referenced in a SELECT, JOIN, and WHERE clause",
    "explanation": "A covering index is a non-clustered index that contains all the columns required by a specific query. This allows the engine to retrieve data directly from the index structure without performing a Key Lookup/RID Lookup to the heap.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "When using the UNION operator, how does the database handle duplicates?",
    "options": [
      "Duplicates are always retained",
      "Duplicates are removed, which has a performance cost",
      "Duplicates cause a syntax error",
      "Duplicates are only removed if UNION DISTINCT is specified"
    ],
    "answer": "Duplicates are removed, which has a performance cost",
    "explanation": "UNION implicitly performs a DISTINCT operation to remove duplicate rows from the combined result sets. This extra sorting/distinct operation is more expensive than UNION ALL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which function calculates the percentile rank of a row relative to a group?",
    "options": [
      "PERCENT_RANK()",
      "CUME_DIST()",
      "PERCENTILE_CONT()",
      "NTILE()"
    ],
    "answer": "PERCENT_RANK()",
    "explanation": "PERCENT_RANK() returns the relative rank of a row as a percentage (0 to 1). It is calculated as (Rank - 1) / (Total Rows - 1). CUME_DIST returns the cumulative distribution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is a 'Deadlock' in SQL Server (or relational databases generally)?",
    "options": [
      "A query that waits indefinitely for a lock to be released",
      "A circular dependency where two processes wait for each other, forcing one to be killed",
      "A state where the database server stops responding to any requests",
      "A syntax error that prevents a transaction from starting"
    ],
    "answer": "A circular dependency where two processes wait for each other, forcing one to be killed",
    "explanation": "A deadlock occurs when Process A holds a lock on Resource 1 and needs Resource 2, while Process B holds Resource 2 and needs Resource 1. The database monitor detects this and kills one process as a victim.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which Normal Form addresses the issue of transitive dependencies, where non-key attributes depend on other non-key attributes?",
    "options": [
      "First Normal Form (1NF)",
      "Second Normal Form (2NF)",
      "Third Normal Form (3NF)",
      "Boyce-Codd Normal Form (BCNF)"
    ],
    "answer": "Third Normal Form (3NF)",
    "explanation": "3NF requires that a table be in 2NF and that all non-key attributes are dependent only on the primary key",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the behavior of the IGNORE NULLS option within FIRST_VALUE or LAST_VALUE window functions?",
    "options": [
      "It filters out rows with NULL values from the partition entirely",
      "It skips NULL values in the window frame when selecting the first or last value",
      "It converts NULL values to zero",
      "It causes an error if any NULL value is present in the partition"
    ],
    "answer": "It skips NULL values in the window frame when selecting the first or last value",
    "explanation": "RESPECT NULLS is the default behavior. IGNORE NULLS allows the function to disregard any rows with NULL values in the target column when determining the first or last value within the frame.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In PostgreSQL, which database object is essentially a stored query that can be used as a table, but does not store data itself?",
    "options": [
      "Materialized View",
      "Temporary Table",
      "View",
      "CTE"
    ],
    "answer": "View",
    "explanation": "A View is a virtual table defined by a query. It does not store data (unlike a Materialized View). A CTE is a temporary result set valid only for the duration of a single statement.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "When using the `RANGE` frame unit in window functions (e.g., `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`), how does the database handle rows with identical values in the `ORDER BY` column?",
    "options": [
      "It treats all rows with identical values as a single group, applying the function to all of them as one unit",
      "It applies the function only to the first row of the duplicate set to optimize performance",
      "It arbitrarily picks one row from the duplicate set as the 'current row' and excludes others",
      "It returns a runtime error because window functions require a unique sort key"
    ],
    "answer": "It treats all rows with identical values as a single group, applying the function to all of them as one unit",
    "explanation": "Unlike `ROWS`, which operates on physical offsets, `RANGE` operates on logical values. 'Peers' (rows with equal sort keys) are considered the same for the frame bounds, meaning the window frame includes all peers for every row in the peer set.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In the context of database indexing, what is the primary technical distinction between a Clustered Index and a Non-Clustered Index?",
    "options": [
      "A Clustered index stores the data rows physically sorted at the leaf level, whereas a Non-Clustered index stores a pointer (or clustering key) to the data row",
      "A Clustered index allows duplicate values, while a Non-Clustered index enforces uniqueness automatically",
      "A Clustered index is limited to one per table, while a Non-Clustered index is limited to two per table",
      "A Clustered index contains only the indexed columns, while a Non-Clustered index contains all table columns"
    ],
    "answer": "A Clustered index stores the data rows physically sorted at the leaf level, whereas a Non-Clustered index stores a pointer (or clustering key) to the data row",
    "explanation": "The leaf nodes of a Clustered Index constitute the actual data pages of the table. The Non-Clustered Index leaf nodes contain the indexed columns plus a reference (lookup) to retrieve the full row.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which condition characterizes a query as 'SARGable' (Search ARGument ABLE), allowing the optimizer to efficiently use an index on the `created_at` column?",
    "options": [
      "WHERE YEAR(created_at) = 2023",
      "WHERE created_at >= '2023-01-01' AND created_at < '2024-01-01'",
      "WHERE CONVERT(VARCHAR, created_at, 112) = '20230101'",
      "WHERE DATEDIFF(day, created_at, GETDATE()) < 30"
    ],
    "answer": "WHERE created_at >= '2023-01-01' AND created_at < '2024-01-01'",
    "explanation": "A predicate is SARGable if the index can be searched directly. Applying functions to the column (`YEAR()`, `CONVERT()`, `DATEDIFF()`) forces a scan (evaluation of the function on every row), whereas comparing the raw column to a constant range allows an index seek.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "When executing a `DELETE` operation on a parent table referenced by a Foreign Key, what mechanism ensures that the deletion fails if related child records exist, provided no `ON DELETE` rule is specified?",
    "options": [
      "The database acquires a write lock on the child table to prevent phantom reads",
      "The database implicitly enables 'Restrict' mode by checking foreign key constraints before committing the transaction",
      "The database triggers a 'cascade' operation to remove child records automatically",
      "The database temporarily disables the Foreign Key constraint to allow the deletion"
    ],
    "answer": "The database implicitly enables 'Restrict' mode by checking foreign key constraints before committing the transaction",
    "explanation": "If no `ON DELETE` action (like `CASCADE` or `SET NULL`) is defined, the default action is `RESTRICT` (or `NO ACTION` in some SQL dialects). The database verifies referential integrity and rejects the deletion if child rows exist.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the behavior difference between the `RANK()` and `DENSE_RANK()` window functions when encountering ties in the ordered set?",
    "options": [
      "`RANK()` assigns a unique number to every row, while `DENSE_RANK()` skips numbers for tied groups",
      "`RANK()` leaves gaps in the ranking sequence after a tie, while `DENSE_RANK()` does not leave gaps",
      "`DENSE_RANK()` resets the count to 1 for every partition, while `RANK()` continues incrementing globally",
      "There is no difference; they are synonyms in the SQL standard"
    ],
    "answer": "`RANK()` leaves gaps in the ranking sequence after a tie, while `DENSE_RANK()` does not leave gaps",
    "explanation": "If two rows tie for rank 1, `RANK()` assigns 1 to both, and the next row receives rank 3 (creating a gap). `DENSE_RANK()` assigns 1 to both, and the next row receives rank 2 (no gap).",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "In a Recursive Common Table Expression (CTE), what is the function of the `UNION ALL` (or `UNION`) set operator?",
    "options": [
      "It merges the results of the anchor member with the recursive member, iterating until the recursive member returns no new rows",
      "It deduplicates the results of the recursive member to prevent infinite loops",
      "It creates a temporary index on the CTE to improve join performance with the base table",
      "It separates the definition of the CTE from the main SELECT statement"
    ],
    "answer": "It merges the results of the anchor member with the recursive member, iterating until the recursive member returns no new rows",
    "explanation": "The recursive CTE is defined by an anchor member and a recursive member joined by `UNION ALL`. The engine executes the anchor, then feeds those rows into the recursive member, adding the results back to the previous set until no new rows are generated.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which join algorithm is generally most efficient when joining two large datasets that are not sorted and have no useful indexes on the join columns?",
    "options": [
      "Nested Loop Join",
      "Hash Join",
      "Merge Join",
      "Cartesian Product Join"
    ],
    "answer": "Hash Join",
    "explanation": "A Hash Join builds a hash table in memory for the smaller input and probes it with the larger input. It is typically superior to Nested Loop (for large data) and Merge Join (which requires pre-sorted inputs) when dealing with large, unsorted, unindexed datasets.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the specific risk associated with using the `REPEATABLE READ` isolation level regarding data consistency, compared to `SERIALIZABLE`?",
    "options": [
      "Non-repeatable reads, where a row retrieved twice within the same transaction returns different values",
      "Phantom reads, where a new row added by another transaction satisfies the query condition of the first transaction",
      "Dirty reads, where uncommitted changes from other transactions are visible",
      "Lost updates, where concurrent writes overwrite each other without detection"
    ],
    "answer": "Phantom reads, where a new row added by another transaction satisfies the query condition of the first transaction",
    "explanation": "`REPEATABLE READ` guarantees that if you re-read a row, you get the same data (preventing non-repeatable reads). However, it does not prevent Phantomsâ€”new rows appearing in a subsequent range query due to inserts by other transactions.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the context of SQL optimization, what is a 'Covering Index'?",
    "options": [
      "An index that includes all columns of the table, effectively duplicating the table storage",
      "An index containing all columns required by a specific query (SELECT, JOIN, WHERE) allowing an index-only scan",
      "A partitioning strategy where the index spans multiple physical disks",
      "A type of full-text index that covers all stop words and variations"
    ],
    "answer": "An index containing all columns required by a specific query (SELECT, JOIN, WHERE) allowing an index-only scan",
    "explanation": "A Covering Index includes all columns referenced in the query (including those in the SELECT list). The database can satisfy the query entirely from the index structure without performing lookups to the heap (base table), significantly reducing I/O.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the purpose of the `FILTER` clause in aggregate functions (e.g., `SUM(amount) FILTER (WHERE status = 'paid')`)?",
    "options": [
      "To limit the total number of rows processed by the aggregate function to a specific memory limit",
      "To conditionally include specific rows in the aggregation without excluding them from the group's result set",
      "To remove duplicate values from the aggregated column before summation",
      "To apply a HAVING condition to the aggregate result before it is returned to the client"
    ],
    "answer": "To conditionally include specific rows in the aggregation without excluding them from the group's result set",
    "explanation": "The `FILTER` clause allows for conditional aggregation within a group. It is semantically similar to a `CASE` statement inside the aggregate but offers cleaner syntax and, in some optimizers, better performance for pivot-like queries.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "When analyzing a Query Execution Plan, what does a 'Key Lookup' or 'Bookmark Lookup' operation indicate?",
    "options": [
      "The query is using the primary key to find a foreign key relationship",
      "The optimizer is performing a seek on a non-clustered index but must retrieve the remaining columns from the clustered index or heap",
      "The query has encountered a deadlock and is looking up the lock key",
      "The database is looking up statistics in the system catalog to determine the cardinality"
    ],
    "answer": "The optimizer is performing a seek on a non-clustered index but must retrieve the remaining columns from the clustered index or heap",
    "explanation": "This operation occurs when a non-clustered index is used to find rows (seek) but does not contain all columns required by the SELECT list (it is not a covering index), necessitating a random I/O lookup to the base table.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the result of `NULLIF(1, 1)`?",
    "options": [
      "1",
      "NULL",
      "TRUE",
      "An error is thrown"
    ],
    "answer": "NULL",
    "explanation": "The `NULLIF` function returns NULL if the two arguments are equal; otherwise, it returns the first argument. Since 1 equals 1, the result is NULL.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Which SQL clause is used to define a window frame that specifically includes only the current row and the *n* rows preceding it?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN CURRENT ROW AND n FOLLOWING",
      "ROWS BETWEEN n PRECEDING AND CURRENT ROW",
      "RANGE BETWEEN n PRECEDING AND CURRENT ROW"
    ],
    "answer": "ROWS BETWEEN n PRECEDING AND CURRENT ROW",
    "explanation": "`ROWS` uses physical offsets. The syntax `n PRECEDING AND CURRENT ROW` explicitly creates a sliding window of size n+1 that moves down the result set.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does the `LATERAL` join keyword modify the behavior of a table reference in a `FROM` or `JOIN` clause?",
    "options": [
      "It allows the right-hand table to reference columns from tables on the left-hand side of the join, effectively acting as a correlated subquery in the FROM clause",
      "It forces the join to be processed last in the execution plan to optimize filtering",
      "It enables a right outer join syntax for databases that do not natively support RIGHT OUTER JOIN",
      "It creates a temporary table in memory that persists for the duration of the session"
    ],
    "answer": "It allows the right-hand table to reference columns from tables on the left-hand side of the join, effectively acting as a correlated subquery in the FROM clause",
    "explanation": "A `LATERAL` join enables a subquery in the FROM clause to reference columns from preceding tables in the same FROM list. This allows for complex, row-by-row calculations that cannot be performed with standard cross joins.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the primary difference in how `EXCEPT` and `NOT IN` handle NULL values when comparing two datasets?",
    "options": [
      "`EXCEPT` treats NULLs as distinct values, while `NOT IN` treats them as equivalent",
      "`NOT IN` returns no rows if the subquery contains a NULL, whereas `EXCEPT` effectively filters NULLs matching the NULL logic of the set operation",
      "`EXCEPT` cannot be used with columns containing NULL values, but `NOT IN` can",
      "There is no difference; they both follow three-valued logic identically"
    ],
    "answer": "`NOT IN` returns no rows if the subquery contains a NULL, whereas `EXCEPT` effectively filters NULLs matching the NULL logic of the set operation",
    "explanation": "`NOT IN` uses the comparison `col != subquery_col`. If any `subquery_col` is NULL, the result of the comparison is UNKNOWN, causing the `NOT IN` condition to fail for all rows. `EXCEPT` treats NULLs as matching NULLs (via set distinctness), behaving more intuitively for set differences.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In the context of Write-Ahead Logging (WAL), what guarantees durability during a database crash?",
    "options": [
      "The modified data pages are written to the data file immediately upon transaction commit",
      "The log records describing the changes are flushed to stable storage (disk) before the transaction is marked as committed",
      "The transaction is stored in a volatile memory cache until the checkpoint process runs",
      "The database lock manager holds an exclusive lock on the modified pages until the restart"
    ],
    "answer": "The log records describing the changes are flushed to stable storage (disk) before the transaction is marked as committed",
    "explanation": "WAL ensures that modifications are written to a log file on disk *before* the actual data pages in the buffer pool are written back to disk. If a crash occurs, the database can 'replay' the log to restore committed transactions.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What distinguishes the `CUBE` extension from the `ROLLUP` extension when performing grouping operations?",
    "options": [
      "`ROLLUP` calculates subtotals for all combinations of grouping columns, while `CUBE` only calculates a grand total",
      "`CUBE` generates subtotals for all possible permutations of the specified columns, while `ROLLUP` generates subtotals based on a hierarchy",
      "`ROLLUP` requires exactly two columns, while `CUBE` can handle any number of columns",
      "`CUBE` is an aggregate function, whereas `ROLLUP` is a window function"
    ],
    "answer": "`CUBE` generates subtotals for all possible permutations of the specified columns, while `ROLLUP` generates subtotals based on a hierarchy",
    "explanation": "`ROLLUP` assumes a hierarchy (e.g., Year -> Month -> Day) and creates subtotals for that roll-up. `CUBE` creates a multi-dimensional cube, calculating subtotals for every combination of the provided grouping columns.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What does the `FOR UPDATE` clause (or `SELECT ... FOR UPDATE`) accomplish in a transaction?",
    "options": [
      "It locks the selected rows, preventing other transactions from modifying or locking them until the current transaction ends",
      "It updates the rows immediately without needing an explicit UPDATE statement",
      "It places an exclusive lock on the entire table to prevent any new inserts",
      "It increments a version number on the row to enable optimistic locking"
    ],
    "answer": "It locks the selected rows, preventing other transactions from modifying or locking them until the current transaction ends",
    "explanation": "This is a pessimistic locking mechanism. It ensures that the data you read cannot be changed by other sessions, allowing you to update the data safely later in the transaction based on the values you just read.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which anomaly is solved by ensuring a table is in Third Normal Form (3NF)?",
    "options": [
      "Partial dependency of non-key attributes on the primary key",
      "Transitive dependency of non-key attributes on other non-key attributes",
      "Multivalued dependency causing redundancy",
      "Insertion anomaly due to lack of a primary key"
    ],
    "answer": "Transitive dependency of non-key attributes on other non-key attributes",
    "explanation": "3NF builds upon 2NF by ensuring that non-key attributes are not dependent on other non-key attributes (transitive dependencies). 2NF addresses partial dependencies.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "In PostgreSQL, what is the primary function of the `VACUUM` command (specifically `VACUUM` versus `VACUUM FULL`)?",
    "options": [
      "`VACUUM` rebuilds the entire table to physically sort rows, while `VACUUM FULL` only reclaims space",
      "Standard `VACUUM` reclaims space occupied by dead tuples (bloat) for reuse but does not compact the file; `VACUUM FULL` creates a fresh copy of the table compacting it entirely",
      "`VACUUM` updates table statistics, while `VACUUM FULL` reindexs the system catalogs",
      "`VACUUM` deletes orphaned rows from child tables, while `VACUUM FULL` locks the parent table"
    ],
    "answer": "Standard `VACUUM` reclaims space occupied by dead tuples (bloat) for reuse but does not compact the file; `VACUUM FULL` creates a fresh copy of the table compacting it entirely",
    "explanation": "Standard `VACUUM` (lazy vacuum) marks dead space in the table file as available for future reuse (reducing bloat) but requires an exclusive lock to return disk space to the OS. `VACUUM FULL` requires an exclusive lock to rewrite the whole table.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the behavior of the `MERGE` statement (or `UPSERT`) when a row matches the join condition but the `WHEN MATCHED` clause is omitted?",
    "options": [
      "The row is inserted as a new record",
      "The row is deleted from the target table",
      "No action is taken on the matched row, and processing continues",
      "The database throws a syntax error or constraint violation"
    ],
    "answer": "No action is taken on the matched row, and processing continues",
    "explanation": "In standard SQL `MERGE` syntax, specific clauses define the action for matches (`UPDATE`) and non-matches (`INSERT`). If a match is found but no `WHEN MATCHED` clause is defined (or no condition within it is met), the statement performs no action on that specific row.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which isolation level prevents 'Non-Repeatable Reads' but allows 'Phantom Reads'?",
    "options": [
      "Read Uncommitted",
      "Read Committed",
      "Repeatable Read",
      "Serializable"
    ],
    "answer": "Repeatable Read",
    "explanation": "`Repeatable Read` ensures that if you read a row, you get the same data if you read it again (preventing non-repeatable reads). However, it does not place a range lock, so new rows (phantoms) can appear in a subsequent query if they meet the WHERE criteria.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "When using `GROUP BY CUBE(a, b)`, how many grouping levels (result sets) are generated?",
    "options": [
      "2",
      "3",
      "4",
      "5"
    ],
    "answer": "4",
    "explanation": "`CUBE` generates 2^n grouping levels",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the 'Halloween Problem' in the context of SQL UPDATE operations?",
    "options": [
      "A deadlock that occurs when two transactions update the same row simultaneously on Oct 31st",
      "A situation where an UPDATE moves a row to a new position that the scan mechanism has already passed, causing the row to be updated multiple times",
      "A query optimization failure that occurs when date filters are applied to non-date columns",
      "A security vulnerability where users can update rows they should not have access to"
    ],
    "answer": "A situation where an UPDATE moves a row to a new position that the scan mechanism has already passed, causing the row to be updated multiple times",
    "explanation": "If an update changes the indexed column used to determine the order of the scan, the updated row might 'move' ahead of the scan cursor. If the cursor encounters it again, it might update it again. Modern databases prevent this using spooling or internal versioning.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In a SQL execution plan, what does the 'Spool' operator indicate?",
    "options": [
      "The query is waiting for a lock on a specific resource",
      "The database is temporarily storing intermediate result rows in a worktable (often tempdb) to avoid re-scanning or to handle rewinds",
      "The data is being written to a permanent dump file for archiving",
      "The query is parallelized and being split across multiple CPUs"
    ],
    "answer": "The database is temporarily storing intermediate result rows in a worktable (often tempdb) to avoid re-scanning or to handle rewinds",
    "explanation": "A spool operator saves the result of an operation to a temporary storage area. This is often used to enable the reuse of a subtree in the plan (e.g., for a Nested Loops Join where the inner input needs to be re-read) or to handle Halloween protection.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the `GENERATED ALWAYS AS` clause (Computed Columns) impact data modification operations?",
    "options": [
      "It requires the user to manually calculate the value on every INSERT",
      "It prevents the column from being updated directly, as the value is strictly determined by the expression defined at creation time",
      "It creates a trigger that fires on every SELECT to calculate the value dynamically",
      "It allows updates but logs a warning if the calculated value does not match the input"
    ],
    "answer": "It prevents the column from being updated directly, as the value is strictly determined by the expression defined at creation time",
    "explanation": "Computed columns (especially those marked `STORED` or `PERSISTED`) derive their values from other columns. They are generally read-only regarding direct INSERT/UPDATE attempts because their values are system-generated based on the expression.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which strategy is employed to minimize 'Contention' on a hot table's Primary Key during high-volume inserts?",
    "options": [
      "Using a sequential `INTEGER` primary key",
      "Using a random `UUID` or a sequential key guided by a sequence that caches values effectively (though random UUIDs can cause page splitting)",
      "Disabling all indexes during the load and rebuilding them afterwards",
      "Using `READ UNCOMMITTED` isolation level"
    ],
    "answer": "Disabling all indexes during the load and rebuilding them afterwards",
    "explanation": "While UUIDs reduce contention by distributing writes, the most effective bulk-load strategy is often dropping non-essential indexes (which maintain costly B-Tree structures on write) and rebuilding them after the data is loaded. Note: UUIDs cause index fragmentation/ page splitting.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the technical reason why a leading wildcard in a `LIKE` predicate (e.g., `LIKE '%term'`) typically prevents an index seek?",
    "options": [
      "The sort order of the index is B-Tree based, and leading wildcards prevent the traversal from knowing where to start the search path",
      "The index stores data in columns, and wildcards only work on rows",
      "The `LIKE` operator is incompatible with B-Tree structures",
      "The query optimizer converts `LIKE` queries into full-text searches by default"
    ],
    "answer": "The sort order of the index is B-Tree based, and leading wildcards prevent the traversal from knowing where to start the search path",
    "explanation": "B-Tree indexes rely on the left-most prefix of the key to navigate the tree. A leading wildcard (`%abc`) implies the start of the string is unknown, rendering the ordered structure useless for seeking; a full index scan is required.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the specific function of the `PARTITION BY` clause inside an `OVER()` window function definition?",
    "options": [
      "It physically splits the table into separate disk files for better query performance",
      "It creates distinct groups (partitions) of rows based on the specified column, resetting the window function calculation for each group independently",
      "It distributes the query processing across multiple CPU cores",
      "It filters out rows that contain NULL values in the partitioning column"
    ],
    "answer": "It creates distinct groups (partitions) of rows based on the specified column, resetting the window function calculation for each group independently",
    "explanation": "While similar to `GROUP BY`, `PARTITION BY` does not collapse rows. It simply divides the result set into logical windows so that the window function (like `RANK` or `SUM`) restarts its calculation at the beginning of each partition.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In SQL, what is the result of `SELECT NULLIF(5, 5) / NULLIF(0, 0);`?",
    "options": [
      "0",
      "NULL",
      "Division by zero error",
      "1"
    ],
    "answer": "NULL",
    "explanation": "`NULLIF(5, 5)` returns NULL. `NULLIF(0, 0)` returns NULL. The expression becomes `NULL / NULL`. In SQL, almost any arithmetic operation involving NULL results in NULL, rather than throwing an error (unless `ANSI_NULLS` or specific settings behave differently, but standard SQL yields NULL).",
    "difficulty": "Advanced"
  }
]