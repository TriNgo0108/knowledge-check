[
  {
    "id": 1,
    "question": "What are React Hooks primarily designed to do?",
    "options": [
      "Improve application security automatically",
      "Allow functional components to use state and lifecycle features",
      "Convert HTML code into React components",
      "Replace the need for JavaScript entirely"
    ],
    "answer": "Allow functional components to use state and lifecycle features",
    "explanation": "React Hooks are functions that enable developers to use state and lifecycle features, which were previously only available in class components, within functional components.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In which version of React were Hooks officially introduced?",
    "options": [
      "React 15.0",
      "React 16.8",
      "React 18.0",
      "React 19.0"
    ],
    "answer": "React 16.8",
    "explanation": "The text states that since their introduction in React 16.8, Hooks have become the standard API for building React applications.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "According to the guide, which hook should be used for managing simple state?",
    "options": [
      "useReducer",
      "useEffect",
      "useState",
      "useContext"
    ],
    "answer": "useState",
    "explanation": "The TL;DR section explicitly advises to 'Use `useState` for simple state, `useReducer` for complex state'.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary use case for the `useReducer` hook?",
    "options": [
      "Fetching data from an API",
      "Managing complex state logic with multiple sub-values",
      "Directly manipulating the DOM",
      "Optimizing image loading"
    ],
    "answer": "Managing complex state logic with multiple sub-values",
    "explanation": "The text explains that `useReducer` is a Hook for managing complex state logic through a reducer function, especially when state has multiple sub-values or complex update logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which external concept inspired the `useReducer` hook?",
    "options": [
      "Angular",
      "Vue",
      "Redux",
      "jQuery"
    ],
    "answer": "Redux",
    "explanation": "The text mentions that `useReducer` is inspired by Redux and excels when managing complex state logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the recommended pattern for data fetching in React 19 as described in the text?",
    "options": [
      "Use useEffect for all data fetching",
      "Use fetch inside the component body",
      "Use `use()` + Suspense",
      "Use componentWillMount"
    ],
    "answer": "Use `use()` + Suspense",
    "explanation": "The guide highlights a shift away from `useEffect` for data fetching, recommending the use of the new `use()` hook combined with Suspense.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the specific purpose of the `useRef` hook?",
    "options": [
      "To manage complex state transitions",
      "To fetch data from a server",
      "For DOM access and mutable values that do not trigger re-renders",
      "To optimize rendering performance"
    ],
    "answer": "For DOM access and mutable values that do not trigger re-renders",
    "explanation": "The TL;DR section specifies that `useRef` is used for DOM access and keeping mutable values that should not cause a component to re-render.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "How does the React Compiler affect the usage of `useMemo` and `useCallback`?",
    "options": [
      "It makes them mandatory for all components",
      "It removes them from the API completely",
      "It handles most optimization cases, so they should be used sparingly",
      "It automatically converts them to `useState`"
    ],
    "answer": "It handles most optimization cases, so they should be used sparingly",
    "explanation": "The text suggests using `useMemo` and `useCallback` sparingly because the React Compiler will handle most memoization cases automatically.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Can React Server Components (RSCs) use hooks directly?",
    "options": [
      "Yes, all hooks work in Server Components",
      "No, Server Components cannot use hooks",
      "Only `useState` works in Server Components",
      "Only `useEffect` works in Server Components"
    ],
    "answer": "No, Server Components cannot use hooks",
    "explanation": "The text notes that Server Components can't use hooks and that one must add `'use client'` for interactivity involving hooks.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What directive must be added to a file to enable the use of hooks and interactivity on the client?",
    "options": [
      "'use server'",
      "'use hooks'",
      "'use client'",
      "'use interactive'"
    ],
    "answer": "'use client'",
    "explanation": "To use hooks like `useState` or `useEffect` in a file intended for Server Components by default, you must add the `'use client'` directive.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What happens to components consuming a Context when the context value changes?",
    "options": [
      "Only the parent component re-renders",
      "All components consuming the context re-render",
      "The application crashes",
      "Nothing happens until a manual refresh"
    ],
    "answer": "All components consuming the context re-render",
    "explanation": "A performance note in the text warns that all components consuming a context will re-render when the context value changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is a major benefit of using React Server Components mentioned in the text?",
    "options": [
      "They allow direct access to the user's webcam",
      "They fetch data and render UI on the server with zero client-side JavaScript for those parts",
      "They force all animations to run at 60fps",
      "They eliminate the need for CSS"
    ],
    "answer": "They fetch data and render UI on the server with zero client-side JavaScript for those parts",
    "explanation": "The text states that React Server Components allow fetching data and rendering on the server, requiring zero client-side JavaScript for those specific parts.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "According to case studies, what is the approximate improvement in initial render times when adopting Server Components with frameworks like Next.js?",
    "options": [
      "From 0.8s to 2.4s",
      "From 2.4s to 0.8s",
      "From 5.0s to 4.5s",
      "No significant change in render times"
    ],
    "answer": "From 2.4s to 0.8s",
    "explanation": "The text reports that initial render times dropped from about 2.4s to 0.8s (a ~67% improvement) when teams adopted Server Components.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What feature in Next.js 16 blends static shells with dynamic regions in a single route?",
    "options": [
      "Full Stack Routing",
      "Partial Prerendering",
      "Static Site Generation",
      "Dynamic Server Rendering"
    ],
    "answer": "Partial Prerendering",
    "explanation": "Next.js 16 formalizes features like Partial Prerendering, which blends static shells with dynamic regions within a single route.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the primary role of AI tools like GitHub Copilot and Vercel's v0 in 2026 development?",
    "options": [
      "To replace the need for developers",
      "To generate boilerplate components, routes, and tests",
      "To write the final production code without review",
      "To manage server infrastructure entirely"
    ],
    "answer": "To generate boilerplate components, routes, and tests",
    "explanation": "The text explains that AI tools are about generating boilerplate code so developers can spend more time on architecture and logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "According to the text, do AI tools remove the need to understand core concepts like state and data flow?",
    "options": [
      "Yes, AI handles all logic",
      "No, understanding of state, data flow, performance, and security is still required",
      "Only for small applications",
      "Only state is required, data flow is automated"
    ],
    "answer": "No, understanding of state, data flow, performance, and security is still required",
    "explanation": "The text emphasizes that AI tools do not remove the need to understand foundational concepts; they just make it easier to express decisions in code.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the 'Suspense' model primarily used for in modern React data fetching?",
    "options": [
      "Handling errors only",
      "Declarative data fetching",
      "Styling components",
      "Managing routing"
    ],
    "answer": "Declarative data fetching",
    "explanation": "The text identifies the 'Suspense' model as the future of declarative data fetching, moving beyond just lazy loading.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which of the following is a newer hook mentioned for handling forms and enhanced UX patterns?",
    "options": [
      "useEffect",
      "useState",
      "useActionState",
      "useContext"
    ],
    "answer": "useActionState",
    "explanation": "The text lists `useActionState` among the newer hooks used for form handling and enhanced user experience patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the purpose of the `useOptimistic` hook?",
    "options": [
      "To always assume the network is fast",
      "For optimistic updates and enhanced UX patterns",
      "To delete old data automatically",
      "To ignore errors in the console"
    ],
    "answer": "For optimistic updates and enhanced UX patterns",
    "explanation": "The text mentions `useOptimistic` as a newer hook specifically used for enhanced UX patterns like optimistic updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How does React's Virtual DOM work with Hooks?",
    "options": [
      "Hooks disable the Virtual DOM",
      "When hook state changes, React calculates the minimal DOM updates needed",
      "Hooks duplicate the Virtual DOM",
      "The Virtual DOM is replaced by the Real DOM when hooks are used"
    ],
    "answer": "When hook state changes, React calculates the minimal DOM updates needed",
    "explanation": "React's Virtual DOM and reconciliation algorithm work with hooks; when state managed by a hook changes, React determines the minimal updates required for the UI.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the `use` hook in React 19 designed to simplify?",
    "options": [
      "CSS styling",
      "Data fetching",
      "Server configuration",
      "HTML structure"
    ],
    "answer": "Data fetching",
    "explanation": "The text states that with React 19, the new `use` hook simplifies data fetching.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Why might developers split contexts in large applications?",
    "options": [
      "To use more than one framework",
      "To prevent unnecessary re-renders when specific context values change",
      "Because React only allows one context per file",
      "To make the code look longer"
    ],
    "answer": "To prevent unnecessary re-renders when specific context values change",
    "explanation": "Because all consumers of a context re-render when its value changes, splitting contexts in large apps helps optimize performance by isolating changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What percentage of professional front-end usage does React account for, according to the text?",
    "options": [
      "About 20%",
      "Over 40%",
      "Less than 10%",
      "About 90%"
    ],
    "answer": "Over 40%",
    "explanation": "The text notes that the ecosystem remains central, with React accounting for over 40% of professional front-end usage.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which hook is specifically mentioned for concurrent features?",
    "options": [
      "useTransition",
      "useState",
      "useReducer",
      "useContext"
    ],
    "answer": "useTransition",
    "explanation": "The text lists Concurrent Features like `useTransition` and `useDeferredValue` as important concepts for UI performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the function of `useDeferredValue`?",
    "options": [
      "To delete state after a delay",
      "To help with UI performance in concurrent features",
      "To fetch data slowly",
      "To create animations"
    ],
    "answer": "To help with UI performance in concurrent features",
    "explanation": "`useDeferredValue` is listed alongside `useTransition` as a concurrent feature relevant to everyday UI performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is 'React Forget' also referred to as in the text?",
    "options": [
      "The React Router",
      "The React Compiler",
      "The React Server",
      "The React DOM"
    ],
    "answer": "The React Compiler",
    "explanation": "The text refers to 'The React Compiler (React Forget)' when discussing the future of manual memoization.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is a defining feature of modern workflows according to trend reports?",
    "options": [
      "Writing code in binary",
      "Avoiding all servers",
      "AI-assisted development",
      "Using only HTML"
    ],
    "answer": "AI-assisted development",
    "explanation": "Trend reports highlight AI-assisted development as a defining feature of modern workflows, rather than an optional bonus.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which of the following is NOT one of the four unifying patterns in 2026 frameworks?",
    "options": [
      "Fine-grained reactivity",
      "Server-first architectures",
      "Compiler-driven optimizations",
      "Manual DOM manipulation"
    ],
    "answer": "Manual DOM manipulation",
    "explanation": "The four patterns listed are fine-grained reactivity, server-first architectures, compiler-driven optimizations, and AI-assisted workflows. Manual DOM manipulation is the opposite of modern React patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What happens to `useEffect` usage patterns in React 19?",
    "options": [
      "It is used for everything including data fetching",
      "The community has shifted away from it for many common patterns like data fetching",
      "It has been removed from React",
      "It is only used for styling"
    ],
    "answer": "The community has shifted away from it for many common patterns like data fetching",
    "explanation": "The text states that with React 19, the community has shifted away from `useEffect` for many common patterns, such as data fetching.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Why is 'Server-first thinking' considered a key design decision in 2026?",
    "options": [
      "Because servers are cheaper than phones",
      "Because 'what runs where' is treated as a first-class design decision",
      "Because client-side JavaScript is banned",
      "Because it makes debugging harder"
    ],
    "answer": "Because 'what runs where' is treated as a first-class design decision",
    "explanation": "Developers are treating 'what runs where' as a first-class design decision, leaning on edge runtimes and server functions.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is a potential strategy for building reusable components that rely on context?",
    "options": [
      "Avoiding context entirely",
      "Establishing a design system",
      "Copying and pasting code",
      "Using global variables"
    ],
    "answer": "Establishing a design system",
    "explanation": "The text suggests that establishing a design system helps maintain consistency when building reusable components that rely on context.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the primary function of the `use` API introduced in React 19?",
    "options": [
      "To create user accounts",
      "To read resources like Promises in a way that supports Suspense",
      "To replace the `return` statement",
      "To delete components"
    ],
    "answer": "To read resources like Promises in a way that supports Suspense",
    "explanation": "The `use` hook simplifies data fetching and allows reading resources (like Promises) which integrates with the Suspense data-fetching model.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "How does the text describe the role of state management libraries (like Redux) for senior developers in 2026?",
    "options": [
      "They are a core requirement for every single project",
      "They might not be a core requirement for every senior dev due to signals and server-state libraries",
      "They are obsolete and should never be used",
      "They are only used for beginners"
    ],
    "answer": "They might not be a core requirement for every senior dev due to signals and server-state libraries",
    "explanation": "The text questions if a state management library is still a core requirement for every senior dev, given the rise of signals and server-state libraries like TanStack Query.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the relationship between React Hooks and the Virtual DOM?",
    "options": [
      "Hooks replace the Virtual DOM",
      "The Virtual DOM watches Hooks to calculate minimal UI updates",
      "They are unrelated concepts",
      "Hooks slow down the Virtual DOM"
    ],
    "answer": "The Virtual DOM watches Hooks to calculate minimal UI updates",
    "explanation": "The text explains that React's Virtual DOM and reconciliation algorithm work with hooks to efficiently update the UI when hook state changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which hook is best suited for logic where the next state depends on the previous state?",
    "options": [
      "useRef",
      "useEffect",
      "useReducer (or useState with functional updates)",
      "useContext"
    ],
    "answer": "useReducer (or useState with functional updates)",
    "explanation": "While `useState` can handle simple logic, `useReducer` is specifically highlighted for complex state logic and complex update logic, often involving previous states.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "According to the React 19 guide, which hook is recommended for managing state logic that involves multiple sub-values or complex update logic?",
    "options": [
      "useState",
      "useEffect",
      "useReducer",
      "useRef"
    ],
    "answer": "useReducer",
    "explanation": "useReducer is recommended for complex state logic involving multiple sub-values, similar to Redux, whereas useState is preferred for simple state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In React 19, what is the recommended pattern for data fetching, replacing the traditional `useEffect` approach?",
    "options": [
      "useEffect with async functions",
      "use() + Suspense",
      "useFetch hook",
      "useReducer + Promises"
    ],
    "answer": "use() + Suspense",
    "explanation": "The guide states that `use()` + Suspense is the new standard for data fetching, marking a shift away from using `useEffect` for this purpose.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Why is the `useRef` hook particularly useful for values that need to persist across renders without triggering a re-render?",
    "options": [
      "It automatically updates the DOM",
      "It stores values in the global window object",
      "It creates a mutable reference object that doesn't trigger re-renders",
      "It optimizes network requests"
    ],
    "answer": "It creates a mutable reference object that doesn't trigger re-renders",
    "explanation": "useRef is used for DOM access and holding mutable values that persist without causing the component to re-render when changed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the primary performance implication of consuming a Context value in React?",
    "options": [
      "Only the parent component re-renders",
      "All components consuming the context re-render when the value changes",
      "Context consumption is always faster than prop drilling",
      "It prevents server-side rendering"
    ],
    "answer": "All components consuming the context re-render when the value changes",
    "explanation": "Performance can be impacted because all components consuming a context will re-render whenever that context's value changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which directive is required to use hooks like `useState` inside a module that is being utilized as a Server Component?",
    "options": [
      "'use server'",
      "'use strict'",
      "'use client'",
      "'use hooks'"
    ],
    "answer": "'use client'",
    "explanation": "Server Components cannot use hooks; you must add the 'use client' directive at the top of the file to enable interactivity and hooks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "According to the 2026 trends, how has the introduction of the React Compiler changed the necessity of manual memoization using `useMemo` and `useCallback`?",
    "options": [
      "Manual memoization is now forbidden",
      "The compiler handles most cases, reducing the need for manual memoization",
      "Manual memoization is now required for every component",
      "useCallback has been removed from the API"
    ],
    "answer": "The compiler handles most cases, reducing the need for manual memoization",
    "explanation": "The React Compiler automates optimizations, meaning developers should use `useMemo` and `useCallback` sparingly as the compiler handles most performance needs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the main benefit of using React Server Components (RSC) regarding initial render times, as noted in case studies?",
    "options": [
      "Eliminates the need for CSS",
      "Reduces initial render times by approximately 67% (e.g., 2.4s to 0.8s)",
      "Makes the application run entirely on the client browser",
      "Removes the need for a build step"
    ],
    "answer": "Reduces initial render times by approximately 67% (e.g., 2.4s to 0.8s)",
    "explanation": "Adopting Server Components alongside frameworks like Next.js has been shown to significantly drop initial render times by offloading work to the server.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which of the following is NOT listed as one of the four converging patterns in JavaScript frameworks for 2026?",
    "options": [
      "Fine-grained reactivity",
      "Server-first architectures",
      "Compiler-driven optimizations",
      "Static-only rendering"
    ],
    "answer": "Static-only rendering",
    "explanation": "The four patterns are fine-grained reactivity, server-first architectures, compiler-driven optimizations, and AI-assisted workflows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the specific purpose of the `useOptimistic` hook mentioned in the context of newer React features?",
    "options": [
      "To force a component to re-render",
      "To handle optimistic updates for enhanced UX",
      "To fetch data from the server",
      "To manage complex routing logic"
    ],
    "answer": "To handle optimistic updates for enhanced UX",
    "explanation": "Newer hooks like `useOptimistic` are designed to handle enhanced UX patterns, specifically optimistic updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "When building large applications, what is the suggested strategy to mitigate performance issues caused by Context re-renders?",
    "options": [
      "Stop using Context entirely",
      "Use only global variables",
      "Split contexts or use state management libraries",
      "Convert all components to Server Components"
    ],
    "answer": "Split contexts or use state management libraries",
    "explanation": "To avoid performance bottlenecks where all consumers re-render, it is recommended to split contexts or utilize specialized state management libraries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does the text describe the impact of AI tools like GitHub Copilot and Vercel v0 on the developer workflow?",
    "options": [
      "They replace the need for senior developers",
      "They generate boilerplate to allow focus on architecture",
      "They eliminate security vulnerabilities automatically",
      "They remove the need to understand state management"
    ],
    "answer": "They generate boilerplate to allow focus on architecture",
    "explanation": "AI tools assist by generating boilerplate code (components, routes, tests), allowing developers to spend more time on architecture and less on wiring.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What feature in Next.js 16 allows for blending static shells with dynamic regions within a single route?",
    "options": [
      "Hybrid Rendering",
      "Partial Prerendering",
      "Static Site Generation",
      "Edge Functions"
    ],
    "answer": "Partial Prerendering",
    "explanation": "Next.js 16 formalizes Partial Prerendering, which blends static shells with dynamic regions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which hook is specifically mentioned in relation to form handling in the list of newer React concepts?",
    "options": [
      "useEffect",
      "useForm",
      "useActionState",
      "useLayoutEffect"
    ],
    "answer": "useActionState",
    "explanation": "The text lists `useActionState` as a newer hook relevant for form handling.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What does the analogy of pushing work \"into the back kitchen\" refer to in modern React architecture?",
    "options": [
      "Moving CSS to a separate server",
      "Using Server Components to fetch data and render on the server",
      "Hiring more developers",
      "Using background workers for JavaScript calculations"
    ],
    "answer": "Using Server Components to fetch data and render on the server",
    "explanation": "The analogy refers to using Server Components to handle data fetching and rendering on the server so the client (front of house) remains performant.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the purpose of the `useTransition` hook in React's concurrent features?",
    "options": [
      "To transition between different pages",
      "To keep the UI responsive during heavy updates by marking them as non-urgent",
      "To fetch data from an API",
      "To animate components entering the screen"
    ],
    "answer": "To keep the UI responsive during heavy updates by marking them as non-urgent",
    "explanation": "`useTransition` is used to mark state updates as transitions, allowing the UI to remain responsive during heavy computations or renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "According to the guide, what remains a core requirement for senior developers even with the rise of AI tools?",
    "options": [
      "Memorizing every API method",
      "Understanding state, data flow, performance, and security",
      "Writing code in Assembly",
      "Manual DOM manipulation"
    ],
    "answer": "Understanding state, data flow, performance, and security",
    "explanation": "AI tools help express decisions but do not remove the need to understand core concepts like state, data flow, performance, and security.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is the `use()` hook designed to simplify in React 19?",
    "options": [
      "Event handling",
      "DOM manipulation",
      "Data fetching",
      "Styling components"
    ],
    "answer": "Data fetching",
    "explanation": "The new `use()` hook is introduced to simplify data fetching patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which hook allows you to defer a re-render of a part of the UI if it is computationally expensive?",
    "options": [
      "useMemo",
      "useCallback",
      "useDeferredValue",
      "useReducer"
    ],
    "answer": "useDeferredValue",
    "explanation": "`useDeferredValue` allows you to defer updating a non-critical part of the UI to maintain responsiveness.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "How does the text describe the shift in mental models required for React in 2026?",
    "options": [
      "Moving from Class components to Functional components",
      "Adopting React Server Components (RSC)",
      "Focusing solely on mobile development",
      "Abandoning JavaScript for WebAssembly"
    ],
    "answer": "Adopting React Server Components (RSC)",
    "explanation": "The text identifies RSC as the biggest mental model shift, questioning whether deep mastery is now essential.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Why might a developer choose `useState` over `useReducer` for a specific piece of state?",
    "options": [
      "The state logic is very complex with multiple sub-values",
      "The state update logic involves heavy calculation",
      "The state is simple and does not require complex logic",
      "The state needs to be shared across the entire app"
    ],
    "answer": "The state is simple and does not require complex logic",
    "explanation": "`useState` is intended for simple state, while `useReducer` is better suited for complex state logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the estimated professional usage percentage of React mentioned in the text?",
    "options": [
      "Over 20%",
      "Over 40%",
      "Less than 10%",
      "Around 90%"
    ],
    "answer": "Over 40%",
    "explanation": "The text states that React accounts for over 40% of professional front-end usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the context of modern state management, which type of library is cited as an alternative to traditional Redux/Zustand for server state?",
    "options": [
      "Signal libraries",
      "Server-state libraries like TanStack Query",
      "Event emitters",
      "Local storage wrappers"
    ],
    "answer": "Server-state libraries like TanStack Query",
    "explanation": "The text questions if state management libraries are still core requirements given the rise of server-state libraries like TanStack Query.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What does 'treating \"what runs where\" as a first-class design decision' imply for modern development?",
    "options": [
      "Writing code only for the server",
      "Writing code only for the client",
      "Consciously deciding between server and client execution for different parts of the app",
      "Ignoring deployment environments"
    ],
    "answer": "Consciously deciding between server and client execution for different parts of the app",
    "explanation": "Developers are leaning on edge runtimes and server functions, making the distinction of where code runs a primary design decision.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which of the following best describes the 'Full Suspense Data-Fetching Model'?",
    "options": [
      "Loading data only after the user clicks a button",
      "Using Suspense for declarative data fetching beyond just lazy loading",
      "Fetching data synchronously in the render body",
      "Disabling JavaScript to load data faster"
    ],
    "answer": "Using Suspense for declarative data fetching beyond just lazy loading",
    "explanation": "The model extends Suspense to handle declarative data fetching, moving away from imperative lazy loading patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is a recommended practice when building reusable components that rely on Context?",
    "options": [
      "Avoid using Context in reusable components",
      "Establish a design system to maintain consistency",
      "Hardcode context values into the component",
      "Use a global state library instead of Context"
    ],
    "answer": "Establish a design system to maintain consistency",
    "explanation": "When building reusable components relying on context, establishing a design system helps maintain consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does React's Virtual DOM interact with Hooks?",
    "options": [
      "Hooks replace the Virtual DOM",
      "Hooks calculate the minimal DOM updates needed when state changes",
      "The Virtual DOM prevents Hooks from working",
      "Hooks slow down the Virtual DOM reconciliation"
    ],
    "answer": "Hooks calculate the minimal DOM updates needed when state changes",
    "explanation": "React's Virtual DOM and reconciliation algorithm work with hooks; when hook state changes, React calculates minimal DOM updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What happens to the importance of manual memoization skills (useMemo/useCallback) once the React Compiler becomes prevalent?",
    "options": [
      "They become completely useless",
      "They remain important for debugging the compiler's output",
      "They are removed from the language",
      "They become the only way to write performant code"
    ],
    "answer": "They remain important for debugging the compiler's output",
    "explanation": "While the compiler handles optimization, understanding manual memoization remains important for debugging purposes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which feature is described as blending static shells with dynamic regions?",
    "options": [
      "Suspense",
      "Partial Prerendering",
      "Server Actions",
      "Hydration"
    ],
    "answer": "Partial Prerendering",
    "explanation": "Partial Prerendering is defined as blending static shells with dynamic regions in a single route.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the primary reason for the shift away from `useEffect` for data fetching in React 19?",
    "options": [
      "useEffect is deprecated",
      "The emergence of the use() hook and Suspense for better patterns",
      "useEffect causes memory leaks",
      "Data fetching is no longer needed in React"
    ],
    "answer": "The emergence of the use() hook and Suspense for better patterns",
    "explanation": "The community has shifted away from `useEffect` because `use()` + Suspense offers a simpler and more effective model for data fetching.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which runtime environment are developers increasingly leaning on for executing server functions?",
    "options": [
      "Browser-based runtimes",
      "Edge runtimes",
      "Mainframe computers",
      "Local desktop environments"
    ],
    "answer": "Edge runtimes",
    "explanation": "Developers are leaning on edge runtimes and server functions to optimize performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "When using `useRef` to access a DOM element, what property on the returned object contains the element?",
    "options": [
      "element",
      "current",
      "dom",
      "value"
    ],
    "answer": "current",
    "explanation": "The `useRef` hook returns an object with a `current` property that holds the mutable value or DOM element.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Why is it suggested to split contexts in large applications?",
    "options": [
      "To reduce the bundle size",
      "To prevent unnecessary re-renders in components that only need a slice of the state",
      "To make the code harder to read",
      "To enable Server Components"
    ],
    "answer": "To prevent unnecessary re-renders in components that only need a slice of the state",
    "explanation": "Splitting contexts prevents components that only consume specific parts of the state from re-rendering when unrelated parts of the state change.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What does the text identify as a defining feature of modern workflows, not an optional bonus?",
    "options": [
      "TypeScript",
      "AI-assisted development",
      "CSS-in-JS",
      "GraphQL"
    ],
    "answer": "AI-assisted development",
    "explanation": "AI-assisted development is highlighted as a defining feature of modern workflows rather than an optional add-on.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the relationship between `useReducer` and Redux?",
    "options": [
      "useReducer replaces Redux entirely",
      "useReducer is inspired by Redux and handles complex state similarly",
      "Redux is a hook inside useReducer",
      "They are unrelated technologies"
    ],
    "answer": "useReducer is inspired by Redux and handles complex state similarly",
    "explanation": "The guide notes that `useReducer` is inspired by Redux and is excellent for complex state logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of 'signals' mentioned in advanced state management patterns, what role do they play?",
    "options": [
      "They replace React Hooks",
      "They are an alternative pattern alongside server-state libraries that impacts state management needs",
      "They are a type of server component",
      "They are used exclusively for styling"
    ],
    "answer": "They are an alternative pattern alongside server-state libraries that impacts state management needs",
    "explanation": "The text asks if state management libraries are still requirements given the rise of server-state libraries and signals.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of React 19 and the introduction of the React Compiler, how should developers approach the use of `useMemo` and `useCallback`?",
    "options": [
      "They should be used in every component to ensure maximum safety.",
      "They should be avoided entirely as they are deprecated in React 19.",
      "They should be used sparingly, as the React Compiler will handle most memoization cases automatically.",
      "They should only be used for server-side data fetching patterns."
    ],
    "answer": "They should be used sparingly, as the React Compiler will handle most memoization cases automatically.",
    "explanation": "With the advent of the React Compiler (React Forget), manual memoization becomes less necessary for writing code, as the compiler optimizes re-renders automatically. Developers are advised to use these hooks sparingly.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "According to the 2026 landscape, what is the recommended pattern for data fetching in React applications, replacing the traditional reliance on `useEffect` for this purpose?",
    "options": [
      "Using `useEffect` with `axios` directly inside the component body.",
      "Using the new `use()` hook combined with Suspense for declarative data fetching.",
      "Using `useReducer` to manage asynchronous API calls manually.",
      "Using `useRef` to store promise results until they resolve."
    ],
    "answer": "Using the new `use()` hook combined with Suspense for declarative data fetching.",
    "explanation": "React 19 introduces the `use()` hook to simplify data fetching. The community has shifted away from `useEffect` for fetching, moving towards a model using `use()` + Suspense.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary performance optimization strategy suggested for large applications using React Context to prevent unnecessary re-renders?",
    "options": [
      "Wrap the entire application in a single Context provider to centralize state.",
      "Avoid using Context entirely and rely solely on prop drilling.",
      "Split contexts into smaller, specific pieces or use state management libraries.",
      "Use `useMemo` to memoize the Context Provider component itself."
    ],
    "answer": "Split contexts into smaller, specific pieces or use state management libraries.",
    "explanation": "Since all components consuming a context re-render when its value changes, the best practice for large apps is to split contexts to minimize the scope of updates or utilize dedicated state management libraries.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which hook is explicitly recommended for managing complex state logic that involves multiple sub-values or intricate update logic, inspired by Redux?",
    "options": [
      "useState",
      "useRef",
      "useReducer",
      "useEffect"
    ],
    "answer": "useReducer",
    "explanation": "`useReducer` is preferred over `useState` when state logic is complex, involving multiple sub-values or complex state transitions, mirroring the Redux pattern.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When utilizing React Server Components (RSC), what is required to use hooks like `useState` or `useEffect` within a component?",
    "options": [
      "You must use the `use()` hook instead of `useState` in Server Components.",
      "You must add the `'use client'` directive at the top of the file to mark it as an interactive Client Component.",
      "You must configure the Next.js config file to enable hooks on the server.",
      "You cannot use hooks in React 19; they are replaced by Server Actions."
    ],
    "answer": "You must add the `'use client'` directive at the top of the file to mark it as an interactive Client Component.",
    "explanation": "Server Components cannot use hooks like `useState` or `useEffect`. To use interactivity and hooks, the component must be marked with `'use client'`.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "In the context of React 19, what is the specific use case for the `useRef` hook compared to state management hooks?",
    "options": [
      "Managing complex form state across multiple components.",
      "Fetching data from an API and handling loading/error states.",
      "Accessing DOM elements directly and storing mutable values that do not trigger re-renders.",
      "Optimizing performance by memoizing expensive calculations."
    ],
    "answer": "Accessing DOM elements directly and storing mutable values that do not trigger re-renders.",
    "explanation": "`useRef` is used for DOM access and holding mutable values that persist across renders without causing the component to re-update when changed.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "According to case studies mentioned in the text, what was the approximate improvement in initial render times observed when teams adopted React Server Components alongside frameworks like Next.js?",
    "options": [
      "A drop from 2.4s to 0.8s (approximately 67% improvement).",
      "A drop from 5.0s to 4.5s (approximately 10% improvement).",
      "A drop from 1.0s to 0.1s (approximately 90% improvement).",
      "A drop from 3.5s to 3.0s (approximately 15% improvement)."
    ],
    "answer": "A drop from 2.4s to 0.8s (approximately 67% improvement).",
    "explanation": "Reports indicate that adopting React Server Components can lead to significant performance gains, specifically a drop from about 2.4s to 0.8s in initial render times.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What are the 'four converging patterns' identified across major JavaScript frameworks in 2026?",
    "options": [
      "Functional programming, immutability, static typing, and monolithic architectures.",
      "Fine-grained reactivity, server-first architectures, compiler-driven optimizations, and AI-assisted workflows.",
      "CSS-in-JS, utility-first CSS, component libraries, and design systems.",
      "WebAssembly, WebGL, WebRTC, and WebSockets."
    ],
    "answer": "Fine-grained reactivity, server-first architectures, compiler-driven optimizations, and AI-assisted workflows.",
    "explanation": "The industry is converging on fine-grained reactivity, server-first architectures (like RSC), compiler-driven optimizations (like React Compiler), and AI-assisted workflows.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which of the following hooks is specifically introduced/enhanced in React 19 for handling enhanced UX patterns like optimistic updates?",
    "options": [
      "useTransition",
      "useDeferredValue",
      "useOptimistic",
      "useCallback"
    ],
    "answer": "useOptimistic",
    "explanation": "The `useOptimistic` hook is one of the newer additions intended to facilitate optimistic UI patterns, allowing the UI to update immediately before a server action completes.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "How does the `use()` hook differ from standard hooks like `useState` regarding its placement in a component?",
    "options": [
      "It can only be used inside the `render` method of a class component.",
      "It can be called conditionally and inside loops, unlike standard hooks which must be called unconditionally at the top level.",
      "It must be used inside a `useEffect` to handle asynchronous operations.",
      "It replaces the need for `useReducer` entirely in complex applications."
    ],
    "answer": "It can be called conditionally and inside loops, unlike standard hooks which must be called unconditionally at the top level.",
    "explanation": "`use()` is a special API that wraps promises or contexts. Unlike standard hooks, it is designed to be callable in conditional statements and loops (e.g., inside `if` or `try/catch` blocks), handling the rendering suspension.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the primary benefit of Next.js 16's 'Partial Prerendering' feature?",
    "options": [
      "It renders the entire application on the client side to improve SEO.",
      "It eliminates the need for API routes by handling database queries directly in the component.",
      "It blends static shells with dynamic regions in a single route, allowing parts of a page to be static while others are streamed.",
      "It automatically optimizes all images without requiring the next/image component."
    ],
    "answer": "It blends static shells with dynamic regions in a single route, allowing parts of a page to be static while others are streamed.",
    "explanation": "Partial Prerendering allows developers to serve a static shell for the immediate parts of a page while dynamically fetching and streaming the rest, combining static and dynamic rendering in one route.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "When designing reusable components that rely on Context, what is a critical design system consideration to maintain consistency?",
    "options": [
      "Ensuring all context providers are defined in the same file as the component.",
      "Using `PropTypes` to validate the context value passed down.",
      "Establishing a design system that helps manage context consumption and propagation consistently.",
      "Avoiding the use of context in reusable components altogether."
    ],
    "answer": "Establishing a design system that helps manage context consumption and propagation consistently.",
    "explanation": "To avoid issues with context re-renders and prop drilling in reusable components, establishing a design system helps ensure that context reliance is handled consistently across the application.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Why is understanding manual memoization (`useMemo`, `useCallback`) still considered relevant despite the React Compiler automating it?",
    "options": [
      "Because the React Compiler is not stable and causes bugs in production.",
      "Because developers must manually write the compiler logic for third-party libraries.",
      "Because understanding the concepts is crucial for debugging performance issues if the compiler's optimizations fail or are insufficient.",
      "Because `useMemo` and `useCallback` are required for Server Components to function."
    ],
    "answer": "Because understanding the concepts is crucial for debugging performance issues if the compiler's optimizations fail or are insufficient.",
    "explanation": "While the compiler handles most optimization, understanding manual memoization remains vital for debugging edge cases where automatic optimization might not behave as expected or for scenarios outside the compiler's scope.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What role do tools like GitHub Copilot and Vercels v0 play in the 2026 React development workflow?",
    "options": [
      "They replace the need for developers to learn JavaScript and React syntax.",
      "They handle state management and data fetching logic automatically without code.",
      "They generate boilerplate code (components, routes, tests), allowing developers to focus on architecture and high-level decisions.",
      "They act as live browsers that render the application without a build step."
    ],
    "answer": "They generate boilerplate code (components, routes, tests), allowing developers to focus on architecture and high-level decisions.",
    "explanation": "AI tools in 2026 focus on generating boilerplate and repetitive tasks, freeing up developers to concentrate on architecture, data flow, and security rather than wiring code.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which hook is intended for form handling and managing the state of a form action in React 19?",
    "options": [
      "useFormState",
      "useActionState",
      "useFormStatus",
      "useTransition"
    ],
    "answer": "useActionState",
    "explanation": "`useActionState` is a hook specifically designed to manage the state of form actions, helping to handle pending states, errors, and submissions more effectively in React 19.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the defining characteristic of the 'Full Suspense Data-Fetching Model' in 2026?",
    "options": [
      "It uses `useEffect` to fetch data and set a loading state boolean.",
      "It relies on callbacks passed down from parent components to trigger fetches.",
      "It treats data fetching as a declarative process where the UI reads a promise that suspends rendering until resolution.",
      "It requires all data fetching to happen in the `componentDidMount` lifecycle method."
    ],
    "answer": "It treats data fetching as a declarative process where the UI reads a promise that suspends rendering until resolution.",
    "explanation": "The Full Suspense model shifts data fetching to a declarative paradigm where components read resources (promises), and React suspends the UI (shows a fallback) until the data is ready, rather than orchestrating fetches imperatively.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does the text describe the evolution of 'what runs where' in modern React applications?",
    "options": [
      "It is an afterthought handled during the deployment phase.",
      "It is a first-class design decision made during architecture planning.",
      "It is determined automatically by the browser based on network speed.",
      "It is no longer relevant because everything runs on the client."
    ],
    "answer": "It is a first-class design decision made during architecture planning.",
    "explanation": "With the rise of Server Components and edge runtimes, deciding whether code runs on the server, edge, or client has become a fundamental architectural decision rather than an afterthought.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "Which of the following best describes the function of `useDeferredValue` in concurrent React features?",
    "options": [
      "It postpones an update to a part of the UI if it is computationally expensive, allowing more urgent updates to proceed.",
      "It defers the mounting of a component until the user scrolls it into view.",
      "It caches the result of a calculation indefinitely.",
      "It prevents a component from rendering until all data is fetched."
    ],
    "answer": "It postpones an update to a part of the UI if it is computationally expensive, allowing more urgent updates to proceed.",
    "explanation": "`useDeferredValue` is used to prioritize rendering updates. It tells React to defer updating a specific value (and the UI depending on it) if there are more urgent interactions (like typing) happening.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the implication of React Server Components on the amount of client-side JavaScript shipped to the browser?",
    "options": [
      "It increases the amount of JavaScript because server code is transpiled to client code.",
      "It has no effect on bundle size; it only changes where the HTML is generated.",
      "It reduces client-side JavaScript to zero for the parts of the UI rendered as Server Components.",
      "It doubles the bundle size to support hydration."
    ],
    "answer": "It reduces client-side JavaScript to zero for the parts of the UI rendered as Server Components.",
    "explanation": "Server Components render on the server and send HTML to the client. They do not send the corresponding JavaScript for those components to the browser, significantly reducing the client-side bundle size for those sections.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "In the context of state management trends, what is the suggested role of 'server-state libraries' like TanStack Query in 2026?",
    "options": [
      "They replace the need for `useState` for all local component state.",
      "They are considered obsolete due to the introduction of `use()`.",
      "They handle server state synchronization and caching, potentially reducing the need for complex global client state managers like Redux.",
      "They are used exclusively for managing CSS-in-JS styles."
    ],
    "answer": "They handle server state synchronization and caching, potentially reducing the need for complex global client state managers like Redux.",
    "explanation": "Libraries like TanStack Query (React Query) manage server state effectively. The text suggests this might reduce the necessity for heavy client-side state management libraries (Redux/Zustand) in many applications.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "When using `useReducer`, what is the term for the function passed as the first argument that determines how the state changes based on an action?",
    "options": [
      "Effect Function",
      "Reducer Function",
      "Dispatcher Function",
      "Action Creator"
    ],
    "answer": "Reducer Function",
    "explanation": "In `useReducer`, the logic for state updates is encapsulated in a 'reducer function'. This function takes the current state and an action, and returns the next state.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the correct interpretation of the performance note regarding React Context consumers?",
    "options": [
      "Only the component closest to the Provider re-renders.",
      "Only the leaf nodes in the component tree re-render.",
      "All components consuming the context will re-render whenever the context value changes.",
      "Context consumers do not re-render unless `forceUpdate` is called."
    ],
    "answer": "All components consuming the context will re-render whenever the context value changes.",
    "explanation": "A common performance pitfall of Context is that any component consuming it (using `useContext`) will re-render if the provider's value prop changes, regardless of whether that specific piece of data was used by the consumer.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How does the `useTransition` hook improve user experience in list filtering or search scenarios?",
    "options": [
      "It cancels the current search request if a new key is pressed.",
      "It marks certain state updates as 'transitions', allowing React to keep the UI interactive (e.g., responsive to typing) while the heavy update processes.",
      "It automatically debounces the input field to prevent API spamming.",
      "It converts the functional component into a class component to handle state better."
    ],
    "answer": "It marks certain state updates as 'transitions', allowing React to keep the UI interactive (e.g., responsive to typing) while the heavy update processes.",
    "explanation": "`useTransition` allows React to interrupt a heavy render (like filtering a large list) if a higher-priority update (like user input) comes in, preventing the UI from freezing.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the relationship between React's Virtual DOM and Hooks regarding state updates?",
    "options": [
      "Hooks bypass the Virtual DOM to update the browser DOM directly.",
      "Hooks manage state, and when state changes, React uses the Virtual DOM and reconciliation algorithm to calculate minimal DOM updates.",
      "Hooks replace the need for the Virtual DOM entirely.",
      "The Virtual DOM is only used in Class Components, while Hooks use a different rendering engine."
    ],
    "answer": "Hooks manage state, and when state changes, React uses the Virtual DOM and reconciliation algorithm to calculate minimal DOM updates.",
    "explanation": "Hooks are the interface for state and lifecycle features in functional components. When hook state changes, React's internal reconciliation engine (working with the Virtual DOM) determines what needs to change in the actual DOM.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Which of the following is NOT listed as a 'must-know' emerging concept for React in 2026?",
    "options": [
      "React Server Components (RSCs)",
      "The Full Suspense Data-Fetching Model",
      "Concurrent Features (useTransition, useDeferredValue)",
      "Using `componentWillMount` in class components"
    ],
    "answer": "Using `componentWillMount` in class components",
    "explanation": "The text highlights RSCs, Suspense, and Concurrent Features as critical. Lifecycle methods like `componentWillMount` are legacy concepts and are not part of the modern roadmap.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is a specific use case for `useRef` that distinguishes it from simply storing a variable in a module scope?",
    "options": [
      "Storing a value that is shared across all instances of a component.",
      "Storing a mutable value that persists across re-renders but is specific to a single component instance.",
      "Storing the API response for a specific network request.",
      "Storing the CSS styles for a component."
    ],
    "answer": "Storing a mutable value that persists across re-renders but is specific to a single component instance.",
    "explanation": "Unlike module-scope variables (which are global), a `useRef` value is tied to the specific component instance. It persists without causing re-renders, making it ideal for instance-specific mutable data.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "According to the text, what is the market share context for React that influences the importance of learning its patterns?",
    "options": [
      "React is used by less than 10% of developers.",
      "React accounts for over 40% of professional front-end usage.",
      "React is exclusively used for hobby projects and startups.",
      "React has been completely replaced by Svelte in enterprise environments."
    ],
    "answer": "React accounts for over 40% of professional front-end usage.",
    "explanation": "The text notes that React accounts for over 40% of professional front-end usage, making the ecosystem patterns and trends highly relevant for professional developers.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Why is the mental model shift to React Server Components considered significant?",
    "options": [
      "Because it requires developers to learn a new programming language.",
      "Because it fundamentally changes how developers think about the division of labor between server and client, moving away from purely client-side rendering.",
      "Because it eliminates the need for CSS.",
      "Because it makes all websites static HTML files."
    ],
    "answer": "Because it fundamentally changes how developers think about the division of labor between server and client, moving away from purely client-side rendering.",
    "explanation": "RSC represents a major paradigm shift where the default is rendering on the server, requiring developers to consciously decide what needs interactivity (client-side) versus what can be static (server-side).",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the primary function of the `use()` hook regarding asynchronous resources?",
    "options": [
      "It creates a new Promise that resolves after a delay.",
      "It reads the value of a resource (like a Promise or Context) and suspends the component if the resource is not yet ready.",
      "It cleans up side effects when a component unmounts.",
      "It triggers a re-render whenever a variable changes."
    ],
    "answer": "It reads the value of a resource (like a Promise or Context) and suspends the component if the resource is not yet ready.",
    "explanation": "The `use()` hook allows a component to read a resource. If the resource is a Promise that hasn't settled, React suspends that component, displaying the nearest Suspense fallback until the data is available.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In a 2026 stack utilizing AI-assisted workflows, what remains the core responsibility of the developer that AI cannot replace?",
    "options": [
      "Writing the syntax for functional components.",
      "Setting up the initial project configuration (npm install).",
      "Understanding state, data flow, performance, and security architecture.",
      "Writing unit tests for simple pure functions."
    ],
    "answer": "Understanding state, data flow, performance, and security architecture.",
    "explanation": "While AI handles boilerplate and syntax, the text emphasizes that AI does not remove the need for developers to deeply understand architecture, state management, data flow, performance, and security.",
    "difficulty": "Advanced"
  }
]