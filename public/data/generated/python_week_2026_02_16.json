[
  {
    "id": 1,
    "question": "What does the acronym 'GIL' stand for in the context of Python?",
    "options": [
      "Global Interface Lock",
      "Global Interpreter Lock",
      "General Internal Logic",
      "Global Integrated Loop"
    ],
    "answer": "Global Interpreter Lock",
    "explanation": "The GIL stands for Global Interpreter Lock. It is a mutex used in CPython to protect access to Python objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which keyword is used to define a function in Python?",
    "options": [
      "function",
      "def",
      "func",
      "define"
    ],
    "answer": "def",
    "explanation": "The `def` keyword is used to define a function in Python. It is followed by the function name and parentheses.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary purpose of the Global Interpreter Lock (GIL)?",
    "options": [
      "To speed up single-threaded execution by compiling bytecode",
      "To prevent multiple threads from executing Python bytecodes at once",
      "To manage memory allocation for large objects",
      "To enforce strict type checking at runtime"
    ],
    "answer": "To prevent multiple threads from executing Python bytecodes at once",
    "explanation": "The GIL is a mutex that ensures only one thread executes Python bytecode at a time. This simplifies memory management but limits parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which of the following data types is immutable in Python?",
    "options": [
      "List",
      "Dictionary",
      "Set",
      "Tuple"
    ],
    "answer": "Tuple",
    "explanation": "Tuples are immutable sequences, meaning their elements cannot be changed after creation. Lists, dictionaries, and sets are mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "How does Python primarily manage memory allocation for objects?",
    "options": [
      "Manual memory management via malloc/free",
      "Reference counting",
      "Mark-and-sweep garbage collection exclusively",
      "Automatic stack allocation only"
    ],
    "answer": "Reference counting",
    "explanation": "Python uses reference counting as its primary memory management technique. Objects are deallocated when their reference count reaches zero.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which symbol is used for single-line comments in Python?",
    "options": [
      "//",
      "#",
      "/*",
      "--"
    ],
    "answer": "#",
    "explanation": "The hash symbol `#` is used to denote a single-line comment in Python. The interpreter ignores everything following `#` on that line.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the output of the following code: `print(type([]))`?",
    "options": [
      "<class 'list'>",
      "<class 'array'>",
      "list",
      "<type 'list'>"
    ],
    "answer": "<class 'list'>",
    "explanation": "The `[]` syntax creates a list. The `type()` function returns the type of the object, which is formatted as `<class 'list'>` in Python 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "For which type of task is the GIL least restrictive, allowing multithreading to be effective?",
    "options": [
      "CPU-bound tasks involving heavy computation",
      "Memory-bound tasks involving large datasets",
      "I/O-bound tasks involving waiting for disk or network",
      "GPU-intensive rendering tasks"
    ],
    "answer": "I/O-bound tasks involving waiting for disk or network",
    "explanation": "The GIL is released during I/O operations. This allows other threads to run while waiting for I/O, making multithreading effective for I/O-bound tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which module is recommended for achieving parallelism for CPU-bound tasks in Python?",
    "options": [
      "threading",
      "multiprocessing",
      "asyncio",
      "concurrent"
    ],
    "answer": "multiprocessing",
    "explanation": "The `multiprocessing` module creates separate processes, each with its own Python interpreter and memory space. This bypasses the GIL, allowing for true parallelism on CPU-bound tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What happens when an object's reference count reaches zero?",
    "options": [
      "The object is moved to a cache for later use",
      "The object is immediately deallocated from memory",
      "The garbage collector is triggered immediately",
      "The object is marked for deletion on the next cycle"
    ],
    "answer": "The object is immediately deallocated from memory",
    "explanation": "In Python's reference counting system, an object is deallocated immediately when its reference count drops to zero. This is the primary mechanism for memory management.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which of the following is the correct syntax for a dictionary?",
    "options": [
      "{'key': 'value'}",
      "['key': 'value']",
      "('key', 'value')",
      "{\"key\": \"value\"}"
    ],
    "answer": "{'key': 'value'}",
    "explanation": "Dictionaries are defined using curly braces `{}` with key-value pairs separated by a colon. Lists use square brackets, and tuples use parentheses.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the result of the expression `10 // 3`?",
    "options": [
      "3.33",
      "3",
      "4",
      "1"
    ],
    "answer": "3",
    "explanation": "The `//` operator performs floor division, which returns the largest integer less than or equal to the division result. 10 divided by 3 is 3.33, so the floor is 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Why is the GIL problematic for CPU-bound multi-threaded programs?",
    "options": [
      "It causes memory leaks due to excessive locking",
      "It prevents threads from running in parallel on multiple CPU cores",
      "It increases the overhead of context switching",
      "It limits the program to a single process"
    ],
    "answer": "It prevents threads from running in parallel on multiple CPU cores",
    "explanation": "The GIL ensures only one thread executes bytecode at a time. This negates the performance benefits of multi-core processors for CPU-intensive tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which function is used to read a single line of input from the user in Python 3?",
    "options": [
      "raw_input()",
      "input()",
      "scanf()",
      "read()"
    ],
    "answer": "input()",
    "explanation": "In Python 3, `input()` is used to read a line from standard input. `raw_input()` was used in Python 2 but was renamed to `input()` in Python 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "How do you start a `for` loop that iterates over a range of numbers from 0 to 4?",
    "options": [
      "for i in range(5):",
      "for i in range(4):",
      "for i in [0, 5]:",
      "for i = 0 to 5:"
    ],
    "answer": "for i in range(5):",
    "explanation": "The `range(5)` function generates a sequence of numbers from 0 up to (but not including) 5. Python uses a colon `:` to start the block.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the behavior of the `sys.getrefcount()` function?",
    "options": [
      "It returns the number of threads currently accessing the object",
      "It returns the number of references pointing to the object",
      "It returns the memory address of the object",
      "It returns the total number of objects in memory"
    ],
    "answer": "It returns the number of references pointing to the object",
    "explanation": "`sys.getrefcount(object)` returns the reference count of the object. Note that the count is temporarily higher when passed to the function itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which keyword is used to import a module in Python?",
    "options": [
      "include",
      "using",
      "import",
      "require"
    ],
    "answer": "import",
    "explanation": "The `import` keyword is used to include modules in a Python script. For example, `import math` makes the math module available.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the result of `bool([])`?",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "answer": "False",
    "explanation": "Empty containers, such as lists, dictionaries, and tuples, evaluate to `False` in a boolean context. Non-empty containers evaluate to `True`.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "In the context of removing the GIL, what is 'Biased Reference Counting'?",
    "options": [
      "A method to increase memory usage for better speed",
      "A thread-safe modification to reference counting",
      "A way to force all operations onto a single thread",
      "A technique to disable garbage collection"
    ],
    "answer": "A thread-safe modification to reference counting",
    "explanation": "Biased reference counting is an optimization designed to make reference counting thread-safe without the performance cost of global locks, necessary for a free-threaded Python.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How do you define a class in Python?",
    "options": [
      "class MyClass:",
      "def MyClass:",
      "class MyClass():",
      "struct MyClass:"
    ],
    "answer": "class MyClass:",
    "explanation": "Classes are defined using the `class` keyword followed by the class name and a colon. Parentheses are optional if not inheriting from another class.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What does the `pass` keyword do in Python?",
    "options": [
      "It skips the next iteration of a loop",
      "It acts as a placeholder for future code",
      "It exits the current function",
      "It raises an exception"
    ],
    "answer": "It acts as a placeholder for future code",
    "explanation": "`pass` is a null operation; nothing happens when it executes. It is often used as a placeholder where code is syntactically required (e.g., inside a function or class).",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which type of error occurs when a variable is used before it has been assigned a value?",
    "options": [
      "SyntaxError",
      "NameError",
      "TypeError",
      "ValueError"
    ],
    "answer": "NameError",
    "explanation": "A `NameError` is raised when a local or global name is not found. This typically happens if you try to access a variable that hasn't been defined.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What character is used to separate items in a list?",
    "options": [
      "semicolon (;)",
      "colon (:)",
      "comma (,)",
      "pipe (|)"
    ],
    "answer": "comma (,)",
    "explanation": "Items in a list, tuple, or dictionary are separated by commas. For example: `[1, 2, 3]`.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "How do you handle exceptions in Python?",
    "options": [
      "try/catch",
      "try/except",
      "do/except",
      "try/error"
    ],
    "answer": "try/except",
    "explanation": "Python uses `try` and `except` blocks to handle exceptions. Code that might raise an error goes in the `try` block, and handling code goes in the `except` block.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is a 'Race Condition' in the context of multithreading?",
    "options": [
      "When two threads finish at the exact same time",
      "When the behavior of software depends on the sequence of uncontrollable events",
      "When a thread runs faster than the others",
      "When the CPU overheats due to heavy calculation"
    ],
    "answer": "When the behavior of software depends on the sequence of uncontrollable events",
    "explanation": "A race condition occurs when the system's outcome depends on the timing of uncontrollable concurrent events. The GIL prevents race conditions regarding Python object reference counts.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which function adds an element to the end of a list?",
    "options": [
      "add()",
      "push()",
      "append()",
      "insert()"
    ],
    "answer": "append()",
    "explanation": "The `append()` method adds a single item to the end of the list. `insert()` is used to add at a specific index.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the file extension for Python source code files?",
    "options": [
      ".python",
      ".py",
      ".pt",
      ".pyt"
    ],
    "answer": ".py",
    "explanation": "Python source code files use the `.py` extension. The interpreter executes files with this extension.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the output of `print('Hello' + 'World')`?",
    "options": [
      "Hello World",
      "HelloWorld",
      "'Hello' 'World'",
      "Error"
    ],
    "answer": "HelloWorld",
    "explanation": "The `+` operator concatenates strings. Since there is no space in the strings or added operator, they are joined directly without a space.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which built-in function returns the length of a list?",
    "options": [
      "size()",
      "length()",
      "len()",
      "count()"
    ],
    "answer": "len()",
    "explanation": "The `len()` function returns the number of items in a container (like a list, string, or dictionary).",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What mechanism in CPython handles circular references (reference cycles)?",
    "options": [
      "The GIL (Global Interpreter Lock)",
      "Reference counting",
      "The Cyclic Garbage Collector",
      "The memory allocator"
    ],
    "answer": "The Cyclic Garbage Collector",
    "explanation": "Reference counting cannot detect cycles where objects reference each other. CPython includes a cyclic garbage collector specifically to identify and clean up these isolated groups.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "How do you create a virtual environment in Python 3?",
    "options": [
      "python createenv venv",
      "python -m venv venv",
      "python venv init",
      "python install venv"
    ],
    "answer": "python -m venv venv",
    "explanation": "The standard way to create a virtual environment in Python 3 is using the `venv` module by running `python -m venv <directory_name>`.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the result of `3 * 'a'`?",
    "options": [
      "aaa",
      "'a' 'a' 'a'",
      "Error",
      "3a"
    ],
    "answer": "aaa",
    "explanation": "Multiplying a string by an integer repeats the string that many times. `3 * 'a'` results in `'aaa'`.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which method returns the keys of a dictionary as a view object?",
    "options": [
      "keys()",
      "list_keys()",
      "get_keys()",
      "items()"
    ],
    "answer": "keys()",
    "explanation": "The `keys()` method returns a view object displaying all the keys in the dictionary. `items()` returns key-value pairs.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What happens if you try to access a list index that is out of bounds?",
    "options": [
      "KeyError",
      "ValueError",
      "IndexError",
      "AttributeError"
    ],
    "answer": "IndexError",
    "explanation": "An `IndexError` is raised when you try to access an item in a list using an index that is outside the valid range.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What does the `yield` keyword do in a function?",
    "options": [
      "It stops the function permanently",
      "It returns a value and suspends the function's execution",
      "It creates a list of results",
      "It raises an exception"
    ],
    "answer": "It returns a value and suspends the function's execution",
    "explanation": "`yield` turns a function into a generator. When called, it returns a generator iterator that yields values one at a time, suspending and resuming execution between each yield.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary reason CPython uses the Global Interpreter Lock (GIL)?",
    "options": [
      "To prevent deadlocks in complex multithreading algorithms",
      "To simplify memory management by making reference counting thread-safe",
      "To enforce strict type checking at runtime",
      "To optimize bytecode compilation speed"
    ],
    "answer": "To simplify memory management by making reference counting thread-safe",
    "explanation": "The GIL protects access to Python objects, specifically the reference count variable. Without it, race conditions on reference counts could cause memory leaks or premature deallocation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "How does the GIL impact CPU-bound tasks in a multi-threaded Python script?",
    "options": [
      "It allows multiple threads to execute on multiple cores simultaneously",
      "It forces threads to run sequentially, effectively negating multi-core benefits",
      "It automatically converts threads into processes",
      "It causes the interpreter to crash if threads exceed CPU core count"
    ],
    "answer": "It forces threads to run sequentially, effectively negating multi-core benefits",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time. For CPU-bound tasks, this prevents true parallelism, making threading inefficient for such workloads.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In Python memory management, what happens when an object's reference count reaches zero?",
    "options": [
      "The object is moved to a 'generation 0' cache for later inspection",
      "The memory occupied by the object is immediately deallocated",
      "The object is marked for deletion but not freed until the program exits",
      "The garbage collector runs a full cycle immediately"
    ],
    "answer": "The memory occupied by the object is immediately deallocated",
    "explanation": "CPython primarily uses reference counting. When the count drops to zero, the memory is reclaimed immediately via the allocator's free routine.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which concurrency model is recommended for CPU-bound tasks in Python to bypass the GIL?",
    "options": [
      "Asyncio event loops",
      "Multi-threading",
      "Multi-processing",
      "Coroutines"
    ],
    "answer": "Multi-processing",
    "explanation": "The `multiprocessing` module creates separate processes, each with its own Python interpreter and memory space (and its own GIL), enabling true parallelism on multi-core CPUs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the role of 'cyclic garbage collection' in CPython?",
    "options": [
      "To optimize CPU cache hits during bytecode execution",
      "To detect and collect reference cycles that reference counting cannot handle",
      "To compress memory fragmentation in the heap",
      "To manage the lifecycle of thread locks"
    ],
    "answer": "To detect and collect reference cycles that reference counting cannot handle",
    "explanation": "Reference counting cannot handle circular references (e.g., A references B, B references A). The cyclic GC traverses objects to identify and collect these isolated groups.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What characteristic defines 'preemptive multitasking' in the context of Python threads?",
    "options": [
      "Threads voluntarily yield control to the operating system",
      "The interpreter forces threads to yield after a specific number of bytecode instructions",
      "The operating system forcibly interrupts threads to schedule others",
      "Threads must explicitly check for signals to switch context"
    ],
    "answer": "The operating system forcibly interrupts threads to schedule others",
    "explanation": "Preemptive multitasking means the OS (or interpreter mechanism) decides when to switch threads, independent of the thread's current logic or willingness to yield.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Why does the GIL negatively affect performance in CPU-bound multi-threaded programs?",
    "options": [
      "It introduces overhead for locking every single variable access",
      "It prevents the interpreter from utilizing multiple CPU cores simultaneously",
      "It forces the program to use only a single CPU core",
      "It causes frequent context switches between user mode and kernel mode"
    ],
    "answer": "It prevents the interpreter from utilizing multiple CPU cores simultaneously",
    "explanation": "The GIL is a mutex that allows only one thread to hold the control of the Python interpreter, meaning threads cannot run in parallel on separate cores.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "According to PEP 703 and recent developments, what is 'Biased Reference Counting'?",
    "options": [
      "A method where objects always have a reference count of 1 to optimize speed",
      "A technique where reference counts are stored on a separate thread to avoid collisions",
      "A thread-safe reference counting mechanism designed for GIL removal",
      "A way to bias the garbage collector towards newer objects"
    ],
    "answer": "A thread-safe reference counting mechanism designed for GIL removal",
    "explanation": "Biased reference counting is an optimization used to make reference counting thread-safe without the heavy performance cost of atomic operations, facilitating the removal of the GIL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "When is the GIL typically released in a CPython thread?",
    "options": [
      "When a thread calls a system I/O operation or runs for a set time interval",
      "Only when the thread explicitly calls `time.sleep()`",
      "When the total memory usage exceeds a threshold",
      "Whenever a variable is reassigned"
    ],
    "answer": "When a thread calls a system I/O operation or runs for a set time interval",
    "explanation": "The GIL is released during I/O operations (waiting for disk/network) and periodically via a check interval, allowing other threads to run.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is a significant change in the Garbage Collector (GC) regarding cycles when the GIL is removed?",
    "options": [
      "The GC is disabled, requiring manual memory management",
      "The GC requires two 'stop-the-world' passes to safely identify cycles",
      "The GC runs only when the CPU is idle",
      "The GC stops running periodically and becomes a one-time operation at exit"
    ],
    "answer": "The GC requires two 'stop-the-world' passes to safely identify cycles",
    "explanation": "Without the GIL, object references can change during collection. A stop-the-world pause is required to ensure stable references while identifying cyclic trash.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the function of `sys.getrefcount(obj)` in Python?",
    "options": [
      "It returns the number of times the object has been accessed in the code",
      "It returns the number of references pointing to the object, plus one for the argument passed to the function",
      "It returns the memory address of the object",
      "It resets the reference count of the object to zero"
    ],
    "answer": "It returns the number of references pointing to the object, plus one for the argument passed to the function",
    "explanation": "The function returns the current reference count. Note that the temporary reference passed as an argument to the function itself is included in the count.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the context of Python's memory management, what is a 'generation'?",
    "options": [
      "A classification of objects based on their data type",
      "A categorization of objects based on how many collection cycles they have survived",
      "A specific segment of heap memory reserved for integers",
      "A version identifier for the Python interpreter instance"
    ],
    "answer": "A categorization of objects based on how many collection cycles they have survived",
    "explanation": "The generational GC assumes that young objects are more likely to become garbage. Objects are moved to older generations if they survive collection sweeps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What happens if you call `sys.setrecursionlimit(10)` and a function recurses deeper than 10 frames?",
    "options": [
      "The program slows down but continues execution",
      "The interpreter raises a `RecursionError` exception",
      "The garbage collector automatically deletes the oldest frames",
      "The operating system terminates the process"
    ],
    "answer": "The interpreter raises a `RecursionError` exception",
    "explanation": "The recursion limit prevents stack overflow. If the limit is exceeded, Python raises a `RecursionError` to halt execution safely.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which statement correctly describes the behavior of `weakref`?",
    "options": [
      "It prevents the garbage collector from deleting the object entirely",
      "It creates a reference that does not increase the object's reference count",
      "It forces the object to be stored in the 'generation 0' space",
      "It creates a hard link that is always faster than a standard reference"
    ],
    "answer": "It creates a reference that does not increase the object's reference count",
    "explanation": "Weak references allow referencing an object without preventing it from being garbage collected. They are useful for caches or observers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How do Python generators manage memory compared to returning a full list?",
    "options": [
      "Generators load the entire dataset into memory but process it faster",
      "Generators compute values one at a time as they are requested, reducing memory footprint",
      "Generators use a separate memory heap called the 'generator pool'",
      "Generators cannot be iterated multiple times, unlike lists"
    ],
    "answer": "Generators compute values one at a time as they are requested, reducing memory footprint",
    "explanation": "Generators use lazy evaluation. They yield items one by one and maintain state, meaning they do not need to store the entire sequence in memory at once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the primary risk of using a mutable default argument in a function definition?",
    "options": [
      "The argument becomes immutable after the first function call",
      "The mutable object is created once at definition time and shared across all calls",
      "The function will throw a `SyntaxError`",
      "The argument is passed by value instead of by reference"
    ],
    "answer": "The mutable object is created once at definition time and shared across all calls",
    "explanation": "Default values are evaluated only once when the function is defined. Mutating it in one call persists the change for subsequent calls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In Python, what distinguishes `is` from `==`?",
    "options": [
      "`is` checks for value equality, while `==` checks for memory address",
      "`is` checks for identity (memory address), while `==` checks for value equality",
      "`is` is used for integers and `==` is used for strings",
      "There is no difference; they are interchangeable aliases"
    ],
    "answer": "`is` checks for identity (memory address), while `==` checks for value equality",
    "explanation": "`is` compares object IDs (identity). `==` invokes the `__eq__` method to compare the content or value of the objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the purpose of the `__slots__` declaration in a class?",
    "options": [
      "To define private methods that cannot be overridden",
      "To restrict the creation of new attributes and save memory",
      "To enable multiple inheritance for that specific class",
      "To specify which methods are available for async operations"
    ],
    "answer": "To restrict the creation of new attributes and save memory",
    "explanation": "`__slots__` replaces the default `__dict__` with a fixed-size array of descriptors, reducing memory usage and preventing the dynamic addition of attributes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the result of attempting to modify a variable declared as `global` inside a function?",
    "options": [
      "A syntax error occurs because globals are read-only",
      "The modification affects the variable in the module's global scope",
      "A local variable is created with the same name, shadowing the global",
      "The variable is moved to the local scope automatically"
    ],
    "answer": "The modification affects the variable in the module's global scope",
    "explanation": "The `global` keyword instructs Python to refer to the variable in the enclosing module scope, allowing the function to modify the global binding.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How does `asyncio` achieve concurrency in Python?",
    "options": [
      "By using multiple CPU cores simultaneously",
      "By utilizing a single thread with an event loop that switches tasks during I/O waits",
      "By creating a new thread for every asynchronous function",
      "By bypassing the GIL for specific CPU-bound operations"
    ],
    "answer": "By utilizing a single thread with an event loop that switches tasks during I/O waits",
    "explanation": "Asyncio uses cooperative multitasking. Tasks yield control back to the event loop when waiting for I/O, allowing other tasks to run on the same thread.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is a 'closure' in Python?",
    "options": [
      "A function that has no access to external variables",
      "A function object that remembers values in enclosing scopes even if they are not present in memory",
      "A method to close a file or network connection automatically",
      "A class that prevents inheritance"
    ],
    "answer": "A function object that remembers values in enclosing scopes even if they are not present in memory",
    "explanation": "A closure occurs when a nested function references a value from its enclosing scope. The function retains access to that variable even after the outer function has finished execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the output of `bool([])` and `bool([0])`?",
    "options": [
      "True, True",
      "False, False",
      "False, True",
      "True, False"
    ],
    "answer": "False, True",
    "explanation": "In Python, empty collections (like `[]`) are falsy. A non-empty list (even if it contains falsy elements like `0`) is truthy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which method is called when an object is garbage collected in Python?",
    "options": [
      "`__del__`",
      "`__destroy__`",
      "`__dealloc__`",
      "`__remove__`"
    ],
    "answer": "`__del__`",
    "explanation": "The `__del__` method is a finalizer called when an object is about to be destroyed, though its execution timing is not guaranteed due to reference counting and cyclic GC nuances.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the 'Leaking Abstraction' principle often associated with Python's GIL?",
    "options": [
      "That the GIL exposes the implementation detail of reference counting to the user, affecting performance",
      "That the GIL prevents the user from accessing abstract base classes",
      "That Python code runs slower than assembly code",
      "That the interpreter hides memory allocation errors from the user"
    ],
    "answer": "That the GIL exposes the implementation detail of reference counting to the user, affecting performance",
    "explanation": "The GIL is an implementation detail of CPython's memory management (reference counting) that leaks into the user experience by limiting multi-threaded parallelism.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What does the `yield` keyword do in a function?",
    "options": [
      "It stops the function and returns a value permanently",
      "It pauses the function and saves its state, returning a value to the caller",
      "It converts the function into a class",
      "It raises an exception if the value is None"
    ],
    "answer": "It pauses the function and saves its state, returning a value to the caller",
    "explanation": "`yield` transforms a function into a generator. It suspends execution and saves the local state, allowing resumption later from the same point.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the result of `1_000` + `2_000` in Python 3?",
    "options": [
      "An error",
      "3000",
      "3",
      "10002000"
    ],
    "answer": "3000",
    "explanation": "Underscores are allowed in numeric literals for readability. Python ignores them when evaluating the numeric value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "How does Python's Method Resolution Order (MRO) work in multiple inheritance?",
    "options": [
      "Depth-first, left-to-right",
      "Breadth-first",
      "C3 linearization (a specific depth-first, left-to-right algorithm preserving local precedence)",
      "Random order based on hash values"
    ],
    "answer": "C3 linearization (a specific depth-first, left-to-right algorithm preserving local precedence)",
    "explanation": "Python uses the C3 linearization algorithm to determine the order in which base classes are searched, ensuring a monotonic and consistent order.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the function of the `@property` decorator?",
    "options": [
      "To make a class variable private",
      "To define a method that can be accessed like an attribute, allowing for encapsulation of logic",
      "To speed up access to class variables",
      "To freeze the value of a variable so it cannot be changed"
    ],
    "answer": "To define a method that can be accessed like an attribute, allowing for encapsulation of logic",
    "explanation": "`@property` allows a method to be called implicitly when accessing an attribute. This is used to enforce data validation or computed data without changing the interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In Python, which of the following is true about arguments passed to functions?",
    "options": [
      "Arguments are passed by reference for mutable objects and by value for immutable objects",
      "Arguments are always passed by value",
      "Arguments are always passed by reference",
      "Arguments are passed by assignment (object references are passed by value)"
    ],
    "answer": "Arguments are passed by assignment (object references are passed by value)",
    "explanation": "Python uses 'call by object reference.' You can rebind the reference in the function (pass-by-value behavior), but if you mutate the object, changes are visible outside (pass-by-reference behavior).",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the 'diamond problem' in the context of Python inheritance?",
    "options": [
      "A situation where a class inherits from two classes that both inherit from a single base class",
      "A situation where a class has no parents",
      "A syntax error caused by incorrect indentation",
      "The inability to initialize a parent class"
    ],
    "answer": "A situation where a class inherits from two classes that both inherit from a single base class",
    "explanation": "The diamond problem creates ambiguity regarding which ancestor method should be called. Python's MRO (C3 linearization) solves this automatically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the purpose of the `super()` function?",
    "options": [
      "To initialize the parent class with a higher memory limit",
      "To return a proxy object that delegates method calls to a parent or sibling class",
      "To convert a subclass into a superclass",
      "To access private attributes of the parent class directly"
    ],
    "answer": "To return a proxy object that delegates method calls to a parent or sibling class",
    "explanation": "`super()` is used to access methods from a superclass in the class hierarchy, essential for cooperative multiple inheritance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which module is used to work with regular expressions in Python?",
    "options": [
      "regex",
      "re",
      "pyexpr",
      "string"
    ],
    "answer": "re",
    "explanation": "The `re` module provides Perl-style regular expression operations in Python. It contains functions like match, search, and sub.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the difference between `__str__` and `__repr__` methods?",
    "options": [
      "`__str__` is for debugging, `__repr__` is for end-users",
      "`__str__` is for end-users (readable), `__repr__` is for developers (unambiguous)",
      "There is no difference",
      "`__repr__` is inherited from Java, `__str__` is Python-specific"
    ],
    "answer": "`__str__` is for end-users (readable), `__repr__` is for developers (unambiguous)",
    "explanation": "`__str__` returns a nicely formatted string for display. `__repr__` returns an unambiguous string representation, ideally looking like a valid Python expression to recreate the object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What does the `with` statement ensure when opening a file?",
    "options": [
      "That the file is opened in read-only mode",
      "That the file is automatically closed even if an exception occurs",
      "That the file content is loaded into memory instantly",
      "That the file pointer is reset to the beginning after reading"
    ],
    "answer": "That the file is automatically closed even if an exception occurs",
    "explanation": "The `with` statement creates a context manager. It guarantees that the `__exit__` method is called, ensuring resource cleanup (closing files) regardless of success or error.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which of the following is NOT a valid keyword argument for the `sorted()` function?",
    "options": [
      "key",
      "reverse",
      "cmp",
      "None of the above (all are valid concepts, though `cmp` was removed in Python 3)"
    ],
    "answer": "cmp",
    "explanation": "The `cmp` parameter was removed in Python 3. To define custom sort logic based on comparisons, one should use the `functools.cmp_to_key` utility with the `key` parameter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In CPython, what is the specific motivation for using the Global Interpreter Lock (GIL) given its memory management strategy?",
    "options": [
      "To prevent deadlocks in user-defined code",
      "To simplify memory management by protecting reference counts from race conditions",
      "To enforce strict type checking at compile time",
      "To allow multiple interpreter states within a single process"
    ],
    "answer": "To simplify memory management by protecting reference counts from race conditions",
    "explanation": "CPython uses reference counting for memory management. The GIL ensures that only one thread executes Python bytecode at a time, preventing concurrent modification of an object's reference count, which avoids memory leaks or corruption.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Which component of CPython's Garbage Collector is specifically responsible for handling reference cycles that reference counting alone cannot resolve?",
    "options": [
      "The Reference Counter",
      "The Generational Collector (cyclic gc)",
      "The Memory Allocator (pymalloc)",
      "The Bytecode Interpreter"
    ],
    "answer": "The Generational Collector (cyclic gc)",
    "explanation": "Reference counting cannot detect cycles where objects reference each other. The cyclic GC (generational collector) periodically traverses objects to identify and deallocate these isolated groups.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary consequence of CPython's GIL on CPU-bound multi-threaded applications?",
    "options": [
      "It causes the interpreter to crash due to stack overflow.",
      "It prevents true parallelism, limiting performance to a single CPU core.",
      "It automatically distributes threads across all available CPU cores.",
      "It forces the operating system to handle thread scheduling exclusively."
    ],
    "answer": "It prevents true parallelism, limiting performance to a single CPU core.",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time. For CPU-bound tasks, this results in serialized execution rather than parallel execution, effectively negating multi-core benefits.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Why is the `multiprocessing` module often preferred over the `threading` module for CPU-intensive tasks in Python?",
    "options": [
      "Threads share memory space, causing high overhead.",
      "Multiprocessing bypasses the GIL by using separate processes with independent interpreter states.",
      "Threads in Python are unable to access CPU cores.",
      "Multiprocessing uses a single process with faster context switching."
    ],
    "answer": "Multiprocessing bypasses the GIL by using separate processes with independent interpreter states.",
    "explanation": "Each process in the `multiprocessing` module has its own Python interpreter and memory space, and therefore its own GIL. This allows the OS to schedule processes on different CPU cores for true parallelism.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What occurs during a 'stop-the-world' event in the context of the CPython Garbage Collector?",
    "options": [
      "All running threads are paused while the GC identifies and collects cyclic garbage.",
      "The program exits immediately if memory usage exceeds a limit.",
      "The interpreter switches to a single thread for all future operations.",
      "The reference counts of all objects are reset to zero."
    ],
    "answer": "All running threads are paused while the GC identifies and collects cyclic garbage.",
    "explanation": "To safely traverse object graphs and update references without race conditions, the GC must pause execution of all other threads. In a free-threaded (no-GIL) build, this requires explicit mechanism implementation.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "How does the GIL affect I/O-bound multi-threaded Python applications compared to CPU-bound ones?",
    "options": [
      "It degrades performance significantly because disk I/O is slower than computation.",
      "It has minimal impact because the GIL is released while waiting for I/O operations.",
      "It prevents I/O operations from running concurrently.",
      "It forces the use of asynchronous libraries exclusively."
    ],
    "answer": "It has minimal impact because the GIL is released while waiting for I/O operations.",
    "explanation": "During I/O operations (like network requests or disk reads), the GIL is released, allowing other threads to acquire it and run. This makes threading effective for concurrent I/O-bound tasks despite the lock.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is 'biased reference counting' as proposed for the GIL removal effort (PEP 703) in Python 3.13+?",
    "options": [
      "A method where objects are assigned to a specific thread to avoid atomic operations.",
      "A technique to reduce memory usage by ignoring references from weakref objects.",
      "A process of biasing the garbage collector toward younger generations.",
      "A legacy system used in Python 2 to manage circular imports."
    ],
    "answer": "A method where objects are assigned to a specific thread to avoid atomic operations.",
    "explanation": "Biased reference counting attempts to make reference counting thread-safe without locks by assuming an object 'belongs' to one thread (local refcounts), allowing for fast increments, while handling shared references differently.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "When using `sys.getrefcount(obj)`, why is the returned value often higher than expected (e.g., 2 instead of 1)?",
    "options": [
      "The function counts the object in the caller's scope and the object itself.",
      "The function creates a temporary reference to the object as an argument during the call.",
      "The interpreter caches the object internally before counting.",
      "The garbage collector retains a hidden reference to all active objects."
    ],
    "answer": "The function creates a temporary reference to the object as an argument during the call.",
    "explanation": "When passed to `sys.getrefcount`, the object is passed by reference, incrementing its count temporarily. This artificial reference is removed once the function returns.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the function of the `tp_clear` slot in a Python type object during garbage collection?",
    "options": [
      "It clears the bytecode cache for the object.",
      "It breaks reference cycles by setting the object's references to NULL.",
      "It clears the object's memory from the heap immediately.",
      "It resets the object's reference count to zero."
    ],
    "answer": "It breaks reference cycles by setting the object's references to NULL.",
    "explanation": "When the cyclic GC determines a group of objects is trash, it calls `tp_clear` on them. This breaks the cycles by zeroing out the pointers contained within those objects, allowing the reference counts to drop to zero.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which mechanism allows CPython to optimize memory usage for small integers and strings?",
    "options": [
      "Memory Mapping",
      "Interning",
      "Reference Counting",
      "Garbage Collection"
    ],
    "answer": "Interning",
    "explanation": "Interning reuses immutable objects (like small integers in the range [-5, 256] or short strings) by caching them. Instead of creating a new object, Python returns a reference to the existing cached object.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In the context of Python's C-API, what does `Py_INCREF` do to an object?",
    "options": [
      "It increases the object's reference count by one, indicating a new owner.",
      "It interprets the object's Python bytecode.",
      "It imports the object into the current namespace.",
      "It initializes a new Python object with a null reference."
    ],
    "answer": "It increases the object's reference count by one, indicating a new owner.",
    "explanation": "`Py_INCREF` is a macro that increments the `ob_refcnt` field of a `PyObject`. It signals that the code has taken a new reference to the object and is responsible for releasing it later.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the risk of accessing a Python object's internal state (like `ob_refcnt`) directly from C extensions without the API?",
    "options": [
      "It causes a syntax error in the C compiler.",
      "It breaks encapsulation and can corrupt memory if the GIL is removed or the ABI changes.",
      "It automatically triggers the garbage collector.",
      "It converts the object to a C string irreversibly."
    ],
    "answer": "It breaks encapsulation and can corrupt memory if the GIL is removed or the ABI changes.",
    "explanation": "Direct structure access bypasses the API functions. In a free-threaded Python, reference counts require specific handling (atomic operations or biased locking), making direct manipulation dangerous and non-portable.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "How does `mimalloc` (included in recent Python builds for GIL removal) improve garbage collection?",
    "options": [
      "It traverses its own internal structures to find objects without a dedicated linked list.",
      "It replaces reference counting with mark-and-sweep.",
      "It compresses Python bytecode to save memory.",
      "It disables the Garbage Collector entirely."
    ],
    "answer": "It traverses its own internal structures to find objects without a dedicated linked list.",
    "explanation": "The custom allocator allows the GC to find live objects by scanning the allocator's metadata, removing the need for Python to maintain a separate, expensive linked list of all objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is 'preemptive multitasking' in the context of OS threads versus Python threads?",
    "options": [
      "The OS decides when to switch threads; Python threads rely on the OS scheduler but are serialized by the GIL.",
      "Python threads voluntarily yield control to the OS.",
      "The programmer must manually call `yield()` in threads.",
      "Python threads run in parallel while OS threads run sequentially."
    ],
    "answer": "The OS decides when to switch threads; Python threads rely on the OS scheduler but are serialized by the GIL.",
    "explanation": "Modern OSs use preemptive multitasking. However, due to the GIL, while the OS schedules multiple Python threads, only one can execute Python bytecode at any specific instant.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which of the following best describes the 'Generational' aspect of CPython's Garbage Collection?",
    "options": [
      "Objects are divided into three 'generations' based on their survival time; older generations are scanned less frequently.",
      "The GC creates a new generation for every Python process.",
      "Objects are only collected when they are three generations old.",
      "It sorts objects by data type (int, str, list) before collection."
    ],
    "answer": "Objects are divided into three 'generations' based on their survival time; older generations are scanned less frequently.",
    "explanation": "The hypothesis is that objects that survive a collection are likely to be long-lived. Thus, CPython scans younger objects (Gen 0) frequently and older objects (Gen 2) infrequently to save overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the `__slots__` attribute used for in a Python class definition?",
    "options": [
      "To reserve memory bandwidth for slot expansion.",
      "To prevent the dynamic creation of `__dict__` and `__weakref__`, saving memory.",
      "To define the order of methods in the class bytecode.",
      "To enable asynchronous method calls."
    ],
    "answer": "To prevent the dynamic creation of `__dict__` and `__weakref__`, saving memory.",
    "explanation": "By default, instances store attributes in a dynamic dictionary. `__slots__` declares a fixed set of attributes, allowing the interpreter to reserve exactly that much space and skip the dictionary overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does Python's `import` system ensure that a module is only loaded once per process, even if imported multiple times?",
    "options": [
      "It uses a singleton mutex on the file system.",
      "It maintains a global cache in `sys.modules` mapping module names to loaded modules.",
      "It checks the file timestamp before every import.",
      "It creates a new namespace but copies the memory references."
    ],
    "answer": "It maintains a global cache in `sys.modules` mapping module names to loaded modules.",
    "explanation": "When a module is imported, the interpreter first checks `sys.modules`. If the name exists, it returns the cached module object; otherwise, it loads and initializes it.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What does the C3 Linearization algorithm resolve in Python?",
    "options": [
      "The order of method resolution in multiple inheritance class hierarchies.",
      "The linearity of memory addresses in the heap.",
      "The order of execution in `asyncio` event loops.",
      "The precedence of mathematical operators."
    ],
    "answer": "The order of method resolution in multiple inheritance class hierarchies.",
    "explanation": "C3 linearization (or MRO) calculates a consistent order in which base classes are searched when looking for a method. It ensures that a parent class is always checked before its children and respects inheritance order.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "In the CPython source code, what is the purpose of the `PyObject_HEAD` macro?",
    "options": [
      "It points to the first instruction of a function.",
      "It defines the fixed prefix of every Python object, containing the reference count and type pointer.",
      "It initializes the main interpreter loop.",
      "It serves as the header for C header files included in Python extensions."
    ],
    "answer": "It defines the fixed prefix of every Python object, containing the reference count and type pointer.",
    "explanation": "Every Python object begins with `PyObject_HEAD`, which includes `ob_refcnt` (for reference counting) and `ob_type` (a pointer to the object's type). This enables the system to treat all objects uniformly.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "Why are `try...except` blocks generally preferred over checking return codes for error handling in Python?",
    "options": [
      "Return codes are not supported by the Python interpreter.",
      "Python uses exceptions for control flow and EAFP ('Easier to Ask for Forgiveness than Permission') is the idiomatic style.",
      "`try...except` blocks are compiled to faster machine code than `if` statements.",
      "Return codes cause memory leaks in C extensions."
    ],
    "answer": "Python uses exceptions for control flow and EAFP ('Easier to Ask for Forgiveness than Permission') is the idiomatic style.",
    "explanation": "Python relies heavily on exception handling. The EAFP principle suggests attempting an operation and catching an exception if it fails, rather than checking conditions beforehand, which leads to cleaner and often faster code.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the result of `id(a) == id(b)` if `a` and `b` are two distinct list objects containing the same values?",
    "options": [
      "True, because Python compares values for `id()`.",
      "True, because integers are cached.",
      "False, because `id()` returns the memory address of the object, and they are distinct objects.",
      "False, because lists cannot be compared using `id()`."
    ],
    "answer": "False, because `id()` returns the memory address of the object, and they are distinct objects.",
    "explanation": "`id()` returns the unique integer (memory address) of an object. Since `a` and `b` are distinct instances (even if contents are identical), they reside at different memory addresses.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the purpose of the `DISCARD` opcode in CPython's bytecode execution?",
    "options": [
      "To remove the top value from the evaluation stack.",
      "To delete a variable from the namespace.",
      "To clear the Garbage Collector buffer.",
      "To stop the current thread."
    ],
    "answer": "To remove the top value from the evaluation stack.",
    "explanation": "The Python evaluation stack is used to pass intermediate results between opcodes. `DISCARD` pops the top item off the stack (typically the result of an expression that isn't being assigned) and discards it.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How does the `async with` statement differ from `with` regarding the underlying magic methods?",
    "options": [
      "`async with` calls `__aenter__` and `__aexit__` which must be awaitable.",
      "`async with` is syntactic sugar for `with` using `yield from`.",
      "`async with` disables the GIL for the duration of the block.",
      "`async with` only works with synchronous file I/O."
    ],
    "answer": "`async with` calls `__aenter__` and `__aexit__` which must be awaitable.",
    "explanation": "To support asynchronous context managers, Python defines `__aenter__` and `__aexit__`. These methods return coroutines (awaitables) that the event loop executes to set up and tear down the context.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What characterizes a 'greenlet' or 'micro-thread' in the context of Python concurrency?",
    "options": [
      "It is an OS-managed thread with a dedicated stack.",
      "It is a lightweight, cooperative thread managed by the application or a library, not the OS.",
      "It is a process fork created by the `os.fork` system call.",
      "It is a thread that runs with a higher priority than standard threads."
    ],
    "answer": "It is a lightweight, cooperative thread managed by the application or a library, not the OS.",
    "explanation": "Greenlets (or coroutines) are lightweight concurrency units. The OS scheduler is unaware of them; instead, the program or runtime explicitly switches between them (cooperative multitasking).",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What does the `GLOBAL` opcode (or `LOAD_GLOBAL`) imply about Python variable scope resolution?",
    "options": [
      "It forces the interpreter to look up the variable in the local scope only.",
      "It loads a global or built-in variable, checking the global dictionary and falling back to built-ins.",
      "It creates a new global variable at runtime.",
      "It prevents the variable from being garbage collected."
    ],
    "answer": "It loads a global or built-in variable, checking the global dictionary and falling back to built-ins.",
    "explanation": "When loading a name that is not local (i.e., not assigned in the function), the interpreter looks in the module's `globals()` dictionary, and if not found, checks the `__builtins__` dictionary.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What happens when you use `yield from` in a generator?",
    "options": [
      "It yields the value of the 'from' variable immediately.",
      "It delegates to a sub-generator, yielding values from it until it is exhausted.",
      "It creates a new thread for the sub-generator.",
      "It converts the generator into an iterator."
    ],
    "answer": "It delegates to a sub-generator, yielding values from it until it is exhausted.",
    "explanation": "`yield from` creates a transparent pipeline. The outer generator yields values produced by the inner (sub)generator, and also returns the final value of the sub-generator when it finishes.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "In the context of GIL removal, why are 'deferred reference counting' or 'biased reference counting' necessary?",
    "options": [
      "To ensure that Python 3.13 code runs on Python 2.7 interpreters.",
      "To prevent the performance degradation of using atomic increments for every reference count change.",
      "To allow the interpreter to run on 32-bit architecture.",
      "To replace the mark-and-sweep garbage collector entirely."
    ],
    "answer": "To prevent the performance degradation of using atomic increments for every reference count change.",
    "explanation": "Without the GIL, reference counts become shared mutable state. Using atomic operations (lock cmpxchg) for every refcount change is slow. Deferred/biased schemes minimize these expensive operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the function of the `PyMem_Malloc` allocator compared to the standard system `malloc`?",
    "options": [
      "`PyMem_Malloc` is the system malloc wrapper.",
      "It is a specialized allocator (pymalloc) optimized for small objects with short lifetimes.",
      "It allocates memory only on the stack.",
      "It performs garbage collection on every allocation."
    ],
    "answer": "It is a specialized allocator (pymalloc) optimized for small objects with short lifetimes.",
    "explanation": "CPython uses pymalloc for small allocations (<= 512 bytes). It uses arenas and pools to reduce overhead and fragmentation compared to the generic system `malloc`.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Which special method allows a class to override the behavior of attribute access (the dot operator)?",
    "options": [
      "`__get__`",
      "`__getattr__` and `__getattribute__`",
      "`__setattr__`",
      "`__access__`"
    ],
    "answer": "`__getattr__` and `__getattribute__`",
    "explanation": "`__getattribute__` is called for every attribute access, while `__getattr__` is called only when the attribute is not found through the usual mechanism. These methods allow custom interception of attribute lookup.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What happens when a reference cycle contains objects with a `__del__` method (finalizer) in CPython?",
    "options": [
      "The cycle is collected immediately and `__del__` is called.",
      "The objects are placed in `gc.garbage` because the GC cannot safely determine the order to call `__del__`.",
      "The `__del__` method is ignored, and the objects are leaked.",
      "The interpreter crashes to prevent data corruption."
    ],
    "answer": "The objects are placed in `gc.garbage` because the GC cannot safely determine the order to call `__del__`.",
    "explanation": "If objects in a cycle have finalizers (`__del__`), the GC cannot break the cycle arbitrarily (which object dies first?) as it might violate invariants expected by the finalizer. These are marked as uncollectable.",
    "difficulty": "Advanced"
  }
]