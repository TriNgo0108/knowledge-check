[
  {
    "id": 1,
    "question": "What is the primary function of Terraform?",
    "options": [
      "To orchestrate containerized applications using Docker",
      "To provision and manage infrastructure as code (IaC)",
      "To monitor application performance and logs",
      "To automate the software build and release process"
    ],
    "answer": "To provision and manage infrastructure as code (IaC)",
    "explanation": "Terraform is an Infrastructure as Code tool that allows users to define and provision data center infrastructure using a declarative configuration language. It is distinct from container orchestrators or CI/CD pipelines.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which language is primarily used for writing Terraform configuration files?",
    "options": [
      "JSON",
      "YAML",
      "HCL (HashiCorp Configuration Language)",
      "Python"
    ],
    "answer": "HCL (HashiCorp Configuration Language)",
    "explanation": "While Terraform can parse JSON, HCL is the primary, human-readable configuration language designed specifically for Terraform. It offers a more concise and readable syntax than JSON for defining infrastructure.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What command is used to download and install the providers defined in a Terraform configuration?",
    "options": [
      "terraform build",
      "terraform init",
      "terraform get",
      "terraform refresh"
    ],
    "answer": "terraform init",
    "explanation": "The `terraform init` command initializes a working directory containing Terraform configuration files. It is the first command that should be run after cloning a new configuration, as it downloads providers and sets up the backend.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which block in Terraform configuration is used to define a specific infrastructure component, such as a virtual machine or database?",
    "options": [
      "provider",
      "data",
      "resource",
      "variable"
    ],
    "answer": "resource",
    "explanation": "The `resource` block describes one or more infrastructure objects, such as compute instances, virtual networks, or DNS records. A resource block declares the desired state and configuration for that object.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the purpose of the Terraform State file?",
    "options": [
      "To encrypt sensitive variables within the configuration",
      "To store the source code of the Terraform modules",
      "To map real-world resources to your configuration and track metadata",
      "To define the provider versions required for the project"
    ],
    "answer": "To map real-world resources to your configuration and track metadata",
    "explanation": "Terraform state is used to track the metadata and attributes of the resources created. It allows Terraform to map real-world resources defined in your configuration and manage them efficiently.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which command allows you to preview the changes Terraform will make to your infrastructure without actually applying them?",
    "options": [
      "terraform plan",
      "terraform show",
      "terraform apply",
      "terraform validate"
    ],
    "answer": "terraform plan",
    "explanation": "The `terraform plan` command creates an execution plan, showing exactly what actions Terraform will take to achieve the desired state. It compares the requested configuration with the current state.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is a Provider in Terraform?",
    "options": [
      "A plugin that translates Terraform code into API calls for a specific service",
      "A module that contains pre-defined security policies",
      "A command-line argument used to pass credentials",
      "A cloud storage location for the Terraform state file"
    ],
    "answer": "A plugin that translates Terraform code into API calls for a specific service",
    "explanation": "Providers are plugins that Terraform uses to manage resources. They act as an abstraction layer between Terraform core and the target API, such as AWS, Azure, or Kubernetes.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "How does Terraform determine the order in which to create or destroy resources?",
    "options": [
      "Alphabetically by resource name",
      "Randomly to distribute load on the API",
      "Based on implicit and explicit dependencies defined in the configuration",
      "In the order they appear in the configuration file"
    ],
    "answer": "Based on implicit and explicit dependencies defined in the configuration",
    "explanation": "Terraform builds a dependency graph to determine the correct order of operations. It respects implicit dependencies (referencing an attribute) and explicit dependencies (using `depends_on`).",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which block construct is used to define values that are passed into a Terraform module from an external source?",
    "options": [
      "output",
      "locals",
      "variable",
      "terraform"
    ],
    "answer": "variable",
    "explanation": "The `variable` block defines input variables for a module. These values allow you to parameterize your configurations so that you can reuse the same module with different settings.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What happens when you run `terraform apply`?",
    "options": [
      "It downloads the required provider plugins",
      "It deletes the Terraform state file",
      "It executes the actions proposed in the Terraform plan to reach the desired state",
      "It formats the configuration files according to HCL standards"
    ],
    "answer": "It executes the actions proposed in the Terraform plan to reach the desired state",
    "explanation": "The `terraform apply` command performs the actual changes to the infrastructure. It reads the state and configuration to create, update, or destroy resources to match the desired state.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is a Terraform Module?",
    "options": [
      "A single configuration file that defines all infrastructure",
      "A container for multiple resources that are used together",
      "A type of provider for managing cloud storage",
      "A command-line interface flag"
    ],
    "answer": "A container for multiple resources that are used together",
    "explanation": "Modules are containers for multiple resources that are used together. They allow you to group resources and reuse code across different projects or environments.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which meta-argument allows you to create multiple instances of a specific resource using a list of strings?",
    "options": [
      "for_each",
      "count",
      "lifecycle",
      "depends_on"
    ],
    "answer": "count",
    "explanation": "The `count` meta-argument accepts a whole number and creates that many instances of the resource. It is the simplest way to create multiple resources based on a static number.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the role of the 'output' block in Terraform?",
    "options": [
      "To import existing infrastructure into Terraform",
      "To define sensitive data that must be encrypted",
      "To display information about resources after they are created",
      "To specify the version constraints for the provider"
    ],
    "answer": "To display information about resources after they are created",
    "explanation": "Output values are like the return values of a module. They allow you to export meaningful data, such as IP addresses or DNS names, to the user or other Terraform configurations.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which command is used to remove resources from the Terraform state but keep the actual infrastructure running?",
    "options": [
      "terraform destroy",
      "terraform state rm",
      "terraform fmt",
      "terraform taint"
    ],
    "answer": "terraform state rm",
    "explanation": "The `terraform state rm` command is used to remove resources from the state file. This is useful when you want to stop managing a resource with Terraform without deleting the actual infrastructure.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "In Terraform, what is a 'backend'?",
    "options": [
      "A server that hosts the Terraform provider registry",
      "A component responsible for storing the state file and potentially locking it",
      "A secondary command-line interface for advanced users",
      "A specific type of resource used for network configuration"
    ],
    "answer": "A component responsible for storing the state file and potentially locking it",
    "explanation": "Backends determine where Terraform stores its state data. They can be local (on disk) or remote (like S3, Consul, or Terraform Cloud) and often provide features like state locking and remote execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the `for_each` meta-argument used for?",
    "options": [
      "To iterate over a map or set of strings to create multiple resource instances",
      "To define a conditional expression inside a resource block",
      "To validate the syntax of the configuration file",
      "To run a script locally on the machine executing Terraform"
    ],
    "answer": "To iterate over a map or set of strings to create multiple resource instances",
    "explanation": "Unlike `count` which creates numbered instances, `for_each` allows you to create resources based on distinct items in a map or set, assigning a unique key to each instance.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "How are data sources different from managed resources in Terraform?",
    "options": [
      "Data sources create new infrastructure, while managed resources update existing ones",
      "Data sources read information from external sources, while managed resources create and manage infrastructure",
      "Managed resources are read-only, while data sources are write-only",
      "There is no difference; they are synonyms"
    ],
    "answer": "Data sources read information from external sources, while managed resources create and manage infrastructure",
    "explanation": "Data sources allow Terraform to fetch and compute information defined outside of Terraform, whereas managed resources (resources) actively create and manage the lifecycle of infrastructure objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which command is used to check the syntax and validity of Terraform configuration files without accessing remote state?",
    "options": [
      "terraform init",
      "terraform fmt",
      "terraform validate",
      "terraform output"
    ],
    "answer": "terraform validate",
    "explanation": "The `terraform validate` command checks whether the configuration is syntactically valid and internally consistent, regardless of any saved state or existing remote resources.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the purpose of 'provisioners' in Terraform?",
    "options": [
      "To define the version constraints for the Terraform CLI",
      "To model specific actions on the local machine or a remote resource after creation",
      "To encrypt the Terraform state file at rest",
      "To download necessary provider plugins"
    ],
    "answer": "To model specific actions on the local machine or a remote resource after creation",
    "explanation": "Provisioners are used to execute scripts on a local or remote machine as part of resource creation or destruction. They are generally used as a last resort when specific steps are not covered by a provider.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which command automatically rewrites Terraform configuration files to a canonical format and style?",
    "options": [
      "terraform plan",
      "terraform fmt",
      "terraform init",
      "terraform validate"
    ],
    "answer": "terraform fmt",
    "explanation": "The `terraform fmt` command is used to rewrite Terraform configuration files to a standard format. This ensures consistency across the codebase and makes diffs cleaner.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the 'taint' command used for?",
    "options": [
      "To remove the resource completely from the state file",
      "To force a resource to be destroyed and recreated on the next apply",
      "To lock the state file so no one else can modify it",
      "To import an existing resource under Terraform management"
    ],
    "answer": "To force a resource to be destroyed and recreated on the next apply",
    "explanation": "Tainting a resource marks it as forced to be destroyed and recreated on the next 'apply'. This is useful if a resource is physically corrupted but the state file does not reflect the issue.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "How do you define dependencies between resources that are not automatically detected by Terraform?",
    "options": [
      "Using the `version` argument",
      "Using the `depends_on` meta-argument",
      "Using the `lifecycle` block",
      "Using the `source` parameter"
    ],
    "answer": "Using the `depends_on` meta-argument",
    "explanation": "While Terraform infers most dependencies from configuration references, you can use the `depends_on` meta-argument to explicitly create dependencies that are not visible in the config, such as an API gateway needing a database to exist.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the purpose of a `locals` block in Terraform?",
    "options": [
      "To define persistent variables stored in the state file",
      "To define a grouping of values for assigning a name to an expression",
      "To import modules from a local directory",
      "To configure the Terraform backend settings"
    ],
    "answer": "To define a grouping of values for assigning a name to an expression",
    "explanation": "Locals are named values that you can reference in your configuration. Unlike variables, locals do not change between plans and are used strictly for organizing complex expressions.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Why is state locking important when running Terraform in a team environment?",
    "options": [
      "It prevents accidental deletion of the Terraform binary",
      "It prevents two team members from running Terraform at the same time and corrupting the state",
      "It encrypts the state file so no one can read it",
      "It reduces the cost of the infrastructure provisioned"
    ],
    "answer": "It prevents two team members from running Terraform at the same time and corrupting the state",
    "explanation": "State locking prevents concurrent operations from modifying the state simultaneously, which can lead to conflicts and data corruption. It ensures state integrity in collaborative environments.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which Terraform block argument is used to specify the source of a module?",
    "options": [
      "path",
      "source",
      "location",
      "origin"
    ],
    "answer": "source",
    "explanation": "The `source` argument in a `module` block tells Terraform where to find the module source code. This can be a local path, a Git repository, or the Terraform Registry.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What does the `terraform import` command do?",
    "options": [
      "Downloads modules from the Terraform Registry",
      "Moves an existing resource into Terraform management",
      "Validates the Terraform code syntax",
      "Upgrades the Terraform state file format"
    ],
    "answer": "Moves an existing resource into Terraform management",
    "explanation": "The `terraform import` command finds existing infrastructure created by other means and brings it under Terraform management. This does not generate configuration but adds the resource to the state.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the 'lifecycle' block used for within a resource?",
    "options": [
      "To manage the versioning of the provider",
      "To configure how Terraform creates, updates, or destroys the resource",
      "To set environment variables for the apply process",
      "To define the providers required by the resource"
    ],
    "answer": "To configure how Terraform creates, updates, or destroys the resource",
    "explanation": "The `lifecycle` nested block allows you to customize resource behavior, such as `ignore_changes`, `create_before_destroy`, and `prevent_destroy`, to manage edge cases.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "When defining variables, which argument is used to describe the purpose of the variable to the user?",
    "options": [
      "default",
      "type",
      "description",
      "sensitive"
    ],
    "answer": "description",
    "explanation": "The `description` argument allows you to provide a concise explanation of what the variable is used for. This text is displayed by the CLI and in documentation tools.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What happens if a resource is removed from the Terraform configuration and `terraform apply` is run?",
    "options": [
      "The resource is left running but is removed from state",
      "The resource is destroyed and deleted",
      "The configuration is automatically rolled back",
      "Terraform will error and refuse to run"
    ],
    "answer": "The resource is destroyed and deleted",
    "explanation": "By default, if a resource block is removed from the configuration, Terraform interprets this as a request to destroy that resource. The `lifecycle` block can be used to prevent this.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which tool is often used alongside Terraform to enforce formatting and naming standards?",
    "options": [
      "Terragrunt",
      "TFLint",
      "Packer",
      "Vault"
    ],
    "answer": "TFLint",
    "explanation": "TFLint is a pluggable linter for Terraform that checks for syntax errors, unused variables, and best practices that `terraform validate` might not catch. Terragrunt is a wrapper tool.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the difference between `terraform plan` and `terraform apply`?",
    "options": [
      "Plan creates resources, apply destroys them",
      "Plan shows the proposed changes, apply executes the changes",
      "Plan is for local state, apply is for remote state",
      "There is no difference; they are aliases"
    ],
    "answer": "Plan shows the proposed changes, apply executes the changes",
    "explanation": "`terraform plan` is a read-only operation that calculates the expected changes. `terraform apply` performs the actual provisioning, modification, or destruction of infrastructure.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "How can you prevent Terraform from logging sensitive data (like passwords) to the console?",
    "options": [
      "By using the `sensitive = true` argument on the output or variable",
      "By encrypting the state file with GPG",
      "By using a private Terraform backend",
      "By using environment variables only"
    ],
    "answer": "By using the `sensitive = true` argument on the output or variable",
    "explanation": "Marking an output or variable as `sensitive = true` instructs Terraform to suppress the value in the console output. However, the value is still stored in the state file (which should be secured separately).",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the `terraform` block used for?",
    "options": [
      "To define managed resources",
      "To define input variables",
      "To configure settings like required_version and backend",
      "To define data sources"
    ],
    "answer": "To configure settings like required_version and backend",
    "explanation": "The `terraform` block contains settings that apply to the entire configuration, such as the required Terraform core version and the backend configuration for state storage.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is a 'workspace' in Terraform?",
    "options": [
      "A directory containing separate configuration files",
      "A separate state file managed by the same configuration",
      "A cloud-based IDE for writing HCL",
      "A synonym for a module"
    ],
    "answer": "A separate state file managed by the same configuration",
    "explanation": "Workspaces allow you to manage multiple distinct instances of the same configuration (like dev/stage/prod) within a single directory by switching between named state files.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which operator is used for string interpolation in Terraform 0.12 and later?",
    "options": [
      "&",
      "${}",
      "#{}",
      "%"
    ],
    "answer": "${}",
    "explanation": "The `${...}` syntax is used for interpolation within strings in HCL. It allows you to embed expressions, variable references, and function calls directly into string values.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary risk of using the `legacy` provider configuration pattern within a child module prior to Terraform v0.13?",
    "options": [
      "It prevents the use of the `for_each` and `count` meta-arguments within the module.",
      "It causes the child module to lose access to the parent module's variables.",
      "It requires all provider configurations to be defined in the root module only.",
      "It creates a dependency cycle that prevents the module from being destroyed cleanly."
    ],
    "answer": "It creates a dependency cycle that prevents the module from being destroyed cleanly.",
    "explanation": "In the legacy pattern, the provider configuration resides inside the module. Removing the module removes both the resources and the provider configuration simultaneously, but Terraform requires the provider configuration to exist to destroy the resources, causing a deadlock.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which Terraform function converts a list of strings into a map with a common key name, enabling its use with the `for_each` meta-argument?",
    "options": [
      "toset",
      "zipmap",
      "tolist",
      "flatten"
    ],
    "answer": "zipmap",
    "explanation": "The `zipmap` function constructs a map from a list of keys and a list of values. This allows you to transform a list of items (like simple strings) into a map structure required by `for_each`, which cannot accept raw lists.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How does the `terraform import` command fundamentally differ from the `import` configuration block introduced in Terraform v1.5?",
    "options": [
      "`terraform import` generates the configuration code automatically, while the block does not.",
      "`terraform import` updates state only, while the `import` block allows Terraform to generate configuration and plan import operations.",
      "`terraform import` is used for resources, while the `import` block is used for modules.",
      "There is no difference; the `import` block is just a syntactic alias for the command."
    ],
    "answer": "`terraform import` updates state only, while the `import` block allows Terraform to generate configuration and plan import operations.",
    "explanation": "The CLI command `terraform import` only modifies the state file to bind an existing resource to an address, requiring you to write the configuration manually. The `import` block enables Terraform to plan, generate, and import resources as part of the standard apply workflow.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When using the `depends_on` meta-argument, which type of dependencies can it explicitly manage?",
    "options": [
      "Only implicit dependencies inferred from references in expressions.",
      "Only dependencies between modules and resources.",
      "Both resource-to-resource and module-to-resource dependencies.",
      "Dependencies between variables and outputs."
    ],
    "answer": "Both resource-to-resource and module-to-resource dependencies.",
    "explanation": "While `depends_on` is most commonly used for resource-to-resource dependencies, it can also be applied to a `module` block to create an explicit dependency between the entire module and a specific resource.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the specific behavior of the `for_each` meta-argument regarding the keys of the map it iterates over?",
    "options": [
      "Keys must be consecutive integers starting at 0.",
      "Keys must be known at `apply` time only.",
      "Keys must be known at `plan` time and cannot contain sensitive values.",
      "Keys are converted to strings automatically, but must be unique."
    ],
    "answer": "Keys must be known at `plan` time and cannot contain sensitive values.",
    "explanation": "Terraform must be able to determine the instances of `for_each` during the planning phase to construct the dependency graph. Additionally, because keys become part of the instance address, they cannot be sensitive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In the context of Terraform Backends, which configuration is required to allow a team to share state but prevent concurrent modifications that corrupt the state file?",
    "options": [
      "Enabling state locking",
      "Configuring state isolation",
      "Using local backend storage",
      "Disabling state refresh"
    ],
    "answer": "Enabling state locking",
    "explanation": "State locking ensures that when one user runs `terraform apply`, other users cannot perform operations that modify the state. This prevents race conditions and corruption, typically supported by remote backends like S3 with DynamoDB or Consul.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What happens to a resource managed by a `module` block when the `source` argument of that module is changed to a different version control system path?",
    "options": [
      "Terraform updates the state to reflect the new module source and immediately re-creates all resources.",
      "Terraform attempts to update the existing resources in-place to match the new module definitions.",
      "Terraform treats the resources as deleted and destroys them, then creates new resources.",
      "Terraform requires a manual `terraform state mv` operation to map the old resource addresses to the new ones."
    ],
    "answer": "Terraform attempts to update the existing resources in-place to match the new module definitions.",
    "explanation": "Terraform tracks resources by their absolute address (module path and resource name). If the `source` changes but the module and resource names remain the same, Terraform sees the same resource addresses and attempts to update the existing remote objects to match the new configuration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which statement accurately describes the `replace_triggered_by` lifecycle argument?",
    "options": [
      "It forces a specific resource to be replaced every time `terraform apply` is run.",
      "It creates a dependency that triggers the replacement of the resource when a target resource changes.",
      "It ignores changes to the resource unless a specified dependency is explicitly updated.",
      "It acts as an alias for the `depends_on` argument."
    ],
    "answer": "It creates a dependency that triggers the replacement of the resource when a target resource changes.",
    "explanation": "Introduced to handle cases where implicit dependencies aren't enough, `replace_triggered_by` allows you to specify that a resource should be destroyed and recreated (replaced) if the configuration of a specific target resource changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the default value of the `refresh` argument within the `terraform refresh` command or the `refresh` block?",
    "options": [
      "false",
      "true",
      "only",
      "plan"
    ],
    "answer": "true",
    "explanation": "By default, Terraform queries the infrastructure provider for the current state of resources (refresh) as part of the `plan` and `apply` workflow to update the state file with real-world data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "When defining a `module` block, how are provider versions inherited if the module does not specify a `required_providers` block?",
    "options": [
      "The module uses the latest version of the provider available in the public registry.",
      "The module inherits the provider versions selected by the root module.",
      "The module fails to initialize due to a missing provider constraint.",
      "The module defaults to version 1.0.0 of the provider."
    ],
    "answer": "The module inherits the provider versions selected by the root module.",
    "explanation": "Terraform uses a dependency lock file (.terraform.lock.hcl) created at the root. Child modules rely on the provider versions selected and installed by the root module's configuration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the primary function of the `terraform state push` command?",
    "options": [
      "To upload a local state file to a remote backend, overwriting the remote state.",
      "To force Terraform to create resources defined in a local state file.",
      "To merge local state changes into the current state file.",
      "To output the current state configuration to stdout."
    ],
    "answer": "To upload a local state file to a remote backend, overwriting the remote state.",
    "explanation": "`terraform state push` is primarily used to write a local state file to the configured remote backend. This is useful for disaster recovery but is dangerous as it overwrites the remote state, potentially losing data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In Terraform, what is the key distinction between the `merge()` function and the `concat()` function?",
    "options": [
      "`merge` combines maps, while `concat` combines lists.",
      "`merge` combines lists, while `concat` combines maps.",
      "`merge` overwrites duplicate keys, while `concat` removes duplicates.",
      "`merge` flattens nested lists, while `concat` creates nested lists."
    ],
    "answer": "`merge` combines maps, while `concat` combines lists.",
    "explanation": "These functions operate on different data structures. `merge` takes an arbitrary number of maps and returns a single map combining them. `concat` takes an arbitrary number of lists and returns a single list combining them.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which `lifecycle` argument prevents Terraform from accidentally destroying a specific resource, even if the configuration block is removed from the code?",
    "options": [
      "`ignore_changes`",
      "`prevent_destroy`",
      "`create_before_destroy`",
      "`replace_triggered_by`"
    ],
    "answer": "`prevent_destroy`",
    "explanation": "Setting `prevent_destroy = true` causes Terraform to return an error if it attempts to destroy that resource (e.g., via resource removal or `terraform destroy`), serving as a safety mechanism for critical infrastructure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "How does Terraform handle `sensitive = true` on an output variable?",
    "options": [
      "It prevents the value from being stored in the state file entirely.",
      "It encrypts the value in the state file using AES-256.",
      "It marks the value so it is redacted in CLI output but not in the state file.",
      "It prevents the output from being referenced by other Terraform configurations."
    ],
    "answer": "It marks the value so it is redacted in CLI output but not in the state file.",
    "explanation": "Sensitive outputs are still stored in plain text in the state file (which must be secured), but Terraform suppresses their display in the standard output of `plan` and `apply` commands to prevent accidental exposure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which command is used to verify that the configuration syntax is valid without actually accessing any remote services or state?",
    "options": [
      "`terraform validate`",
      "`terraform fmt -check`",
      "`terraform plan -refresh=false`",
      "`terraform init -backend=false`"
    ],
    "answer": "`terraform validate`",
    "explanation": "`terraform validate` checks the configuration files for syntactic correctness, internal consistency, and argument types. It runs locally and does not contact providers, backends, or remote services.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the result of using the `length()` function on a map that has been converted from a set using `toset()`?",
    "options": [
      "It returns the count of unique elements in the set.",
      "It returns 0, as sets do not have a length.",
      "It throws an error because sets cannot be converted to maps.",
      "It returns the count of all elements including duplicates."
    ],
    "answer": "It returns the count of unique elements in the set.",
    "explanation": "A `set` contains only unique elements. When converted to a map (or iterated over), `length()` reflects the number of these unique items, ignoring any duplicates that might have existed in the original input list before conversion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "When configuring a backend, what does the `key` parameter define in an S3 backend?",
    "options": [
      "The encryption key used to secure the state file.",
      "The path to the state file inside the bucket.",
      "The AWS access key ID for authentication.",
      "The unique identifier for the lock table."
    ],
    "answer": "The path to the state file inside the bucket.",
    "explanation": "In the context of S3 backends, the `key` argument specifies the file path (object key) where the Terraform state file will be stored.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which mechanism allows Terraform to continue creating resources in a module even if one resource creation fails?",
    "options": [
      "`on_failure = continue` in the resource lifecycle",
      "`ignore_errors = true` in the provider configuration",
      "`-continue-on-error` flag in the CLI",
      "Terraform always stops on the first error to prevent partial state corruption."
    ],
    "answer": "Terraform always stops on the first error to prevent partial state corruption.",
    "explanation": "Terraform does not natively support 'best effort' creation for a single parallel run. If a resource creation fails, Terraform stops to ensure the state remains consistent and avoid leaving infrastructure in an undefined or unreproducible state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the purpose of the `terraform state list` command?",
    "options": [
      "To display all resources currently tracked in the state file.",
      "To list all available Terraform versions.",
      "To show the command history of Terraform operations.",
      "To display the order in which resources will be created."
    ],
    "answer": "To display all resources currently tracked in the state file.",
    "explanation": "`terraform state list` outputs the addresses of all resources managed by the current state and configuration. This is useful for auditing or identifying resources to move or remove.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which `dynamic` block iterator is valid for use within a `resource` or `module` block?",
    "options": [
      "`dynamic 'setting' { for_each = ... content { ... } }`",
      "`dynamic 'setting' { iterator = ... content { ... } }`",
      "`dynamic 'setting' { count = ... content { ... } }`",
      "`dynamic 'setting' { list = ... content { ... } }`"
    ],
    "answer": "`dynamic 'setting' { for_each = ... content { ... } }`",
    "explanation": "The `dynamic` block requires a `for_each` argument to provide the collection of values to iterate over. It generates a nested block for each iteration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In the context of `terraform workspace`, where are the state files for non-default workspaces stored?",
    "options": [
      "In a directory named after the workspace within the configured backend.",
      "In the local `.terraform` directory, regardless of backend type.",
      "In the root directory of the configuration.",
      "Non-default workspaces do not have separate state files; they use environment variables."
    ],
    "answer": "In a directory named after the workspace within the configured backend.",
    "explanation": "For most backends (including local), Terraform stores the state for a workspace named `env` in a file or path prefixed by `env`. (e.g., `env.tfstate` or `env/` directory).",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the behavior of `terraform taint` compared to `terraform apply -replace`?",
    "options": [
      "`taint` modifies the state file, while `-replace` is a flag that does not persist.",
      "`taint` re-creates the resource immediately, while `-replace` waits for the next plan.",
      "`taint` is deprecated and no longer functions in Terraform v1.x.",
      "There is no functional difference between the two commands."
    ],
    "answer": "`taint` modifies the state file, while `-replace` is a flag that does not persist.",
    "explanation": "`terraform taint` flags a resource in the state file as 'tainted', forcing it to be destroyed and recreated on the next apply. The `-replace` argument achieves the same effect for a single plan/apply command without permanently marking the resource in the state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which condition causes Terraform to read a data source during the 'plan' phase rather than the 'apply' phase?",
    "options": [
      "When the data source uses `count` or `for_each`.",
      "When the data source arguments depend on a computed value from a resource change.",
      "When the data source configuration is fully known during the planning phase.",
      "Data sources are always read during the 'plan' phase."
    ],
    "answer": "When the data source configuration is fully known during the planning phase.",
    "explanation": "If all arguments to a data source are known constants (not dependent on resource outputs), Terraform can read it during the `plan` phase. If it relies on a computed value (result of a resource), it must wait until the `apply` phase.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the effect of the `ignore_changes` lifecycle argument?",
    "options": [
      "It causes Terraform to revert changes made manually in the cloud provider back to the code definition.",
      "It prevents Terraform from generating a plan if the resource is changed outside of Terraform.",
      "It tells Terraform to ignore specific future external changes and not update the state to match them.",
      "It completely removes the resource from state management."
    ],
    "answer": "It tells Terraform to ignore specific future external changes and not update the state to match them.",
    "explanation": "`ignore_changes` allows you to ignore specific attributes (or all attributes) in a resource. If a manual change occurs to a listed attribute outside of Terraform, Terraform will not attempt to 'fix' it on the next apply.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is required to pass a provider configuration from a root module to a child module?",
    "options": [
      "A `providers` block within the `module` block.",
      "Defining the provider configuration inside the child module's `.tf` files.",
      "Using the `-provider` CLI flag during init.",
      "Child modules automatically inherit all parent provider configurations."
    ],
    "answer": "A `providers` block within the `module` block.",
    "explanation": "Since Terraform 0.13, explicit provider passing is the standard. You must use a `providers` map inside the `module` block to map the parent's provider aliases (or default) to the child's expected provider name.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which function is used to explicitly convert a primitive type or complex type into a specific type, such as converting a string to a number?",
    "options": [
      "`try`",
      "`can`",
      "`tonumber`",
      "`cast`"
    ],
    "answer": "`tonumber`",
    "explanation": "Terraform provides type conversion functions like `tonumber`, `tostring`, and `tobool`. The `try` function is for handling errors, and `can` is for checking validity, but `tonumber` performs the actual conversion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "When using `locals` blocks, what is the scope of the declared values?",
    "options": [
      "They are accessible only within the resource block where they are defined.",
      "They are accessible globally within the entire configuration (module).",
      "They are accessible only to other `locals` blocks defined above them.",
      "They are accessible only to outputs."
    ],
    "answer": "They are accessible globally within the entire configuration (module).",
    "explanation": "Values defined in `locals` blocks are available to reference anywhere within the same module, including resources, other locals, and outputs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the correct syntax to reference a variable declared in a root module from a child module?",
    "options": [
      "The child module must explicitly accept the variable as an input variable.",
      "The child module can reference it using `var.parent_variable_name`.",
      "The child module inherits all parent variables automatically.",
      "The child module uses a `global_variables` block."
    ],
    "answer": "The child module must explicitly accept the variable as an input variable.",
    "explanation": "Modules are encapsulated. A child module has no access to the parent's variables unless the parent passes a value to an input variable explicitly defined within the child module's configuration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How does Terraform 1.x handle `provisioner` blocks compared to standard resource lifecycle management?",
    "options": [
      "Provisioners are executed before the main resource is created.",
      "Provisioners are added to the resource graph and run during the creation/update phase.",
      "Provisioners run asynchronously and do not block the `apply` command.",
      "Provisioners are ignored during `terraform destroy`."
    ],
    "answer": "Provisioners are added to the resource graph and run during the creation/update phase.",
    "explanation": "Provisioners are actions performed on the local machine or a remote resource *after* the resource is created. They are part of the resource graph execution but are generally discouraged because they can cause resource creation to fail if the provisioner script fails.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the purpose of the `-target` flag in the `terraform apply` command?",
    "options": [
      "To limit the number of concurrent operations.",
      "To apply only specific resources or modules, excluding dependencies.",
      "To specify the remote backend to use.",
      "To generate a plan file without applying it."
    ],
    "answer": "To apply only specific resources or modules, excluding dependencies.",
    "explanation": "The `-target` flag instructs Terraform to focus only on the specified resource address. This is an advanced escape hatch for partial recovery, though it can lead to inconsistent state if used incorrectly (it ignores dependencies).",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which Backend type effectively runs Terraform on HashiCorp's servers rather than on your local machine?",
    "options": [
      "S3",
      "Consul",
      "Terraform Cloud / Terraform Enterprise",
      "Artifactory"
    ],
    "answer": "Terraform Cloud / Terraform Enterprise",
    "explanation": "Standard backends (S3, Consul, etc.) store state but run the operations (plan/apply) on your local machine. Terraform Cloud and Enterprise offer 'remote operations' where the CLI acts as an interface and the heavy lifting occurs on the remote server.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which statement describes the behavior of `time_static` or `timestamp` functions in Terraform regarding dependencies?",
    "options": [
      "They are recomputed every time `terraform apply` is run, forcing resource updates.",
      "They are computed only once during initial creation.",
      "They are ignored by the dependency graph.",
      "They cannot be used in resource configurations."
    ],
    "answer": "They are recomputed every time `terraform apply` is run, forcing resource updates.",
    "explanation": "Functions like `timestamp()` return a new value every time they are evaluated. Using them directly in a resource configuration often causes that resource to be updated (replaced or modified) on every run.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "How can you expose a resource attribute defined in a nested module to the root module's output?",
    "options": [
      "The root module references it directly via `module.child.module.grandchild.resource.id`.",
      "The nested module must output the value, the intermediate module must output it, and the root module must output it.",
      "Nested module resources are automatically available as root outputs.",
      "It is not possible to access nested resources from the root module."
    ],
    "answer": "The nested module must output the value, the intermediate module must output it, and the root module must output it.",
    "explanation": "Modules are encapsulated. To pass data up the hierarchy, every level in the chain must explicitly define an output that passes the value from the child module's output to the parent module's scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the correct CLI command to move an existing resource address to a module address within the Terraform state file?",
    "options": [
      "terraform state move",
      "terraform state mv",
      "terraform import",
      "terraform state relocate"
    ],
    "answer": "terraform state mv",
    "explanation": "The `terraform state mv` command is used to rename or move items in the state, effectively changing the address of a resource. This is critical when refactoring flat resources into modules.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "What feature introduced in Terraform 1.1 allows you to refactor configuration code (e.g., moving a resource into a module) without manually running `terraform state mv` commands?",
    "options": [
      "The `refactored` block",
      "The `moved` block",
      "The `imported` block",
      "The `migrated` block"
    ],
    "answer": "The `moved` block",
    "explanation": "The `moved` block tells the Terraform language processor that an object has moved to a new address, allowing it to automatically map the old state to the new configuration address.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "In Terraform modules, how are provider configurations explicitly passed from a parent module to a child module?",
    "options": [
      "Using the `providers` argument within the `module` block",
      "Defining provider configurations inside the child module automatically",
      "Using the `provider` meta-argument in every resource block",
      "Setting the `TF_PROVIDER` environment variable"
    ],
    "answer": "Using the `providers` argument within the `module` block",
    "explanation": "The `providers` meta-argument inside a `module` block maps the parent module's provider configurations to the provider names expected by the child module.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary use case for ephemeral resources (introduced in Terraform 1.10)?",
    "options": [
      "To manage temporary cloud infrastructure like spot instances",
      "To fetch values at run-time without storing them in the persistent state file",
      "To replace the `null_resource` for all use cases",
      "To encrypt state files before uploading them"
    ],
    "answer": "To fetch values at run-time without storing them in the persistent state file",
    "explanation": "Ephemeral resources allow Terraform to perform logic or fetch values (like secrets or dynamic data) during the plan or apply phase without writing that data into the permanent state file.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the function of the `.terraform.lock.hcl` file in a Terraform configuration?",
    "options": [
      "To lock the state file during concurrent runs",
      "To record the exact provider versions and checksums used in the project",
      "To store the backend configuration credentials",
      "To define the required Terraform version constraints"
    ],
    "answer": "To record the exact provider versions and checksums used in the project",
    "explanation": "This dependency lock file ensures that Terraform uses the exact same versions of providers for every run, preventing unexpected changes caused by automatic provider updates.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Terraform constructs a Directed Acyclic Graph (DAG) to determine the order of operations. What primarily defines the edges of this graph?",
    "options": [
      "The alphabetical order of resource names in the configuration",
      "The implicit and explicit dependencies between resources and data sources",
      "The order in which files are listed in the directory",
      "The provider initialization sequence"
    ],
    "answer": "The implicit and explicit dependencies between resources and data sources",
    "explanation": "The DAG represents dependencies; implicit dependencies are created via reference interpolation, while explicit dependencies are created using the `depends_on` meta-argument.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "Under what circumstance should you use the `depends_on` meta-argument?",
    "options": [
      "To speed up the `terraform apply` process",
      "When an implicit dependency cannot be determined because there is no direct reference in the configuration",
      "To create a circular dependency between resources",
      "To force a resource to be created before a data source is read"
    ],
    "answer": "When an implicit dependency cannot be determined because there is no direct reference in the configuration",
    "explanation": "Terraform usually infers dependencies from variable references. `depends_on` is necessary when a resource depends on another's side effects or behavior not exposed in the configuration arguments.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which `lifecycle` argument prevents Terraform from updating specific arguments of an existing resource, even if the configuration code changes?",
    "options": [
      "`prevent_destroy`",
      "`create_before_destroy`",
      "`ignore_changes`",
      "`ignore_removed`"
    ],
    "answer": "`ignore_changes`",
    "explanation": "The `ignore_changes` meta-argument tells Terraform to disregard specific changes in the configuration and not update the remote object for those attributes, preserving manual changes or external drift.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How do you configure a custom timeout for a resource that takes longer to create than the provider default?",
    "options": [
      "Using the `timeout` meta-argument in the resource block",
      "Setting the `TF_TIMEOUT` environment variable",
      "Nesting a `timeouts` block within the resource configuration",
      "Configuring a `timeouts` block in the `provider` block globally"
    ],
    "answer": "Nesting a `timeouts` block within the resource configuration",
    "explanation": "Most resources support a nested `timeouts` block where you can customize the duration for create, update, read, and delete operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What happens if a data source query returns no results during a `terraform apply`?",
    "options": [
      "Terraform outputs null for all data source attributes",
      "Terraform automatically creates the missing resources",
      "Terraform raises an error and halts execution",
      "Terraform waits indefinitely until the resource is created"
    ],
    "answer": "Terraform raises an error and halts execution",
    "explanation": "Data sources represent read-only views of existing infrastructure; if the object is not found, Terraform cannot proceed and returns an error stating the object was not found.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Why is `for_each` generally preferred over `count` for creating multiple resource instances?",
    "options": [
      "`for_each` creates resources sequentially, reducing API thrashing",
      "`for_each` allows referencing specific instances by a map key label rather than a numeric index",
      "`count` cannot be used with module blocks",
      "`for_each` is the only method that supports conditional creation"
    ],
    "answer": "`for_each` allows referencing specific instances by a map key label rather than a numeric index",
    "explanation": "Using `for_each` with a map or set provides stable identifiers (keys) for instances, making it safer to add or remove items without re-indexing the entire list.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the function of the `replace_triggered_by` lifecycle argument?",
    "options": [
      "It forces a resource to be replaced when a specific dependency changes",
      "It triggers a run in Terraform Cloud when a resource is updated",
      "It creates a dependency that forces the dependency to be replaced first",
      "It manually refreshes the state of a resource"
    ],
    "answer": "It forces a resource to be replaced when a specific dependency changes",
    "explanation": "`replace_triggered_by` allows you to force a resource to be destroyed and recreated (tainted) even if its configuration hasn't changed, often used to force an update when a downstream dependency (like an AMI ID) changes.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What happens when Terraform detects configuration drift during a standard `terraform plan`?",
    "options": [
      "It automatically corrects the drift to match the configuration",
      "It deletes the drifting resource",
      "It ignores the drift unless a `refresh` is explicitly run",
      "It displays the differences between the real-world state and the configuration"
    ],
    "answer": "It displays the differences between the real-world state and the configuration",
    "explanation": "Terraform reads the real-world state, compares it to the configuration, and displays a diff. It does not take corrective action until an `apply` is executed.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is a significant limitation of using `terraform import`?",
    "options": [
      "It cannot import resources from SaaS providers",
      "It cannot import resources that are already in the state",
      "It does not generate the corresponding configuration code (HCL) for the imported resource",
      "It requires the state file to be local"
    ],
    "answer": "It does not generate the corresponding configuration code (HCL) for the imported resource",
    "explanation": "Import only adds the resource to the state file. You must manually write the matching resource block in your configuration, or the resource will be deleted in the next plan.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is required for an S3 backend to support state locking in Terraform?",
    "options": [
      "A valid AWS IAM user with full S3 permissions",
      "A DynamoDB table with a primary key named `LockID`",
      "Enabling S3 Versioning on the bucket",
      "A VPC endpoint for S3"
    ],
    "answer": "A DynamoDB table with a primary key named `LockID`",
    "explanation": "S3 alone does not support locking; Terraform uses a DynamoDB table to manage a conditional write lock that prevents concurrent modifications.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "Why are `provisioner` blocks generally considered a last resort?",
    "options": [
      "They run asynchronously and cannot be logged",
      "They add imperative logic outside the declarative model and are not idempotent",
      "They require a local executor to be running",
      "They are only compatible with the `local-exec` type"
    ],
    "answer": "They add imperative logic outside the declarative model and are not idempotent",
    "explanation": "Provisioners can fail silently, complicate the graph, and rely on success of external scripts, making them less reliable than native provider resources.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the primary purpose of a `dynamic` block in Terraform?",
    "options": [
      "To dynamically change the provider version at runtime",
      "To construct nested repeating blocks based on a collection value",
      "To execute shell scripts dynamically during the plan",
      "To loop through a list of resources to update them"
    ],
    "answer": "To construct nested repeating blocks based on a collection value",
    "explanation": "`dynamic` blocks allow you to construct nested configuration blocks (like `ingress` rules in a security group) programmatically, similar to a for-loop.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which feature allows custom logic validation for input variables, such as ensuring a string matches a specific regex?",
    "options": [
      "Precondition blocks",
      "Validation blocks",
      "Postcondition blocks",
      "Type constraints"
    ],
    "answer": "Validation blocks",
    "explanation": "The `validation` block within a `variable` block allows you to define a condition that returns true or false, along with a custom error message.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How do you prevent a secret output value from being displayed in the Terraform CLI logs or console output?",
    "options": [
      "Setting the `sensitive = true` argument in the output block",
      "Marking the variable as `secret = true`",
      "Using the `terraform output -redact` command",
      "Storing the secret in a file named `secret.tfvars`"
    ],
    "answer": "Setting the `sensitive = true` argument in the output block",
    "explanation": "When an output is marked as sensitive, Terraform suppresses its value in the console output, showing `<sensitive>` instead, though the value is still stored in plaintext in the state file.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What resource type was introduced in Terraform 1.4 to replace the `null_resource` and `null_data_source` patterns?",
    "options": [
      "`terraform_resource`",
      "`terraform_data`",
      "`generic_resource`",
      "`trigger_resource`"
    ],
    "answer": "`terraform_data`",
    "explanation": "`terraform_data` is a first-class resource designed to handle general-purpose data storage and triggers, replacing the need for the legacy `null_resource` provider.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is a major drawback of splitting infrastructure into multiple Terraform state files (state isolation)?",
    "options": [
      "It prevents the use of Terraform Cloud",
      "It increases the time required for `terraform init`",
      "It makes sharing data between states (e.g., passing VPC ID to Compute state) complex",
      "It forces you to use different providers for each state"
    ],
    "answer": "It makes sharing data between states (e.g., passing VPC ID to Compute state) complex",
    "explanation": "Resources in one state cannot directly reference resources in another state. You must manually output and pass data as inputs, which removes the safety net of the dependency graph.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What happens if you use a resource attribute (a computed value) as a key in a `for_each` meta-argument?",
    "options": [
      "Terraform waits for the apply to finish to determine the key",
      "Terraform errors because `for_each` requires keys that are known before apply",
      "Terraform defaults to using the resource index as the key",
      "Terraform creates a null map for the iteration"
    ],
    "answer": "Terraform errors because `for_each` requires keys that are known before apply",
    "explanation": "Terraform must know the unique identifiers (keys) for all instances during the plan phase to build the graph; resource attributes are unknown until after the apply.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the behavior of the `-refresh=false` flag when running `terraform plan`?",
    "options": [
      "It prevents Terraform from reading the state file",
      "It prevents Terraform from querying the provider API to check for real-world drift",
      "It disables the refresh of the provider binaries",
      "It forces Terraform to use cached data exclusively"
    ],
    "answer": "It prevents Terraform from querying the provider API to check for real-world drift",
    "explanation": "By default, Terraform refreshes the state against the real infrastructure before planning. This flag skips that read-only step to save time or prevent API rate limits.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which variable assignment method takes the highest precedence in Terraform?",
    "options": [
      "Environment variables (e.g., TF_VAR_foo)",
      "The `terraform.tfvars` file",
      "Command-line flags (e.g., `-var`)",
      "Auto-loaded `*.auto.tfvars` files"
    ],
    "answer": "Command-line flags (e.g., `-var`)",
    "explanation": "The precedence order generally places CLI arguments at the top, followed by `.tfvars` files, and finally environment variables, which have the lowest priority.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "In Terraform 1.x, what is the purpose of the `terraform state replace-provider` command?",
    "options": [
      "To upgrade a provider to the latest version",
      "To change the provider address (e.g., from a local namespace to a registry namespace) in the state file",
      "To remove a provider from the configuration",
      "To downgrade the provider binary"
    ],
    "answer": "To change the provider address (e.g., from a local namespace to a registry namespace) in the state file",
    "explanation": "This command updates the state file when a provider's source address changes, such as migrating a provider from `hashicorp/aws` to a custom fork or different registry namespace.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "When using `create_before_destroy` in a lifecycle block, what must be true about the resource arguments?",
    "options": [
      "The `name` argument must be unique",
      "All arguments must be computed values",
      "The resource must have a primary identifier (like `name`) that can differ between the old and new instance",
      "The resource must be a data source"
    ],
    "answer": "The resource must have a primary identifier (like `name`) that can differ between the old and new instance",
    "explanation": "For `create_before_destroy` to work, Terraform must be able to create the new resource alongside the old one, which requires a unique identifier attribute (e.g., changing the name).",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the `precondition` block used for within a `resource` block?",
    "options": [
      "To verify that the system meets requirements before Terraform applies the resource",
      "To verify that the state file is not locked",
      "To validate that the provider version is compatible",
      "To ensure the resource is not created on weekends"
    ],
    "answer": "To verify that the system meets requirements before Terraform applies the resource",
    "explanation": "Preconditions allow you to check arbitrary conditions (e.g., DNS settings, external APIs) before a resource is created or updated, failing the plan if the check fails.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the `depends_on` meta-argument interact with `for_each`?",
    "options": [
      "`depends_on` cannot be used with `for_each`",
      "`depends_on` creates a dependency for every instance in the `for_each` set",
      "`depends_on` must be repeated for each key in the `for_each` map",
      "`for_each` automatically infers `depends_on` based on the map keys"
    ],
    "answer": "`depends_on` creates a dependency for every instance in the `for_each` set",
    "explanation": "Applying `depends_on` to a resource using `for_each` applies the dependency to the entire resource block, meaning all instances depend on the target.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the primary purpose of the `terraform init` command?",
    "options": [
      "To verify the configuration syntax and exit",
      "To download providers, configure the backend, and initialize child modules",
      "To apply the configuration changes",
      "To format the Terraform files"
    ],
    "answer": "To download providers, configure the backend, and initialize child modules",
    "explanation": "Initialization is the first step, preparing the working directory by installing plugins and setting up the backend context.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Why might a developer choose to write Terraform configuration in JSON format (`.tf.json`) rather than HCL?",
    "options": [
      "To enable syntax highlighting in all editors",
      "To facilitate programmatic generation of configuration files by non-HCL aware tools",
      "To utilize features not available in HCL",
      "To decrease the execution time of `terraform apply`"
    ],
    "answer": "To facilitate programmatic generation of configuration files by non-HCL aware tools",
    "explanation": "JSON is machine-readable and easier to generate with standard string-manipulation libraries than HCL, which requires complex parsing.",
    "difficulty": "Advanced"
  }
]