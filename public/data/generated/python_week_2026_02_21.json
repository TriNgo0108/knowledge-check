[
  {
    "id": 1,
    "question": "What character is used to denote a block of code in Python, such as the body of a function or a loop?",
    "options": [
      "Curly braces {}",
      "Indentation",
      "Parentheses ()",
      "Square brackets []"
    ],
    "answer": "Indentation",
    "explanation": "Python uses whitespace indentation to delimit blocks of code, unlike many other languages that use braces. This enforces readability and consistent formatting.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which of the following is the correct file extension for Python source code files?",
    "options": [
      ".python",
      ".py",
      ".pt",
      ".pyt"
    ],
    "answer": ".py",
    "explanation": "The standard and recognized file extension for Python source files is .py. The interpreter looks for this extension to execute scripts.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the result of the boolean expression `not (True or False)`?",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "answer": "False",
    "explanation": "The expression inside the parenthesis evaluates to True. The `not` operator inverts this, resulting in False.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which operator is used to perform floor division in Python?",
    "options": [
      "/",
      "//",
      "%",
      "%%"
    ],
    "answer": "//",
    "explanation": "The // operator performs floor division, which divides the operands and returns the largest integer less than or equal to the result.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which data type is immutable in Python?",
    "options": [
      "List",
      "Dictionary",
      "Tuple",
      "Set"
    ],
    "answer": "Tuple",
    "explanation": "Tuples are immutable sequences, meaning once defined, their elements cannot be changed, added, or removed. Lists, dictionaries, and sets are mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the output of `len([1, 2, 3, 4] * 2)`?",
    "options": [
      "2",
      "4",
      "5",
      "8"
    ],
    "answer": "8",
    "explanation": "The * operator repeats the list, creating `[1, 2, 3, 4, 1, 2, 3, 4]`. The `len` function counts the elements, resulting in 8.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which keyword is used to define a function in Python?",
    "options": [
      "function",
      "func",
      "def",
      "define"
    ],
    "answer": "def",
    "explanation": "The `def` keyword is the standard statement used to define a function in Python, followed by the function name and parentheses.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is the primary function of the `import` statement?",
    "options": [
      "To load external code from a module into the current script",
      "To install a package from the PyPI repository",
      "To compile Python code into bytecode",
      "To declare a global variable"
    ],
    "answer": "To load external code from a module into the current script",
    "explanation": "The `import` statement allows a script to access functionalities (functions, classes, variables) defined in another module or library.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "In Python, which of the following represents a comment?",
    "options": [
      "// This is a comment",
      "/* This is a comment */",
      "# This is a comment",
      "-- This is a comment"
    ],
    "answer": "# This is a comment",
    "explanation": "Python uses the hash symbol (#) to denote a single-line comment. The text following # on that line is ignored by the interpreter.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What value does a function return by default if it does not contain a `return` statement?",
    "options": [
      "0",
      "null",
      "None",
      "False"
    ],
    "answer": "None",
    "explanation": "If a function finishes execution without hitting a `return` statement, it implicitly returns the `None` object.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the output of `type(3.0)`?",
    "options": [
      "<class 'int'>",
      "<class 'float'>",
      "<class 'str'>",
      "<class 'double'>"
    ],
    "answer": "<class 'float'>",
    "explanation": "In Python 3, numbers with a decimal point are treated as floats, even if the fractional part is zero. There is no 'double' type distinct from float.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which function is used to accept user input in Python 3?",
    "options": [
      "input()",
      "raw_input()",
      "scan()",
      "read()"
    ],
    "answer": "input()",
    "explanation": "In Python 3, `input()` is used to read a line from input and convert it to a string. `raw_input()` was used in Python 2.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the correct syntax to create a list in Python?",
    "options": [
      "list = (1, 2, 3)",
      "list = [1, 2, 3]",
      "list = {1, 2, 3}",
      "list = <1, 2, 3>"
    ],
    "answer": "list = [1, 2, 3]",
    "explanation": "Lists in Python are defined using square brackets []. Parentheses denote tuples, and curly braces denote dictionaries or sets.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which method adds an element to the end of a list?",
    "options": [
      "add()",
      "append()",
      "insert()",
      "push()"
    ],
    "answer": "append()",
    "explanation": "The `append()` method adds its argument as a single element to the end of the list. `insert()` is used for specific indices, and `add` is not a list method.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the result of `str[2:5]` if `str = 'Python Programming'`?",
    "options": [
      "tho",
      "thon",
      "on P",
      "Pyth"
    ],
    "answer": "thon",
    "explanation": "Slicing follows the syntax `[start:stop]`. It starts at index 2 ('t') and stops before index 5 (' '), resulting in 'thon'.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which of the following is true regarding variable names in Python?",
    "options": [
      "They can begin with a number",
      "They can contain spaces",
      "They are case-sensitive",
      "They cannot contain underscores"
    ],
    "answer": "They are case-sensitive",
    "explanation": "Python variable names are case-sensitive (e.g., `Age` and `age` are different). They cannot start with a number or contain spaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the `Global Interpreter Lock` (GIL) in the context of CPython?",
    "options": [
      "A lock that prevents the deletion of global variables",
      "A mutex that allows only one thread to execute Python bytecode at a time",
      "A mechanism to speed up multi-threaded I/O operations",
      "A compiler optimization flag"
    ],
    "answer": "A mutex that allows only one thread to execute Python bytecode at a time",
    "explanation": "The GIL ensures that only one thread holds the control of the Python interpreter, simplifying memory management but limiting CPU-bound parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the primary mechanism Python uses for memory management?",
    "options": [
      "Manual memory management via `malloc` and `free`",
      "Reference counting",
      "Garbage collection only",
      "Stack-only allocation"
    ],
    "answer": "Reference counting",
    "explanation": "Python primarily uses reference counting, where the memory for an object is automatically deallocated when the reference count drops to zero.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What happens to the memory occupied by an object when its reference count reaches zero?",
    "options": [
      "It remains in memory until the program restarts",
      "It is deallocated immediately",
      "It is moved to a swap file",
      "It is persisted to disk"
    ],
    "answer": "It is deallocated immediately",
    "explanation": "In Python's reference counting model, an object is destroyed and its memory reclaimed immediately when the number of references pointing to it reaches zero.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How does the GIL affect multi-threaded Python programs that are CPU-bound?",
    "options": [
      "It allows them to run faster on multiple cores",
      "It prevents them from achieving true parallelism",
      "It has no effect on CPU-bound tasks",
      "It causes the interpreter to crash"
    ],
    "answer": "It prevents them from achieving true parallelism",
    "explanation": "Because the GIL ensures only one thread executes bytecode at a time, CPU-bound threads do not run in parallel, effectively negating multi-core benefits.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the correct syntax for an `if` statement in Python?",
    "options": [
      "if x > 0:",
      "if x > 0 then:",
      "if (x > 0) {",
      "if [x > 0]:"
    ],
    "answer": "if x > 0:",
    "explanation": "Python uses the `if` keyword followed by the condition and a colon. Parentheses around the condition are optional, and braces are not used.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which loop construct is used to iterate over a sequence of numbers in Python?",
    "options": [
      "loop",
      "while",
      "for",
      "do-while"
    ],
    "answer": "for",
    "explanation": "The `for` loop is used for iteration over sequences (lists, tuples, strings) or numbers (often using the `range()` function). Python does not have a `do-while` loop.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the purpose of the `range()` function?",
    "options": [
      "To calculate the statistical range of a list",
      "To generate a sequence of numbers",
      "To select a specific range of characters in a string",
      "To define the scope of a variable"
    ],
    "answer": "To generate a sequence of numbers",
    "explanation": "The `range()` function generates an immutable sequence of numbers, commonly used for looping a specific number of times.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which keyword is used to skip the rest of the current loop iteration and proceed to the next?",
    "options": [
      "break",
      "skip",
      "continue",
      "pass"
    ],
    "answer": "continue",
    "explanation": "The `continue` keyword forces the loop to move to the next iteration immediately, skipping any code remaining in the current block.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the result of `bool(0)` and `bool('')` in Python?",
    "options": [
      "True, True",
      "True, False",
      "False, False",
      "False, True"
    ],
    "answer": "False, False",
    "explanation": "In Python, `0`, `0.0`, empty strings `''`, and `None` evaluate to `False` in a boolean context. All non-zero and non-empty values evaluate to `True`.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which data structure is defined using key-value pairs?",
    "options": [
      "List",
      "Tuple",
      "Dictionary",
      "Set"
    ],
    "answer": "Dictionary",
    "explanation": "Dictionaries (dict) store data in key-value pairs, allowing for fast lookup of values based on their unique keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the output of `print(2 ** 3)`?",
    "options": [
      "5",
      "6",
      "8",
      "9"
    ],
    "answer": "8",
    "explanation": "The `**` operator is the exponentiation operator in Python. 2 raised to the power of 3 is 8.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "How do you start a `try` block to handle potential exceptions?",
    "options": [
      "try:",
      "attempt:",
      "catch:",
      "throw:"
    ],
    "answer": "try:",
    "explanation": "Exception handling in Python begins with the `try:` block, followed by `except:` blocks to catch and handle specific errors.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the function `sys.getrefcount(x)` used for?",
    "options": [
      "To count the number of lines in a file",
      "To return the number of references pointing to the object `x`",
      "To calculate the size of object `x` in bytes",
      "To reset the reference count of `x`"
    ],
    "answer": "To return the number of references pointing to the object `x`",
    "explanation": "This system function returns the current reference count for an object. Note that the count is temporarily higher when passed to the function itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the result of `'Hello' + ' World'`?",
    "options": [
      "'Hello World'",
      "'Hello' 'World'",
      "Hello + World",
      "Error"
    ],
    "answer": "'Hello World'",
    "explanation": "The `+` operator is overloaded for strings to perform concatenation, joining the two strings into one.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which keyword is used to define a class in Python?",
    "options": [
      "class",
      "Class",
      "struct",
      "object"
    ],
    "answer": "class",
    "explanation": "The `class` keyword is used to define a new user-defined structure (class) in Python.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What does the `pass` keyword do in Python?",
    "options": [
      "It skips the next line of code",
      "It acts as a placeholder for a function or loop that does nothing",
      "It passes control to the next function",
      "It exits the current loop"
    ],
    "answer": "It acts as a placeholder for a function or loop that does nothing",
    "explanation": "`pass` is a null operation; when executed, nothing happens. It is useful as a placeholder when a statement is required syntactically.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which module is used to interact with the operating system, such as file path manipulation?",
    "options": [
      "sys",
      "os",
      "platform",
      "system"
    ],
    "answer": "os",
    "explanation": "The `os` module provides a portable way of using operating system-dependent functionality, including file and directory path manipulation.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the output of `list(range(2, 5))`?",
    "options": [
      "[1, 2, 3, 4]",
      "[2, 3, 4]",
      "[2, 3, 4, 5]",
      "[3, 4, 5]"
    ],
    "answer": "[2, 3, 4]",
    "explanation": "The `range(start, stop)` function generates numbers starting from `start` up to, but not including, `stop`.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Under what condition does CPython typically release the Global Interpreter Lock (GIL) during execution?",
    "options": [
      "Every 1000 bytecode instructions, regardless of operation",
      "During blocking I/O operations, such as reading from a network socket or file",
      "When a thread accesses a shared dictionary object",
      "Only when explicitly released by the programmer via a C-extension call"
    ],
    "answer": "During blocking I/O operations, such as reading from a network socket or file",
    "explanation": "The GIL is released during I/O-bound operations to prevent the CPU from idling while waiting for data. This allows other threads to run Python bytecode. The 1000 instruction check is a heuristic for thread switching, not GIL release.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the primary motivation behind the introduction of 'Biased Reference Counting' in experimental versions of CPython (PEP 703)?",
    "options": [
      "To allow multiple threads to modify object reference counts without heavy locking overhead",
      "To completely eliminate the need for a garbage collector",
      "To increase the speed of list comprehensions by 50%",
      "To enforce type strictness in function arguments"
    ],
    "answer": "To allow multiple threads to modify object reference counts without heavy locking overhead",
    "explanation": "Standard reference counting requires atomic operations or locks to be thread-safe without a GIL. Biased reference counting optimizes this by assuming a 'local' thread owns the object, reducing synchronization contention in a free-threaded environment.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Why does `sys.getrefcount(a)` typically return a count one higher than expected for an object referenced by variable `a`?",
    "options": [
      "The object stores a hidden self-reference",
      "The function creates a temporary reference to the object passed as an argument",
      "Python includes the namespace dictionary as a reference",
      "The garbage collector adds a sentinel reference"
    ],
    "answer": "The function creates a temporary reference to the object passed as an argument",
    "explanation": "When an object is passed to a function, a reference to it is pushed onto the stack (creating a temporary reference). `sys.getrefcount` counts this temporary reference in addition to the persistent references.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the context of Python's Cyclic Garbage Collector, what is the purpose of the 'generational' approach?",
    "options": [
      "To separate objects based on their data types (int, str, list)",
      "To reduce the collection cost by scanning long-lived objects less frequently than new objects",
      "To ensure that objects with circular references are never deallocated",
      "To prioritize the deletion of objects created in the main thread"
    ],
    "answer": "To reduce the collection cost by scanning long-lived objects less frequently than new objects",
    "explanation": "The generational hypothesis suggests that young objects are more likely to become garbage. By segregating objects into generations (0, 1, 2), the GC avoids the expensive process of scanning long-lived, stable objects on every cycle.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What happens when a Python function contains a `yield` keyword?",
    "options": [
      "The function returns a list of values",
      "The function compiles to C code for faster execution",
      "The function becomes a generator function that returns an iterator",
      "The function pauses execution indefinitely until a signal is received"
    ],
    "answer": "The function becomes a generator function that returns an iterator",
    "explanation": "Using `yield` transforms a function into a generator. When called, it returns a generator object that produces values lazily via the iterator protocol, pausing and resuming state automatically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which of the following accurately describes the resolution order (MRO) in Python classes that utilize multiple inheritance?",
    "options": [
      "Depth-first, left-to-right (DFLR) without checking for duplicates",
      "Breadth-first search",
      "C3 linearization, which preserves local precedence and monotonicity",
      "Random order determined by the hash of the class names"
    ],
    "answer": "C3 linearization, which preserves local precedence and monotonicity",
    "explanation": "Python 3 uses the C3 linearization algorithm (also known as C3 MRO). It calculates a consistent method resolution order that respects the inheritance hierarchy (left-to-right, depth-first) while ensuring that a parent class is always checked before its subclasses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When creating a decorator in Python, why is `functools.wraps` commonly used on the wrapper function?",
    "options": [
      "To automatically execute the wrapped function in a separate thread",
      "To copy the metadata (name, docstring, etc.) of the original function to the wrapper",
      "To convert the wrapper function into a generator",
      "To increase the execution speed of the decorated function"
    ],
    "answer": "To copy the metadata (name, docstring, etc.) of the original function to the wrapper",
    "explanation": "Decorators replace the original function with a wrapper. Without `functools.wraps`, the wrapper's name and docstring replace the original's. `wraps` updates the wrapper to look like the original function, preserving introspection.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the result of `isinstance(True, int)` in Python?",
    "options": [
      "False",
      "True",
      "TypeError",
      "AttributeError"
    ],
    "answer": "True",
    "explanation": "In Python, `bool` is a subclass of `int`. `True` has the integer value 1 and `False` has the value 0. Therefore, `True` is an instance of `int`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "How does the `mimalloc` allocator integration (in free-threaded Python builds) improve performance for dictionary read-only operations?",
    "options": [
      "It compresses dictionary keys to save memory",
      "It enables heaps and allocations based on size class to avoid acquiring locks",
      "It converts dictionaries into C-arrays during compilation",
      "It implements a software transactional memory system"
    ],
    "answer": "It enables heaps and allocations based on size class to avoid acquiring locks",
    "explanation": "The mimalloc integration allows specific memory management strategies. By segregating allocations by size class and using thread-local heaps, read-only operations on collections like dicts can often proceed without locking the entire structure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the primary difference between `__new__` and `__init__` in Python class creation?",
    "options": [
      "`__new__` is used for initialization, while `__init__` is used for object allocation",
      "`__new__` is a static method responsible for creating and returning the instance, while `__init__` initializes it",
      "`__init__` is called automatically, but `__new__` must be called manually",
      "`__new__` can only be called once per object, but `__init__` can be called multiple times"
    ],
    "answer": "`__new__` is a static method responsible for creating and returning the instance, while `__init__` initializes it",
    "explanation": "`__new__` controls the creation of a new instance (memory allocation and object construction) and returns it. `__init__` receives the already-created instance to set up its initial state (attribute initialization).",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the function of the `__slots__` declaration in a class?",
    "options": [
      "To define a list of allowed thread names for the class methods",
      "To save memory by preventing the dynamic creation of `__dict__` and restricting valid attribute names",
      "To enable operator overloading for bitwise operations",
      "To specify the order in which methods are executed"
    ],
    "answer": "To save memory by preventing the dynamic creation of `__dict__` and restricting valid attribute names",
    "explanation": "`__slots__` replaces the default `__dict__` with a fixed-size array of descriptors. This significantly reduces memory overhead per instance and prevents the addition of attributes not listed in `__slots__`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In a multithreaded Python script, which library is preferred to achieve true parallelism for CPU-bound tasks?",
    "options": [
      "threading",
      "asyncio",
      "multiprocessing",
      "os.fork"
    ],
    "answer": "multiprocessing",
    "explanation": "Due to the GIL, the `threading` module is limited to concurrent execution (interleaving), not parallel execution on multi-core CPUs. The `multiprocessing` module creates separate memory spaces and processes, each with its own GIL, bypassing this limitation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is a 'closure' in Python?",
    "options": [
      "A function that deletes itself after execution",
      "A record that stores a function together with an environment, allowing the function to access variables from an outer scope that has finished execution",
      "A method used to close open file handles automatically",
      "The process of converting a string into a raw bytes literal"
    ],
    "answer": "A record that stores a function together with an environment, allowing the function to access variables from an outer scope that has finished execution",
    "explanation": "A closure occurs when a nested function references a value from its enclosing scope. The nested function retains access to those variables even after the outer function has returned, effectively 'closing over' the variables.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Why are 'weak references' useful in Python?",
    "options": [
      "They allow access to private class methods without authentication",
      "They allow a program to maintain a reference to an object without preventing it from being garbage collected",
      "They create a pointer to a C-structure directly, bypassing Python overhead",
      "They enforce immutability on dictionary keys"
    ],
    "answer": "They allow a program to maintain a reference to an object without preventing it from being garbage collected",
    "explanation": "A weak reference does not increase the reference count of the object. If all strong references are removed, the object can be garbage collected, and the weak reference will return `None` or raise an error when accessed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What happens when you attempt to pickle an object containing an open file handle or a database connection?",
    "options": [
      "It works seamlessly, restoring the connection on unpickling",
      "It raises a `PicklingError` because such objects cannot be serialized by default",
      "It converts the handle into a string path automatically",
      "It closes the handle permanently"
    ],
    "answer": "It raises a `PicklingError` because such objects cannot be serialized by default",
    "explanation": "Python's `pickle` module serializes object state. External resources like open files, sockets, or database connections rely on system state that cannot be serialized or safely reconstructed across processes/sessions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which statement correctly describes the behavior of the `else` block in a `try...except` structure?",
    "options": [
      "The `else` block executes if no exception was raised in the `try` block",
      "The `else` block executes if an exception was caught in the `except` block",
      "The `else` block executes regardless of whether an exception occurred",
      "The `else` block replaces the `finally` block"
    ],
    "answer": "The `else` block executes if no exception was raised in the `try` block",
    "explanation": "The `else` block provides code that should run only if the `try` block completes successfully without hitting an `except` block. It is useful for separating code that might cause errors from code that shouldn't.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the behavior of variable scope within a list comprehension in Python 3?",
    "options": [
      "Variables defined in the comprehension leak into the enclosing scope",
      "The comprehension creates a new function (generator scope), so variables do not leak",
      "Variables can only be accessed using the `global` keyword",
      "List comprehensions do not support variable assignment"
    ],
    "answer": "The comprehension creates a new function (generator scope), so variables do not leak",
    "explanation": "In Python 3, list comprehensions have their own local scope. Unlike Python 2 or a `for` loop, variables assigned in the comprehension expression (e.g., `[x for x in range(5)]`) do not overwrite or persist in the surrounding scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What does the `__mro__` attribute on a class represent?",
    "options": [
      "The Memory Reference Object list for garbage collection",
      "The Method Resolution Order tuple showing the search order for methods",
      "The Modified Runtime Optimization flag",
      "The Module Registration Order for imports"
    ],
    "answer": "The Method Resolution Order tuple showing the search order for methods",
    "explanation": "`Class.__mro__` returns a tuple of classes that Python searches when looking for a method or attribute. This attribute exposes the C3 linearization order used by the interpreter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "In Python, what distinguishes `deepcopy` from `copy` (shallow copy) when applied to a list of lists?",
    "options": [
      "`deepcopy` creates a new list but keeps references to the inner lists",
      "`copy` creates a completely independent copy of the list and all inner objects",
      "`deepcopy` recursively creates new objects for all nested elements, while `copy` does not",
      "`deepcopy` converts the list into a tuple for safety"
    ],
    "answer": "`deepcopy` recursively creates new objects for all nested elements, while `copy` does not",
    "explanation": "A shallow copy (`copy()`) constructs a new compound object and inserts references into it to the original nested objects. A deep copy (`deepcopy()`) constructs new compound objects and recursively copies the original objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the purpose of the `@property` decorator?",
    "options": [
      "To define a method that can be accessed like an attribute, often used to encapsulate getter logic",
      "To make a class attribute private and read-only",
      "To initialize a class variable with a default value",
      "To specify that a method should run in a background thread"
    ],
    "answer": "To define a method that can be accessed like an attribute, often used to encapsulate getter logic",
    "explanation": "`@property` allows a method to be accessed as if it were a public attribute. This is the Pythonic way to implement getters and setters, allowing computed data without changing the class interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How does Python's `asyncio` library achieve concurrency?",
    "options": [
      "By using the GIL to switch between threads rapidly",
      "By using an event loop and cooperative multitasking with `await` keywords",
      "By spawning multiple operating system processes for each coroutine",
      "By compiling Python code into C parallel blocks"
    ],
    "answer": "By using an event loop and cooperative multitasking with `await` keywords",
    "explanation": "`asyncio` uses a single-threaded event loop. Concurrency is achieved by tasks voluntarily yielding control with `await` when waiting for I/O, allowing the loop to switch to other tasks without the overhead of threading.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the 'StopIteration' exception used for?",
    "options": [
      "To signal to a loop that an error has occurred",
      "To signal to the iterator protocol that there are no more items to yield",
      "To halt the execution of the Python interpreter",
      "To cancel a running thread"
    ],
    "answer": "To signal to the iterator protocol that there are no more items to yield",
    "explanation": "Built-in iterators raise `StopIteration` when the `next()` method is called but no further items are available. The `for` loop catches this exception to terminate iteration gracefully.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Why is modifying a list while iterating over it generally considered unsafe?",
    "options": [
      "It causes a memory leak in the interpreter",
      "It can skip elements or process elements multiple times due to index shifts",
      "Python lists are immutable",
      "It triggers a `SyntaxError` at compile time"
    ],
    "answer": "It can skip elements or process elements multiple times due to index shifts",
    "explanation": "Iterators maintain an internal index. If an item is removed from the list, subsequent elements shift positions. The iterator index may inadvertently skip over an element or re-process one, leading to logical errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "In Python's garbage collection, what occurs during the 'Stop-the-World' pause in a free-threaded (no-GIL) environment?",
    "options": [
      "All threads are paused to ensure object references are stable while the GC identifies cyclic trash",
      "The application pauses indefinitely to wait for user input",
      "The GIL is temporarily re-acquired to allow legacy code to run",
      "The application switches to single-core mode"
    ],
    "answer": "All threads are paused to ensure object references are stable while the GC identifies cyclic trash",
    "explanation": "Without a GIL, other threads might modify object references while the GC is tracing them. The Stop-the-World pause freezes all threads so the GC can safely traverse the object graph and identify cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the result of the operation `[1, 2, 3] * 3`?",
    "options": [
      "[3, 6, 9]",
      "[1, 2, 3, 1, 2, 3, 1, 2, 3]",
      "An error",
      "Type multiplication is not supported for lists"
    ],
    "answer": "[1, 2, 3, 1, 2, 3, 1, 2, 3]",
    "explanation": "When a sequence (like a list) is multiplied by an integer `n`, Python creates a new sequence containing the content of the original sequence repeated `n` times.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which built-in function returns the unique identifier (memory address) for an object?",
    "options": [
      "id()",
      "ref()",
      "ptr()",
      "mem()"
    ],
    "answer": "id()",
    "explanation": "The `id()` function returns an integer representing the 'identity' of an object, which is guaranteed to be unique and constant for the lifetime of the object, effectively corresponding to its memory address in CPython.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the primary issue with using a mutable default argument (e.g., `def foo(l=[]):`)?",
    "options": [
      "The list is created once at function definition time, so changes persist across calls",
      "It causes a syntax error because lists cannot be default arguments",
      "It prevents the function from being imported into other modules",
      "It consumes excessive CPU cycles during type checking"
    ],
    "answer": "The list is created once at function definition time, so changes persist across calls",
    "explanation": "Default argument values are evaluated only once when the function is defined. If the default is mutable (like a list or dict), modifications to it in one call will affect the default value in subsequent calls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What does the `global` keyword do inside a function?",
    "options": [
      "It allows the function to access variables from any module",
      "It declares that a variable refers to a variable at the module scope, enabling assignment",
      "It imports a module from the global Python library",
      "It makes the variable thread-safe"
    ],
    "answer": "It declares that a variable refers to a variable at the module scope, enabling assignment",
    "explanation": "Without `global`, assigning to a variable inside a function creates or modifies a local variable. The `global` keyword tells Python to look for the variable in the module (global) scope instead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the behavior of the `super()` function in Python 3?",
    "options": [
      "It calls the grandparent class, skipping the immediate parent",
      "It returns a proxy object that delegates method calls to the parent or sibling class in the MRO",
      "It converts the method into a static method automatically",
      "It initializes the class with no arguments"
    ],
    "answer": "It returns a proxy object that delegates method calls to the parent or sibling class in the MRO",
    "explanation": "`super()` provides a way to delegate method calls to classes in the MRO (Method Resolution Order) without explicitly naming them. In multiple inheritance, this ensures the correct 'next' class is called according to C3 linearization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How do `frozenset` and `set` differ?",
    "options": [
      "frozenset is faster to iterate over than set",
      "frozenset is hashable and can be used as a dictionary key or element of another set, while set cannot",
      "set requires all elements to be integers",
      "frozenset automatically sorts its elements"
    ],
    "answer": "frozenset is hashable and can be used as a dictionary key or element of another set, while set cannot",
    "explanation": "A `set` is mutable and unhashable. A `frozenset` is immutable and therefore hashable, allowing it to be used as keys in dictionaries or stored within other sets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the purpose of `__all__` in a Python module?",
    "options": [
      "To list all private variables in the module",
      "To specify the public API of the module, controlling what is imported with `from module import *`",
      "To enable multiprocessing features",
      "To prevent the GIL from being acquired"
    ],
    "answer": "To specify the public API of the module, controlling what is imported with `from module import *`",
    "explanation": "If a module defines `__all__` as a list of strings, only those names are exported when `from module import *` is used. It acts as an explicit declaration of the module's public interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the GIL's impact on reference counting in standard CPython?",
    "options": [
      "It prevents reference counting from being used at all",
      "It ensures that reference count updates are atomic because only one thread runs at a time",
      "It forces all reference count changes to be written to a log file",
      "It doubles the reference count for thread safety"
    ],
    "answer": "It ensures that reference count updates are atomic because only one thread runs at a time",
    "explanation": "In standard CPython, the GIL ensures mutual exclusion. This simplifies memory management because the interpreter knows only one thread can modify the reference count at a specific moment, preventing race conditions on the count variable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which data structure is typically most efficient for implementing a Least Recently Used (LRU) cache in Python?",
    "options": [
      "Standard dictionary",
      "Ordered dictionary (collections.OrderedDict) or functools.lru_cache",
      "List of tuples",
      "Binary search tree"
    ],
    "answer": "Ordered dictionary (collections.OrderedDict) or functools.lru_cache",
    "explanation": "An LRU cache requires moving items to the front/bottom of a container when accessed. `collections.OrderedDict` allows efficient reordering of keys, and `functools.lru_cache` implements this algorithm as a decorator.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the function of `__missing__` in a class subclassing `dict`?",
    "options": [
      "It is called when a key is not found in the dictionary, allowing custom handling",
      "It is called when the dictionary runs out of memory",
      "It deletes a key if it does not exist",
      "It acts as a finalizer when the dictionary is garbage collected"
    ],
    "answer": "It is called when a key is not found in the dictionary, allowing custom handling",
    "explanation": "Defining `__missing__(self, key)` allows a dictionary subclass to return a value or perform an action when `dict.__getitem__` is called with a non-existent key, rather than raising a `KeyError`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which operator is used for matrix multiplication in Python 3.5+?",
    "options": [
      "*",
      "^",
      "@",
      "%"
    ],
    "answer": "@",
    "explanation": "The `@` operator (infix operator) was introduced in Python 3.5 (PEP 465) specifically for matrix multiplication. It is utilized by libraries like NumPy to perform dot products.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In CPython 3.11+, what optimization technique rearranges bytecode instructions to minimize jumping and improve cache locality?",
    "options": [
      "Loop vectorization",
      "Speculative execution",
      "Specializing adaptive interpreters",
      "Inline caching"
    ],
    "answer": "Specializing adaptive interpreters",
    "explanation": "CPython 3.11 introduced a specializing adaptive interpreter that quickly specializes bytecode instructions for types and values encountered at runtime, often replacing generic instructions with faster type-specific ones.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the primary mechanism allowing a Python descriptor to override the default behavior of attribute access (get/set/delete) on a class?",
    "options": [
      "Implementing `__getattribute__` on the metaclass",
      "Defining methods named `__get__`, `__set__`, or `__delete__` in the descriptor class",
      "Overriding the `__setattr__` magic method on the instance",
      "Using the `@property` decorator exclusively"
    ],
    "answer": "Defining methods named `__get__`, `__set__`, or `__delete__` in the descriptor class",
    "explanation": "A descriptor is any object that defines `__get__`, `__set__`, or `__delete__`. When accessed as a class attribute, the protocol overrides the default mechanism to invoke these methods.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Which algorithm does CPython use to determine the Method Resolution Order (MRO) in multiple inheritance scenarios?",
    "options": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "C3 Linearization",
      "Topological Sorting"
    ],
    "answer": "C3 Linearization",
    "explanation": "C3 Linearization (also known as C3 superclass linearization) is the algorithm used to compute the MRO, ensuring a monotonic order where subclasses appear before base classes and local precedence order is respected.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does the `super()` function in Python 3 determine the correct class to delegate method calls to without explicitly passing arguments?",
    "options": [
      "It inspects the stack frame to find the `__class__` cell variable created by the compiler",
      "It performs a runtime lookup of the MRO using the instance's `__bases__` attribute",
      "It relies on the `__mro__` attribute of the calling function's global scope",
      "It uses a global registry of all active method calls"
    ],
    "answer": "It inspects the stack frame to find the `__class__` cell variable created by the compiler",
    "explanation": "The compiler creates a hidden closure variable named `__class__` in methods. Zero-arg `super()` accesses this cell variable and the caller's stack frame to determine the start class.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "In the context of PEP 703 (Making the GIL Optional), what is 'biased reference counting' intended to achieve?",
    "options": [
      "Eliminating the need for a cyclic garbage collector",
      "Reducing overhead by allowing a thread to modify refcounts without atomic operations if it owns the object",
      "Ensuring all objects are stored in a single contiguous memory block",
      "Prioritizing reference counting for objects with the highest memory usage"
    ],
    "answer": "Reducing overhead by allowing a thread to modify refcounts without atomic operations if it owns the object",
    "explanation": "Biased reference counting assumes that if a single thread 'owns' an object, it can modify the reference count using cheap, non-atomic increments/decrements, switching to atomic operations only when ownership is shared.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What specific trigger causes CPython to promote an object from the 'young' generation to the 'old' generation in its generational garbage collector?",
    "options": [
      "The object exceeds a specific size threshold (e.g., 1KB)",
      "The object survives a garbage collection cycle of the young generation",
      "The object is involved in a reference cycle",
      "The object is referenced by a static C variable"
    ],
    "answer": "The object survives a garbage collection cycle of the young generation",
    "explanation": "In generational GC, objects that survive a collection of the young generation (generation 0) are aged or promoted to an older generation (generation 1 or 2), under the hypothesis that they are long-lived.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the purpose of `PYTHONHASHSEED=random` in Python 3.3+?",
    "options": [
      "To randomize the memory allocator's offset to prevent heap spraying attacks",
      "To randomize the hash seed of strings, bytes, and datetime objects to prevent algorithmic complexity DoS attacks",
      "To ensure that dictionary keys are stored in a random order on disk",
      "To force the garbage collector to run in a non-deterministic order"
    ],
    "answer": "To randomize the hash seed of strings, bytes, and datetime objects to prevent algorithmic complexity DoS attacks",
    "explanation": "Randomizing the hash values of strings prevents attackers from exploiting hash collisions to force dict/set lookups into O(n) worst-case performance, effectively mitigating Hash DoS attacks.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In CPython, which opcode is responsible for implementing the logic of the `with` statement?",
    "options": [
      "WITH_ENTER and WITH_EXIT",
      "SETUP_WITH and WITH_CLEANUP",
      "SETUP_BLOCK and POP_BLOCK",
      "LOAD_CTX and STORE_CTX"
    ],
    "answer": "SETUP_WITH and WITH_CLEANUP",
    "explanation": "Historically, `SETUP_WITH` and `WITH_CLEANUP` were used (pre-3.10). While Python 3.10+ simplified this logic, conceptually the bytecode manages the setup of the context manager and the cleanup/exit logic within the block.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What happens when a weak reference to an object is accessed after the object has been destroyed by the garbage collector?",
    "options": [
      "It raises a ReferenceError",
      "It returns the memory address of where the object used to be",
      "It returns None",
      "It raises a WeakRefDeadError"
    ],
    "answer": "It returns None",
    "explanation": "When the referent is deleted, the weak reference callback (if any) is triggered, and calling the weak reference object returns `None` rather than the original object.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which memory management technique does CPython's `pymalloc` allocator specifically optimize for?",
    "options": [
      "Huge allocations over 1GB",
      "Object allocations smaller than 512 bytes with short lifetimes",
      "Contiguous memory blocks for numpy arrays",
      "Thread-local storage for static variables"
    ],
    "answer": "Object allocations smaller than 512 bytes with short lifetimes",
    "explanation": "The `pymalloc` allocator is designed for efficient allocation and deallocation of small objects (up to 512 bytes) by using memory pools called 'arenas', 'pools', and 'blocks'.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the significance of the `tp_traverse` slot in a CPython type object?",
    "options": [
      "It is used during garbage collection to visit referenced objects and detect reference cycles",
      "It defines how the object is converted to a string representation",
      "It is the function pointer called when the object is pickled",
      "It handles attribute lookup during method resolution"
    ],
    "answer": "It is used during garbage collection to visit referenced objects and detect reference cycles",
    "explanation": "The `tp_traverse` function pointer is part of the C type structure. It is called by the cyclic garbage collector to walk the object's containment graph and identify live references.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Why does CPython maintain a global linked list of all 'generation' objects for the garbage collector?",
    "options": [
      "To allow users to iterate over all objects in memory for debugging",
      "To prevent memory fragmentation by compacting objects physically",
      "To enable the garbage collector to traverse all containers without a global root set",
      "To facilitate fast object cloning during multiprocessing"
    ],
    "answer": "To enable the garbage collector to traverse all containers without a global root set",
    "explanation": "The GC maintains containers (objects that may contain references) in a doubly-linked list. This allows the GC to find all potential candidates for cycle detection without scanning raw memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In the context of Python's Global Interpreter Lock (GIL), what mechanism allows an I/O-bound thread to yield control to another thread?",
    "options": [
      "The thread voluntarily releases the GIL before making a blocking system call",
      "The operating system preempts the thread and forces a GIL release",
      "The Python interpreter detects idle CPU cycles and forces a context switch",
      "A signal handler interrupts the running thread"
    ],
    "answer": "The thread voluntarily releases the GIL before making a blocking system call",
    "explanation": "Python code wrapping I/O operations (like `read` or `write`) explicitly releases the GIL around the blocking system call, allowing other threads to acquire it and run bytecode.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the function of the `PyErr_Occurred()` function in the CPython C API?",
    "options": [
      "To log the error message to standard error",
      "To check if an exception is currently set in the thread",
      "To clear the current exception and restore the state to normal",
      "To raise a new Python exception from C code"
    ],
    "answer": "To check if an exception is currently set in the thread",
    "explanation": "In the CPython C API, exceptions are signaled by setting a global thread-local indicator. `PyErr_Occurred()` checks if an exception is currently active for the thread.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "Which protocol defines how an object controls the result of `isinstance()` and `issubclass()` checks?",
    "options": [
      "The Descriptor Protocol (`__get__`, `__set__`)",
      "The Abstract Base Class (ABC) Protocol (`__instancecheck__`, `__subclasscheck__`)",
      "The Protocol Protocol (`__class_getitem__`)",
      "The Comparison Protocol (`__eq__`, `__ne__`)"
    ],
    "answer": "The Abstract Base Class (ABC) Protocol (`__instancecheck__`, `__subclasscheck__`)",
    "explanation": "Metaclasses can define `__instancecheck__` and `__subclasscheck__` to customize the behavior of `isinstance()` and `issubclass()`, allowing virtual subclasses to be registered.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is 'namespace pollution' in the context of Python's `__import__` mechanism and module caching?",
    "options": [
      "When too many files are imported into `sys.modules` causing memory leaks",
      "When a module imports itself, creating an infinite recursion loop",
      "When submodules are not exposed in the parent package's namespace, requiring explicit attribute access",
      "When the parent package's `__dict__` is cluttered by automatically importing all submodules"
    ],
    "answer": "When submodules are not exposed in the parent package's namespace, requiring explicit attribute access",
    "explanation": "Historically, `import package.submodule` did not bind `submodule` to `package.submodule` in `package`'s namespace. PEP 420 (Namespace Packages) and explicit `__init__.py` imports address this, but the lack of implicit exposure is often referred to as namespace handling challenges.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the role of the `__prepare__` method in a metaclass?",
    "options": [
      "To initialize the class attributes dictionary before the class body is executed",
      "To serialize the class object to disk after creation",
      "To modify the Method Resolution Order (MRO) dynamically",
      "To intercept the instantiation of the new class object"
    ],
    "answer": "To initialize the class attributes dictionary before the class body is executed",
    "explanation": "`__prepare__` is called to create the mapping (usually a dict) used as the local namespace for the class body. This allows custom metaclasses to use ordered mappings or other structures for class attributes.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does CPython implement dictionary insertion order preservation (since Python 3.7)?",
    "options": [
      "It maintains a separate linked list of keys in insertion order",
      "It uses a balanced binary search tree instead of a hash table",
      "It stores the insertion index in the hash table entry and relies on the dense array of entries",
      "It performs a stable sort on the keys whenever the dictionary is accessed"
    ],
    "answer": "It stores the insertion index in the hash table entry and relies on the dense array of entries",
    "explanation": "CPython 3.6+ combines the hash table (indices) and a dense array of entries (`dk_entries`). New entries are appended to the dense array, and the indices point to them, naturally preserving order.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the CPython C API, what does the `Py_INCREF` macro do regarding the Global Interpreter Lock (GIL)?",
    "options": [
      "It automatically acquires the GIL if it is not currently held",
      "It performs an atomic increment regardless of the GIL state",
      "It assumes the caller already holds the GIL",
      "It releases the GIL to prevent race conditions during the increment"
    ],
    "answer": "It assumes the caller already holds the GIL",
    "explanation": "Standard reference counting operations like `Py_INCREF` assume the GIL is held. They are simple non-atomic increments. If the GIL were not held, race conditions would corrupt the refcount.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the `__calculate_meta__` hook used for in the `typing` module (conceptually related to Type Hinting PEPs)?",
    "options": [
      "It is a hypothetical hook for calculating class methods at runtime",
      "There is no such hook in standard Python; the user is confusing it with `__class_getitem__`",
      "It calculates the size of the class instance",
      "It resolves forward references in type hints"
    ],
    "answer": "There is no such hook in standard Python; the user is confusing it with `__class_getitem__`",
    "explanation": "This is a distractor. The relevant hook for generic types is `__class_getitem__`. `__calculate_meta__` does not exist, testing precise knowledge of the data model.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When implementing `__eq__` in a class that relies on hash-based collections (like sets or dict keys), what must also be implemented?",
    "options": [
      "`__ne__`",
      "`__hash__`",
      "`__cmp__`",
      "`__lt__`"
    ],
    "answer": "`__hash__`",
    "explanation": "If a class defines `__eq__` but not `__hash__`, instances of that class are considered unhashable (defaulting to a hash of None) and cannot be used as dictionary keys or set members.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the outcome of defining a class-level attribute with the same name as a method in a subclass?",
    "options": [
      "The method overrides the attribute during lookup",
      "The attribute hides the method if it is a data descriptor, otherwise the method prevails if it is a non-data descriptor",
      "Python raises a SyntaxError due to naming collision",
      "The attribute and method are merged into a single bound method"
    ],
    "answer": "The attribute hides the method if it is a data descriptor, otherwise the method prevails if it is a non-data descriptor",
    "explanation": "Data descriptors (with `__set__`) have priority over instance dictionaries. Methods are non-data descriptors (only `__get__`). If an entry in `__dict__` has the same name, the instance attribute usually wins, unless a data descriptor exists in the class.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In Python's asyncio, what is the fundamental primitive that represents a unit of work scheduled on the event loop?",
    "options": [
      "A 'generator' function",
      "A 'coroutine' object (obtained by calling an async def function)",
      "A 'thread' object",
      "A 'process' object"
    ],
    "answer": "A 'coroutine' object (obtained by calling an async def function)",
    "explanation": "Calling an `async def` function returns a coroutine object. This object must be awaited or scheduled on the event loop (e.g., wrapped in a Task) to execute.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How does Python's `multiprocessing` module share complex Python objects between processes?",
    "options": [
      "It uses shared memory by default for all Python objects",
      "It relies on pickling and unpickling data to send it through pipes/queues",
      "It automatically creates proxy objects for all types without configuration",
      "It uses the Global Interpreter Lock to synchronize access"
    ],
    "answer": "It relies on pickling and unpickling data to send it through pipes/queues",
    "explanation": "Since separate processes have distinct memory spaces, `multiprocessing` communicates by serializing objects (pickling) and sending them over IPC mechanisms like pipes or queues.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What does the `__reduce_ex__` protocol allow an object to control?",
    "options": [
      "How the object is converted to a string for `str()`",
      "How the object is pickled, offering more control than `__reduce__` regarding protocol versions",
      "How the object participates in mathematical reduction operations",
      "How the object's memory is freed"
    ],
    "answer": "How the object is pickled, offering more control than `__reduce__` regarding protocol versions",
    "explanation": "`__reduce_ex__` is the method called by the `pickle` module. It takes a protocol argument, allowing the object to customize its pickling strategy based on the pickle protocol version.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In CPython, what is a 'free list' (specifically regarding integers or tuples)?",
    "options": [
      "A linked list of all objects currently managed by the cycle detector",
      "A cache of pre-allocated immutable objects to avoid the overhead of frequent allocation/deallocation",
      "A list of threads waiting to acquire the GIL",
      "A debugging structure containing all unreachable objects"
    ],
    "answer": "A cache of pre-allocated immutable objects to avoid the overhead of frequent allocation/deallocation",
    "explanation": "CPython maintains free lists for certain immutable types like small integers (5 to 256 range) and tuples (up to a size), reusing memory instead of returning it to the system allocator.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the primary risk of using a mutable default argument in a function definition (e.g., `def foo(l=[]):`)?",
    "options": [
      "It causes a memory leak because the argument cannot be garbage collected",
      "The default object is evaluated once at definition time, so changes persist across calls",
      "It raises a TypeError when the function is called without arguments",
      "It violates Python's strict typing rules"
    ],
    "answer": "The default object is evaluated once at definition time, so changes persist across calls",
    "explanation": "Default argument values are evaluated only once when the function is defined. If the default is mutable (like a list), mutations to it in one call will be visible in subsequent calls.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which of the following correctly describes the behavior of the `intern()` function (from `sys` in CPython)?",
    "options": [
      "It moves the object to the 'old' generation in the garbage collector",
      "It stores the string in a global table to ensure only one copy is used, speeding up comparisons",
      "It compiles the string into bytecode for faster execution",
      "It converts the string into a C-style `char*` array"
    ],
    "answer": "It stores the string in a global table to ensure only one copy is used, speeding up comparisons",
    "explanation": "Interning strings (checking identity via `is`) is often faster than checking equality (`==`). `sys.intern()` explicitly places a string in the internal intern table.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "When using the `with` statement, why might a context manager need to save the exception as a local variable in `__exit__`?",
    "options": [
      "To log it after the `with` block has finished",
      "To re-raise it after performing cleanup, if desired",
      "To prevent the exception from propagating to the caller",
      "To convert it into a warning"
    ],
    "answer": "To re-raise it after performing cleanup, if desired",
    "explanation": "The `__exit__` method receives the exception info. If it returns `False` (the default), the exception is re-raised. Returning `True` suppresses it. Saving it allows re-raising after cleanup logic.",
    "difficulty": "Advanced"
  }
]