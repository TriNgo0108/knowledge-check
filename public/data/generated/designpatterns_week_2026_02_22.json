[
  {
    "id": 1,
    "question": "What is the primary purpose of the Singleton design pattern?",
    "options": [
      "To create a family of related objects",
      "To ensure a class has only one instance and provide a global point of access to it",
      "To separate the construction of a complex object from its representation",
      "To define a skeleton of an algorithm in a base class"
    ],
    "answer": "To ensure a class has only one instance and provide a global point of access to it",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable?",
    "options": [
      "Strategy",
      "Observer",
      "Singleton",
      "Adapter"
    ],
    "answer": "Strategy",
    "explanation": "The Strategy pattern defines a set of algorithms, encapsulates each algorithm, and makes them interchangeable at runtime. It lets the algorithm vary independently from clients that use it.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In the Model-View-Controller (MVC) pattern, what is the role of the View?",
    "options": [
      "To manage application data and business logic",
      "To handle user input and update the Model",
      "To display data to the user and capture user interactions",
      "To establish network connections between servers"
    ],
    "answer": "To display data to the user and capture user interactions",
    "explanation": "The View is responsible for rendering the data from the Model to the user. It acts as the presentation layer and sends user commands to the Controller.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the main benefit of using the Repository pattern?",
    "options": [
      "It provides a way to evaluate language grammar",
      "It decouples the domain logic from the data access logic",
      "It allows multiple threads to execute simultaneously",
      "It restricts a class to a single instance"
    ],
    "answer": "It decouples the domain logic from the data access logic",
    "explanation": "The Repository pattern mediates between the domain and data mapping layers, acting like an in-memory domain object collection. It abstracts the underlying data store implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which architectural pattern strictly separates read operations from write operations?",
    "options": [
      "Layered Architecture",
      "Microservices Architecture",
      "Command Query Responsibility Segregation (CQRS)",
      "Event-Driven Architecture"
    ],
    "answer": "Command Query Responsibility Segregation (CQRS)",
    "explanation": "CQRS separates the application into two parts: the command side (writes) and the query side (reads). This separation allows for independent scaling and optimized performance for each operation type.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What problem does the Adapter pattern solve?",
    "options": [
      "It creates a subclass to override existing behavior",
      "It allows incompatible interfaces to work together",
      "It provides a unified interface to a set of interfaces in a subsystem",
      "It defers the execution of steps to subclasses"
    ],
    "answer": "It allows incompatible interfaces to work together",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. It wraps an existing class with a new interface so that a client can interact with it without modifying the existing code.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "In a Layered Architecture pattern, how do components typically interact?",
    "options": [
      "Components in upper layers can use components in lower layers, but not vice versa",
      "All components interact directly with the database layer",
      "Components interact randomly regardless of their layer",
      "Components only interact with components in the same layer"
    ],
    "answer": "Components in upper layers can use components in lower layers, but not vice versa",
    "explanation": "Layered architecture enforces a strict separation where the presentation layer uses the business logic layer, which in turn uses the data access layer. This promotes modularity and separation of concerns.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which pattern is used to provide a simplified interface to a complex subsystem?",
    "options": [
      "Facade",
      "Proxy",
      "Decorator",
      "Bridge"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a high-level interface that makes a subsystem easier to use. It does not encapsulate the subsystem but merely provides a simplified unified interface.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the core intent of the Factory Method pattern?",
    "options": [
      "To define an interface for creating an object, but let subclasses decide which class to instantiate",
      "To compose objects into tree structures to represent part-whole hierarchies",
      "To attach additional responsibilities to an object dynamically",
      "To avoid costly acquisition and release of resources by recycling them"
    ],
    "answer": "To define an interface for creating an object, but let subclasses decide which class to instantiate",
    "explanation": "The Factory Method pattern defines a virtual constructor. It lets a class defer instantiation to subclasses, allowing the logic of object creation to be decoupled from the logic of object use.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which pattern allows you to subscribe to notifications of specific events occurring in other objects?",
    "options": [
      "Observer",
      "State",
      "Visitor",
      "Memento"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern defines a one-to-many dependency between objects. When one object changes state, all its dependents are notified and updated automatically.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the primary characteristic of the Microservices architectural pattern?",
    "options": [
      "The entire application must be deployed as a single monolithic unit",
      "It structures the application as a collection of loosely coupled, independently deployable services",
      "It relies on a shared database for all services to ensure consistency",
      "It uses a central mainframe to process all business logic"
    ],
    "answer": "It structures the application as a collection of loosely coupled, independently deployable services",
    "explanation": "Microservices architecture breaks down the application into small, autonomous services. Each service runs in its own process and communicates via lightweight mechanisms, usually HTTP APIs.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which design pattern is best suited for adding behavior to individual objects dynamically without affecting others?",
    "options": [
      "Decorator",
      "Inheritance",
      "Singleton",
      "Factory"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the function of the 'Unit of Work' pattern in enterprise applications?",
    "options": [
      "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes",
      "To map object attributes to database columns",
      "To route incoming requests to specific command handlers",
      "To generate user interface components based on data models"
    ],
    "answer": "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes",
    "explanation": "The Unit of Work pattern tracks changes to objects during a transaction. It ensures that all changes are committed to the database as a single atomic operation or rolled back entirely.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which pattern involves an object that intercepts and controls access to another object?",
    "options": [
      "Proxy",
      "Adapter",
      "Bridge",
      "Composite"
    ],
    "answer": "Proxy",
    "explanation": "The Proxy pattern provides a surrogate or placeholder for another object to control access to it. This can be used for lazy loading, access control, or logging.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the purpose of the Data Transfer Object (DTO) pattern?",
    "options": [
      "To encapsulate and aggregate data for transfer between layers to reduce the number of method calls",
      "To persist business logic in a relational database",
      "To handle concurrent requests from multiple users",
      "To render HTML views for the client browser"
    ],
    "answer": "To encapsulate and aggregate data for transfer between layers to reduce the number of method calls",
    "explanation": "A DTO is a simple object that carries data between processes. It reduces the network overhead of multiple remote calls by aggregating data into a single transfer.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which Creational pattern constructs complex objects step by step?",
    "options": [
      "Builder",
      "Prototype",
      "Singleton",
      "Abstract Factory"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. It allows the same construction process to create different representations.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the primary function of the Circuit Breaker pattern?",
    "options": [
      "To detect failures and prevent the application from trying to execute an operation that is likely to fail",
      "To route incoming traffic to the server with the lowest latency",
      "To compress data packets before transmission",
      "To increase the processing speed of the CPU"
    ],
    "answer": "To detect failures and prevent the application from trying to execute an operation that is likely to fail",
    "explanation": "The Circuit Breaker pattern stops cascading failures in distributed systems. It wraps a protected function call and detects if it fails, preventing further calls until the system recovers.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which pattern suggests that a class should have only one reason to change?",
    "options": [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Liskov Substitution Principle",
      "Dependency Inversion Principle"
    ],
    "answer": "Single Responsibility Principle",
    "explanation": "The Single Responsibility Principle (SRP) states that a class should have one, and only one, reason to change. This minimizes coupling between distinct responsibilities.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "In the context of software architecture, what is 'Loose Coupling'?",
    "options": [
      "Reducing the dependencies between components so that changes in one minimally affect others",
      "Increasing the number of database connections to improve speed",
      "Writing code that is difficult to read to protect intellectual property",
      "Tightly integrating the user interface with the database logic"
    ],
    "answer": "Reducing the dependencies between components so that changes in one minimally affect others",
    "explanation": "Loose coupling refers to minimizing the interdependencies between different modules or services. This allows components to evolve independently and increases system maintainability.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which design pattern defines a structure for composing objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Composite",
      "Flyweight",
      "Decorator",
      "Facade"
    ],
    "answer": "Composite",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly. It is used when clients should ignore the difference between compositions of objects and individual objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the Command pattern primarily used for?",
    "options": [
      "Encapsulating a request as an object, thereby allowing parameterization and queuing of requests",
      "Creating a duplicate of an object to improve performance",
      "Connecting to external databases efficiently",
      "Formatting output strings for different locales"
    ],
    "answer": "Encapsulating a request as an object, thereby allowing parameterization and queuing of requests",
    "explanation": "The Command pattern turns a request into a stand-alone object. This object contains all information about the request, enabling actions like undo/redo, queuing, and logging.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which architectural pattern organizes an application into layers of specific responsibilities, such as Presentation, Business, and Data?",
    "options": [
      "N-Tier Architecture",
      "Monolithic Architecture",
      "Peer-to-Peer Architecture",
      "Space-Based Architecture"
    ],
    "answer": "N-Tier Architecture",
    "explanation": "N-Tier (or Multi-tier) architecture organizes software into distinct horizontal layers. The most common structure is Presentation, Application Logic (Business), and Data layers.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "The 'Template Method' pattern is used to:",
    "options": [
      "Define the skeleton of an algorithm in a base class, deferring some steps to subclasses",
      "Create new objects using a prototype instance",
      "Provide an interface for accessing a complex subsystem",
      "Separate the construction of a complex object"
    ],
    "answer": "Define the skeleton of an algorithm in a base class, deferring some steps to subclasses",
    "explanation": "The Template Method pattern defines the steps of an algorithm and allows subclasses to override specific steps without changing the algorithm's structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the role of the 'Gateway' pattern in enterprise integration?",
    "options": [
      "To encapsulate and expose the functionality of an external system or service",
      "To store the state of a user session",
      "To compile code dynamically at runtime",
      "To generate random cryptographic keys"
    ],
    "answer": "To encapsulate and expose the functionality of an external system or service",
    "explanation": "A Gateway acts as an API or client interface that hides the complexity of communicating with an external service or system. It handles the communication protocol and data translation.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which design pattern allows a client to create an object without knowing the exact class of the object that will be created?",
    "options": [
      "Factory Method",
      "Adapter",
      "Decorator",
      "Observer"
    ],
    "answer": "Factory Method",
    "explanation": "The Factory Method pattern delegates the instantiation logic to child classes. The client code interacts with the interface or abstract class, remaining unaware of the concrete implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In the 'State' pattern, what happens when an object's state changes?",
    "options": [
      "The object alters its behavior when its internal state changes, appearing to change its class",
      "The object is destroyed and recreated from scratch",
      "The object notifies all other objects in the system regardless of interest",
      "The object saves its current state to a file immediately"
    ],
    "answer": "The object alters its behavior when its internal state changes, appearing to change its class",
    "explanation": "The State pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class because it delegates behavior to a state object.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which of the following best describes 'Cohesion' in software design?",
    "options": [
      "The degree to which elements within a module belong together",
      "The number of dependencies a module has on other modules",
      "The speed at which an application executes",
      "The total number of lines of code in a file"
    ],
    "answer": "The degree to which elements within a module belong together",
    "explanation": "High cohesion means that the responsibilities of a single module are closely related. High cohesion is generally desirable as it makes the module easier to understand and maintain.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator",
      "Composite",
      "Facade",
      "Proxy"
    ],
    "answer": "Iterator",
    "explanation": "The Iterator pattern provides a method to access the elements of an aggregate object sequentially without exposing its internal structure. It is commonly used in collections.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the 'Transaction Script' pattern?",
    "options": [
      "A procedure that handles a single business request from beginning to end",
      "A way to represent database relationships as object graphs",
      "A method for compiling scripts into machine code",
      "A pattern for encrypting transaction logs"
    ],
    "answer": "A procedure that handles a single business request from beginning to end",
    "explanation": "Transaction Script organizes business logic primarily as a single procedure. It is a simple way to handle business logic where each request is handled by a specific function or method.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which pattern is best used to manage a one-to-many dependency between objects such that when one object changes state, all its dependents are notified?",
    "options": [
      "Observer",
      "Singleton",
      "Prototype",
      "Bridge"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern establishes a publish-subscribe relationship. The subject (publisher) notifies observers (subscribers) of state changes without needing to know who or how many observers exist.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "The 'Bridge' pattern is intended to:",
    "options": [
      "Decouple an abstraction from its implementation so that the two can vary independently",
      "Connect two different databases together",
      "Create a bridge between the client and the server",
      "Improve the performance of SQL queries"
    ],
    "answer": "Decouple an abstraction from its implementation so that the two can vary independently",
    "explanation": "The Bridge pattern separates the abstract interface from the implementation details. This allows changing the implementation (e.g., different OS backends) without recompiling the abstraction code.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the main advantage of using the Prototype pattern?",
    "options": [
      "It creates new objects by cloning a prototype instance instead of building from scratch",
      "It ensures that a class has only one instance",
      "It converts the interface of a class into another interface clients expect",
      "It defines a family of algorithms"
    ],
    "answer": "It creates new objects by cloning a prototype instance instead of building from scratch",
    "explanation": "The Prototype pattern specifies the kinds of objects to create using a prototypical instance. It avoids the cost of creating new objects using the 'new' keyword when initialization is expensive.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "In the context of Domain-Driven Design, what is a 'Bounded Context'?",
    "options": [
      "A specific boundary within which a specific domain model applies",
      "A limitation on the size of a database transaction",
      "A constraint on the number of users in a system",
      "A security role that restricts access to specific files"
    ],
    "answer": "A specific boundary within which a specific domain model applies",
    "explanation": "A Bounded Context is a conceptual boundary where a particular domain model is valid and applicable. It prevents ambiguity by ensuring terms and rules have specific meanings only within that boundary.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which pattern uses a shared object to support large numbers of fine-grained objects efficiently?",
    "options": [
      "Flyweight",
      "Facade",
      "Proxy",
      "Strategy"
    ],
    "answer": "Flyweight",
    "explanation": "The Flyweight pattern reduces the cost of creating and manipulating many similar objects by sharing intrinsic state. It is useful for minimizing memory usage when many objects are required.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the purpose of the 'Chain of Responsibility' pattern?",
    "options": [
      "To pass a request along a chain of handlers until one handles it",
      "To create a hierarchy of classes",
      "To separate the user interface from the business logic",
      "To compress data before storage"
    ],
    "answer": "To pass a request along a chain of handlers until one handles it",
    "explanation": "The Chain of Responsibility pattern decouples the sender of a request from its receiver. It passes the request through a chain of processing objects until an object handles it or the chain ends.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary advantage of separating the read and write models in the Command Query Responsibility Segregation (CQRS) pattern?",
    "options": [
      "It allows read and write operations to be scaled independently to optimize performance",
      "It ensures that the database schema is always normalized to third normal form",
      "It removes the need for an Object-Relational Mapping (ORM) layer",
      "It guarantees immediate consistency across all distributed nodes"
    ],
    "answer": "It allows read and write operations to be scaled independently to optimize performance",
    "explanation": "CQRS separates the responsibilities of reading and writing data. This allows independent scaling (e.g., scaling reads but not writes) and optimization of data models for specific use cases.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which design pattern mediates between the domain and data mapping layers, acting like an in-memory domain object collection?",
    "options": [
      "Data Mapper",
      "Active Record",
      "Repository",
      "Unit of Work"
    ],
    "answer": "Repository",
    "explanation": "The Repository pattern mimics a collection of domain objects, adding an abstraction layer over the data mapping logic. Data Mapper moves data between objects and the DB, while Active Record couples them.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary responsibility of the Unit of Work pattern in enterprise applications?",
    "options": [
      "To define the schema of the database tables",
      "To maintain a list of objects affected by a transaction and coordinate writing out changes",
      "To map database rows to domain objects automatically",
      "To serve as the entry point for all incoming HTTP requests"
    ],
    "answer": "To maintain a list of objects affected by a transaction and coordinate writing out changes",
    "explanation": "The Unit of Work tracks changes to business objects during a transaction. It ensures that all changes are committed to the database as a single atomic operation or rolled back.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Why would a developer use a Data Transfer Object (DTO) in a distributed system?",
    "options": [
      "To encapsulate database access logic within the object itself",
      "To reduce the number of remote calls by aggregating data into a single structure",
      "To enforce strict validation rules on the server side",
      "To hide the implementation details of the business logic from the client"
    ],
    "answer": "To reduce the number of remote calls by aggregating data into a single structure",
    "explanation": "DTOs are used to transfer data between processes or layers efficiently. By aggregating multiple data points into one object, they reduce the chattiness of network communication.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which implementation strategy is required to ensure a Singleton class remains thread-safe during instantiation?",
    "options": [
      "Making all methods private and static",
      "Using synchronization or double-checked locking during the instance creation",
      "Inheriting from a ThreadSafe base class provided by the framework",
      "Cloning the instance during runtime to handle concurrency"
    ],
    "answer": "Using synchronization or double-checked locking during the instance creation",
    "explanation": "In a multithreaded environment, multiple threads could simultaneously access the initialization logic. Synchronization or specific memory models (like Java's `volatile` with double-checking) prevent race conditions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the Factory Method pattern promote loose coupling in an application?",
    "options": [
      "By using a shared static instance of the class to reduce memory overhead",
      "By allowing a class to defer instantiation to subclasses, decoupling the client from concrete classes",
      "By automatically synchronizing access to shared resources",
      "By converting the interface of a class into another interface clients expect"
    ],
    "answer": "By allowing a class to defer instantiation to subclasses, decoupling the client from concrete classes",
    "explanation": "Factory Method defines an interface for creating an object but lets subclasses alter the type of objects that will be created, preventing the client from depending on specific concrete classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In the Strategy design pattern, what role does the Context object play?",
    "options": [
      "It stores a reference to a concrete Strategy object and delegates work to it",
      "It implements the family of algorithms to ensure they are interchangeable",
      "It acts as a factory for creating Strategy instances at runtime",
      "It defines the abstract interface that all concrete strategies must implement"
    ],
    "answer": "It stores a reference to a concrete Strategy object and delegates work to it",
    "explanation": "The Context maintains a reference to a Strategy object. It forwards requests from the client to the Strategy, allowing the algorithm's behavior to change dynamically without altering the Context.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the primary limitation of the Observer pattern compared to modern reactive streams?",
    "options": [
      "It does not support one-to-many relationships between objects",
      "The Subject often blocks while notifying Observers, leading to potential performance bottlenecks",
      "It cannot be implemented in statically typed languages",
      "Observers cannot modify the state of the Subject directly"
    ],
    "answer": "The Subject often blocks while notifying Observers, leading to potential performance bottlenecks",
    "explanation": "Traditional Observer implementations often invoke updates synchronously on the Subject's thread. If one Observer is slow, it can block the notification chain for all others.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which statement best distinguishes the Facade pattern from the Adapter pattern?",
    "options": [
      "Facade wraps a complex subsystem; Adapter converts the interface of an existing class",
      "Adapter wraps a complex subsystem; Facade converts the interface of an existing class",
      "Facade is used for runtime object composition; Adapter is used for compile-time class inheritance",
      "Adapter requires multiple inheritance; Facade prevents any inheritance"
    ],
    "answer": "Facade wraps a complex subsystem; Adapter converts the interface of an existing class",
    "explanation": "The Facade pattern provides a simplified interface to a complex subsystem, whereas the Adapter pattern allows incompatible interfaces to work together by wrapping an existing class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which design pattern allows you to attach additional responsibilities to an object dynamically without affecting other objects of the same class?",
    "options": [
      "Proxy",
      "Decorator",
      "Composite",
      "Bridge"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In the Composite pattern, what is the purpose of defining a common interface for both Leaf and Composite objects?",
    "options": [
      "To ensure that all objects are created using the same factory method",
      "To allow clients to treat individual objects and compositions of objects uniformly",
      "To enforce a strict hierarchy where Composites cannot contain other Composites",
      "To reduce the memory footprint by sharing common state between objects"
    ],
    "answer": "To allow clients to treat individual objects and compositions of objects uniformly",
    "explanation": "The Composite pattern defines a uniform interface (typically `Component`) for both primitive objects (Leaves) and their containers (Composites), enabling clients to interact with both seamlessly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In a microservices architecture, which state in the Circuit Breaker pattern indicates that requests are failing and the system has temporarily stopped sending traffic to the failing service?",
    "options": [
      "Closed",
      "Half-Open",
      "Open",
      "Suspended"
    ],
    "answer": "Open",
    "explanation": "When the Circuit Breaker is Open, it fails immediately without calling the service, preventing cascading failures. It moves to Half-Open to test if the service has recovered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which characteristic distinguishes the Microservices architectural style from a Monolithic architecture?",
    "options": [
      "Microservices deploy as a single unit, while Monoliths deploy as multiple units",
      "Microservices organize around business capabilities with independent deployments, whereas Monoliths couple all functions",
      "Monoliths use a shared database, while Microservices cannot share data",
      "Monoliths are easier to scale horizontally than Microservices"
    ],
    "answer": "Microservices organize around business capabilities with independent deployments, whereas Monoliths couple all functions",
    "explanation": "Microservices decompose the application into small, independent services centered on business capabilities. Monoliths bundle all functionality into a single deployable unit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the primary function of a Service Mesh in a distributed system?",
    "options": [
      "To manage the business logic of the services",
      "To handle service-to-service communication, including retries, load balancing, and security",
      "To act as the primary database for all microservices",
      "To compile the source code of the microservices into binaries"
    ],
    "answer": "To handle service-to-service communication, including retries, load balancing, and security",
    "explanation": "A Service Mesh (like Istio or Linkerd) abstracts the network logic (resilience, observability, security) away from the application code, managing communication between microservices.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In a distributed system utilizing Eventual Consistency, what is the expected behavior immediately after a write operation?",
    "options": [
      "The read operation will immediately reflect the new data",
      "The system might return stale data for a short period until updates propagate",
      "The write operation will block until all replicas acknowledge the change",
      "The system will reject the read operation until consistency is reached"
    ],
    "answer": "The system might return stale data for a short period until updates propagate",
    "explanation": "Eventual Consistency guarantees that if no new updates are made, eventually all accesses will return the last updated value. However, immediate reads after a write might return stale data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "How does the Saga pattern manage distributed transactions compared to a two-phase commit (2PC)?",
    "options": [
      "Saga uses ACID transactions to ensure atomicity across all services",
      "Saga executes a sequence of local transactions and uses compensating transactions to undo changes if a failure occurs",
      "Saga relies on a central locking mechanism to prevent concurrent access",
      "Saga requires all services to share the same database instance"
    ],
    "answer": "Saga executes a sequence of local transactions and uses compensating transactions to undo changes if a failure occurs",
    "explanation": "Unlike 2PC, which uses a single coordinator and locks resources, Saga breaks a transaction into a sequence of local transactions. If one fails, it executes compensating transactions to undo the previous steps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In Event Sourcing, how is the current state of an entity determined?",
    "options": [
      "By querying the current state column in the primary database table",
      "By replaying the sequence of events stored in the event store from the beginning",
      "By maintaining a materialized view that is updated only by batch jobs",
      "By calculating the difference between the last two snapshots of the entity"
    ],
    "answer": "By replaying the sequence of events stored in the event store from the beginning",
    "explanation": "Event Sourcing persists the state of a business entity as a sequence of state-changing events. The current state is derived by reprocessing all past events for that entity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which pattern solves the problem of a constructor with too many parameters by using a step-by-step approach?",
    "options": [
      "Factory Method",
      "Abstract Factory",
      "Builder",
      "Prototype"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. It allows the same construction process to create different representations and handles multiple parameters gracefully.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "In the Template Method pattern, which methods are declared as abstract to enforce implementation by subclasses?",
    "options": [
      "The primitive operations that vary among subclasses",
      "The template method itself which defines the algorithm skeleton",
      "The hooks that provide default functionality",
      "The public interface methods used by the client"
    ],
    "answer": "The primitive operations that vary among subclasses",
    "explanation": "The Template Method defines the skeleton of an algorithm in a base class but defers specific steps (primitive operations) to subclasses, which must implement them.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "In a strict Layered Architecture pattern, which layering rule is typically enforced to prevent tight coupling?",
    "options": [
      "A layer can access any layer above or below it",
      "A layer can only access the layer directly below it",
      "A layer can only access layers below it, but layers below cannot access layers above",
      "All layers must access a central service bus for communication"
    ],
    "answer": "A layer can only access layers below it, but layers below cannot access layers above",
    "explanation": "Strict layering enforces that dependencies flow downward. Higher-level layers (Presentation) can use lower-level layers (Business Logic), but lower-level layers are unaware of higher-level ones.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the core concept of Hexagonal (Ports and Adapters) Architecture?",
    "options": [
      "The application core is isolated from external concerns by defining interfaces (Ports) that are implemented by infrastructure adapters",
      "The database is the center of the application, and all logic revolves around it",
      "The user interface controls the business logic directly to ensure responsiveness",
      "The application is split into three distinct layers: View, Controller, and Model"
    ],
    "answer": "The application core is isolated from external concerns by defining interfaces (Ports) that are implemented by infrastructure adapters",
    "explanation": "Hexagonal Architecture isolates the application's core logic from the outside world (UI, DB, Services) by using Ports (interfaces) and Adapters (implementations), making it technology-agnostic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which term describes the principle where a class receives its dependencies from external sources rather than creating them itself?",
    "options": [
      "Inversion of Control (IoC)",
      "High Cohesion",
      "Encapsulation",
      "Polymorphism"
    ],
    "answer": "Inversion of Control (IoC)",
    "explanation": "IoC inverts the flow of control: instead of the class creating its dependencies, a framework or container provides them. Dependency Injection is a common technique to achieve IoC.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which architectural pattern is characterized by a domain model class that directly contains both data access logic (CRUD) and business logic?",
    "options": [
      "Data Mapper",
      "Active Record",
      "Table Module",
      "Repository"
    ],
    "answer": "Active Record",
    "explanation": "In Active Record, an object corresponds to a row in a database table and wraps data access and domain logic together. Data Mapper separates these concerns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the primary goal of the Data Mapper pattern?",
    "options": [
      "To keep the domain model independent of the database details by transferring data between objects and the database",
      "To map the user interface directly to the database tables",
      "To define a centralized place for all SQL queries",
      "To ensure that every domain object is a Singleton"
    ],
    "answer": "To keep the domain model independent of the database details by transferring data between objects and the database",
    "explanation": "Data Mapper is a layer of software that separates the in-memory objects from the database. Its responsibility is to transfer data between the two and keep them independent of each other.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which pattern ensures that each object is loaded only once per transaction by keeping a map of all loaded objects to avoid identity conflicts?",
    "options": [
      "Identity Map",
      "Unit of Work",
      "Lazy Load",
      "Object-Relational Impedance Mismatch"
    ],
    "answer": "Identity Map",
    "explanation": "An Identity Map ensures that each object gets loaded only once by keeping a map of every loaded object. It prevents inconsistencies and circular references within a session.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "In a Microservices architecture, what is the role of an API Gateway?",
    "options": [
      "To act as a reverse proxy that routes client requests to appropriate backend services and aggregates responses",
      "To serve as the primary database for all microservices",
      "To compile and deploy the microservices code",
      "To replace the need for a Service Discovery mechanism"
    ],
    "answer": "To act as a reverse proxy that routes client requests to appropriate backend services and aggregates responses",
    "explanation": "An API Gateway sits between clients and services, handling cross-cutting concerns like routing, composition, authentication, and rate limiting, providing a single entry point.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "In Domain-Driven Design (DDD), what is a Bounded Context?",
    "options": [
      "A linguistic boundary where a specific domain model applies and terms have specific meaning",
      "A generic module that contains all shared utilities for the application",
      "The database schema that spans all microservices",
      "The physical limit of a server's memory allocation"
    ],
    "answer": "A linguistic boundary where a specific domain model applies and terms have specific meaning",
    "explanation": "A Bounded Context delimits the applicability of a particular model. Within the boundary, all terms have a specific, unambiguous meaning; outside it, the same terms may mean something else.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "In DDD, what is the function of an Aggregate Root?",
    "options": [
      "It is the only member of an aggregate that outside objects are allowed to hold references to",
      "It acts as the main entry point for the database connection",
      "It represents the collection of all value objects in the system",
      "It is a global identifier for all microservices"
    ],
    "answer": "It is the only member of an aggregate that outside objects are allowed to hold references to",
    "explanation": "The Aggregate Root is the entry point to an Aggregate (a cluster of domain objects). External references must only point to the Root, ensuring data integrity within the Aggregate.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is a common anti-pattern associated with the Registry pattern?",
    "options": [
      "It acts as a global object repository, often leading to hidden dependencies and reduced testability",
      "It creates too many instances of the Singleton class",
      "It enforces strict type checking at compile time",
      "It prevents the use of interfaces"
    ],
    "answer": "It acts as a global object repository, often leading to hidden dependencies and reduced testability",
    "explanation": "While the Registry pattern provides a lookup service, it often degenerates into a global variable structure, hiding dependencies between classes and making the system harder to test.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "How does the Virtual Proxy pattern assist in performance optimization?",
    "options": [
      "By creating multiple threads for a single object instantiation",
      "By delaying the initialization of an object until it is actually needed",
      "By compressing the object data in memory",
      "By caching the database query results indefinitely"
    ],
    "answer": "By delaying the initialization of an object until it is actually needed",
    "explanation": "A Virtual Proxy acts as a surrogate for another object. It defers the full initialization of the resource-intensive object until the client specifically requests it (Lazy Loading).",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which pattern describes an immutable object defined by its attributes rather than a unique identity, used to share data between contexts?",
    "options": [
      "Entity",
      "Value Object",
      "Aggregate",
      "Service"
    ],
    "answer": "Value Object",
    "explanation": "A Value Object is defined by its attributes (e.g., Money, DateRange). It lacks a unique identity and is immutable, making it safe to share across different parts of the system.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is a typical scalability limitation of a Monolithic architecture?",
    "options": [
      "You must scale the entire application as a single unit, even if only one module requires more resources",
      "It requires multiple database technologies to function",
      "It cannot be deployed to cloud environments",
      "It prevents the use of any design patterns"
    ],
    "answer": "You must scale the entire application as a single unit, even if only one module requires more resources",
    "explanation": "Monoliths package all functionality together. Scaling a single bottleneck component requires replicating the entire application, which is inefficient and resource-intensive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which pattern is useful for solving problems with no deterministic solution steps, where specialized subsystems assemble their partial solutions?",
    "options": [
      "Blackboard",
      "Interpreter",
      "Mediator",
      "Memento"
    ],
    "answer": "Blackboard",
    "explanation": "The Blackboard pattern handles complex, ill-defined problems by allowing multiple independent specialized subsystems (Knowledge Sources) to read/write to a shared data structure (the Blackboard).",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In the Pipe and Filter architectural pattern, how is data processed?",
    "options": [
      "Filters are independent processing steps connected by pipes that pass data streams",
      "All data is loaded into memory before processing begins",
      "A central controller calls each filter sequentially",
      "The database triggers the filters to run"
    ],
    "answer": "Filters are independent processing steps connected by pipes that pass data streams",
    "explanation": "Pipe and Filter structures the system as a sequence of transformations. Each Filter processes input data and produces output data, passing it to the next Filter via a Pipe.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the Model-View-Controller (MVC) pattern, what is the Model responsible for?",
    "options": [
      "Handling user input and routing commands",
      "Managing the behavior and data of the application domain",
      "Rendering the user interface and visual elements",
      "Acting as a bridge between the View and the database only"
    ],
    "answer": "Managing the behavior and data of the application domain",
    "explanation": "The Model represents the application's core logic and state. It is independent of the View (presentation) and Controller (input handling), responding to requests for state updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of the Unit of Work pattern, what is the primary function of the 'Commit' operation?",
    "options": [
      "It writes every change to the database immediately upon invocation.",
      "It tracks changes made to objects during a business transaction and ensures the database is updated to reflect them only when called.",
      "It establishes a new database connection pool for the duration of the HTTP request.",
      "It flushes the object cache to improve memory utilization."
    ],
    "answer": "It tracks changes made to objects during a business transaction and ensures the database is updated to reflect them only when called.",
    "explanation": "The Unit of Work pattern maintains a list of objects affected by a transaction and coordinates the writing out of changes. The Commit operation triggers the actual persistence of these tracked changes as a single atomic transaction.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the defining consistency trade-off when implementing the Command Query Responsibility Segregation (CQRS) pattern?",
    "options": [
      "The system experiences strong consistency within a single node but eventual consistency across the cluster.",
      "Read models are eventually consistent with the write model because they are updated asynchronously.",
      "Queries must be run on the primary database to ensure data integrity while writes are replicated.",
      "The system sacrifices availability to ensure linearizability of commands."
    ],
    "answer": "Read models are eventually consistent with the write model because they are updated asynchronously.",
    "explanation": "CQRS separates reads and writes into distinct models. While this allows independent scaling, the write model typically propagates changes to the read model via events, introducing a lag where the read model is not immediately up to date.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In a Microservices architecture, which pattern is specifically designed to encapsulate legacy systems or external services with a modern interface, gradually replacing functionality?",
    "options": [
      "The Sidecar pattern",
      "The Strangler Fig pattern",
      "The Ambassador pattern",
      "The Circuit Breaker pattern"
    ],
    "answer": "The Strangler Fig pattern",
    "explanation": "The Strangler Fig pattern creates a facade around an existing legacy system. New functionality is built behind the facade, and the old system is gradually 'strangled' (replaced) by redirecting calls to the new services.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which of the following statements best describes the 'Liskov Substitution Principle' (LSP) in the context of object-oriented design?",
    "options": [
      "Derived classes must be substitutable for their base classes without altering the correctness of the program.",
      "A class should have only one reason to change, implying a single responsibility.",
      "Software entities should be open for extension but closed for modification.",
      "Clients should not be forced to depend on interfaces they do not use."
    ],
    "answer": "Derived classes must be substitutable for their base classes without altering the correctness of the program.",
    "explanation": "LSP dictates that if a program is using a base class, it should be able to use any of its subclasses without the program knowing it. Subtypes must not alter the expected behavior defined by the supertype.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the primary role of the 'Data Mapper' pattern in an Enterprise Application Architecture?",
    "options": [
      "To map database columns directly to public properties of the domain object (Active Record).",
      "To move data between objects and a database while keeping them independent of each other.",
      "To generate SQL queries dynamically based on the object state.",
      "To serialize complex object graphs into JSON for API responses."
    ],
    "answer": "To move data between objects and a database while keeping them independent of each other.",
    "explanation": "Unlike Active Record, the Data Mapper pattern separates the in-memory object (Domain Model) from the database persistence logic. The Mapper is responsible for transferring data between the two, allowing the domain objects to remain oblivious to the database.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "When using the 'Event Sourcing' pattern, why is the system typically described as 'append-only'?",
    "options": [
      "Events are written to a log and updates to the current state are performed by overwriting the previous record.",
      "Once an event is stored in the event store, it is never modified or deleted; new events are appended to represent state changes.",
      "The database triggers automatically append history logs to a separate audit table.",
      "Users can only append data to the end of a document in the UI."
    ],
    "answer": "Once an event is stored in the event store, it is never modified or deleted; new events are appended to represent state changes.",
    "explanation": "Event Sourcing persists the state of a business entity as a sequence of state-changing events. Since these events represent facts that occurred in the past, they are immutable; the system evolves by appending new events to the stream.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How does the 'Ambassador' pattern differ from the 'Sidecar' pattern in containerized cloud-native architectures?",
    "options": [
      "The Ambassador acts as a client-side proxy for connecting to external services, while the Sidecar acts as a helper container to the main application.",
      "The Ambassador handles logging, while the Sidecar handles service discovery.",
      "The Ambassador runs in a separate process, while the Sidecar shares the process ID with the application.",
      "There is no difference; the terms are synonymous."
    ],
    "answer": "The Ambassador acts as a client-side proxy for connecting to external services, while the Sidecar acts as a helper container to the main application.",
    "explanation": "An Ambassador container acts as a proxy to the outside world, usually sitting between the application and a remote service. A Sidecar accompanies the main service to handle local concerns like monitoring or configuration.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the primary disadvantage of using the 'Two-Phase Commit' (2PC) protocol for distributed transactions?",
    "options": [
      "It guarantees high availability but sacrifices consistency.",
      "It is a blocking protocol where if the coordinator fails, participants may hold locks indefinitely.",
      "It requires the database to support sharding.",
      "It allows for partial commits to optimize performance."
    ],
    "answer": "It is a blocking protocol where if the coordinator fails, participants may hold locks indefinitely.",
    "explanation": "2PC is a blocking protocol. During the prepare phase, nodes lock resources. If the coordinator fails before sending the commit/rollback message, these resources remain locked, potentially causing a system-wide halt until recovery.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the 'Repository' pattern, what is the main reason for treating the database as a collection of in-memory objects?",
    "options": [
      "To improve query performance by avoiding SQL generation.",
      "To decouple the application logic from the specific data access technology and persistence details.",
      "To enforce a rigid schema that prevents the storage of polymorphic objects.",
      "To automatically cache all database queries in RAM."
    ],
    "answer": "To decouple the application logic from the specific data access technology and persistence details.",
    "explanation": "The Repository pattern abstracts the data source, presenting it as a collection of domain objects. This hides the complexities of data access (SQL, table structures, ORMs) from the domain logic layer.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which architectural pattern specifically addresses the 'N+1 select problem' by managing object identity within a session?",
    "options": [
      "The Identity Map pattern",
      "The Lazy Loading pattern",
      "The Data Mapper pattern",
      "The Superclass pattern"
    ],
    "answer": "The Identity Map pattern",
    "explanation": "The Identity Map ensures that each object gets loaded only once per session by keeping a map of all loaded objects. When an object is requested again, the map returns the existing instance, preventing redundant database hits (N+1 issues) related to fetching the same data.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In the 'Saga' pattern for distributed transactions, what is a 'Compensating Transaction'?",
    "options": [
      "A transaction that retries the failed operation immediately.",
      "A transaction that undoes the changes made by a previous transaction in the saga sequence.",
      "A transaction that commits the changes to a secondary backup database.",
      "A transaction that pauses the saga workflow until manual intervention."
    ],
    "answer": "A transaction that undoes the changes made by a previous transaction in the saga sequence.",
    "explanation": "Unlike ACID transactions that support rollback, Sagas are composed of a sequence of local transactions. If one step fails, the system executes compensating transactions to undo the effects of previously completed steps to maintain data consistency.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the primary purpose of the 'Front Controller' pattern in web application architecture?",
    "options": [
      "To create a separate controller for every unique web page URL.",
      "To consolidate request handling logic into a single handler that dispatches to specific commands or views.",
      "To move view rendering logic to the client-side browser.",
      "To route database traffic away from the application server."
    ],
    "answer": "To consolidate request handling logic into a single handler that dispatches to specific commands or views.",
    "explanation": "The Front Controller pattern provides a centralized entry point for all requests. This allows for common logic (authentication, logging, routing) to be handled in one place before dispatching to specific handlers.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In the context of concurrency patterns, how does the 'Balking' pattern differ from the 'Guarded Suspension' pattern?",
    "options": [
      "Balking blocks the thread until a condition is met, while Guarded Suspension returns an error immediately.",
      "Balking executes the action immediately if the condition is not met, while Guarded Suspension blocks the thread.",
      "Balking terminates the process if the lock is unavailable, while Guarded Suspension creates a new thread.",
      "Balking returns immediately without executing the action if the object is not in the appropriate state, whereas Guarded Suspension blocks until it is."
    ],
    "answer": "Balking returns immediately without executing the action if the object is not in the appropriate state, whereas Guarded Suspension blocks until it is.",
    "explanation": "In Balking, if the condition is not met, the method returns immediately (or throws an exception) without performing the action. In Guarded Suspension, the thread blocks (waits) until the condition required to proceed is satisfied.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What specific problem does the 'ReadReplica' pattern solve in high-load enterprise systems?",
    "options": [
      "It solves data inconsistency issues by forcing all writes to go through the primary node.",
      "It solves performance bottlenecks by offloading read traffic to read-only copies of the database.",
      "It solves network latency by compressing the data packets before transmission.",
      "It solves security issues by encrypting data at rest on the secondary nodes."
    ],
    "answer": "It solves performance bottlenecks by offloading read traffic to read-only copies of the database.",
    "explanation": "The ReadReplica pattern involves replicating data to secondary read-only nodes. This allows the system to horizontally scale read capacity, relieving the primary database (which handles writes) from the load of frequent read queries.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Why is the 'Anemic Domain Model' generally considered an anti-pattern in Domain-Driven Design (DDD)?",
    "options": [
      "It creates deep inheritance hierarchies that are difficult to understand.",
      "It separates the domain logic from the domain data, effectively reducing domain objects to passive data holders.",
      "It creates a circular dependency between the database and the user interface.",
      "It prevents the use of polymorphism in the business logic layer."
    ],
    "answer": "It separates the domain logic from the domain data, effectively reducing domain objects to passive data holders.",
    "explanation": "An Anemic Domain Model lacks behavior; logic is placed in service classes rather than the entities themselves. This violates the core object-oriented principle of encapsulation and fails to leverage the domain model's potential to express business rules.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which of the following best describes the 'Half-Open' state in the 'Circuit Breaker' pattern?",
    "options": [
      "The state where the circuit allows traffic to flow but checks for failures to determine if it should trip again.",
      "The state where the circuit is permanently closed due to successful operations.",
      "The state where all requests are immediately rejected without attempting the operation.",
      "The state where the circuit breaker is being uninstalled."
    ],
    "answer": "The state where the circuit allows traffic to flow but checks for failures to determine if it should trip again.",
    "explanation": "After the Open state (blocking requests) times out, the Circuit Breaker enters the Half-Open state. It allows a limited number of requests through to test if the underlying service has recovered; if successful, it closes; otherwise, it re-opens.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the primary function of the 'Decorator' pattern in structural design?",
    "options": [
      "To convert an interface into another interface that clients expect.",
      "To attach additional responsibilities to an object dynamically without affecting other objects of the same class.",
      "To compose objects into tree structures to represent part-whole hierarchies.",
      "To provide a unified interface to a set of interfaces in a subsystem."
    ],
    "answer": "To attach additional responsibilities to an object dynamically without affecting other objects of the same class.",
    "explanation": "The Decorator pattern provides a flexible alternative to subclassing for extending functionality. It wraps an object to add new behaviors at runtime, adhering to the Single Responsibility Principle.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the context of API design, what distinguishes a 'Facade' from a 'Gateway'?",
    "options": [
      "A Facade simplifies the interface of a complex subsystem, while a Gateway encapsulates access to external systems or resources.",
      "A Gateway simplifies the interface, while a Facade encapsulates access to external systems.",
      "A Facade is used only for internal communication, while a Gateway is used only for internet-facing communication.",
      "There is no technical difference; the terms are interchangeable."
    ],
    "answer": "A Facade simplifies the interface of a complex subsystem, while a Gateway encapsulates access to external systems or resources.",
    "explanation": "A Facade (GoF) provides a simplified interface to a library or complex internal code. A Gateway or API Gateway acts as a reverse proxy, accepting calls, aggregating results, and routing them to backend services.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the 'Double Dispatch' mechanism utilized by the Visitor design pattern?",
    "options": [
      "It allows a single method call to be routed to two different receivers simultaneously.",
      "It determines the operation to execute based on the types of two elements: the visitor and the element being visited.",
      "It dispatches the request twice to ensure network reliability in distributed systems.",
      "It creates two instances of the object to ensure thread safety."
    ],
    "answer": "It determines the operation to execute based on the types of two elements: the visitor and the element being visited.",
    "explanation": "Visitor achieves double dispatch: the client calls `accept(visitor)` on the element, which calls `visit(this)` on the visitor. This allows adding new operations to the object structure without modifying the structures themselves.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "Which pattern is best suited to prevent a 'Thundering Herd' problem when a cached resource expires?",
    "options": [
      "The Cache-Aside pattern",
      "The Locking pattern (or Mutex)",
      "The Write-Through caching pattern",
      "The Memoization pattern"
    ],
    "answer": "The Locking pattern (or Mutex)",
    "explanation": "When a cache expires, if all requests hit the database simultaneously, it causes a Thundering Herd. The Locking pattern ensures that only the first request populates the cache while others wait, preventing database overload.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In the 'Model-View-ViewModel' (MVVM) pattern, how does the View update itself compared to the 'Model-View-Controller' (MVC) pattern?",
    "options": [
      "The View queries the Model directly and renders the state.",
      "The Controller updates the View manually after receiving user input.",
      "The View uses data binding to observe the ViewModel for changes automatically.",
      "The ViewModel pushes changes to the View via the Observer pattern exclusively."
    ],
    "answer": "The View uses data binding to observe the ViewModel for changes automatically.",
    "explanation": "MVVM relies heavily on data binding. The View binds to properties on the ViewModel. When data in the ViewModel changes, the binding engine automatically updates the View elements, removing the need for manual UI update logic found in traditional MVC.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the primary advantage of using 'Sharding' as a scaling strategy compared to 'Replication'?",
    "options": [
      "Sharding provides high availability, whereas Replication does not.",
      "Sharding splits the dataset across multiple machines, enabling horizontal scaling of write capacity.",
      "Sharding creates full copies of the data to minimize read latency.",
      "Sharding eliminates the need for a load balancer."
    ],
    "answer": "Sharding splits the dataset across multiple machines, enabling horizontal scaling of write capacity.",
    "explanation": "While replication copies data to all nodes (good for reads), sharding partitions data so each node holds only a subset. This allows the system to distribute write loads across nodes, scaling total write throughput.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the role of the 'Leader Election' pattern in distributed systems?",
    "options": [
      "To select a single node to coordinate a task or manage shared state to avoid split-brain scenarios.",
      "To load balance traffic evenly across all available nodes.",
      "To elect the node with the highest computational power to perform all calculations.",
      "To determine the order in which requests are processed."
    ],
    "answer": "To select a single node to coordinate a task or manage shared state to avoid split-brain scenarios.",
    "explanation": "In distributed systems, Leader Election ensures that exactly one node acts as the leader (coordinator) for a specific task or partition. This prevents conflicts (split-brain) where multiple nodes attempt to manage the same shared resource independently.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the 'Specification' pattern, what is the main benefit of encapsulating business rules into separate objects?",
    "options": [
      "It allows business rules to be chained, combined, and reused independently of the domain objects they validate.",
      "It ensures that the database schema is normalized to 3NF.",
      "It converts imperative programming logic into declarative XML configuration.",
      "It eliminates the need for unit testing."
    ],
    "answer": "It allows business rules to be chained, combined, and reused independently of the domain objects they validate.",
    "explanation": "The Specification pattern defines a predicate (boolean function) as an object. This allows complex validation logic to be composed (AND/OR/NOT) and reused across different parts of the application (e.g., filtering, validation) without bloating the entity itself.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Which 'Proxy' pattern flavor is primarily used to optimize performance by delaying the initialization of an expensive object until it is actually needed?",
    "options": [
      "Remote Proxy",
      "Virtual Proxy",
      "Protection Proxy",
      "Smart Reference"
    ],
    "answer": "Virtual Proxy",
    "explanation": "A Virtual Proxy acts as a placeholder for a resource-intensive object. It defers the creation and initialization of the real object until it is requested by the client, optimizing startup time and memory usage.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the 'Chain of Responsibility' pattern differ from the 'Decorator' pattern?",
    "options": [
      "Chain of Responsibility passes a request along a dynamic chain of handlers, whereas Decorator wraps an object to add behavior.",
      "Decorator passes a request along a chain, whereas Chain of Responsibility adds behavior to an object.",
      "Chain of Responsibility modifies the object's state, while Decorator modifies the object's structure.",
      "Decorator is used for concurrency, while Chain of Responsibility is used for UI layout."
    ],
    "answer": "Chain of Responsibility passes a request along a dynamic chain of handlers, whereas Decorator wraps an object to add behavior.",
    "explanation": "Chain of Responsibility allows a request to pass through a series of handlers until one handles it (decoupling sender from receiver). Decorator is structural, strictly adding layers of responsibility (behavior) to a specific object instance.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "In the context of the 'Blackboard' pattern, what is the role of the 'Controller' (or 'Knowledge Source Scheduler')?",
    "options": [
      "It modifies the data on the blackboard directly.",
      "It monitors the blackboard state and determines which expert module (knowledge source) should act next.",
      "It serves as the user interface for displaying the blackboard.",
      "It encrypts the data stored on the blackboard."
    ],
    "answer": "It monitors the blackboard state and determines which expert module (knowledge source) should act next.",
    "explanation": "The Blackboard pattern involves a shared repository. The Controller (or Scheduler) observes the blackboard and triggers the appropriate expert modules to apply their knowledge to the problem based on the current state.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the 'Capability' security model in distributed systems design?",
    "options": [
      "A model where access rights are granted based on the user's role within the organization hierarchy.",
      "A model where access rights are granted based on possession of an unforgeable token (capability) that references a specific object.",
      "A model where all access control lists are stored in a centralized database.",
      "A model that relies solely on SSL/TLS for security."
    ],
    "answer": "A model where access rights are granted based on possession of an unforgeable token (capability) that references a specific object.",
    "explanation": "In Capability-based security, the 'token' (capability) itself is the key. If you hold the token (e.g., a URL or a memory pointer), you have the permission to access the resource. It contrasts with ACL models where permissions are checked against an identity list.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Why might an architect choose 'Eventual Consistency' over 'Strong Consistency' in a distributed database?",
    "options": [
      "Eventual consistency ensures zero data loss under network partitions.",
      "Eventual consistency trades immediate data consistency for higher availability and lower latency.",
      "Eventual consistency allows the database to function without any replication.",
      "Strong consistency is technically impossible to implement in distributed systems."
    ],
    "answer": "Eventual consistency trades immediate data consistency for higher availability and lower latency.",
    "explanation": "According to the CAP theorem, one must sacrifice Consistency or Availability during a Partition. Eventual consistency systems prioritize Availability and low latency (performance) over guaranteeing that all nodes see the same data simultaneously.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the specific responsibility of the 'Interceptor' pattern in an enterprise application framework?",
    "options": [
      "To encrypt data before it is stored in the database.",
      "To pre-process and post-process requests or responses by cross-cutting logic like logging or authentication.",
      "To intercept SQL queries and optimize them.",
      "To compress outgoing HTTP packets."
    ],
    "answer": "To pre-process and post-process requests or responses by cross-cutting logic like logging or authentication.",
    "explanation": "The Interceptor pattern allows an application to dynamically add or remove behavior (cross-cutting concerns) to a request processing flow without changing the core handler code. It acts like a filter or middleware within the execution chain.",
    "difficulty": "Advanced"
  }
]