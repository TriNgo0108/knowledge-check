[
  {
    "id": 1,
    "question": "Which scaling strategy involves adding more nodes to a system to handle increased load, rather than upgrading the hardware of existing nodes?",
    "options": [
      "Vertical Scaling",
      "Horizontal Scaling",
      "Functional Scaling",
      "Diagonal Scaling"
    ],
    "answer": "Horizontal Scaling",
    "explanation": "Horizontal Scaling (scaling out) distributes the load across multiple compute nodes. Vertical Scaling (scaling up) increases the capacity of a single machine (CPU/RAM).",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In a client-server architecture, what is the primary role of the Load Balancer?",
    "options": [
      "To persist data permanently across multiple database instances",
      "To distribute incoming network traffic across multiple servers",
      "To authenticate users before they access the server",
      "To encrypt data packets between the client and the server"
    ],
    "answer": "To distribute incoming network traffic across multiple servers",
    "explanation": "A Load Balancer acts as a reverse proxy, routing client requests to backend servers to ensure no single server is overwhelmed. It does not persist data, handle authentication (primarily), or manage encryption (TLS termination is a specific feature, not the primary role).",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which caching strategy stores the entire dataset in a fast storage layer (like Redis) to avoid hitting the database entirely?",
    "options": [
      "Write-Through Cache",
      "Write-Back (Write-Behind) Cache",
      "Look-Aside (Lazy Loading) Cache",
      "Read-Through Cache"
    ],
    "answer": "Look-Aside (Lazy Loading) Cache",
    "explanation": "In a Look-Aside cache, the application checks the cache first; if data is missing, it retrieves it from the database and populates the cache. Write-Through and Write-Back refer to how data is written, while Read-Through implies the cache layer manages the retrieval.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the main trade-off when using a SQL database compared to a NoSQL database?",
    "options": [
      "SQL databases sacrifice consistency for availability",
      "SQL databases require a fixed schema, limiting flexibility for unstructured data",
      "SQL databases cannot handle relationships between entities",
      "SQL databases are only suitable for small-scale applications"
    ],
    "answer": "SQL databases require a fixed schema, limiting flexibility for unstructured data",
    "explanation": "SQL databases are relational and rely on a rigid, predefined schema (schema-on-write), whereas NoSQL databases are schema-less or have flexible schemas (schema-on-read) designed for unstructured data.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In the CAP Theorem, which property guarantees that every request receives a (non-error) response, without the guarantee that it contains the most recent write?",
    "options": [
      "Consistency",
      "Availability",
      "Partition Tolerance",
      "Durability"
    ],
    "answer": "Availability",
    "explanation": "Availability ensures the system remains operational and responsive even during failures, though it may return stale data. Consistency ensures all nodes see the same data at the same time. Partition Tolerance allows the system to continue operating despite network failures.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which technique allows a database to handle a higher volume of read traffic by copying data from a primary node to secondary nodes?",
    "options": [
      "Sharding",
      "Replication",
      "Indexing",
      "Partitioning"
    ],
    "answer": "Replication",
    "explanation": "Replication creates copies of the same data on different nodes (Primary-Replica), enabling read operations to be distributed across replicas. Sharding distributes distinct subsets of data across nodes.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the primary function of a Content Delivery Network (CDN)?",
    "options": [
      "To execute server-side code closer to the user",
      "To serve static content (images, videos, CSS) from geographically distributed edge servers",
      "To facilitate secure database connections",
      "To balance dynamic API requests"
    ],
    "answer": "To serve static content (images, videos, CSS) from geographically distributed edge servers",
    "explanation": "CDNs cache static assets at edge locations near users to reduce latency and bandwidth usage. They do not typically execute server-side logic (dynamic processing) or handle database connections.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which type of database uses a key-value pair structure and offers the highest performance for simple read/write operations?",
    "options": [
      "Relational Database",
      "Document Store",
      "Key-Value Store",
      "Graph Database"
    ],
    "answer": "Key-Value Store",
    "explanation": "Key-Value Stores (like Redis or Memcached) use an in-memory hash map structure, offering O(1) access time for simple retrieval. Relational databases use tables, Document stores use JSON/XML, and Graph stores focus on nodes and edges.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is a 'Database Index' primarily designed to improve?",
    "options": [
      "Write speed",
      "Read speed",
      "Data security",
      "Storage capacity"
    ],
    "answer": "Read speed",
    "explanation": "Indexes create a data structure (like a B-Tree) that allows the database to find rows quickly without scanning the entire table. This trades off storage space and write speed (updating the index) for significantly faster read performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which ACID property ensures that concurrent transactions execute in a way that produces the same effect as if they were executed sequentially?",
    "options": [
      "Atomicity",
      "Consistency",
      "Isolation",
      "Durability"
    ],
    "answer": "Isolation",
    "explanation": "Isolation ensures that concurrent transactions do not interfere with each other. Serializability is the highest level of isolation, ensuring the result is the same as if transactions ran one after another.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What distinguishes a Microservices architecture from a Monolithic architecture?",
    "options": [
      "Microservices are written in different languages only",
      "Microservices organize code as a single deployable unit",
      "Microservices decompose the application into small, loosely coupled services",
      "Microservices share the same database instance"
    ],
    "answer": "Microservices decompose the application into small, loosely coupled services",
    "explanation": "Microservices architecture structures the application as a collection of services that are independently deployable, scalable, and maintainable. Monoliths are built as a single unified unit, typically sharing a large codebase and database.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Why is 'Idempotency' important in API design?",
    "options": [
      "It ensures the API can only be called once per second",
      "It guarantees that making the same request multiple times has the same effect as making it once",
      "It encrypts the data sent over the network",
      "It reduces the payload size of the response"
    ],
    "answer": "It guarantees that making the same request multiple times has the same effect as making it once",
    "explanation": "Idempotency is crucial for fault tolerance, particularly in distributed systems where network retries may occur. It ensures that duplicate requests (like retries due to timeout) do not cause unintended side effects (e.g., double charging).",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which HTTP method is technically idempotent and safe, meaning it requests a representation of the specified resource without modifying it?",
    "options": [
      "POST",
      "PUT",
      "GET",
      "DELETE"
    ],
    "answer": "GET",
    "explanation": "GET is defined as safe and idempotent; it retrieves data and does not alter server state. POST is not idempotent, while PUT and DELETE are idempotent but not safe (they modify state).",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the primary disadvantage of using Read Replicas in a database architecture?",
    "options": [
      "They decrease read throughput",
      "They introduce eventual consistency between the primary and replicas",
      "They do not allow horizontal scaling",
      "They increase the write latency of the primary node"
    ],
    "answer": "They introduce eventual consistency between the primary and replicas",
    "explanation": "Data must propagate from the writer to the reader, creating a replication lag. Consequently, a client reading from a replica might see stale data (eventual consistency) compared to the primary.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which Consistent Hashing technique helps to minimize data movement when nodes are added or removed from a distributed system?",
    "options": [
      "Modulo Hashing",
      "Virtual Nodes (VNodes)",
      "Range Partitioning",
      "Directory-based Partitioning"
    ],
    "answer": "Virtual Nodes (VNodes)",
    "explanation": "Virtual Nodes allow each physical node to hold multiple hash ring positions. This ensures that when a node is added or removed, only the data associated with its specific tokens is redistributed, creating a more balanced load and minimizing disruption.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "In system design, what is the 'N+1 Select Problem'?",
    "options": [
      "Executing N separate queries to fetch a list of items, plus 1 query per item to fetch related data",
      "A security vulnerability where N users access 1 table",
      "A network latency issue caused by N servers and 1 load balancer",
      "The inability of the database to handle more than N+1 connections"
    ],
    "answer": "Executing N separate queries to fetch a list of items, plus 1 query per item to fetch related data",
    "explanation": "This anti-pattern occurs when an ORM or application queries the parent record (1) and then executes a separate query for every single child record (N) to fetch associations, severely degrading performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which architectural pattern is best suited for real-time data ingestion where components react asynchronously to state changes?",
    "options": [
      "Request-Response",
      "Event-Driven Architecture",
      "Monolithic Architecture",
      "Service-Oriented Architecture (SOA)"
    ],
    "answer": "Event-Driven Architecture",
    "explanation": "Event-Driven Architecture uses events (messages) to trigger decoupled services. It is ideal for real-time processing, whereas Request-Response is synchronous and Monolithic/ SOA describes structure, not communication flow.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the purpose of a 'Circuit Breaker' in a distributed system?",
    "options": [
      "To route traffic to the nearest server",
      "To stop cascading failures by detecting them and failing fast",
      "To increase the voltage of the server power supply",
      "To compress data packets for faster transmission"
    ],
    "answer": "To stop cascading failures by detecting them and failing fast",
    "explanation": "A Circuit Breaker detects when a downstream service is failing and prevents requests from reaching it (tripping the breaker). It allows the system to handle the error gracefully rather than waiting for a timeout, conserving resources.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which data storage format is typically semi-structured, consisting of key-value pairs (or attributes), and is favored in NoSQL Document Stores?",
    "options": [
      "CSV (Comma Separated Values)",
      "XML (eXtensible Markup Language)",
      "JSON (JavaScript Object Notation)",
      "HTML (HyperText Markup Language)"
    ],
    "answer": "JSON (JavaScript Object Notation)",
    "explanation": "JSON is the standard data format for many NoSQL document stores (like MongoDB) because it is human-readable, hierarchical, and flexible (schema-less). CSV is tabular, XML is verbose, and HTML is for presentation.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the primary function of a 'Message Queue' in asynchronous processing?",
    "options": [
      "To store data permanently for 10 years",
      "To buffer requests so they can be processed by workers at a controlled rate",
      "To automatically translate code from Java to Python",
      "To serve web pages to the end user"
    ],
    "answer": "To buffer requests so they can be processed by workers at a controlled rate",
    "explanation": "Message Queues allow asynchronous communication by decoupling services. Producers send messages to the queue, and consumers (workers) process them later, enabling load smoothing (backpressure handling).",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "When designing a URL Shortener, what is the most efficient way to generate a unique short key for a long URL?",
    "options": [
      "Store the full URL as the primary key",
      "Use a hashing function (like MD5) or base62 encoding of the database ID",
      "Use a random string of 200 characters",
      "Encrypt the URL using AES-256"
    ],
    "answer": "Use a hashing function (like MD5) or base62 encoding of the database ID",
    "explanation": "Base62 encoding of a unique integer ID (like a database auto-increment counter) produces short, unique, URL-safe strings. Hashing the URL itself can lead to collisions, and random long strings defeat the purpose of shortening.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is 'Fan-out' in the context of distributed messaging?",
    "options": [
      "A cooling mechanism for server racks",
      "Delivering one message to multiple consumers (or multiple queues)",
      "The process of compressing data before storage",
      "Merging multiple queues into a single queue"
    ],
    "answer": "Delivering one message to multiple consumers (or multiple queues)",
    "explanation": "Fan-out describes a pattern where a single message produced by a service is distributed to multiple subscribers, often used for notifications or updating various denormalized views.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What defines a 'Stateless' service in system design?",
    "options": [
      "The service does not store any data in a database",
      "Every request from a client contains all information needed to process it",
      "The service has no downtime",
      "The service is written in a functional programming language"
    ],
    "answer": "Every request from a client contains all information needed to process it",
    "explanation": "Stateless services do not retain client context (session data) between requests. This allows any server to handle any request, improving scalability and reliability.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Why are long-polling and WebSockets used instead of traditional HTTP polling for chat applications?",
    "options": [
      "They are easier to implement than HTTP requests",
      "They allow servers to push data to clients instantly without repeated HTTP handshakes",
      "They encrypt messages by default without TLS",
      "They do not require an internet connection"
    ],
    "answer": "They allow servers to push data to clients instantly without repeated HTTP handshakes",
    "explanation": "Traditional HTTP polling creates high overhead. Long-polling holds a connection open, and WebSockets provide a persistent, full-duplex communication channel, enabling real-time updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which mechanism helps prevent a specific user from sending too many requests to a server in a short period of time?",
    "options": [
      "Rate Limiting",
      "Data Sharding",
      "Database Indexing",
      "Horizontal Scaling"
    ],
    "answer": "Rate Limiting",
    "explanation": "Rate Limiting controls the rate of incoming traffic to protect server resources and ensure fair usage. Sharding and Indexing optimize data handling, while Horizontal Scaling adds capacity.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is 'Sharding' in the context of databases?",
    "options": [
      "Creating backups of the database",
      "Splitting a large database into smaller, faster, more easily managed parts called data shards",
      "Encrypting the database at rest",
      "Compressing the database to save space"
    ],
    "answer": "Splitting a large database into smaller, faster, more easily managed parts called data shards",
    "explanation": "Sharding is a horizontal partitioning method where data is distributed across multiple distinct databases (shards) based on a shard key, allowing massive scale-out.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "In the context of an API Gateway, what is 'Throttling'?",
    "options": [
      "Increasing the bandwidth of the network",
      "Restricting the number of requests a user can make to prevent service overload",
      "Accelerating the processing speed of the server",
      "Deleting old data from the database"
    ],
    "answer": "Restricting the number of requests a user can make to prevent service overload",
    "explanation": "Throttling is a form of rate limiting used to control network traffic by defining specific thresholds for API usage, ensuring stability for all users.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the primary distinction between 'Availability' and 'Reliability' in system design?",
    "options": [
      "Availability measures uptime, while Reliability measures the system's ability to function correctly over time",
      "Reliability measures uptime, while Availability measures the correctness of data",
      "They are synonyms and mean the exact same thing",
      "Availability refers to hardware, while Reliability refers to software"
    ],
    "answer": "Availability measures uptime, while Reliability measures the system's ability to function correctly over time",
    "explanation": "Availability is the proportion of time a system is in a functioning condition (Uptime). Reliability implies the system can perform its required functions correctly consistently (Mean Time Between Failures).",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which of the following best describes the 'Backpressure' mechanism in streaming systems?",
    "options": [
      "Increasing the speed of data producers",
      "A mechanism to handle slow consumers by slowing down producers or dropping data",
      "Compressing data streams to use less memory",
      "Replicating data across multiple regions"
    ],
    "answer": "A mechanism to handle slow consumers by slowing down producers or dropping data",
    "explanation": "Backpressure occurs when a data buffer is full. The mechanism signals the upstream producer to slow down or stop to prevent the system from crashing due to resource exhaustion.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Why might a system designer choose 'Eventual Consistency' over 'Strong Consistency'?",
    "options": [
      "To ensure all users see the exact same data immediately",
      "To prioritize high availability and low latency over immediate data synchronization",
      "To simplify the code logic of the application",
      "To avoid using databases entirely"
    ],
    "answer": "To prioritize high availability and low latency over immediate data synchronization",
    "explanation": "Under the CAP theorem, if you prioritize Availability and Partition Tolerance, you sacrifice Strong Consistency, resulting in Eventual Consistency (data propagates eventually).",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the primary advantage of using a Bloom Filter as a pre-step in searching a database?",
    "options": [
      "It reduces the storage size of the database",
      "It can quickly determine if an element is definitely NOT in a set, avoiding expensive disk lookups",
      "It sorts the data alphabetically",
      "It acts as a primary key for the table"
    ],
    "answer": "It can quickly determine if an element is definitely NOT in a set, avoiding expensive disk lookups",
    "explanation": "A Bloom Filter is a space-efficient probabilistic data structure. It is highly effective at avoiding unnecessary reads to a database or key-value store if the key does not exist.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which architectural pattern hides the complexity of interacting with multiple microservices by providing a unified entry point?",
    "options": [
      "Load Balancer",
      "API Gateway",
      "Service Registry",
      "Database Proxy"
    ],
    "answer": "API Gateway",
    "explanation": "An API Gateway acts as a reverse proxy to accept all API calls, aggregate the responses from various microservices, and return them to the client, handling cross-cutting concerns like auth and throttling.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "In a distributed system, what is 'Service Discovery'?",
    "options": [
      "A process to find new business ideas",
      "A mechanism for services to find the network locations of other service instances",
      "A type of search engine for the internet",
      "A debugging tool for finding code errors"
    ],
    "answer": "A mechanism for services to find the network locations of other service instances",
    "explanation": "In dynamic environments (like Docker/Kubernetes), where IP addresses change frequently, Service Discovery allows clients to locate available service instances (via a registry or DNS).",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of 'Heartbeat' messages in distributed systems?",
    "options": [
      "To measure the latency of the network",
      "To send data packets to the client",
      "To detect if a remote node is still alive and functioning",
      "To synchronize the time on all servers"
    ],
    "answer": "To detect if a remote node is still alive and functioning",
    "explanation": "Heartbeat messages are sent periodically between nodes. If a heartbeat is missed within a specific timeout interval, the system assumes the node has failed and takes corrective action.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which HTTP status code is best used for 'Too Many Requests' when enforcing rate limits?",
    "options": [
      "401 Unauthorized",
      "403 Forbidden",
      "429 Too Many Requests",
      "500 Internal Server Error"
    ],
    "answer": "429 Too Many Requests",
    "explanation": "HTTP 429 is the standard status code returned when a user has sent too many requests in a given amount of time (rate limiting). 401/403 relate to permissions, and 500 relates to server errors.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In the context of the CAP Theorem, which characteristic must be sacrificed to ensure Partition Tolerance in a distributed system?",
    "options": [
      "Latency",
      "Scalability",
      "Consistency or Availability",
      "Durability"
    ],
    "answer": "Consistency or Availability",
    "explanation": "According to the CAP theorem, a distributed system can only guarantee two of three properties: Consistency, Availability, and Partition Tolerance. During a network partition (P), the system must choose between remaining Available (A) and accepting inconsistent writes, or remaining Consistent (C) and rejecting writes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which load balancing algorithm ensures that requests from a specific client are always routed to the same server, assuming the client's IP remains constant?",
    "options": [
      "Round Robin",
      "Least Connections",
      "IP Hash",
      "Weighted Response Time"
    ],
    "answer": "IP Hash",
    "explanation": "IP Hash uses a hash of the client's IP address to determine the server, ensuring session persistence. Round Robin and Least Connections do not inherently guarantee that a specific client hits the same server repeatedly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary trade-off when implementing a Strong Consistency model in a distributed database?",
    "options": [
      "Lower availability during network partitions",
      "Higher data storage requirements",
      "Slower read performance due to lack of indexing",
      "Inability to scale horizontally"
    ],
    "answer": "Lower availability during network partitions",
    "explanation": "Strong consistency often requires synchronous replication or quorum reads, which can block operations if nodes cannot communicate, directly impacting Availability (CAP theorem). Storage costs and read speed are secondary effects compared to the systemic availability trade-off.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In database sharding, what is a specific disadvantage of using 'Range-based Sharding' compared to 'Hash-based Sharding'?",
    "options": [
      "Requires complex application logic to determine the shard",
      "Can lead to uneven load distribution or 'hot spots'",
      "Prevents the database from being horizontally scalable",
      "Eliminates the ability to perform efficient range queries"
    ],
    "answer": "Can lead to uneven load distribution or 'hot spots'",
    "explanation": "Range-based sharding places contiguous data on the same shard; if certain ranges (e.g., recent dates) are accessed more frequently, those specific shards become 'hot spots.' Hash-based sharding distributes data more uniformly but sacrifices efficient range query capability.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which caching strategy writes data to the cache and the persistent database simultaneously in a single transaction?",
    "options": [
      "Cache-aside (Lazy Loading)",
      "Write-through",
      "Write-back (Write-behind)",
      "Write-around"
    ],
    "answer": "Write-through",
    "explanation": "Write-through caching ensures that data is written to the cache and the backing store synchronously, ensuring consistency. Cache-aside updates the cache only on a read miss; Write-back updates only the cache and persists later.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When designing a RESTful API, what is the primary purpose of the ETag header?",
    "options": [
      "To authenticate the user making the request",
      "To facilitate caching and concurrency control",
      "To specify the content format (JSON/XML)",
      "To rate limit the client based on their ID"
    ],
    "answer": "To facilitate caching and concurrency control",
    "explanation": "An ETag is a fingerprint of a resource; clients use it with `If-Match` or `If-None-Match` headers to verify if content has changed (optimistic locking) or to save bandwidth with 304 Not Modified responses. It is not used for authentication or content negotiation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which component is responsible for terminating TLS (Transport Layer Security) and inspecting HTTP requests before forwarding them to backend servers?",
    "options": [
      "DNS Server",
      "L4 Load Balancer",
      "Reverse Proxy",
      "CDN Edge Node"
    ],
    "answer": "Reverse Proxy",
    "explanation": "A Reverse Proxy operates at Layer 7 (Application Layer), allowing it to handle TLS termination and inspect HTTP headers/routing. An L4 Load Balancer operates at the Transport layer (TCP/UDP) and generally cannot inspect HTTP content.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the 'Thundering Herd' problem in the context of system design?",
    "options": [
      "A database deadlock caused by multiple transactions",
      "Massive concurrent requests overwhelming a cache after it expires",
      "A network storm caused by a switch loop",
      "Memory leaks in the application server"
    ],
    "answer": "Massive concurrent requests overwhelming a cache after it expires",
    "explanation": "The Thundering Herd occurs when a cached object expires, causing numerous concurrent requests to miss the cache and hit the backend simultaneously, potentially crashing it. It specifically relates to cache stampedes, not database deadlocks or network loops.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which database storage structure is optimized for write-heavy workloads due to append-only operations?",
    "options": [
      "B-Tree",
      "LSM Tree (Log-Structured Merge Tree)",
      "Hash Index",
      "Clustered Index"
    ],
    "answer": "LSM Tree (Log-Structured Merge Tree)",
    "explanation": "LSM trees buffer writes in memory and sequentially append them to disk (SSTables), minimizing random disk I/O and offering higher write throughput. B-Trees require random disk I/O for updates, making them slower for heavy write loads.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Why is a Two-Phase Commit (2PC) protocol considered undesirable in high-performance distributed systems?",
    "options": [
      "It requires all database nodes to be located in the same data center",
      "It is a blocking protocol that reduces system availability",
      "It can only handle one participant database",
      "It uses weak consistency by default"
    ],
    "answer": "It is a blocking protocol that reduces system availability",
    "explanation": "2PC is blocking because if the coordinator fails, participants may hold locks indefinitely while waiting for instructions, causing the system to stall. This makes it brittle and unavailable during failures, despite ensuring atomicity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In a Master-Slave replication topology, what is the primary limitation of the 'Slave' node?",
    "options": [
      "It cannot serve read traffic",
      "It cannot handle write operations",
      "It stores only the schema, not the data",
      "It must act as the leader in consensus algorithms"
    ],
    "answer": "It cannot handle write operations",
    "explanation": "In Master-Slave replication, writes *must* go through the Master node to ensure data is propagated to Slaves. Slaves can typically serve read traffic (eventual consistency) but accept no writes to prevent data divergence.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which design pattern involves intercepting a request to perform preliminary checks (like authentication or rate limiting) before passing it to the core service?",
    "options": [
      "Sidecar Pattern",
      "Ambassador Pattern",
      "Adapter Pattern",
      "Facade Pattern"
    ],
    "answer": "Ambassador Pattern",
    "explanation": "The Ambassador pattern (often a sidecar proxy) handles tasks like monitoring, logging, and routing logic on behalf of the main service, sending sanitized requests to the primary application. A Sidecar assists the main container but does not necessarily intercept all inbound requests in the same way.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which consistency model allows reading stale data but guarantees that if no new updates are made, eventually all accesses will return the last updated value?",
    "options": [
      "Strong Consistency",
      "Eventual Consistency",
      "Causal Consistency",
      "Read Your Writes"
    ],
    "answer": "Eventual Consistency",
    "explanation": "Eventual consistency guarantees that stops updates propagate eventually, meaning reads might be stale temporarily. Strong consistency requires reads to reflect the latest write immediately.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "When using a Content Delivery Network (CDN), what does the 'Time to Live' (TTL) value control?",
    "options": [
      "The duration a user remains logged in",
      "How long the CDN edge server caches the asset before checking the origin",
      "The time taken to download a file",
      "The maximum lifespan of a TCP connection"
    ],
    "answer": "How long the CDN edge server caches the asset before checking the origin",
    "explanation": "TTL defines the cache duration. A longer TTL reduces origin load but may mean stale content is served longer; a shorter TTL ensures freshness but increases origin requests.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the primary benefit of using 'Consistent Hashing' in a distributed cache cluster?",
    "options": [
      "It ensures all nodes contain exactly the same data",
      "It minimizes data remapping when nodes are added or removed",
      "It guarantees that the data is sorted alphabetically",
      "It eliminates the need for a load balancer"
    ],
    "answer": "It minimizes data remapping when nodes are added or removed",
    "explanation": "Consistent hashing maps both data and nodes to a ring, ensuring that adding/removing a node only affects the keys adjacent to it. Standard hashing requires remapping almost all keys if the number of nodes changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In the context of message queues, what is the semantic difference between 'At-Most-Once' and 'At-Least-Once' delivery?",
    "options": [
      "At-Most-Once allows duplicates; At-Least-Once guarantees no loss",
      "At-Most-Once guarantees no duplicates but may lose messages; At-Least-Once guarantees delivery but may duplicate",
      "At-Least-Once requires acknowledgments; At-Most-Once uses UDP",
      "There is no difference; they are synonymous"
    ],
    "answer": "At-Most-Once guarantees no duplicates but may lose messages; At-Least-Once guarantees delivery but may duplicate",
    "explanation": "At-Least-Once ensures the message arrives but retries can cause duplicates. At-Most-Once sends the message without persisting it; if it fails, it is lost, but it will never be delivered twice.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which rate-limiting algorithm allows for bursts of traffic up to a set capacity but refills tokens at a fixed rate?",
    "options": [
      "Fixed Window",
      "Leaky Bucket",
      "Token Bucket",
      "Sliding Window Log"
    ],
    "answer": "Token Bucket",
    "explanation": "The Token Bucket algorithm stores tokens (capacity) and consumes them for requests; it accumulates tokens when idle, allowing for bursts. The Leaky Bucket strictly smooths traffic to a fixed rate and does not allow large bursts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "In SQL databases, what is a 'Clustered Index'?",
    "options": [
      "An index on multiple columns",
      "The physical order of data on disk matching the index order",
      "A separate data structure that points to the heap",
      "An index used specifically for full-text search"
    ],
    "answer": "The physical order of data on disk matching the index order",
    "explanation": "A clustered index sorts and stores the data rows in the table based on their key values; there can be only one per table. A Non-Clustered index is a separate structure pointing to the data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the primary function of an 'Oracle' or 'Sentinel' in a distributed system?",
    "options": [
      "To encrypt data in transit",
      "To monitor the health of nodes and trigger automatic failover",
      "To store user authentication credentials",
      "To route incoming HTTP traffic"
    ],
    "answer": "To monitor the health of nodes and trigger automatic failover",
    "explanation": "These systems (like Redis Sentinel) monitor masters/slaves. If a master fails, the Sentinel notifies other nodes and promotes a slave to master to maintain availability.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which partitioning strategy involves placing rows related to specific business entities (e.g., Customer A and all their orders) on the same database node?",
    "options": [
      "Vertical Partitioning",
      "Horizontal Partitioning (Sharding)",
      "Range-based Sharding",
      "Directory-based Sharding"
    ],
    "answer": "Horizontal Partitioning (Sharding)",
    "explanation": "While sharding is the general mechanism, this specifically refers to Horizontal Partitioning logic where the shard key ensures co-location. Vertical partitioning splits *tables*, not rows of the same table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is 'Backpressure' in the context of data streaming (e.g., Kafka or Akka)?",
    "options": [
      "The latency caused by network congestion",
      "A mechanism to slow down producers when consumers cannot process data fast enough",
      "The force applied to restart a crashed service",
      "The size of the network buffer"
    ],
    "answer": "A mechanism to slow down producers when consumers cannot process data fast enough",
    "explanation": "Backpressure prevents a fast producer from overwhelming a slow consumer, avoiding out-of-memory errors or data loss. It signals the producer to reduce the throughput rate.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Why is 'Idempotency' critical when designing APIs for distributed systems?",
    "options": [
      "It allows the server to encrypt data",
      "It ensures that multiple identical requests have the same effect as a single request",
      "It reduces the payload size of JSON",
      "It enables OAuth 2.0 authentication"
    ],
    "answer": "It ensures that multiple identical requests have the same effect as a single request",
    "explanation": "In unreliable networks, clients may retry requests due to timeouts. Idempotency guarantees that these retries do not create duplicate side effects (e.g., charging a credit card twice).",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which pattern allows a client to receive updates from a server without the client explicitly requesting them repeatedly?",
    "options": [
      "Short Polling",
      "Long Polling",
      "Stateless REST",
      "SOAP"
    ],
    "answer": "Long Polling",
    "explanation": "Long Polling keeps the connection open until the server has data to send, effectively simulating push. Short Polling requires the client to ask repeatedly, often receiving empty responses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is 'Write Skew' anomaly in database isolation levels?",
    "options": [
      "Reading uncommitted data from another transaction",
      "Two concurrent transactions updating the same row",
      "Two transactions read overlapping data sets and concurrently update disjoint rows, breaking an invariant",
      "A transaction that commits before reading data"
    ],
    "answer": "Two transactions read overlapping data sets and concurrently update disjoint rows, breaking an invariant",
    "explanation": "Write skew occurs in Snapshot Isolation where two transactions read the same consistent snapshot but make non-conflicting updates that, when combined, violate a business constraint (e.g., two on-call doctors both resigning simultaneously).",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the primary purpose of a 'Bloom Filter' in a database read path?",
    "options": [
      "To compress the data before storage",
      "To quickly check if an element is definitely NOT in a set",
      "To sort the query results",
      "To establish a secure connection"
    ],
    "answer": "To quickly check if an element is definitely NOT in a set",
    "explanation": "Bloom filters are space-efficient probabilistic structures used to avoid unnecessary disk lookups. If the filter says 'No', the item is certainly not there; if it says 'Yes', it *might* be there (false positives are possible).",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which algorithm is used by Google's Chubby or Zookeeper to achieve consensus in a distributed system?",
    "options": [
      "Paxos / ZAB",
      "Two-Phase Commit",
      "Vector Clocks",
      "Gossip Protocol"
    ],
    "answer": "Paxos / ZAB",
    "explanation": "Zookeeper Atomic Broadcast (ZAB) and Paxos are consensus algorithms ensuring a consistent log across nodes. Gossip is an eventual consistency protocol, and 2PC is a commit protocol, not a consensus election.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "In Microservices architecture, what is the primary role of an 'API Gateway'?",
    "options": [
      "To host the database schemas",
      "To provide a single entry point for request routing, composition, and cross-cutting concerns",
      "To replace the need for a load balancer",
      "To compile the source code for the services"
    ],
    "answer": "To provide a single entry point for request routing, composition, and cross-cutting concerns",
    "explanation": "The Gateway acts as a reverse proxy to handle routing, authentication, rate limiting, and aggregation, decoupling the client from the internal microservice topology.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which technique is used to split a large database into two or more smaller, faster, and more easily managed parts based on data usage patterns?",
    "options": [
      "Clustering",
      "Sharding",
      "Indexing",
      "Caching"
    ],
    "answer": "Sharding",
    "explanation": "Sharding partitions data horizontally (e.g., by user ID) across multiple database instances. Clustering usually implies replication of the same data for availability, not splitting data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the difference between a 'Process' and a 'Thread' in the context of server architecture?",
    "options": [
      "Threads share the same memory space; Processes have isolated memory",
      "Processes are faster to create than threads",
      "Threads cannot run in parallel",
      "Processes share memory; Threads do not"
    ],
    "answer": "Threads share the same memory space; Processes have isolated memory",
    "explanation": "Threads are lightweight units of execution within a process and share the process's heap. Processes are distinct execution units with separate memory spaces, requiring heavier context switching.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is a 'PHY' (Physical) compromise in the context of network security?",
    "options": [
      "A SQL injection attack",
      "An attacker accessing physical hardware to extract data",
      "A DDoS attack on port 80",
      "A man-in-the-middle attack via ARP spoofing"
    ],
    "answer": "An attacker accessing physical hardware to extract data",
    "explanation": "PHY refers to the physical layer. A compromise here involves physical access (e.g., stealing a hard drive, plugging in a USB device), whereas software attacks occur at higher layers of the OSI model.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which strategy allows a system to continue operating even if one of its critical components fails?",
    "options": [
      "Vertical Scaling",
      "Redundancy / Fault Tolerance",
      "Denormalization",
      "Compression"
    ],
    "answer": "Redundancy / Fault Tolerance",
    "explanation": "Redundancy involves having spare components (hot or cold standbys) that take over if the primary fails. Vertical Scaling simply adds resources to a single component, creating a single point of failure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is 'Natural Prime' sharding?",
    "options": [
      "Sharding based on the primary key",
      "Sharding based on a modulo of a prime number to reduce collisions",
      "Sharding based on the timestamp",
      "Sharding based on the user's geographic location"
    ],
    "answer": "Sharding based on a modulo of a prime number to reduce collisions",
    "explanation": "Using a prime number for the modulus in sharding can help distribute data more evenly than a composite number in certain arithmetic distributions, though it is a specific numeric hashing technique.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "In a NoSQL 'Column-Family' store (like Cassandra), how is data physically stored on disk?",
    "options": [
      "As a document in JSON format",
      "As rows and columns, but sparse columns are stored efficiently together",
      "As a graph of nodes and edges",
      "As key-value pairs only"
    ],
    "answer": "As rows and columns, but sparse columns are stored efficiently together",
    "explanation": "Column-family stores map multi-dimensional data, often storing columns that are frequently accessed together on the same storage file/region, optimizing for wide rows and sparse data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which pagination method offers the best performance for large datasets but does not allow jumping to specific pages easily?",
    "options": [
      "Offset-based pagination",
      "Keyset (Cursor-based) pagination",
      "Seek method",
      "Page-based pagination"
    ],
    "answer": "Keyset (Cursor-based) pagination",
    "explanation": "Keyset pagination uses the index of the last seen item to fetch the next set, avoiding the `OFFSET` scan that makes Offset-based pagination slow on large datasets. It prevents direct page jumping (e.g., 'Page 50').",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is 'Component-Based Scalability'?",
    "options": [
      "Scaling the entire application as a single unit",
      "Scaling specific parts of the system (e.g., just the image processor) independently",
      "Using only components from a specific vendor",
      "Scaling the database but not the application servers"
    ],
    "answer": "Scaling specific parts of the system (e.g., just the image processor) independently",
    "explanation": "This granularity allows scaling based on demand for specific functions (e.g., scaling the upload service but not the profile viewing service), which is a key benefit of Microservices.",
    "difficulty": "Intermediate"
  }
]