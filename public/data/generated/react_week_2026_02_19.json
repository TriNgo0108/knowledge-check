[
  {
    "id": 1,
    "question": "In React, which term describes the algorithm used to diff one tree with another to determine which parts of the application need to be changed?",
    "options": [
      "Reconciliation",
      "Hydration",
      "Committing",
      "Scheduling"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation is the process React uses to compare the previous rendered tree with the new tree to calculate the minimal set of changes required for the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the primary reason React uses a Virtual DOM instead of manipulating the browser DOM directly for every change?",
    "options": [
      "To provide a stronger security layer against XSS attacks",
      "To improve performance by batching updates and minimizing direct DOM manipulation",
      "To automatically generate CSS styles based on component state",
      "To allow components to be written in plain HTML without JavaScript"
    ],
    "answer": "To improve performance by batching updates and minimizing direct DOM manipulation",
    "explanation": "The Virtual DOM acts as a lightweight in-memory representation. React calculates changes against it first, then updates the actual browser DOM efficiently in batches.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which syntax is required in JSX to write a JavaScript expression, such as a variable or a function call?",
    "options": [
      "Double curly braces {{ }}",
      "Single quotes ' '",
      "Curly braces { }",
      "Backticks ` `"
    ],
    "answer": "Curly braces { }",
    "explanation": "Curly braces are the syntax in JSX for embedding dynamic JavaScript expressions, variables, or functions within the markup.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In React, 'props' (properties) are used to:",
    "options": [
      "Manage internal state within a component",
      "Pass data from a parent component down to a child component",
      "Fetch data from an external API",
      "Handle user events like clicks and form submissions"
    ],
    "answer": "Pass data from a parent component down to a child component",
    "explanation": "Props are read-only inputs passed to components, enabling a unidirectional data flow from parent to child.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the correct syntax for creating a functional component in React?",
    "options": [
      "function MyComponent() { return <div />; }",
      "class MyComponent extends React.Component { render() { return <div />; } }",
      "createComponent('MyComponent', () => { return <div />; })",
      "const MyComponent = function() { render(<div />); }"
    ],
    "answer": "function MyComponent() { return <div />; }",
    "explanation": "Functional components are defined as standard JavaScript functions that accept props as an argument and return JSX.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which Hook is specifically designed to manage side effects in functional components, such as data fetching or subscriptions?",
    "options": [
      "useState",
      "useEffect",
      "useContext",
      "useReducer"
    ],
    "answer": "useEffect",
    "explanation": "useEffect is the built-in Hook for performing side effects in functional components, running after the render is committed to the screen.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What must you include in the array passed as the second argument to `useEffect` to ensure it only runs once when the component mounts?",
    "options": [
      "The state variable you are updating",
      "An empty array []",
      "The document object",
      "The prop dependencies"
    ],
    "answer": "An empty array []",
    "explanation": "Passing an empty dependency array tells React that the effect does not depend on any values from props or state, so it should only run once after the initial mount.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which HTML attribute must be renamed in JSX to avoid conflicts with JavaScript reserved keywords?",
    "options": [
      "class -> className",
      "id -> idName",
      "style -> cssStyle",
      "for -> htmlFor"
    ],
    "answer": "class -> className",
    "explanation": "Because 'class' is a reserved keyword in JavaScript, JSX uses 'className' to apply CSS classes to elements. 'for' is also changed to 'htmlFor' on labels.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What happens if you try to modify the `props` object received by a component?",
    "options": [
      "The component re-renders automatically",
      "The props are merged with the new values",
      "An error is thrown in development (if usingPropTypes) or the object is read-only (frozen)",
      "The parent component is notified of the change"
    ],
    "answer": "An error is thrown in development (if usingPropTypes) or the object is read-only (frozen)",
    "explanation": "React props are read-only. Pure functions must not modify their inputs, and mutating props breaks the one-way data flow paradigm.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which rule must be followed when using Hooks like `useState` and `useEffect`?",
    "options": [
      "They can only be called inside class components",
      "They must be called at the top level of a component, not inside loops or conditions",
      "They can only be used once per component file",
      "They must be called before the return statement of any function"
    ],
    "answer": "They must be called at the top level of a component, not inside loops or conditions",
    "explanation": "Hooks rely on call order to work correctly. Conditional rendering or loops can change the order of hooks, causing bugs.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is a 'key' prop used for when rendering a list of elements in React?",
    "options": [
      "To secure the data passed to the list items",
      "To help React identify which items have changed, been added, or been removed",
      "To act as a unique CSS selector for styling",
      "To encrypt the list data before rendering"
    ],
    "answer": "To help React identify which items have changed, been added, or been removed",
    "explanation": "Keys give elements a stable identity, allowing React to efficiently update the DOM by reconciling the list correctly.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which function is used to update the state variable when using the `useState` Hook?",
    "options": [
      "The second element returned by the useState array",
      "this.setState",
      "A direct reassignment of the variable (e.g., state = newValue)",
      "The first element returned by the useState array"
    ],
    "answer": "The second element returned by the useState array",
    "explanation": "useState returns a pair: the current state value and a function that lets you update it (e.g., const [count, setCount] = useState(0)).",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In the context of React's reconciliation process, what is an 'Update'?",
    "options": [
      "A change in the data used to render a React app (usually via setState)",
      "The process of installing a new version of the React library",
      "A mechanism to hot-reload code during development",
      "A function that converts JSX into HTML"
    ],
    "answer": "A change in the data used to render a React app (usually via setState)",
    "explanation": "An update represents a change in data that triggers React to re-render the component and reconcile the changes with the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the behavior of a React component if its render method is called but the virtual DOM has not changed?",
    "options": [
      "React will throw an error to prevent wasted cycles",
      "The component will re-render and the DOM will be updated",
      "React will contact the server to verify the state",
      "React will not touch the DOM (subtree rendering is skipped)"
    ],
    "answer": "React will not touch the DOM (subtree rendering is skipped)",
    "explanation": "If the render output is identical to the previous render, React detects no changes and does not modify the actual browser DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Why is it recommended to use an arrow function for event handlers in React components?",
    "options": [
      "Arrow functions are faster than regular functions",
      "To automatically bind 'this' to the component instance",
      "To prevent the event from bubbling up the DOM tree",
      "Regular JavaScript functions are not supported in JSX"
    ],
    "answer": "To automatically bind 'this' to the component instance",
    "explanation": "Arrow functions do not have their own 'this' context, so they inherit 'this' from the enclosing React component instance, ensuring the handler works correctly.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the purpose of the `React.StrictMode` component?",
    "options": [
      "To enforce strict typing for props",
      "To perform additional checks and warnings for potential issues in the application during development",
      "To block the application from running in production without a license",
      "To compress the bundle size for production builds"
    ],
    "answer": "To perform additional checks and warnings for potential issues in the application during development",
    "explanation": "StrictMode is a development tool that highlights potential problems in an application, such as unsafe lifecycles or legacy API usage. It does not render visible UI.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which Hook allows you to access the DOM node or React element created in the render method directly?",
    "options": [
      "useRef",
      "useEffect",
      "useContext",
      "useMemo"
    ],
    "answer": "useRef",
    "explanation": "useRef returns a mutable ref object whose .current property is initialized to the passed argument, persisting across re-renders without causing a re-render itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the concept of 'Lifting State Up' in React?",
    "options": [
      "Moving the state to a higher global variable",
      "Moving state from a child component to a common parent so multiple children can share it",
      "Deleting the state from components to make them lighter",
      "Using the 'context' API to bypass the need for props"
    ],
    "answer": "Moving state from a child component to a common parent so multiple children can share it",
    "explanation": "When several components need to reflect the same changing data, the state should be moved up to their closest common ancestor and passed down via props.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How do you apply inline styles to a React element?",
    "options": [
      "style=\"color: 'red'\"",
      "style={color: 'red'}",
      "style={{ color: 'red' }}",
      "css={{ color: 'red' }}"
    ],
    "answer": "style={{ color: 'red' }}",
    "explanation": "The style attribute accepts a JavaScript object with camelCased properties rather than a CSS string. The outer braces denote a JS expression, the inner braces denote the object.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which component lifecycle event is represented by the return function of `useEffect`?",
    "options": [
      "Component Mount",
      "Component Update",
      "Component Unmount (Cleanup)",
      "Component Error"
    ],
    "answer": "Component Unmount (Cleanup)",
    "explanation": "The function returned from useEffect runs when the component unmounts or before the effect runs again (cleanup), allowing you to reset timers or subscriptions.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the React Context API primarily used for?",
    "options": [
      "Managing complex state transitions",
      "Passing data through the component tree without having to pass props down manually at every level",
      "Styling components globally",
      "Routing between different pages"
    ],
    "answer": "Passing data through the component tree without having to pass props down manually at every level",
    "explanation": "Context provides a way to share values like themes or authenticated users between components without explicitly threading props through every level of the tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is a 'Fragment' in React?",
    "options": [
      "A broken component that needs to be fixed",
      "A way to group multiple elements without adding an extra DOM node",
      "A specific type of React class component",
      "A method to delete unnecessary DOM elements"
    ],
    "answer": "A way to group multiple elements without adding an extra DOM node",
    "explanation": "Fragments let you group a list of children without adding extra nodes to the DOM, keeping the DOM structure clean (e.g., <>...</>).",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which of the following is the correct way to receive props in a functional component?",
    "options": [
      "function MyComponent(props) { ... }",
      "function MyComponent({ props }) { ... }",
      "function MyComponent(...props) { ... }",
      "function MyComponent <Props> { ... }"
    ],
    "answer": "function MyComponent(props) { ... }",
    "explanation": "Props are passed as the first argument to the functional component. While destructuring (e.g., function MyComponent({ title })) is common, the base object is passed as 'props'.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the default behavior when a user types into an uncontrolled input field in React?",
    "options": [
      "The component's state is updated immediately",
      "The input's value is managed by the DOM itself, not React state",
      "The input value is reset to empty on every keypress",
      "An error is thrown because inputs must be controlled"
    ],
    "answer": "The input's value is managed by the DOM itself, not React state",
    "explanation": "Uncontrolled components store their state in the DOM. You query the DOM using a ref to find the current value when needed, rather than driving it via state.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which Hook is best suited for managing complex state logic involving multiple sub-values or when the next state depends on the previous one?",
    "options": [
      "useState",
      "useContext",
      "useReducer",
      "useCallback"
    ],
    "answer": "useReducer",
    "explanation": "useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the purpose of the synthetic event system in React?",
    "options": [
      "To create new types of DOM events",
      "To provide a cross-browser wrapper around the browser's native events",
      "To stop all events from firing",
      "To replace the standard DOM event listeners entirely"
    ],
    "answer": "To provide a cross-browser wrapper around the browser's native events",
    "explanation": "SyntheticEvents wrap native browser events to ensure they have consistent properties across different browsers (e.g., IE vs Chrome).",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "How does the React Fiber architecture improve application performance?",
    "options": [
      "By compiling JSX to machine code",
      "By allowing React to pause, abort, or reuse work during rendering to prioritize tasks",
      "By reducing the memory footprint of the Virtual DOM to zero",
      "By automatically converting class components to functional components"
    ],
    "answer": "By allowing React to pause, abort, or reuse work during rendering to prioritize tasks",
    "explanation": "Fiber enables 'incremental rendering', allowing React to split rendering work into chunks and prioritize updates to keep the interface responsive.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What happens if you modify the state directly (e.g., `state.count = 5`) in a functional component?",
    "options": [
      "The component re-renders with the new value",
      "The state updates, but the re-render is delayed",
      "The component will not re-render, and the change may be overwritten in the next render",
      "React creates a new state variable automatically"
    ],
    "answer": "The component will not re-render, and the change may be overwritten in the next render",
    "explanation": "Direct mutation of state does not trigger a re-render. You must use the state setter function so React can detect the change and update the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which method is used to render a React component into the DOM?",
    "options": [
      "ReactDOM.mount()",
      "ReactDOM.render()",
      "React.render()",
      "ReactDOM.insert()"
    ],
    "answer": "ReactDOM.render()",
    "explanation": "ReactDOM.render() is the legacy API (in React 17) to render a React element into the DOM in the supplied container. (React 18 uses createRoot).",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Why is the `key` prop important when using `.map()` to render lists?",
    "options": [
      "It allows CSS to target the specific list item",
      "It prevents React from reusing DOM elements incorrectly, ensuring state is preserved for the right item",
      "It automatically adds an index to every item",
      "It enables the list to be sortable via drag and drop"
    ],
    "answer": "It prevents React from reusing DOM elements incorrectly, ensuring state is preserved for the right item",
    "explanation": "Stable keys help React identify which items have changed, are added, or are removed. Without proper keys, React may mutate the wrong DOM node.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the 'children' prop in React?",
    "options": [
      "A special prop used to define nested components",
      "A prop that contains the child elements passed between the opening and closing tags of a component",
      "A prop that determines how many children a component can have",
      "A reserved prop for defining sub-components in a Class component"
    ],
    "answer": "A prop that contains the child elements passed between the opening and closing tags of a component",
    "explanation": "props.children represents the content passed between the component's tags, allowing for generic and composable wrapper components.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the main benefit of using `React.memo` for a component?",
    "options": [
      "It automatically memoizes the styles used in the component",
      "It allows the component to run faster on mobile devices",
      "It skips re-rendering the component if its props have not changed",
      "It converts the component into a pure function automatically"
    ],
    "answer": "It skips re-rendering the component if its props have not changed",
    "explanation": "React.memo is a higher-order component that memoizes the result. If props haven't changed, React skips rendering the component and reuses the last rendered result.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "In a controlled form input, what determines the value of the input?",
    "options": [
      "The user's keystrokes only",
      "The browser's internal cache",
      "The React component's state",
      "The defaultValue attribute"
    ],
    "answer": "The React component's state",
    "explanation": "In a controlled component, the form element's value is driven by React state, making the single source of truth the state rather than the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "How does React typically handle the 'class' HTML attribute?",
    "options": [
      "It ignores it completely",
      "It translates it to 'className'",
      "It translates it to 'cssClass'",
      "It keeps it as 'class' but treats it as a JavaScript object"
    ],
    "answer": "It translates it to 'className'",
    "explanation": "JSX translates 'class' to 'className' because 'class' is a reserved keyword in JavaScript. This ensures valid HTML rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the role of `useMemo` in a React application?",
    "options": [
      "To memoize the component's entire output",
      "To cache a calculated value so it is only recomputed when dependencies change",
      "To memoize event handlers for better performance",
      "To store data in the browser's local storage"
    ],
    "answer": "To cache a calculated value so it is only recomputed when dependencies change",
    "explanation": "useMemo returns a memoized value. It only recalculates the value when one of the dependencies has changed, optimizing expensive calculations.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In the context of React Hooks, why is an empty dependency array `[]` passed to the `useEffect` hook?",
    "options": [
      "It ensures the effect runs after every render cycle",
      "It causes the effect to run strictly once after the initial mount",
      "It prevents the component from re-rendering",
      "It enables the effect to access the most recent props without re-running"
    ],
    "answer": "It causes the effect to run strictly once after the initial mount",
    "explanation": "An empty dependency array signals to React that the effect does not depend on any values from props or state. Therefore, React never re-runs the effect after the initial mount.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary distinction between `useEffect` and `useLayoutEffect` regarding browser painting?",
    "options": [
      "useLayoutEffect runs synchronously after all DOM mutations but before the browser paints; useEffect runs asynchronously after paint",
      "useEffect runs synchronously before DOM mutations; useLayoutEffect runs after DOM mutations",
      "There is no difference; they are aliases for the same lifecycle method",
      "useLayoutEffect is deprecated in favor of useEffect in React 18"
    ],
    "answer": "useLayoutEffect runs synchronously after all DOM mutations but before the browser paints; useEffect runs asynchronously after paint",
    "explanation": "useLayoutEffect blocks the browser from painting until the callback completes, allowing for synchronous layout reads/writes. useEffect does not block the paint, offering better performance for non-critical visual updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the React Fiber architecture, what is the purpose of the 'double-buffering' technique involving the `current` and `workInProgress` trees?",
    "options": [
      "To store the previous and next state values for every component simultaneously",
      "To allow the UI to update incrementally by swapping the tree reference once work is complete",
      "To enable two different threads to modify the DOM at the same time",
      "To provide a backup tree in case the rendering process crashes"
    ],
    "answer": "To allow the UI to update incrementally by swapping the tree reference once work is complete",
    "explanation": "React builds the `workInProgress` tree off-screen based on the `current` tree. Once the render work is finished, it swaps the pointer, making the `workInProgress` tree the new `current` tree, ensuring a smooth transition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When using `React.memo` on a functional component, under what condition will the component re-render?",
    "options": [
      "When the component's internal state changes using setState",
      "When the parent component re-renders, regardless of props",
      "When the props passed to it have changed according to shallow comparison",
      "When the context consumed by the component changes"
    ],
    "answer": "When the props passed to it have changed according to shallow comparison",
    "explanation": "`React.memo` performs a shallow comparison of the previous and current props. The component skips re-rendering if the props have not changed, though it will still re-render if its own internal state changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the specific mechanism that allows React to interrupt a rendering task to handle a high-priority event, such as a user input?",
    "options": [
      "The Virtual DOM diffing algorithm",
      "The Fiber Scheduler and Time Slicing",
      "The Synthetic Event System",
      "The Reconciler's stack frame recursion"
    ],
    "answer": "The Fiber Scheduler and Time Slicing",
    "explanation": "React Fiber implements a scheduler that splits rendering work into units. Using time slicing, it can pause the work loop (`workLoopConcurrent`) to yield to the main thread, ensuring high-priority interactions remain responsive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Why must the `key` prop be unique among siblings in a list of React elements?",
    "options": [
      "It allows React to identify which items have changed, been added, or been removed efficiently",
      "It ensures that the elements are rendered in the correct alphabetical order",
      "It is required for the component to access its own index in the array",
      "It prevents the browser from duplicating the DOM nodes"
    ],
    "answer": "It allows React to identify which items have changed, been added, or been removed efficiently",
    "explanation": "Keys help React associate state with DOM elements. Stable keys allow React to reorder existing elements rather than destroying and recreating them, significantly improving reconciliation performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In React's reconciliation process, if a component's type changes from `<div />` to `<span />`, what action does React take?",
    "options": [
      "It attempts to patch the existing DOM node with new attributes",
      "It destroys the old node and all of its children, then builds a new tree from scratch",
      "It reuses the DOM node but changes the tag name using `replaceChild`",
      "It preserves the children but changes the parent wrapper's styling"
    ],
    "answer": "It destroys the old node and all of its children, then builds a new tree from scratch",
    "explanation": "If the element type differs, React assumes the entire tree structure is different. It tears down the old tree (including unmounting children) and builds the new tree, as reconciliation cannot occur between fundamentally different node types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the primary function of the `useReducer` hook compared to `useState`?",
    "options": [
      "useReducer automatically persists state to local storage",
      "useReducer manages component state logic that involves complex sub-values or when the next state depends on the previous one",
      "useReducer is the only way to manage arrays in state",
      "useReducer prevents the component from re-rendering when the state changes"
    ],
    "answer": "useReducer manages component state logic that involves complex sub-values or when the next state depends on the previous one",
    "explanation": "`useReducer` is preferable when state logic is complex and involves multiple sub-values or when the next state relies heavily on the previous state, using a reducer function to centralize the update logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the 'default' behavior of React when a parent component re-renders and has a child component defined as a standard functional component?",
    "options": [
      "The child component never re-renders unless its props change",
      "The child component re-renders even if its props have not changed",
      "The child component is automatically memoized by the compiler",
      "The child component throws an error to prevent wasted cycles"
    ],
    "answer": "The child component re-renders even if its props have not changed",
    "explanation": "Without memoization (like `React.memo`), a child component will re-render whenever its parent does, simply because the parent is generating a new set of JSX elements (children) to pass down.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "When implementing 'React.StrictMode' in development, why does React intentionally invoke component effects, mount, update, and unmount methods twice?",
    "options": [
      "To ensure the application runs at exactly 60 frames per second",
      "To detect unintended side effects and impure rendering logic that might break concurrent features",
      "To simulate a hot-module reload during the development phase",
      "To force the garbage collector to remove memory leaks"
    ],
    "answer": "To detect unintended side effects and impure rendering logic that might break concurrent features",
    "explanation": "StrictMode double-invokes certain functions (like the component body, reducer functions, and effect cleanup/setup) in development. This helps surface side effects that would otherwise break rendering if React were to 'undo' and 'redo' a render.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the specific behavior of `useRef` compared to creating a standard instance variable (e.g., `let count = 0`) directly in the component body?",
    "options": [
      "useRef triggers a re-render when its value is updated",
      "useRef returns the same mutable ref object on every render, persisting values across renders without triggering re-renders",
      "Instance variables in the component body are reset to their initial value on every render, unlike useRef",
      "useRef can only store DOM nodes, not other data types"
    ],
    "answer": "useRef returns the same mutable ref object on every render, persisting values across renders without triggering re-renders",
    "explanation": "Unlike local variables which reset on every render, `useRef` persists a mutable object across the entire lifecycle of the component. Changing the `.current` property does not cause a re-render.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "How does the SyntheticEvent system in React 17+ differ from previous versions regarding event pooling?",
    "options": [
      "Events are now pooled more aggressively to save memory",
      "Event pooling has been removed; events are no longer pooled and are not nullified",
      "Events are now synchronous instead of asynchronous",
      "SyntheticEvent was removed entirely in favor of native DOM events"
    ],
    "answer": "Event pooling has been removed; events are no longer pooled and are not nullified",
    "explanation": "Prior to React 17, SyntheticEvents were pooled for performance, requiring `event.persist()` to keep them. In modern React, pooling is removed, meaning events can be accessed asynchronously without calling `persist()`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the technical reason why updating the State directly (e.g., `state.count = 1`) fails to trigger a re-render in React?",
    "options": [
      "Direct mutation violates the immutability principle React relies on to detect changes via shallow comparison",
      "State variables are defined as constants using `const` and cannot be reassigned",
      "React does not watch object properties, it only watches variable assignments",
      "Direct mutation is blocked by the browser's security policy"
    ],
    "answer": "Direct mutation violates the immutability principle React relies on to detect changes via shallow comparison",
    "explanation": "React determines if a re-render is needed by checking if the state reference has changed (shallow equality). Directly mutating an object keeps the reference the same, so React assumes nothing changed and skips the render.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the purpose of the `startTransition` API introduced in React 18?",
    "options": [
      "To start the CSS transition animations for component mounting",
      "To mark specific state updates as non-urgent, allowing React to keep the interface responsive during heavy renders",
      "To transition a component from a class component to a functional component",
      "To defer the loading of JavaScript bundles until the user interacts with the page"
    ],
    "answer": "To mark specific state updates as non-urgent, allowing React to keep the interface responsive during heavy renders",
    "explanation": "`startTransition` allows React to interrupt lower-priority updates (transitions) if higher-priority user interactions (like typing) occur. This prevents UI blocking during computationally expensive state changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In the context of `useCallback`, what is the consequence of omitting a dependency from the dependency array that is used inside the callback?",
    "options": [
      "The callback will automatically memoize based on the arguments passed to it",
      "The callback will capture 'stale' values from the initial or previous render, potentially causing bugs",
      "The component will throw a runtime error immediately",
      "The callback will trigger an infinite loop"
    ],
    "answer": "The callback will capture 'stale' values from the initial or previous render, potentially causing bugs",
    "explanation": "Hooks rely on closures. If a dependency is missing, the callback function closes over the values from the specific render when it was created. Subsequent renders will not update the variables inside the callback.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What occurs when a React Component throws an error inside its `render` method, and it is wrapped in an Error Boundary component?",
    "options": [
      "The entire application crashes and displays a white screen",
      "The Error Boundary catches the error, displays a fallback UI, and the error propagates up to the window",
      "The error is ignored and the component continues to render with partial data",
      "The Error Boundary fixes the error automatically and retries the render"
    ],
    "answer": "The Error Boundary catches the error, displays a fallback UI, and the error propagates up to the window",
    "explanation": "Error boundaries catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the crashed component tree. They do not catch errors in event handlers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What does the 'Lifting State Up' pattern in React specifically refer to?",
    "options": [
      "Moving state from a class component to a functional component",
      "Merging multiple state variables into a single complex object",
      "Moving state to the closest common ancestor of components that need it to share data",
      "Storing state in a global variable outside of the React tree"
    ],
    "answer": "Moving state to the closest common ancestor of components that need it to share data",
    "explanation": "When two sibling components need access to the same data, the state should be moved up to their parent. The parent then passes the data down via props, enabling synchronization between the siblings.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the behavior of the `children` prop in React when a parent component renders its children without utilizing `{props.children}` or an outlet?",
    "options": [
      "The children are automatically rendered by the browser's DOM engine",
      "The children are ignored and nothing is rendered for them",
      "React throws a 'Missing Children' error",
      "The children are rendered into a hidden document fragment"
    ],
    "answer": "The children are ignored and nothing is rendered for them",
    "explanation": "JSX produces React elements. If a component's JSX does not explicitly include `{props.children}` (or `<Outlet />` in React Router), the child elements passed to the component are effectively discarded and not rendered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Why might you choose `useId` over generating a random ID with `Math.random()` for accessibility attributes like `htmlFor`?",
    "options": [
      "useId ensures the ID is unique across the entire internet, not just the page",
      "useId guarantees that IDs remain stable across server-side and client-side rendering (hydration)",
      "Math.random is deprecated in modern JavaScript versions",
      "useId is the only way to pass IDs into CSS-in-JS libraries"
    ],
    "answer": "useId guarantees that IDs remain stable across server-side and client-side rendering (hydration)",
    "explanation": "If the server generates a random ID and the client generates a different random ID, the hydration check will fail due to a mismatch. `useId` ensures ID consistency between the server and client environments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What does the `React.forwardRef` HOC allow a developer to do?",
    "options": [
      "Automatically forward a component's state to its parent component",
      "Pass a ref attribute through a component to one of its children",
      "Optimize performance by skipping the reconciliation phase for the component",
      "Allow a component to forward events to the window object"
    ],
    "answer": "Pass a ref attribute through a component to one of its children",
    "explanation": "By default, components cannot pass `ref` props down. `forwardRef` creates a component that exposes an inner child's DOM node or component instance to the parent component via a `ref`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In React reconciliation, if two elements have different types (e.g., `<Button />` vs `<div />`), React destroys the existing subtree. Why is this necessary?",
    "options": [
      "To simplify the logic of the React reconciler",
      "Because the previous component's state and side effects are irrelevant to the new type",
      "Because the browser requires a new DOM node for every HTML tag change",
      "To force the parent component to re-render"
    ],
    "answer": "Because the previous component's state and side effects are irrelevant to the new type",
    "explanation": "When the type changes, the structure and behavior (lifecycle, state, hooks) of the old component are inapplicable to the new one. React must unmount the old tree completely to clean up effects and reset state before mounting the new one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the primary purpose of the 'key' prop when used in a `map` function to render a list?",
    "options": [
      "To uniquely identify elements so React can update the DOM efficiently instead of destroying and recreating elements",
      "To enable CSS animations to work correctly with React Transition Group",
      "To allow the developer to access the index of the current item in the array",
      "To prevent the browser from caching the rendered HTML"
    ],
    "answer": "To uniquely identify elements so React can update the DOM efficiently instead of destroying and recreating elements",
    "explanation": "Keys help React identify which items have changed, are added, or are removed. Using stable keys allows React to reuse DOM nodes, whereas indices or unstable keys often lead to unnecessary DOM destruction and state loss.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the 'Stale Closure' problem in the context of React Hooks?",
    "options": [
      "When a component unmounts but a closure remains in memory",
      "When an event handler or effect captures old state or props from a previous render cycle",
      "When the `useEffect` hook fails to clean up its subscriptions",
      "When the browser's garbage collector fails to remove unused components"
    ],
    "answer": "When an event handler or effect captures old state or props from a previous render cycle",
    "explanation": "If a function defined in one render (closure) is accessed later (e.g., via a `setTimeout`), it will refer to the variables as they were when the function was created. Properly defining dependencies ensures the closure updates to the latest values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "How does `React.lazy` function technically compared to a standard import?",
    "options": [
      "It bundles the component code into a separate file during the build process and imports it dynamically at runtime",
      "It converts the functional component into a class component automatically",
      "It compresses the component code using gzip before sending it to the browser",
      "It allows the component to render even if the JavaScript file fails to load"
    ],
    "answer": "It bundles the component code into a separate file during the build process and imports it dynamically at runtime",
    "explanation": "`React.lazy` takes a function that invokes a dynamic `import()`. This tells webpack (or other bundlers) to split the code into a separate bundle, which is only loaded when the component is rendered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In React's synthetic event system, what is 'Event Delegation'?",
    "options": [
      "Delegating events from the child component to the parent component via props",
      "Attaching a single event listener at the root of the document to manage all child events",
      "Splitting event listeners across multiple nodes to improve concurrency",
      "Using the native browser event system instead of React's wrappers"
    ],
    "answer": "Attaching a single event listener at the root of the document to manage all child events",
    "explanation": "React does not attach event handlers to individual DOM nodes. Instead, it attaches one listener to the root (document or React root). Events bubble up, and React determines which component to invoke based on the event target.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "When using `React.PureComponent`, what comparison method is used to determine if a component should update?",
    "options": [
      "Deep comparison of props and state",
      "Shallow comparison of props and state",
      "Reference equality check of the entire component tree",
      "It checks if the `shouldComponentUpdate` method returns true"
    ],
    "answer": "Shallow comparison of props and state",
    "explanation": "`React.PureComponent` implements `shouldComponentUpdate` with a shallow comparison of both props and state. This prevents re-renders if the references of complex objects/arrays haven't changed, unlike `Component` which always re-renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the main advantage of using Portals in React?",
    "options": [
      "To render a component into a different part of the DOM tree that is outside the parent component's DOM hierarchy",
      "To transfer data between sibling components without using props",
      "To optimize the rendering performance of heavy components",
      "To create a secure tunnel for sending data to a backend server"
    ],
    "answer": "To render a component into a different part of the DOM tree that is outside the parent component's DOM hierarchy",
    "explanation": "Portals allow rendering children into a DOM node that exists outside the parent component's div. This is useful for modals, tooltips, or dropdowns that need to break out of CSS overflow or stacking contexts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "How does Automatic Batching in React 18 differ from the batching behavior in React 17?",
    "options": [
      "Batching only happened inside React event handlers previously, but now it also works for promises, setTimeout, and native events",
      "React 18 batches all updates into a single microtask regardless of priority",
      "React 18 eliminates batching to ensure updates happen immediately",
      "React 17 had automatic batching, but React 18 removed it to improve concurrency"
    ],
    "answer": "Batching only happened inside React event handlers previously, but now it also works for promises, setTimeout, and native events",
    "explanation": "Prior to React 18, updates were only batched inside React event handlers. React 18 introduces Automatic Batching (via `createRoot`), extending batching to async operations, timeouts, and native events.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the purpose of the `fallback` prop in the `<Suspense>` component?",
    "options": [
      "To define the UI shown while the nested component or data fetch is resolving (loading state)",
      "To define the error UI displayed if the child component fails to load",
      "To provide a default set of props if the parent fails to pass them",
      "To redirect the user to a different page if the rendering takes too long"
    ],
    "answer": "To define the UI shown while the nested component or data fetch is resolving (loading state)",
    "explanation": "`Suspense` wraps components that perform asynchronous operations (like code splitting with `lazy` or experimental data fetching). The `fallback` prop accepts a React element to display while the content is loading.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Why is it recommended to use the `setState` updater function (e.g., `setState(prev => prev + 1)`) when the new state depends on the old state?",
    "options": [
      "It ensures the state update is batched synchronously",
      "It prevents race conditions by ensuring the update is based on the most recent state, avoiding stale state issues",
      "It is the only way to update state in class components",
      "It automatically triggers a re-render of all child components recursively"
    ],
    "answer": "It prevents race conditions by ensuring the update is based on the most recent state, avoiding stale state issues",
    "explanation": "Because state updates may be asynchronous and batched, reading `this.state` directly can lead to stale state. The updater function receives the guaranteed previous state, ensuring correct incremental updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What happens to the cleanup function returned by `useEffect` when the component re-renders?",
    "options": [
      "The cleanup function is ignored and only runs on unmount",
      "The cleanup function from the previous effect execution runs before the next effect executes",
      "The cleanup function runs immediately after the effect executes",
      "The cleanup function is garbage collected without running"
    ],
    "answer": "The cleanup function from the previous effect execution runs before the next effect executes",
    "explanation": "Before running a new effect (and only if the dependencies changed), React cleans up the previous effect. This ensures logic from the old render is undone before logic from the new render applies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is a 'Render Prop' in React component design?",
    "options": [
      "A prop that accepts a boolean value to control visibility",
      "A function prop that a component uses to know what to render, sharing code between components using a function whose value is a React element",
      "A prop that is used specifically to pass render lifecycle methods to child components",
      "A special prop that forces the component to render on the server"
    ],
    "answer": "A function prop that a component uses to know what to render, sharing code between components using a function whose value is a React element",
    "explanation": "The render prop pattern involves a prop (usually named `render`) that is a function returning a React element. This allows a component to share logic (like state or fetching data) while delegating the rendering output to the consumer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the specific role of the `reconciler` (specifically the stack reconciler or fiber reconciler) vs the `renderer`?",
    "options": [
      "The reconciler calculates which parts of the tree have changed; the renderer takes that information and updates the UI (DOM, iOS, etc.)",
      "The renderer decides which components to mount; the reconciler draws them to the screen",
      "The reconciler handles network requests; the renderer handles state",
      "They are two names for the exact same process"
    ],
    "answer": "The reconciler calculates which parts of the tree have changed; the renderer takes that information and updates the UI (DOM, iOS, etc.)",
    "explanation": "React is designed to be renderer-agnostic. The reconciler (Fiber) is the core logic that determines changes (diffing), while the renderer (React-DOM, React-Native) applies those changes to the specific platform.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "When using `useContext`, what happens when the context value changes?",
    "options": [
      "Only the component consuming the context re-renders, ignoring memoization",
      "All components consuming that context will re-render, regardless of whether they are memoized with `React.memo`",
      "The re-render is blocked unless the component's props also change",
      "The context provider must be manually destroyed and recreated"
    ],
    "answer": "All components consuming that context will re-render, regardless of whether they are memoized with `React.memo`",
    "explanation": "Context consumers force a re-render whenever the Provider's value object changes. `React.memo` is ineffective because the context bypasses props comparison, effectively triggering updates on all consumers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of React Fiber architecture, what is the primary purpose of the 'alternate' property on a fiber node?",
    "options": [
      "To store the previous props and state for comparison during the 'commit' phase",
      "To point to the corresponding node in the 'workInProgress' tree (double buffering)",
      "To maintain a linked list of sibling components for efficient traversal",
      "To store the return value of the component's render method for memoization"
    ],
    "answer": "To point to the corresponding node in the 'workInProgress' tree (double buffering)",
    "explanation": "The 'alternate' property creates a double-buffering system, linking nodes in the 'current' tree with their counterparts in the 'workInProgress' tree to facilitate swapping trees without blocking rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "How does React's reconciliation algorithm handle functional components versus class components during the 'beginWork' phase?",
    "options": [
      "Class components are ignored, while functional components trigger a re-render of the entire subtree",
      "Functional components are processed by calling 'render', while class components invoke 'getDerivedStateFromProps'",
      "Class components instantiate a class, while functional components simply invoke the function to update the 'workInProgress' node",
      "Both are treated identically by the reconciler to ensure zero-cost abstractions"
    ],
    "answer": "Class components instantiate a class, while functional components simply invoke the function to update the 'workInProgress' node",
    "explanation": "During 'beginWork', React processes the fiber based on its tag: class components involve lifecycle methods and instantiation, whereas functional components strictly involve executing the function logic against the current fiber.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What specific condition triggers React to bail out of rendering a subtree early in a functional component using `React.memo`?",
    "options": [
      "When the component's state has not changed since the last render",
      "When the new props are shallowly equal to the previous props",
      "When the component returns `null` instead of a JSX element",
      "When the parent component is a class component with `shouldComponentUpdate` returning false"
    ],
    "answer": "When the new props are shallowly equal to the previous props",
    "explanation": "`React.memo` performs a shallow comparison of the previous and current props. If they are equal, React skips re-rendering that component and its descendants, reusing the previously generated fiber node.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In React's 'render' phase, what happens during the 'completeUnitOfWork' stage?",
    "options": [
      "It creates the DOM nodes for the application and appends them to the document body",
      "It processes the return value of the component, creates sibling fibers, and constructs the side-effects list",
      "It calculates the new state by applying the reducer to the current state and action",
      "It determines if concurrent mode allows yielding to the main thread based on expiration times"
    ],
    "answer": "It processes the return value of the component, creates sibling fibers, and constructs the side-effects list",
    "explanation": "After 'beginWork' traverses down, 'completeUnitOfWork' bubbles back up. It handles the resulting React element (sibling/child creation), merges effect lists, and finalizes the fiber node.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which of the following best describes the function of `workLoopConcurrent` compared to `workLoopSync` in the React scheduler?",
    "options": [
      "`workLoopSync` processes fibers asynchronously, while `workLoopConcurrent` processes them synchronously",
      "`workLoopConcurrent` checks `shouldYield` to allow the browser to handle high-priority tasks, whereas `workLoopSync` does not",
      "`workLoopSync` supports 'time-slicing', while `workLoopConcurrent` blocks the main thread until completion",
      "`workLoopConcurrent` is used for class components only, while `workLoopSync` is reserved for functional components"
    ],
    "answer": "`workLoopConcurrent` checks `shouldYield` to allow the browser to handle high-priority tasks, whereas `workLoopSync` does not",
    "explanation": "Concurrent mode allows interruptible rendering. `workLoopConcurrent` calls `shouldYield` (checking if the frame's time budget is exceeded), while `workLoopSync` runs to completion without yielding.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the role of the `lane` model introduced in React 17/18 for updates?",
    "options": [
      "To enforce strict ordering of network requests in Server-Side Rendering",
      "To represent the priority and concurrency of updates using bitmasks for granular scheduling",
      "To group fibers into 'lanes' based on their component hierarchy (parent/child)",
      "To prevent memory leaks in legacy event listeners by tracking which DOM nodes are active"
    ],
    "answer": "To represent the priority and concurrency of updates using bitmasks for granular scheduling",
    "explanation": "Lanes replace the older expiration time model. They use bitmasks to define update priority, allowing React to schedule, merge, or abort updates (e.g., low-priority transitions vs. high-priority typing) efficiently.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Why does React 17+ attach event listeners to the `root` DOM node instead of individual document nodes?",
    "options": [
      "To reduce the memory footprint by eliminating the need for event delegation",
      "To allow multiple React roots to co-exist safely without interfering with each other's event bubbling",
      "To enable the use of the `capture` phase exclusively, ignoring the `bubble` phase",
      "To strictly support Server-Side Rendering (SSR) without requiring client-side hydration"
    ],
    "answer": "To allow multiple React roots to co-exist safely without interfering with each other's event bubbling",
    "explanation": "Attaching to the root enables 'event bubbling' to work correctly within a subtree without global interference, allowing incremental adoption of React and safer integration with non-React code.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of React Suspense and Data Fetching, what behavior defines a 'Suspense Boundary' during the render phase?",
    "options": [
      "It catches JavaScript errors in child components and displays a fallback UI",
      "It detects if a component threw a Promise and suspends rendering, showing the fallback UI until the Promise resolves",
      "It prevents the parent component from re-rendering if a child component's state changes",
      "It acts as a barrier to stop the propagation of context updates to specific child branches"
    ],
    "answer": "It detects if a component threw a Promise and suspends rendering, showing the fallback UI until the Promise resolves",
    "explanation": "Suspense works by intercepting a thrown Promise (representing pending data). When caught, React commits the fallback content and retries rendering the suspended content once the promise resolves.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "When using `useTransition`, how does React prioritize the state update marked as a 'transition'?",
    "options": [
      "It is prioritized higher than user input events to ensure immediate UI feedback",
      "It is treated as non-urgent, allowing React to interrupt it for more urgent updates like typing or clicking",
      "It is executed immediately but does not trigger a re-render of child components",
      "It is deferred until the browser enters an idle state, similar to `requestIdleCallback`"
    ],
    "answer": "It is treated as non-urgent, allowing React to interrupt it for more urgent updates like typing or clicking",
    "explanation": "Transitions mark updates as low-priority. If a high-priority update (like an input keystroke) comes in, React will pause the transition work, handle the input, and then resume the transition work.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What specific mechanism allows `useEffect` to run after the browser paint, whereas `useLayoutEffect` runs before?",
    "options": [
      "`useEffect` uses the 'passive' flag in the fiber effect node, deferring execution to the next tick",
      "`useEffect` is a macro-task while `useLayoutEffect` is a micro-task within the event loop",
      "`useEffect` runs synchronously during the commit phase but relies on `setTimeout` for delays",
      "`useLayoutEffect` blocks the main thread, preventing the browser from calculating the layout"
    ],
    "answer": "`useEffect` uses the 'passive' flag in the fiber effect node, deferring execution to the next tick",
    "explanation": "Both are scheduled during the commit phase, but effects with the 'Passive' flag (useEffect) are dispatched asynchronously after paint, while Layout flags (useLayoutEffect) execute synchronously before paint.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which React hook is specifically optimized to read a value from the context and subscribe only to updates for that specific value, preventing unnecessary re-renders?",
    "options": [
      "`useContext`",
      "`useSelector`",
      "`useReducer`",
      "`useSyncExternalStore`"
    ],
    "answer": "`useSyncExternalStore`",
    "explanation": "While `useContext` triggers re-renders on any context change, `useSyncExternalStore` is designed to expose external store state changes selectively and align with concurrent rendering features.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What happens when a component throws an error during the 'render' phase but is not wrapped in an Error Boundary?",
    "options": [
      "The error is caught by the global error handler and the component retries rendering",
      "The entire React tree is unmounted, leaving the user with a blank screen",
      "The error is ignored, and the previous rendered state remains visible",
      "The component is paused and re-rendered when the next props are received"
    ],
    "answer": "The entire React tree is unmounted, leaving the user with a blank screen",
    "explanation": "Without an Error Boundary component (which uses `componentDidCatch` or `static getDerivedStateFromError`), errors during rendering bubble up to the root, causing React to unmount the whole root node.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In React's reconciliation algorithm, how are React elements with differing `type` attributes treated?",
    "options": [
      "React attempts to patch the existing DOM element to match the new type",
      "React reuses the existing fiber node and simply updates the props",
      "React destroys the old fiber node and its children, building a new tree from scratch",
      "React moves the old DOM element to a hidden document fragment for potential restoration"
    ],
    "answer": "React destroys the old fiber node and its children, building a new tree from scratch",
    "explanation": "If the element type changes (e.g., from `<div>` to `<span>`), React assumes the structure is fundamentally different. It tears down the old DOM nodes/fibers and constructs new ones.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the purpose of the `key` prop when rendering a list of elements?",
    "options": [
      "To provide a unique ID for CSS selectors to style individual list items",
      "To allow React to identify which items have changed, been added, or been removed, preserving state and DOM nodes",
      "To encrypt the list data so that it cannot be accessed via the browser's console",
      "To force React to re-render the list items synchronously, ignoring concurrent mode"
    ],
    "answer": "To allow React to identify which items have changed, been added, or been removed, preserving state and DOM nodes",
    "explanation": "Keys help React match elements in the previous tree with elements in the next tree. Stable keys allow React to reuse DOM nodes and state, preventing unnecessary destruction and re-creation.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "Why must the `useState` updater function be considered 'impure' regarding rendering?",
    "options": [
      "It triggers a synchronous re-render of the entire application immediately upon call",
      "It can be called multiple times within a single render pass, batching updates for efficiency",
      "It modifies the state variable directly, bypassing the virtual DOM",
      "It performs network requests automatically whenever the state is updated"
    ],
    "answer": "It can be called multiple times within a single render pass, batching updates for efficiency",
    "explanation": "State updates are queued. React may batch multiple `setState` calls or process them asynchronously. The state is not updated immediately (synchronously), so relying on it for logic immediately after setting it leads to bugs.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the primary technical distinction between `useRef` and a standard instance variable (like `this.variable = ...`) in class components?",
    "options": [
      "`useRef` values are reset on every re-render, whereas instance variables persist",
      "`useRef` creates a mutable object that persists for the full lifetime of the component without triggering re-renders",
      "Instance variables trigger a re-render when changed, while `useRef` does not",
      "`useRef` is only accessible within the render function, not in event handlers"
    ],
    "answer": "`useRef` creates a mutable object that persists for the full lifetime of the component without triggering re-renders",
    "explanation": "Unlike state, changing a ref's `.current` property does not trigger a re-render. It behaves like a class instance variable but is specifically designed for the Functional Component lifecycle and Hooks rules.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "How does `React.StrictMode` help developers prepare for Concurrent Mode?",
    "options": [
      "It automatically converts synchronous rendering to concurrent rendering at runtime",
      "It double-invokes certain functions (like render, constructor, and state update functions) to detect impure side-effects",
      "It enforces the usage of `useMemo` and `useCallback` for all function props",
      "It disables all logging to the console to improve runtime performance"
    ],
    "answer": "It double-invokes certain functions (like render, constructor, and state update functions) to detect impure side-effects",
    "explanation": "By intentionally invoking functions twice (e.g., `setState` updaters), Strict Mode highlights unexpected side-effects that might break rendering if an update is interrupted and restarted.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is 'reconciliation' in the context of React's architecture?",
    "options": [
      "The process of committing changes to the DOM",
      "The process of converting JSX into vanilla JavaScript functions",
      "The algorithm React uses to diff one tree with another to determine which parts need to be changed",
      "The optimization technique used by the browser to reduce paint times"
    ],
    "answer": "The algorithm React uses to diff one tree with another to determine which parts need to be changed",
    "explanation": "Reconciliation is the 'render' phase algorithm where React compares the new element tree with the previous fiber tree to create a list of changes (effects) to apply to the DOM.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "When using `ReactDOM.flushSync` (or the deprecated unstable_flushSync), what behavior is forced upon the React renderer?",
    "options": [
      "It forces the browser to repaint the screen immediately before any JavaScript execution continues",
      "It forces React to execute the callback synchronously and flush any pending updates/effects immediately",
      "It disables concurrent mode for the entire application for the duration of the session",
      "It clears all existing state and resets the component tree to its initial mount state"
    ],
    "answer": "It forces React to execute the callback synchronously and flush any pending updates/effects immediately",
    "explanation": "This API is used to force a synchronous update outside of the normal prioritized schedule, typically needed to ensure DOM mutations happen immediately for external logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "In the Fiber architecture, what represents the 'output' of the 'commit' phase?",
    "options": [
      "A new list of virtual DOM elements to be compared in the next frame",
      "A list of side-effects (mutations, ref updates) to be applied to the host environment",
      "A serialized JSON string representing the current UI state",
      "A Promise that resolves once all network requests are finished"
    ],
    "answer": "A list of side-effects (mutations, ref updates) to be applied to the host environment",
    "explanation": "The commit phase takes the finished 'workInProgress' tree and applies the calculated changes (insertions, updates, deletions) to the DOM. It runs synchronously and cannot be interrupted.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "Which scheduler priority level is typically associated with user interactions like clicks or key presses?",
    "options": [
      "Immediate Priority",
      "User Blocking Priority",
      "Normal Priority",
      "Low Priority"
    ],
    "answer": "Immediate Priority",
    "explanation": "Direct user interactions require immediate feedback to feel responsive. React assigns these high priority (Lane 1) to ensure they are not delayed by lower priority tasks like data fetching or rendering off-screen content.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "How does the `Profiler` component measure performance, and what unit does it typically report?",
    "options": [
      "It measures the time taken for network requests to complete in milliseconds",
      "It measures the time spent rendering a component and its descendants using the Performance API",
      "It counts the number of times a component re-renders during a user session",
      "It calculates the heap memory size of the component's virtual DOM tree"
    ],
    "answer": "It measures the time spent rendering a component and its descendants using the Performance API",
    "explanation": "The Profiler API uses `performance.now()` to record timestamps when a component renders, allowing developers to identify expensive renders in terms of actual wall-clock time.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the consequence of mutating `state` directly in a React component?",
    "options": [
      "The component re-renders immediately with the new value",
      "The re-render will be skipped entirely because React assumes the props haven't changed",
      "It bypasses React's lifecycle hooks, preventing `shouldComponentUpdate` and re-renders",
      "It causes a runtime error that immediately crashes the React app"
    ],
    "answer": "It bypasses React's lifecycle hooks, preventing `shouldComponentUpdate` and re-renders",
    "explanation": "Direct mutation (`state.value = 1`) modifies the object in memory. React relies on object reference checks for state changes; since the reference remains the same, React assumes no update occurred.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What distinguishes a 'Controlled Component' from an 'Uncontrolled Component' in React?",
    "options": [
      "Controlled components are class components, while uncontrolled components are functional components",
      "Controlled components derive their input value from React state, while uncontrolled components manage their own internal state",
      "Controlled components cannot be used with refs, while uncontrolled components require refs",
      "Controlled components are automatically validated by React, whereas uncontrolled components are not"
    ],
    "answer": "Controlled components derive their input value from React state, while uncontrolled components manage their own internal state",
    "explanation": "In a controlled component, React is the 'single source of truth' for the input value. In an uncontrolled component, the DOM node itself maintains the state, accessed via refs.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the primary purpose of `ReactDOM.createPortal` in the reconciliation process?",
    "options": [
      "To enable data pre-fetching for components that are not yet mounted",
      "To render a child component into a different DOM node while preserving its position in the React tree hierarchy",
      "To create a wormhole that allows server-side rendered components to merge with client-side state",
      "To bypass the Strict Mode checks for legacy components"
    ],
    "answer": "To render a child component into a different DOM node while preserving its position in the React tree hierarchy",
    "explanation": "Portals break out of the physical DOM containment (e.g., rendering a modal to `document.body`) but remain logically children of the parent React component, ensuring event bubbling works as expected.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Why is it recommended to pass a function to `setState` (e.g., `setState(prev => prev + 1)`) rather than an object?",
    "options": [
      "Using a function forces the update to be synchronous instead of asynchronous",
      "It prevents race conditions when multiple updates are batched based on the same previous state",
      "Function updates are stored in memory more efficiently than object updates",
      "It automatically triggers a re-render of all child components"
    ],
    "answer": "It prevents race conditions when multiple updates are batched based on the same previous state",
    "explanation": "When updates are batched, object updates might rely on stale state. The functional form receives the guaranteed current state at the time the update is applied, ensuring accuracy.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the definition of 'Hydration' in React Server-Side Rendering (SSR)?",
    "options": [
      "The process of generating HTML on the server and sending it to the client",
      "The client-side process where React 'reuses' the existing server-generated HTML DOM and attaches event listeners",
      "The process of converting JSX into HTML strings before sending them to the browser",
      "A technique to compress the HTML payload using GZIP before transmission"
    ],
    "answer": "The client-side process where React 'reuses' the existing server-generated HTML DOM and attaches event listeners",
    "explanation": "Hydration bridges the server HTML and the client React app. React traverses the existing DOM nodes, attaches listeners, and takes over from the static HTML, without re-rendering the nodes if they match.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "How does `getDerivedStateFromProps` differ from `componentWillReceiveProps` (legacy)?",
    "options": [
      "`getDerivedStateFromProps` is called after every render, while `componentWillReceiveProps` is only called on mount",
      "`getDerivedStateFromProps` is static and has no access to `this`, preventing side-effects",
      "`getDerivedStateFromProps` is purely for calculating state from props, whereas `componentWillReceiveProps` was for side-effects",
      "Both B and C are correct"
    ],
    "answer": "Both B and C are correct",
    "explanation": "The lifecycle method was changed to be static (no `this` context) to ensure pure calculation of state from props and to prevent unsafe side-effect practices common in the legacy `componentWillReceiveProps`.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the 'shallow comparison' used in `PureComponent` and `React.memo`?",
    "options": [
      "A deep recursive comparison of all properties and nested objects",
      "A reference check ( `prev === next` and `Object.is()` for primitive values)",
      "A string comparison of the JSON.stringify output of the props object",
      "A comparison of the component's DOM tree structure"
    ],
    "answer": "A reference check ( `prev === next` and `Object.is()` for primitive values)",
    "explanation": "Shallow comparison checks only the top-level references. If the object reference hasn't changed, React assumes the data hasn't changed, even if nested properties inside the object have mutated.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Which execution context guarantees that the DOM has been fully updated before the code runs?",
    "options": [
      "Inside the render function of a component",
      "Inside the callback passed to useEffect",
      "Inside the callback passed to useLayoutEffect",
      "Inside the event handler callback"
    ],
    "answer": "Inside the callback passed to useLayoutEffect",
    "explanation": "`useLayoutEffect` fires synchronously after all DOM mutations but before the browser has painted the changes to the screen, making it the correct place to read layout synchronously.",
    "difficulty": "Advanced"
  }
]