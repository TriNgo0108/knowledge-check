[
  {
    "id": 1,
    "question": "What is the primary function of the Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "To allow multiple threads to execute Python bytecode simultaneously on multi-core CPUs",
      "To prevent multiple threads from executing Python bytecode at the same time",
      "To manage automatic memory deallocation via reference counting",
      "To compile Python code into machine code for faster execution"
    ],
    "answer": "To prevent multiple threads from executing Python bytecode at the same time",
    "explanation": "The GIL is a mutex that ensures only one thread holds the control of the Python interpreter, preventing concurrent execution of bytecode. This simplifies memory management but limits CPU-bound parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which of the following correctly describes Python's primary memory management strategy?",
    "options": [
      "Mark-and-sweep garbage collection exclusively",
      "Manual memory management using malloc and free",
      "Reference counting with a cyclic garbage collector as a backup",
      "Copy-on-write semantics for all variable assignments"
    ],
    "answer": "Reference counting with a cyclic garbage collector as a backup",
    "explanation": "CPython primarily uses reference counting, where memory is freed immediately when an object's reference count reaches zero. The cyclic garbage collector handles reference cycles that reference counting cannot resolve.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the result of the following code: `print(True + True + False)`?",
    "options": [
      "True",
      "2",
      "1",
      "TypeError"
    ],
    "answer": "2",
    "explanation": "In Python, `bool` is a subclass of `int`, where `True` equals 1 and `False` equals 0. The expression evaluates to an integer sum of 2.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which data type is immutable?",
    "options": [
      "List",
      "Dictionary",
      "Set",
      "Tuple"
    ],
    "answer": "Tuple",
    "explanation": "Tuples cannot be modified after creation (no item assignment or deletion). Lists, dictionaries, and sets are mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the output of `type([1, 2]) == type(list)`?",
    "options": [
      "True",
      "False",
      "TypeError",
      "SyntaxError"
    ],
    "answer": "False",
    "explanation": "`type([1, 2])` returns `<class 'list'>`, while `type(list)` returns `<class 'type'>`. `list` is the class (type) itself, not an instance of a list.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which operator checks for identity rather than equality?",
    "options": [
      "==",
      "=",
      "is",
      "eq"
    ],
    "answer": "is",
    "explanation": "The `is` operator checks if two variables point to the exact same object in memory. The `==` operator checks if the values held by the objects are equal.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What happens when you try to access a key in a dictionary that does not exist?",
    "options": [
      "It returns None",
      "It raises a KeyError",
      "It returns False",
      "It raises an IndexError"
    ],
    "answer": "It raises a KeyError",
    "explanation": "Direct access via `d[key]` raises a `KeyError` if the key is missing. Use the `.get()` method to return `None` or a default value if the key is missing.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which statement regarding variable scope is correct?",
    "options": [
      "Variables defined inside a function are global by default",
      "Variables defined outside all functions are local",
      "A variable defined inside a function cannot be accessed outside that function",
      "The `global` keyword is required to read a global variable inside a function"
    ],
    "answer": "A variable defined inside a function cannot be accessed outside that function",
    "explanation": "Variables defined inside a function have local scope. They are not accessible outside the function unless explicitly returned, though global variables can be read inside functions without the `global` keyword (only modification requires it).",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the result of `list(range(3, 0, -1))`?",
    "options": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[3, 2]",
      "[]"
    ],
    "answer": "[3, 2, 1]",
    "explanation": "The `range` function starts at 3 (inclusive), stops at 0 (exclusive), with a step of -1. This generates the sequence 3, 2, 1.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which keyword is used to define a generator function?",
    "options": [
      "yield",
      "return",
      "async",
      "next"
    ],
    "answer": "yield",
    "explanation": "Using `yield` inside a function transforms it into a generator function that returns an iterator. The function state is paused and resumed between yields.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "How do you create a shallow copy of a list `my_list`?",
    "options": [
      "list2 = my_list",
      "list2 = my_list.copy()",
      "list2 = copy(my_list)",
      "list2 = clone(my_list)"
    ],
    "answer": "list2 = my_list.copy()",
    "explanation": "The `.copy()` method (or slicing `my_list[:]`) creates a new list with the same elements. Simple assignment (`list2 = my_list`) creates a reference to the same object.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the correct syntax for a lambda function that adds two arguments?",
    "options": [
      "def add(x, y): return x + y",
      "lambda x, y: x + y",
      "lambda (x, y): return x + y",
      "lambda x, y = x + y"
    ],
    "answer": "lambda x, y: x + y",
    "explanation": "Lambda functions use the syntax `lambda arguments: expression`. They cannot contain statements or multiple expressions and implicitly return the result of the expression.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What does the `__init__` method do in a class?",
    "options": [
      "Initializes the class instance attributes",
      "Creates a new instance of the object",
      "Destroys the object and frees memory",
      "Defines the string representation of the object"
    ],
    "answer": "Initializes the class instance attributes",
    "explanation": "`__init__` is a constructor that runs immediately after the object is created (`__new__`) to set up its initial state. It does not create the instance itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which of the following represents a valid dictionary key?",
    "options": [
      "A list",
      "Another dictionary",
      "A tuple containing a list",
      "A tuple containing integers"
    ],
    "answer": "A tuple containing integers",
    "explanation": "Dictionary keys must be hashable (immutable). Tuples are hashable only if all their elements are hashable, whereas lists and dictionaries are mutable and unhashable.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the output of `'hello' * 3`?",
    "options": [
      "'hellohellohello'",
      "'hello3'",
      "TypeError",
      "ValueError"
    ],
    "answer": "'hellohellohello'",
    "explanation": "Multiplying a sequence (like a string or list) by an integer `n` concatenates `n` copies of that sequence.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which module is used to interact with the operating system, such as file path manipulation?",
    "options": [
      "sys",
      "os",
      "platform",
      "pathlib"
    ],
    "answer": "os",
    "explanation": "The `os` module provides a portable way of using operating system dependent functionality, including file and directory operations. While `pathlib` handles paths, `os` is the standard module for broader OS interaction.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What happens if you iterate over a dictionary using `for key in my_dict:`?",
    "options": [
      "It iterates over the keys of the dictionary",
      "It iterates over the values of the dictionary",
      "It iterates over (key, value) tuples",
      "It raises a TypeError"
    ],
    "answer": "It iterates over the keys of the dictionary",
    "explanation": "Iterating directly over a dictionary yields its keys. To get values or items, you must explicitly use `.values()` or `.items()`.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which statement regarding the `with` statement is correct?",
    "options": [
      "It is used for exception handling only",
      "It automatically closes resources like files after the block",
      "It creates a new scope for all variables defined inside it",
      "It is syntactic sugar for a `while` loop"
    ],
    "answer": "It automatically closes resources like files after the block",
    "explanation": "The `with` statement creates a context manager that guarantees resource cleanup (like closing a file) is performed, even if an exception occurs within the block.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the result of `bool([])`?",
    "options": [
      "True",
      "False",
      "None",
      "[]"
    ],
    "answer": "False",
    "explanation": "Empty sequences (lists, tuples, strings) and collections (dicts, sets) evaluate to `False` in a boolean context. Non-empty containers evaluate to `True`.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How do you enforce type hints in Python 3?",
    "options": [
      "Use the `enforce` decorator",
      "Python automatically checks types at runtime based on hints",
      "Type hints are purely informational and ignored by the interpreter",
      "Use the `check_types()` function"
    ],
    "answer": "Type hints are purely informational and ignored by the interpreter",
    "explanation": "Python does not enforce type hints at runtime; they are annotations for static analysis tools (like mypy) and do not affect execution. Third-party tools are required for runtime enforcement.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the behavior of the `pass` statement?",
    "options": [
      "It skips the next iteration of a loop",
      "It acts as a placeholder and does nothing",
      "It exits the current function or loop",
      "It raises a NotImplementedError"
    ],
    "answer": "It acts as a placeholder and does nothing",
    "explanation": "`pass` is a null operation used when a statement is syntactically required but no code needs to execute. It differs from `continue` (loops) or `return` (functions).",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What does `*args` in a function definition signify?",
    "options": [
      "It accepts a single list argument",
      "It accepts a variable number of keyword arguments",
      "It accepts a variable number of positional arguments",
      "It is a syntax error"
    ],
    "answer": "It accepts a variable number of positional arguments",
    "explanation": "The `*args` syntax collects any number of extra positional arguments into a tuple. `**kwargs` is used for keyword arguments.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which function is used to obtain the memory address of an object?",
    "options": [
      "memory()",
      "id()",
      "ref()",
      "address()"
    ],
    "answer": "id()",
    "explanation": "The built-in `id()` function returns the identity (integer memory address) of an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the result of `set([1, 1, 2, 2, 3])`?",
    "options": [
      "[1, 1, 2, 2, 3]",
      "{1, 2, 3}",
      "{1, 2, 2, 3, 1}",
      "{1: 1, 2: 2, 3: 3}"
    ],
    "answer": "{1, 2, 3}",
    "explanation": "Sets are unordered collections of unique elements. Duplicates are automatically removed when the set is created.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the difference between `==` and `is` for two integers `a = 1000` and `b = 1000`?",
    "options": [
      "`==` checks if they are the same object, `is` checks value",
      "`is` checks if they are the same object, `==` checks value",
      "They are functionally identical for integers",
      "`is` works only for immutable types"
    ],
    "answer": "`is` checks if they are the same object, `==` checks value",
    "explanation": "`is` compares object identity (memory location), while `==` compares value equality. Due to interning, small integers may be identical, but `1000` typically creates distinct objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which method is called when an object is printed (converted to a string)?",
    "options": [
      "__str__",
      "__repr__",
      "__print__",
      "__format__"
    ],
    "answer": "__str__",
    "explanation": "`__str__` returns a user-friendly string representation. If not found, Python falls back to `__repr__`, but `__str__` is the target for `print()` and `str()`.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the result of `[1, 2, 3].extend([4])`?",
    "options": [
      "[1, 2, 3, [4]]",
      "[1, 2, 3, 4]",
      "None",
      "True"
    ],
    "answer": "None",
    "explanation": "The `extend()` method modifies the list in-place and returns `None`. Assigning the result of `extend()` to a variable is a common mistake.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the behavior of the `else` block in a `try...except` structure?",
    "options": [
      "It executes if an exception occurs",
      "It executes if no exception occurs in the `try` block",
      "It executes regardless of whether an exception occurred",
      "It executes only if the `finally` block fails"
    ],
    "answer": "It executes if no exception occurs in the `try` block",
    "explanation": "The `else` block runs only when the `try` block completes successfully without raising an exception. It is useful for code that should not run if an error handler is triggered.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which type of inheritance creates a \"diamond\" shape in the class hierarchy?",
    "options": [
      "Single inheritance",
      "Multiple inheritance",
      "Multilevel inheritance",
      "Hierarchical inheritance"
    ],
    "answer": "Multiple inheritance",
    "explanation": "Multiple inheritance occurs when a class inherits from more than one base class. If the base classes share a common ancestor, it forms a diamond structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the output of `print(list('abc'))`?",
    "options": [
      "['abc']",
      "['a', 'b', 'c']",
      "('a', 'b', 'c')",
      "Error"
    ],
    "answer": "['a', 'b', 'c']",
    "explanation": "The `list()` constructor takes an iterable and splits it into individual items. Passing a string converts it into a list of characters.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which built-in function sorts a list in-place?",
    "options": [
      "sorted()",
      "sort()",
      "order()",
      "arrange()"
    ],
    "answer": "sort()",
    "explanation": "`list.sort()` modifies the list in-place and returns `None`. `sorted()` creates and returns a new sorted list, leaving the original unchanged.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the default return value of a function that executes a return statement without an expression?",
    "options": [
      "0",
      "True",
      "None",
      "null"
    ],
    "answer": "None",
    "explanation": "If the `return` keyword is used without a value (or if the function ends without hitting a return), the function returns `None`.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "How does Python handle integer division compared to float division?",
    "options": [
      "`/` performs integer division, `//` performs float division",
      "`//` performs floor (integer) division, `/` performs true (float) division",
      "Both perform the same operation",
      "`//` rounds up, `/` rounds down"
    ],
    "answer": "`//` performs floor (integer) division, `/` performs true (float) division",
    "explanation": "The single slash `/` always returns a float. The double slash `//` performs floor division, rounding down to the nearest integer.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of the `__name__` variable in a Python script?",
    "options": [
      "It stores the name of the current user",
      "It indicates if the script is being run directly or imported",
      "It holds the filename of the script",
      "It defines the class name"
    ],
    "answer": "It indicates if the script is being run directly or imported",
    "explanation": "When a script is executed directly, `__name__` is set to `'__main__'`. If imported, it is set to the module's name.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which character represents a single-line comment in Python?",
    "options": [
      "//",
      "#",
      "/*",
      "--"
    ],
    "answer": "#",
    "explanation": "Python uses the hash (`#`) symbol for single-line comments. Everything following `#` on that line is ignored by the interpreter.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "How does CPython's Global Interpreter Lock (GIL) specifically impact CPU-bound tasks in a multi-threaded Python application?",
    "options": [
      "It prevents race conditions by allowing multiple threads to access Python objects simultaneously.",
      "It serializes thread execution, limiting the process to a single CPU core regardless of core count.",
      "It causes memory leaks by preventing the garbage collector from accessing shared memory.",
      "It improves performance by releasing the lock during every bytecode instruction."
    ],
    "answer": "It serializes thread execution, limiting the process to a single CPU core regardless of core count.",
    "explanation": "The GIL is a mutex that prevents multiple native threads from executing Python bytecodes at once. This effectively limits CPU-bound threads to a single core, negating parallelism. Options A and D incorrectly describe the locking behavior, while C describes a phenomenon not caused by the GIL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Why does Python require a separate Garbage Collector (GC) module in addition to reference counting for memory management?",
    "options": [
      "Reference counting is too slow for reallocate memory in the heap.",
      "Reference counting cannot handle reference cycles (circular references) where objects reference each other.",
      "The GC is responsible for deallocating stack memory, while reference counting handles heap memory.",
      "Reference counting fails when the system RAM is full."
    ],
    "answer": "Reference counting cannot handle reference cycles (circular references) where objects reference each other.",
    "explanation": "Reference counting fails to reclaim memory if a group of objects reference one another (creating a cycle) but have no external references. The GC specifically detects and breaks these cycles. Option A is incorrect because ref counting is fast; Option C is incorrect because both manage heap memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the context of the 'free-threading' (NOGIL) builds discussed for Python 3.13+, what is 'Biased Reference Counting' designed to address?",
    "options": [
      "Reducing the memory footprint of integers by using fewer bits.",
      "Eliminating the need for a mark-and-sweep garbage collector entirely.",
      "Mitigating race conditions when multiple threads modify an object's reference count without a global lock.",
      "Forcing all threads to run on a single CPU to ensure data consistency."
    ],
    "answer": "Mitigating race conditions when multiple threads modify an object's reference count without a global lock.",
    "explanation": "Without the GIL, standard reference counting is prone to race conditions. Biased reference counting optimizes updates by assuming a 'owning' thread, reducing the need for expensive atomic operations or locks on every update. Option A is unrelated; Option B is false as GC is still needed for cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the primary mechanism by which the CPython Garbage Collector identifies objects involved in circular references?",
    "options": [
      "It monitors the system's available RAM and triggers when usage exceeds 80%.",
      "It utilizes a 'generational' hypothesis, scanning only objects created in the last 10 milliseconds.",
      "It maintains a container list and uses a 'mark-and-sweep' algorithm to trace reachable objects from roots.",
      "It uses a 'copy-on-write' strategy to duplicate objects before checking their references."
    ],
    "answer": "It maintains a container list and uses a 'mark-and-sweep' algorithm to trace reachable objects from roots.",
    "explanation": "The GC tracks container objects (which can hold references) and periodically runs a mark-and-sweep pass. It marks objects reachable from the outside and sweeps (deallocates) the unmarked ones in cycles. Option A is false; Option B describes a specific tuning, not the core algorithm.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "When using the `multiprocessing` module to bypass the GIL, how is data typically shared between processes?",
    "options": [
      "Processes share the same memory space by default, allowing direct variable access.",
      "Data is copied to a shared memory space or passed via pickling (serialization) when communicating.",
      "Processes cannot share data; they must rely on a central database.",
      "Data is shared via the Global Interpreter Lock."
    ],
    "answer": "Data is copied to a shared memory space or passed via pickling (serialization) when communicating.",
    "explanation": "Processes have distinct memory spaces. The `multiprocessing` module uses pickling to send data through queues/pipes or explicitly allocated shared memory (Value/Array). Option A describes threads; Option D is incorrect because the GIL does not handle inter-process communication.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the specific behavior of the GIL during an I/O-bound operation (e.g., reading a file or network request)?",
    "options": [
      "The GIL remains locked, preventing any other thread from executing during the I/O wait.",
      "The GIL is released, allowing other threads to execute Python bytecode while the current thread waits.",
      "The process forks a new child process to handle the I/O operation.",
      "The GIL triggers a garbage collection cycle immediately."
    ],
    "answer": "The GIL is released, allowing other threads to execute Python bytecode while the current thread waits.",
    "explanation": "To prevent blocking the entire interpreter during I/O waits, Python releases the GIL. This allows other threads to run, making threading effective for I/O-bound tasks despite the lock. Option A is incorrect as it describes the behavior for CPU-bound tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In Python's memory management, what happens when `sys.getrefcount(obj)` is called on an object `obj`?",
    "options": [
      "It returns the actual number of references to `obj` in the user program.",
      "It returns the actual number of references plus one, because the function argument itself creates a temporary reference.",
      "It returns zero if the object is part of a circular reference.",
      "It deallocates the object immediately after returning the count."
    ],
    "answer": "It returns the actual number of references plus one, because the function argument itself creates a temporary reference.",
    "explanation": "Passing an object to a function creates a new reference to it (pushed onto the stack). Therefore, `getrefcount` always returns a number one higher than the 'visible' references in the code. Option A is the common misconception; Option C is false as it only counts references, not cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the function of the `__slots__` declaration in a Python class?",
    "options": [
      "To reserve memory for specific object attributes, preventing the creation of a `__dict__` and saving RAM.",
      "To define private methods that cannot be accessed outside the class.",
      "To automatically initialize all class variables to None upon instantiation.",
      "To override the `__new__` method for faster object creation."
    ],
    "answer": "To reserve memory for specific object attributes, preventing the creation of a `__dict__` and saving RAM.",
    "explanation": "`__slots__` replaces the dynamic `__dict__` with a fixed-size static array for attributes. This reduces memory overhead per instance and speeds up attribute access. Option B is incorrect; access control is done via name mangling, not slots.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which of the following correctly describes the difference between `is` and `==` in Python?",
    "options": [
      "`is` checks for value equality, while `==` checks for memory address identity.",
      "`is` checks for object identity (memory address), while `==` checks for value equality.",
      "`is` is used for integers, while `==` is used for strings.",
      "There is no difference; they are interchangeable aliases."
    ],
    "answer": "`is` checks for object identity (memory address), while `==` checks for value equality.",
    "explanation": "`is` compares the `id()` of two objects (checking if they are the exact same object in memory). `==` invokes the `__eq__` method to compare values. Option A reverses the definitions; Options C and D are factually incorrect.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the primary risk associated with using mutable default arguments in Python function definitions (e.g., `def foo(lst=[]):`)?",
    "options": [
      "The function will raise a SyntaxError because defaults must be immutable.",
      "The default argument is evaluated only once at function definition time, causing state to persist across calls.",
      "The mutable argument cannot be pickled, breaking the `multiprocessing` module.",
      "It causes a memory leak that the Garbage Collector cannot fix."
    ],
    "answer": "The default argument is evaluated only once at function definition time, causing state to persist across calls.",
    "explanation": "Default values are bound to the function object when the function is defined, not when it is called. If the default is mutable and modified, subsequent calls will see the modified state. Option A is false; Option D is incorrect as GC can handle the objects, but the logic is the flaw.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does Python's Method Resolution Order (MRO) work in the context of multiple inheritance (C3 linearization)?",
    "options": [
      "It executes the methods of the left-most parent class first, ignoring the hierarchy depth.",
      "It calculates a monotonic order ensuring a class is always checked before its parents, and parents are checked in the order listed.",
      "It randomly selects a parent class's method to avoid diamond ambiguity errors.",
      "It requires the programmer to explicitly call `ParentClass.method(self)` on every method call."
    ],
    "answer": "It calculates a monotonic order ensuring a class is always checked before its parents, and parents are checked in the order listed.",
    "explanation": "C3 linearization (used by Python's `mro()`) creates a consistent precedence list. It respects the inheritance list order and ensures that a subclass appears before its superclass, resolving the Diamond Problem. Option A describes depth-first left-to-right (old-style Python), which fails in diamond cases.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the behavior of the `global` keyword inside a nested function?",
    "options": [
      "It allows the function to modify a variable defined in the enclosing (non-global) scope.",
      "It creates a new variable in the local namespace that shadows the global variable.",
      "It indicates that the variable refers to the module-level namespace, allowing modification of that global variable.",
      "It exports the variable so it can be imported by other modules."
    ],
    "answer": "It indicates that the variable refers to the module-level namespace, allowing modification of that global variable.",
    "explanation": "Without `global`, assigning to a variable creates a local one. The `global` keyword tells Python to refer to the existing module-level variable instead. To modify enclosing scope (non-global), `nonlocal` is used (Option A). Option B is the behavior *without* keywords.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the purpose of the `__enter__` and `__exit__` methods in a Python class?",
    "options": [
      "To define the constructor and destructor of the class respectively.",
      "To support the Context Manager protocol, allowing the class to be used with the `with` statement.",
      "To handle keyboard interrupts (KeyboardInterrupt) cleanly.",
      "To enable iteration over the class instances using a `for` loop."
    ],
    "answer": "To support the Context Manager protocol, allowing the class to be used with the `with` statement.",
    "explanation": "These magic methods define the setup and teardown actions for a context manager. `__enter__` returns the resource; `__exit__` handles cleanup (even if errors occur). Option D refers to `__iter__` and `__next__`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In the context of Generational Garbage Collection, why does the CPython GC primarily scan 'younger' generations (Generation 0) more frequently?",
    "options": [
      "Younger objects contain more data, so clearing them frees more RAM.",
      "The 'generational hypothesis' suggests that most objects die young; scanning them frequently reclaims memory faster.",
      "Older objects are protected by the GIL and cannot be scanned.",
      "Generation 0 is the only generation that handles circular references."
    ],
    "answer": "The 'generational hypothesis' suggests that most objects die young; scanning them frequently reclaims memory faster.",
    "explanation": "The generational hypothesis observes that short-lived objects are the most common. By focusing collection efforts on Gen 0, the GC maximizes throughput (garbage collected per CPU cycle). All generations can handle cycles, so Option D is false.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the technical definition of 'interning' in CPython regarding strings?",
    "options": [
      "Storing strings in a compressed format to save disk space.",
      "Caching string objects in a global table so that equal strings share the same memory address (identity).",
      "Converting strings to UTF-8 bytes automatically.",
      "Encrypting strings for security purposes."
    ],
    "answer": "Caching string objects in a global table so that equal strings share the same memory address (identity).",
    "explanation": "Interning ensures that only one copy of specific strings (like identifiers or small strings) exists in memory. This allows pointer comparison (`is`) instead of value comparison (`==`) for checks, improving performance. Option A is incorrect; it is an in-memory optimization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "How does `await` differ from `yield` in an asynchronous Python function?",
    "options": [
      "`await` transfers control to the event loop, pausing the coroutine until the awaited object completes, whereas `yield` produces a value to the iterator.",
      "`await` executes the function synchronously, while `yield` executes it asynchronously.",
      "`await` can only be used inside a standard function, while `yield` requires an `async def`.",
      "There is no functional difference; they are aliases."
    ],
    "answer": "`await` transfers control to the event loop, pausing the coroutine until the awaited object completes, whereas `yield` produces a value to the iterator.",
    "explanation": "`await` is specific to coroutines and `async` functions, suspending execution to let the event loop run other tasks. `yield` is used in generators to produce a sequence of values. Option C is reversed; `await` requires `async def`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What happens when a Python object's reference count drops to zero?",
    "options": [
      "The object is marked for deletion by the Garbage Collector in the next cycle.",
      "The object's memory is immediately deallocated (freed) via the object's `__dealloc__` or type-specific method.",
      "The object is moved to Generation 2 of the garbage collector for long-term storage.",
      "The program crashes with a Segmentation Fault."
    ],
    "answer": "The object's memory is immediately deallocated (freed) via the object's `__dealloc__` or type-specific method.",
    "explanation": "Reference counting is the primary memory management mechanism. Once the counter hits zero, *immediate* deallocation occurs (calls `tp_dealloc`), unlike the cyclic GC which runs periodically. Option A describes behavior for circular references, which ref counting misses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the function of the `gil` parameter in the `sys` module (e.g., `sys._is_gil_enabled()` in experimental builds)?",
    "options": [
      "It forces the Python interpreter to release the GIL permanently.",
      "It allows a programmer to query if the Python build was compiled with thread support.",
      "It checks the status of the GIL (enabled/disabled) to verify if the interpreter is running in free-threaded mode.",
      "It increases the reference count of the Global Interpreter Lock."
    ],
    "answer": "It checks the status of the GIL (enabled/disabled) to verify if the interpreter is running in free-threaded mode.",
    "explanation": "With the advent of sub-interpreters and NOGIL builds (PEP 703), APIs like `sys._is_gil_enabled()` allow code to detect if the Global Interpreter Lock is active. Option B is incorrect because threading support can exist with or without the GIL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Why are integers typically cached in CPython (e.g., integers from -5 to 256)?",
    "options": [
      "To prevent integer overflow errors in mathematical calculations.",
      "To save memory allocation overhead and improve performance for commonly used small integers.",
      "To ensure that integer division always results in a float.",
      "Because 32-bit systems cannot address integers outside this range."
    ],
    "answer": "To save memory allocation overhead and improve performance for commonly used small integers.",
    "explanation": "Pre-allocating a range of small integers avoids the constant creation and destruction of these objects, which are frequently used in loops and logic. Option A is a logical error handled differently; Option D is archaic and unrelated to Python's arbitrary precision ints.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the purpose of the `dis` module in Python?",
    "options": [
      "To disassemble functions and methods into their underlying bytecode instructions.",
      "To disconnect a running process from the network.",
      "To display the differences between two files (diff).",
      "To disable the Garbage Collector manually."
    ],
    "answer": "To disassemble functions and methods into their underlying bytecode instructions.",
    "explanation": "The `dis` module (disassembler) provides a human-readable representation of the Python bytecode (e.g., `LOAD_FAST`, `CALL_FUNCTION`) that the interpreter executes. Option D is handled by the `gc` module.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Why might `gc.collect()` be called manually in a long-running Python application?",
    "options": [
      "To force the interpreter to exit immediately.",
      "To reclaim memory from reference cycles *before* the automatic generational GC triggers, preventing memory spikes.",
      "To reset the reference counts of all objects to zero.",
      "To increase the speed of the CPU by disabling context switching."
    ],
    "answer": "To reclaim memory from reference cycles *before* the automatic generational GC triggers, preventing memory spikes.",
    "explanation": "Automatic GC runs periodically based on allocation thresholds. Manually calling `gc.collect()` is useful when a large number of cyclic references are deallocated at once to free memory immediately. Option C is impossible; ref counts are managed incrementally.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "How does `process.join()` in the `multiprocessing` module affect the parent process?",
    "options": [
      "It terminates the child process immediately.",
      "It blocks the parent process until the child process completes its execution.",
      "It allows the parent and child to run simultaneously in shared memory.",
      "It detaches the child process so it becomes a daemon."
    ],
    "answer": "It blocks the parent process until the child process completes its execution.",
    "explanation": "The `join()` method ensures the main program waits for the worker/child to finish. If `join` is not called, the parent might exit while children are still running (orphans). Option A is `terminate()`; Option D is `daemon=True`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the 'Stop-the-World' phase in the context of the NOGIL Garbage Collector implementation?",
    "options": [
      "It stops the program execution indefinitely to fix memory leaks.",
      "It pauses all mutator threads to ensure the GC can safely traverse the object graph without race conditions.",
      "It stops the Garbage Collector from running to improve application throughput.",
      "It kills threads that are taking too long to execute."
    ],
    "answer": "It pauses all mutator threads to ensure the GC can safely traverse the object graph without race conditions.",
    "explanation": "Without the GIL, threads can modify objects while the GC tries to scan them. A stop-the-world pause ensures consistency by freezing other threads during critical GC phases. Option C describes disabling the GC.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "In Python, what occurs when you attempt to pickle an object containing an open file handle?",
    "options": [
      "The file content is serialized into the pickle stream.",
      "A `PicklingError` or `TypeError` is raised because file handles cannot be pickled by default.",
      "The file is automatically closed before pickling.",
      "The file handle is converted to a path string."
    ],
    "answer": "A `PicklingError` or `TypeError` is raised because file handles cannot be pickled by default.",
    "explanation": "Stateful resources like open files, sockets, or database connections generally cannot be pickled directly because they rely on external OS resources. You must usually close/reopen or use custom `__reduce__` logic. Option A is false; only the handle meta is stored, but standard pickling forbids it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the primary difference between a `Thread` and a `Process` in Python's `concurrency` modules?",
    "options": [
      "Threads share the same memory space and GIL; Processes have separate memory and separate GILs.",
      "Processes are lighter and faster to create than Threads.",
      "Threads cannot use the `queue` module, while Processes can.",
      "Processes share the Global Interpreter Lock, while Threads do not."
    ],
    "answer": "Threads share the same memory space and GIL; Processes have separate memory and separate GILs.",
    "explanation": "Threads live within one process and share memory/heap (protected by one GIL). Processes are distinct OS entities with independent memory spaces and interpreters (each with its own GIL if applicable). Option B is generally incorrect; processes have higher overhead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the behavior of the `finally` clause in a `try-except-finally` block if the `try` block executes a `return` statement?",
    "options": [
      "The `finally` block is skipped to ensure the `return` is processed immediately.",
      "The `finally` block executes, and then the `return` is processed.",
      "The `return` value is discarded, and the `finally` block's result is returned instead.",
      "The program enters an infinite loop."
    ],
    "answer": "The `finally` block executes, and then the `return` is processed.",
    "explanation": "The `finally` block is guaranteed to execute before the function actually returns. If `finally` has a `return` itself, that overrides the original one; otherwise, the original return value is preserved after `finally` runs. Option A is a common misconception.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Why is the `with` statement preferred for file handling over manually opening and closing files?",
    "options": [
      "It makes the code run faster by using a C-optimized buffer.",
      "It guarantees that the file is closed even if an exception is raised during processing.",
      "It automatically converts file contents to UTF-8.",
      "It allows multiple threads to write to the file simultaneously without locking."
    ],
    "answer": "It guarantees that the file is closed even if an exception is raised during processing.",
    "explanation": "The context manager protocol (`__exit__`) ensures cleanup logic (closing the file, releasing locks) runs regardless of successful execution or exceptions. Manual `try...finally` does this, but `with` is cleaner and safer. Option D is false; file writes are still atomic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the purpose of `__init__.py` inside a Python package directory?",
    "options": [
      "It marks the directory as a Python package, allowing it to be imported.",
      "It serves as the main entry point for the application.",
      "It initializes the Python interpreter.",
      "It is a legacy file that is ignored in Python 3."
    ],
    "answer": "It marks the directory as a Python package, allowing it to be imported.",
    "explanation": "Without `__init__.py` (historically), Python treated directories as namespace packages or ordinary folders. While namespace packages exist, `__init__.py` defines an explicit package and can execute initialization code. Option D is false; it is still widely used.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How does the `nonlocal` keyword differ from the `global` keyword regarding scope resolution?",
    "options": [
      "`nonlocal` binds to the module-level scope, while `global` binds to the built-in scope.",
      "`nonlocal` binds to a variable in the nearest enclosing scope (excluding global), while `global` binds to the module-level scope.",
      "`nonlocal` is used to declare variables in C-extensions, while `global` is for pure Python.",
      "There is no difference; they perform the same function."
    ],
    "answer": "`nonlocal` binds to a variable in the nearest enclosing scope (excluding global), while `global` binds to the module-level scope.",
    "explanation": "`nonlocal` specifically targets variables in a parent function's scope (closure), useful for nested functions. `global` skips all enclosing scopes and goes directly to the module level. Option A is incorrect; `global` binds to module, not built-in.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the definition of 'duck typing' in Python?",
    "options": [
      "An explicit type checking mechanism performed by the interpreter before runtime.",
      "A coding style where an object's suitability is determined by the presence of specific methods and properties, rather than its actual type.",
      "A strict typing system requiring all variables to be declared as `Duck` type.",
      "A security feature that prevents code injection."
    ],
    "answer": "A coding style where an object's suitability is determined by the presence of specific methods and properties, rather than its actual type.",
    "explanation": "Duck typing focuses on behavior: 'If it walks like a duck and quacks like a duck, it's a duck.' It enables polymorphism without explicit inheritance. Option A describes static typing; Option C is nonsensical.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which Python feature allows an instance method to behave like a static function but retains access to the class (`cls`) rather than the instance (`self`)?",
    "options": [
      "The `@staticmethod` decorator.",
      "The `@classmethod` decorator.",
      "The `@property` decorator.",
      "The `__init__` method."
    ],
    "answer": "The `@classmethod` decorator.",
    "explanation": "`@classmethod` receives the class (`cls`) as the implicit first argument. `@staticmethod` receives no implicit first argument. `@property` turns a method into an attribute getter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the implication of CPython using reference counting as its primary memory management strategy?",
    "options": [
      "Memory leaks are impossible because every object is tracked.",
      "Circular references are handled automatically without a separate Garbage Collector.",
      "Memory is reclaimed immediately when an object is no longer referenced, but it cannot detect circular references.",
      "The interpreter must be restarted periodically to free memory."
    ],
    "answer": "Memory is reclaimed immediately when an object is no longer referenced, but it cannot detect circular references.",
    "explanation": "Ref counting offers immediate deterministic deallocation (pros). However, it strictly fails on cycles (A->B->A) because counts never hit zero (cons), necessitating the cyclic GC. Option A is false; cycles cause leaks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "In the context of the `gc` module, what do the thresholds (e.g., `gc.set_threshold(threshold0, ...)` ) control?",
    "options": [
      "The maximum amount of RAM (in MB) the Python process is allowed to use.",
      "The number of generations the garbage collector uses.",
      "The number of object allocations that must occur before triggering a collection cycle for specific generations.",
      "The number of threads that can access the Python interpreter simultaneously."
    ],
    "answer": "The number of object allocations that must occur before triggering a collection cycle for specific generations.",
    "explanation": "GC thresholds define how many new objects must be allocated *minus* how many deallocated before the automatic collector runs for that generation. Option A is OS-controlled; Option D is controlled by the GIL/OS.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the result of `list(zip([1, 2, 3], ['a', 'b']))` in Python 3?",
    "options": [
      "`[(1, 'a'), (2, 'b'), (3, None)]`",
      "`[(1, 'a'), (2, 'b')]`",
      "`[(1, 'a'), (2, 'b'), (3,)]`",
      "`[1, 2, 3, 'a', 'b']`"
    ],
    "answer": "`[(1, 'a'), (2, 'b')]`",
    "explanation": "`zip` aggregates elements from iterables. It stops when the *shortest* iterable is exhausted. Since the second list has 2 items, the result contains only 2 tuples. Option A implies padding (requires `itertools.zip_longest`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of CPython's implementation, what is the primary limitation of reference counting that necessitates a separate cyclic garbage collector?",
    "options": [
      "Reference counting cannot immediately detect when objects are deleted by external C libraries",
      "Reference counting fails to decrement counters for objects involved in circular references where the reference count never reaches zero",
      "Reference counting is too slow for high-performance applications and requires a background optimizer",
      "Reference counting does not track memory allocated on the stack, only the heap"
    ],
    "answer": "Reference counting fails to decrement counters for objects involved in circular references where the reference count never reaches zero",
    "explanation": "In a reference cycle (e.g., A refers to B and B refers to A), every object in the cycle has a reference count of at least 1, preventing the memory manager from reclaiming them via standard reference counting alone.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "How does the Global Interpreter Lock (GIL) in CPython affect the performance of CPU-bound versus I/O-bound Python programs?",
    "options": [
      "The GIL degrades performance for both CPU-bound and I/O-bound tasks by forcing all operations to run sequentially",
      "The GIL severely limits CPU-bound tasks by preventing parallel execution of bytecode on multi-core systems, but has minimal impact on I/O-bound tasks as the lock is released during I/O waits",
      "The GIL is automatically bypassed when using libraries like NumPy, allowing full parallelism for all types of tasks",
      "The GIL improves CPU-bound performance by caching bytecode instructions across threads"
    ],
    "answer": "The GIL severely limits CPU-bound tasks by preventing parallel execution of bytecode on multi-core systems, but has minimal impact on I/O-bound tasks as the lock is released during I/O waits",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time, hindering CPU-bound parallelism. However, it is released during I/O operations, allowing threads to run concurrently while waiting for external resources.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Which specific types of objects does CPython's cyclic garbage collector track by default to detect circular references?",
    "options": [
      "All user-defined objects and native types like int and float",
      "Only objects that define the __del__ method",
      "Container objects (lists, dicts, classes, tuples) that may contain references to other objects",
      "Objects allocated on the heap that exceed 1KB in size"
    ],
    "answer": "Container objects (lists, dicts, classes, tuples) that may contain references to other objects",
    "explanation": "Atomic types like integers or strings cannot form reference cycles. The GC specifically tracks container objects that *can* hold references to other objects to detect circular dependencies.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In the proposed 'nogil' (free-threaded) CPython builds, what mechanism replaces the standard reference counting to ensure thread safety?",
    "options": [
      "Atomic reference counting using hardware-level atomic operations",
      "Biased reference counting, where object ownership is attributed to a specific thread to reduce synchronization overhead",
      "A stop-the-world garbage collector that runs exclusively, removing the need for reference counting",
      "Lock strips (mutexes) associated with every single object in the heap"
    ],
    "answer": "Biased reference counting, where object ownership is attributed to a specific thread to reduce synchronization overhead",
    "explanation": "Biased reference counting optimizes performance by assuming an object belongs to a single thread (the 'bias'), allowing that thread to modify the reference count without expensive atomic locks.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the behavior difference regarding garbage collection generations between standard CPython and the 'nogil' implementation described in recent developments?",
    "options": [
      "The 'nogil' implementation introduces a fourth generation specifically for long-lived daemon threads",
      "The 'nogil' implementation removes generational collection, scanning the entire object heap in every cycle to ensure thread safety",
      "Standard CPython uses a non-generational sweep, while 'nogil' implements a tri-generational system",
      "Both implementations use a generational approach, but 'nogil' skips the 'young' generation scan"
    ],
    "answer": "The 'nogil' implementation removes generational collection, scanning the entire object heap in every cycle to ensure thread safety",
    "explanation": "To manage the complexity of concurrent garbage collection without the GIL, the 'nogil' implementation (as described in the provided context) utilizes a non-generational approach, often relying on stop-the-world pauses to scan all objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What does the `sys.getrefcount(obj)` function return, and why is the result often higher than expected?",
    "options": [
      "It returns the number of times the object has been accessed; it is higher due to internal caching",
      "It returns the reference count; it includes the temporary reference held by the argument passed to the function itself",
      "It returns the number of strong references excluding weak references; it is higher because of the interpreter's internal object stack",
      "It returns the total memory size of the object in bytes; the value is an estimate"
    ],
    "answer": "It returns the reference count; it includes the temporary reference held by the argument passed to the function itself",
    "explanation": "When you pass an object to `sys.getrefcount`, a new reference is passed to the C function, incrementing the count by 1 temporarily. Therefore, the result is usually 1 higher than the apparent references in your code.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the function of the `__slots__` declaration in a Python class?",
    "options": [
      "To define private methods that cannot be overridden by subclasses",
      "To prevent the creation of instance dictionaries, thereby saving memory and preventing dynamic attribute assignment",
      "To specify the order in which attributes are serialized for pickling",
      "To allocate a fixed amount of stack memory for the class methods"
    ],
    "answer": "To prevent the creation of instance dictionaries, thereby saving memory and preventing dynamic attribute assignment",
    "explanation": "`__slots__` replaces the dynamic `__dict__` with a fixed-size descriptor structure. This significantly reduces memory overhead per instance but restricts the ability to add new attributes at runtime.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which Python construct utilizes a 'mark-and-sweep' algorithm implicitly to manage memory?",
    "options": [
      "The `contextlib` module",
      "The cyclic garbage collector (gc module)",
      "The reference counting mechanism",
      "The buffer protocol"
    ],
    "answer": "The cyclic garbage collector (gc module)",
    "explanation": "The `gc` module implements a cycle detection algorithm. It 'marks' all reachable objects traversing from roots and then 'sweeps' (deallocates) any container objects that were not marked, effectively cleaning up reference cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In CPython, what happens when an object's `__del__` method is invoked during garbage collection?",
    "options": [
      "The object is immediately removed from memory and the method is executed in a separate thread",
      "The method is called, but if it resurrects the object (creates a new reference), the garbage collector halts to prevent a crash",
      "The object is moved to generation 3 and `__del__` is called at program exit",
      "The `__del__` method is ignored during cyclic GC to avoid infinite recursion"
    ],
    "answer": "The method is called, but if it resurrects the object (creates a new reference), the garbage collector halts to prevent a crash",
    "explanation": "While `__del__` is a finalizer, if it adds a reference back to the object during collection ('resurrection'), it complicates the GC logic. Historically, such objects might be placed in an `uncollectable` list (`gc.garbage`).",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "How does the `multiprocessing` module bypass the GIL limitations of the `threading` module?",
    "options": [
      "It compiles Python code into machine code using LLVM",
      "It spawns multiple processes, each with its own Python interpreter and memory space (and its own GIL)",
      "It uses microthreads (greenlets) managed by the application rather than the OS",
      "It disables the GIL globally for the duration of the child processes"
    ],
    "answer": "It spawns multiple processes, each with its own Python interpreter and memory space (and its own GIL)",
    "explanation": "Processes do not share memory space. By creating a new Python interpreter instance for each process, `multiprocessing` achieves true parallelism on multi-core CPUs because each process has its own GIL.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which of the following statements is true regarding Python's handling of integer objects?",
    "options": [
      "Integers are always allocated on the stack, not the heap",
      "Python caches a range of small integers (typically -5 to 256) and reuses them to optimize memory allocation",
      "Every integer operation results in a new unique heap allocation regardless of size",
      "Integers are stored as 64-bit values regardless of the underlying architecture"
    ],
    "answer": "Python caches a range of small integers (typically -5 to 256) and reuses them to optimize memory allocation",
    "explanation": "CPython pre-allocates an array of integer objects for the small integer range. Instead of creating a new object, Python returns a reference to the existing cached object for these values.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the purpose of the 'generational' hypothesis in the context of CPython's garbage collector?",
    "options": [
      "Older objects are more likely to die than newer objects",
      "Newer objects are more likely to become garbage quickly, while older objects tend to live longer",
      "Objects in the same generation must be of the same type",
      "Memory must be compacted every generation to prevent heap fragmentation"
    ],
    "answer": "Newer objects are more likely to become garbage quickly, while older objects tend to live longer",
    "explanation": "The generational hypothesis assumes that most objects die young. CPython optimizes by scanning 'young' objects (Generation 0) more frequently than 'old' objects (Generation 2), reducing the overhead of scanning long-lived objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "When comparing strings `a` and `b` using `a is b`, under what specific condition does this expression evaluate to `True`?",
    "options": [
      "When the strings have identical length and content",
      "When the strings are interned (forced or implicitly) and point to the same memory address",
      "When the `==` operator returns True",
      "Only when strings are declared using single quotes versus double quotes"
    ],
    "answer": "When the strings are interned (forced or implicitly) and point to the same memory address",
    "explanation": "`is` checks identity (memory address), not equality. Python interns strings implicitly (e.g., small strings, identifiers) or explicitly via `sys.intern()`, ensuring variables point to the same object.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What characterizes 'stop-the-world' pauses in the context of the 'nogil' garbage collector implementation?",
    "options": [
      "The interpreter pauses all execution threads to safely perform garbage collection, preventing race conditions",
      "The application pauses I/O operations to flush buffers to disk",
      "The GIL is reacquired by the main thread, freezing all other threads indefinitely",
      "The garbage collector runs incrementally, pausing only the currently executing thread"
    ],
    "answer": "The interpreter pauses all execution threads to safely perform garbage collection, preventing race conditions",
    "explanation": "Without a GIL to synchronize access, concurrent mutation by other threads can corrupt GC state. A stop-the-world pause ensures no other threads run while the collector is tracing or modifying object references.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In Python's Descriptor Protocol, what is the technical distinction between a 'data descriptor' and a 'non-data descriptor'?",
    "options": [
      "A data descriptor is defined in a class, while a non-data descriptor is defined in an instance",
      "A data descriptor implements both `__get__` and `__set__` (or `__delete__`), while a non-data descriptor only implements `__get__`",
      "A data descriptor handles integers, while a non-data descriptor handles strings",
      "A data descriptor is used for properties, while a non-data descriptor is used for classmethods"
    ],
    "answer": "A data descriptor implements both `__get__` and `__set__` (or `__delete__`), while a non-data descriptor only implements `__get__`",
    "explanation": "Data descriptors (like `property`) take precedence over instance dictionaries because they define how to set the value. Non-data descriptors (like `function`/`method`) only define how to get the value, allowing instance attributes to shadow them.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Why is using the `multiprocessing` module generally preferred over the `threading` module for CPU-bound tasks in CPython?",
    "options": [
      "Threads cannot access the CPU due to OS restrictions on Python interpreters",
      "Multiprocessing creates separate processes with their own GIL, allowing true parallel execution of bytecode on multiple cores",
      "Threads share memory which causes cache invalidation issues that multiprocessing solves via copy-on-write",
      "Multiprocessing has a lower overhead for context switching than threading"
    ],
    "answer": "Multiprocessing creates separate processes with their own GIL, allowing true parallel execution of bytecode on multiple cores",
    "explanation": "Because of the GIL, multiple threads within a single process cannot execute Python bytecode in parallel. Multiprocessing sidesteps this by using separate processes, each with its own interpreter state and GIL.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the function of the `gc.set_threshold(threshold0, threshold1, threshold2)` method?",
    "options": [
      "It sets the memory limit in bytes after which the program crashes",
      "It configures the frequency of automatic garbage collection based on the number of allocations minus deallocations in each generation",
      "It defines the maximum number of objects allowed in each generation before an exception is raised",
      "It sets the minimum reference count for an object to be considered 'long-lived'"
    ],
    "answer": "It configures the frequency of automatic garbage collection based on the number of allocations minus deallocations in each generation",
    "explanation": "The threshold determines how often the collector runs. For example, if the threshold for generation 0 is 700, a collection is triggered after 700 new allocations have occurred since the last collection.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does the `with` statement (Context Manager) ensure resource cleanup?",
    "options": [
      "It uses the `__enter__` and `__exit__` magic methods to guarantee that `__exit__` is called even if an exception occurs within the block",
      "It relies on the reference counter to immediately call `__del__` when the block scope ends",
      "It wraps the code in a try-finally block at the bytecode level to handle exceptions manually",
      "It registers the resource with the garbage collector to be swept up at the next cycle"
    ],
    "answer": "It uses the `__enter__` and `__exit__` magic methods to guarantee that `__exit__` is called even if an exception occurs within the block",
    "explanation": "The `with` statement protocol requires `__exit__` to handle exceptions (if any) and cleanup. The compiler generates bytecode equivalent to a `try...finally` block to ensure this method executes.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is a 'freelist' in the context of CPython's memory allocator (pymalloc)?",
    "options": [
      "A linked list of all currently alive Python objects",
      "A pool of pre-allocated memory chunks used to quickly satisfy allocation requests for objects of a specific size without system calls",
      "A list of memory addresses that are available for the Garbage Collector to ignore",
      "A debugging tool used to track memory leaks in C extensions"
    ],
    "answer": "A pool of pre-allocated memory chunks used to quickly satisfy allocation requests for objects of a specific size without system calls",
    "explanation": "To avoid the overhead of `malloc` and `free` for every small object, CPython maintains freelists (e.g., for integers, tuples). When an object is freed, its memory is returned to the freelist for reuse.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What happens when a `weakref` to an object is accessed after the object has been destroyed?",
    "options": [
      "It raises an `AttributeError`",
      "It returns `None` if the callback was set, otherwise it raises a `ReferenceError`",
      "It returns the memory address of where the object used to be",
      "It automatically resurrects the object"
    ],
    "answer": "It returns `None` if the callback was set, otherwise it raises a `ReferenceError`",
    "explanation": "Calling a weak reference object returns the referenced object if it is still alive. If the object is dead, accessing the weak reference returns `None` when using `weakref.ref(obj)()`. (Note: technically, calling the proxy returns None, but the ref object itself raises ReferenceError if not handled, though standard behavior of `weakref.ref` is to return None or raise ReferenceError).",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "Which of the following best describes the Method Resolution Order (MRO) in Python 3?",
    "options": [
      "Depth-first, left-to-right search (as used in Python 2.2 classic classes)",
      "Breadth-first search to ensure the closest parent is checked first",
      "C3 Linearization, which preserves local precedence ordering and monotonicity",
      "The order in which methods are defined in the source code file"
    ],
    "answer": "C3 Linearization, which preserves local precedence ordering and monotonicity",
    "explanation": "Python 3 uses the C3 linearization algorithm to calculate the MRO. This algorithm ensures that a class appears before its parents (monotonicity) and respects the order of inheritance in base classes.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the primary risk of using mutable default arguments in function definitions?",
    "options": [
      "They cause a SyntaxError because Python cannot hash mutable types",
      "The default object is created once at definition time and shared across all calls, leading to unintended state persistence",
      "They are slower to access than immutable defaults",
      "They cannot be pickled and thus break multiprocessing"
    ],
    "answer": "The default object is created once at definition time and shared across all calls, leading to unintended state persistence",
    "explanation": "Default argument values are evaluated only once when the function is defined. If the default is mutable (like a list or dict), changes to it in one call persist to the next.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the 'Small Integer Interning' range in standard CPython?",
    "options": [
      "0 to 100",
      "-5 to 256",
      "-128 to 127",
      "0 to 1024"
    ],
    "answer": "-5 to 256",
    "explanation": "CPython pre-allocates integer objects for the range -5 to 256. Any integer literal or calculation resulting in a value within this range will reference the pre-existing object.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "In the `gc` module, what does `gc.get_objects()` return?",
    "options": [
      "A list of all objects tracked by the garbage collector (excluding those not tracked, like simple atomic types)",
      "A list of all objects currently in memory, including untracked atomic types",
      "A dictionary mapping object IDs to their reference counts",
      "A list of only the objects in the 'young' generation"
    ],
    "answer": "A list of all objects tracked by the garbage collector (excluding those not tracked, like simple atomic types)",
    "explanation": "The `gc` module only tracks container objects. `gc.get_objects()` returns a list of all container objects currently managed by the collector; simple types like ints or strings (unless part of a container) are generally excluded.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Why does CPython use a memory pool allocator (pymalloc) instead of the system `malloc` for small objects?",
    "options": [
      "To compress data in memory using the LZO algorithm",
      "To avoid costly system calls and memory fragmentation by managing fixed-size blocks for object allocations",
      "To ensure that all Python objects are stored in contiguous memory for better cache locality",
      "To allow objects to be moved in memory during defragmentation"
    ],
    "answer": "To avoid costly system calls and memory fragmentation by managing fixed-size blocks for object allocations",
    "explanation": "System `malloc` has overhead and can fragment memory. `pymalloc` optimizes for many small allocations by requesting large chunks of memory from the OS and slicing them into fixed-size arenas.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What occurs during the 'Mark' phase of CPython's garbage collection?",
    "options": [
      "The interpreter marks the `__del__` method for execution",
      "The GC traverses reachable objects from container roots and marks them as active",
      "The memory is compacted to remove gaps between allocated objects",
      "The reference counts of all objects are synchronized"
    ],
    "answer": "The GC traverses reachable objects from container roots and marks them as active",
    "explanation": "The cyclic GC starts by initializing a 'clear' bit. It then iterates over containers, traversing their references and toggling the mark bit. Objects that remain 'unmarked' (or clear, depending on implementation nuance) after the traversal are identified as garbage.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the `__new__` method differ from `__init__` in Python class instantiation?",
    "options": [
      "`__new__` is the constructor responsible for allocating memory and returning the instance, while `__init__` initializes the state of the created instance",
      "`__init__` is static and runs first, creating the object, while `__new__` sets the attributes",
      "`__new__` can only be called on classes that inherit from `object`, while `__init__` is universal",
      "There is no difference; they are aliases for backward compatibility"
    ],
    "answer": "`__new__` is the constructor responsible for allocating memory and returning the instance, while `__init__` initializes the state of the created instance",
    "explanation": "`__new__` is a static method controlling the creation of a new instance (and thus the type). `__init__` receives the already-created instance to set up initial attribute values.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the behavior of `gc.disable()` in a CPython application?",
    "options": [
      "It stops all reference counting, requiring manual memory management",
      "It prevents the automatic cyclic garbage collection from running, but reference counting remains active",
      "It halts the interpreter's execution until `gc.enable()` is called",
      "It releases the Global Interpreter Lock (GIL) permanently"
    ],
    "answer": "It prevents the automatic cyclic garbage collection from running, but reference counting remains active",
    "explanation": "Python relies primarily on reference counting. `gc.disable()` only stops the periodic sweeps of the cyclic garbage collector; memory is still freed immediately when reference counts hit zero.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "When implementing `__eq__` for a custom class, why is it often recommended to also implement `__hash__` (or set it to None)?",
    "options": [
      "To ensure the class can be used as a dictionary key or in a set, where hash consistency with equality is required",
      "To ensure that the `==` operator works correctly with the `is` operator",
      "To prevent the interpreter from using the default identity hash",
      "To increase the speed of attribute lookups on instances of the class"
    ],
    "answer": "To ensure the class can be used as a dictionary key or in a set, where hash consistency with equality is required",
    "explanation": "If two objects are equal (`a == b`), they *must* have the same hash value (`hash(a) == hash(b)`). Failure to maintain this contract makes instances unusable in hash-based collections like dict or set.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the technical reason behind the 'Intering' of strings in Python?",
    "options": [
      "To enable efficient string concatenation by modifying the buffer in place",
      "To reduce memory usage and speed up comparisons by reusing a single immutable object for identical strings",
      "To facilitate garbage collection by grouping identical strings together",
      "To ensure that strings are always encoded in UTF-8 format"
    ],
    "answer": "To reduce memory usage and speed up comparisons by reusing a single immutable object for identical strings",
    "explanation": "String interning ensures that identical string values share the same memory address. This saves memory and allows equality checks to be performed via pointer comparison (`is`) rather than character-by-character comparison.",
    "difficulty": "Advanced"
  }
]