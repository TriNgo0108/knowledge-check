[
  {
    "id": 1,
    "question": "What is the primary distinction between Architecture Patterns and Design Patterns?",
    "options": [
      "Architecture patterns deal with data structures, while Design patterns deal with database schemas.",
      "Architecture patterns operate at a system-wide structural level, while Design patterns address specific component implementation details.",
      "Architecture patterns are used for frontend development, while Design patterns are exclusively for backend logic.",
      "Design patterns are defined by the Gang of Four, whereas Architecture patterns have no formal definition."
    ],
    "answer": "Architecture patterns operate at a system-wide structural level, while Design patterns address specific component implementation details.",
    "explanation": "Architecture patterns (e.g., Microservices, Layered) define the high-level structure of the entire system. Design patterns (e.g., Factory, Observer) provide reusable solutions for smaller, localized problems within components.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which design pattern defines a skeleton of an algorithm in a base class but allows subclasses to override specific steps without changing the algorithm's structure?",
    "options": [
      "Strategy Pattern",
      "Template Method Pattern",
      "Builder Pattern",
      "Prototype Pattern"
    ],
    "answer": "Template Method Pattern",
    "explanation": "The Template Method pattern defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps. Strategy pattern encapsulates the entire algorithm, while Builder focuses on construction.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In the context of the Model-View-Controller (MVC) pattern, which component is primarily responsible for handling user input and updating the Model?",
    "options": [
      "View",
      "Database",
      "Controller",
      "Service Locator"
    ],
    "answer": "Controller",
    "explanation": "The Controller acts as an intermediary that accepts user inputs from the View and updates the Model state. The View is responsible for display, and the Model manages data logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the main benefit of using the Repository pattern in data access logic?",
    "options": [
      "It directly couples the application code to the database schema.",
      "It provides a mechanism for caching database queries indefinitely.",
      "It abstracts the data access layer, providing a more object-oriented collection-like interface to the domain.",
      "It eliminates the need for a database."
    ],
    "answer": "It abstracts the data access layer, providing a more object-oriented collection-like interface to the domain.",
    "explanation": "The Repository pattern mediates between the domain and data mapping layers, acting like an in-memory domain object collection. It reduces duplication of query logic and decouples the domain from persistence details.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which design pattern allows you to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests?",
    "options": [
      "Command Pattern",
      "Observer Pattern",
      "Facade Pattern",
      "Adapter Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This enables queuing, callback, and undoable operations, unlike Observer (pub/sub) or Adapter (interface compatibility).",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which statement best describes the intent of the Strategy pattern?",
    "options": [
      "To define a family of algorithms, encapsulate each one, and make them interchangeable.",
      "To separate the construction of a complex object from its representation.",
      "To provide a unified interface to a set of interfaces in a subsystem.",
      "To attach additional responsibilities to an object dynamically."
    ],
    "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable.",
    "explanation": "The Strategy pattern lets the algorithm vary independently from clients that use it. Builder separates construction, Facade simplifies interfaces, and Decorator adds responsibilities.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the core principle of the Separation of Concerns (SoC) principle?",
    "options": [
      "All logic must be contained within a single class to avoid overhead.",
      "A system should be divided into distinct, non-overlapping features or concerns.",
      "Data must be separated from the user interface only.",
      "Business logic should be tightly coupled with the database logic."
    ],
    "answer": "A system should be divided into distinct, non-overlapping features or concerns.",
    "explanation": "SoC dictates that a software system must be separated into distinct sections (like presentation, business, and data layers), such that each section addresses a separate concern.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which Creational pattern is used to ensure that a class has only one instance and provides a global point of access to it?",
    "options": [
      "Factory Method",
      "Singleton",
      "Prototype",
      "Builder"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. Factory Method defines an interface for creation, Prototype clones objects, and Builder constructs complex objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "In the context of CQRS (Command Query Responsibility Segregation), what is the primary motivation for separating read and write operations?",
    "options": [
      "To increase the coupling between the user interface and the database.",
      "To allow independent scaling and optimization of read and write models.",
      "To simplify the database schema into a single table.",
      "To eliminate the need for a data access layer."
    ],
    "answer": "To allow independent scaling and optimization of read and write models.",
    "explanation": "CQRS separates the operations that read data (queries) from the operations that update data (commands). This allows for optimized performance and scalability, as the data models for reading and writing can differ.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which design pattern converts the interface of a class into another interface that clients expect?",
    "options": [
      "Decorator",
      "Proxy",
      "Adapter",
      "Bridge"
    ],
    "answer": "Adapter",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. Decorator adds behavior, Proxy controls access, and Bridge separates abstraction from implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "In Layered Architecture, which layer is primarily responsible for executing business rules and validating requests?",
    "options": [
      "Presentation Layer",
      "Business Layer",
      "Persistence Layer",
      "Database Layer"
    ],
    "answer": "Business Layer",
    "explanation": "The Business Layer contains the logic required to execute business processes and rules. Presentation handles UI, Persistence handles data storage logic, and Database stores data.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the primary role of the Unit of Work pattern?",
    "options": [
      "To track changes made to business objects during a transaction and write them out atomically.",
      "To map database tables to application objects.",
      "To generate SQL queries on the fly.",
      "To separate the user interface from the business logic."
    ],
    "answer": "To track changes made to business objects during a transaction and write them out atomically.",
    "explanation": "The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates the writing out of changes. Repository handles data access abstraction, while Unit of Work ensures consistency.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which architectural pattern is characterized by decoupled components that communicate asynchronously via events?",
    "options": [
      "Monolithic Architecture",
      "Layered Architecture",
      "Event-Driven Architecture",
      "N-Tier Architecture"
    ],
    "answer": "Event-Driven Architecture",
    "explanation": "Event-Driven Architecture uses events to trigger and communicate between decoupled services. Monolithic and Layered architectures typically rely on synchronous method calls.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which Gang of Four pattern allows you to compose objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Composite",
      "Flyweight",
      "Memento",
      "Chain of Responsibility"
    ],
    "answer": "Composite",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly. Flyweight shares fine-grained objects, Memento saves state, and Chain of Responsibility passes requests along a chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "In Microservices Architecture, how does deployment differ from Monolithic Architecture?",
    "options": [
      "Microservices require all services to be deployed as a single unit.",
      "Microservices allow for independent deployment of individual services.",
      "Microservices do not support continuous integration.",
      "Deployment complexity is lower in Microservices due to shared codebases."
    ],
    "answer": "Microservices allow for independent deployment of individual services.",
    "explanation": "A core feature of Microservices is that they are independently deployable. In a Monolith, the entire application is deployed as a single unit.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which pattern acts as a simplified interface to a larger, more complex body of code, such as a library or framework?",
    "options": [
      "Adapter",
      "Facade",
      "Decorator",
      "Proxy"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a higher-level interface that makes a subsystem easier to use. Adapter converts interfaces, Decorator adds behavior, and Proxy controls access.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the primary function of a Data Transfer Object (DTO)?",
    "options": [
      "To execute complex business logic within the database.",
      "To encapsulate data and transfer it between layers or processes, reducing the number of method calls.",
      "To serve as the main entry point for all application requests.",
      "To maintain the state of the user interface."
    ],
    "answer": "To encapsulate data and transfer it between layers or processes, reducing the number of method calls.",
    "explanation": "A DTO is an object that carries data between processes to reduce the number of calls, especially in remote calls. It lacks business logic, unlike Entities or Domain Objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which Behavioral pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified?",
    "options": [
      "Mediator",
      "Observer",
      "State",
      "Visitor"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern (also known as Publish/Subscribe) is used to notify multiple objects about any events that happen to the object they are observing. Mediator reduces chaotic communication.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which architectural pattern focuses on isolating the core business logic from external interfaces and infrastructure using Ports and Adapters?",
    "options": [
      "Hexagonal Architecture",
      "Layered Architecture",
      "Monolithic Architecture",
      "Service-Oriented Architecture (SOA)"
    ],
    "answer": "Hexagonal Architecture",
    "explanation": "Hexagonal Architecture (also known as Ports and Adapters) aims to decouple the application's core logic from external concerns like databases, UIs, or third-party APIs.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "The Dependency Inversion Principle (DIP) suggests that:",
    "options": [
      "High-level modules should not depend on low-level modules; both should depend on abstractions.",
      "Low-level modules should not depend on high-level modules.",
      "Classes should depend only on concrete implementations, not interfaces.",
      "Dependencies should flow from the database towards the user interface."
    ],
    "answer": "High-level modules should not depend on low-level modules; both should depend on abstractions.",
    "explanation": "DIP states that decoupling is achieved by reversing the dependency: high-level policy should not depend on low-level details; both should depend on abstractions.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which pattern provides a surrogate or placeholder for another object to control access to it?",
    "options": [
      "Proxy",
      "Decorator",
      "Flyweight",
      "Bridge"
    ],
    "answer": "Proxy",
    "explanation": "The Proxy pattern provides a representative for another object to control access to it (e.g., for lazy loading, security, or logging). Decorator adds behavior, and Flyweight shares state.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which domain logic pattern organizes business logic primarily around database tables, where each class typically corresponds to a table?",
    "options": [
      "Active Record",
      "Transaction Script",
      "Domain Model",
      "Service Layer"
    ],
    "answer": "Active Record",
    "explanation": "Active Record is an architectural pattern where a model object corresponds to a row in a database table. Transaction Script organizes logic by procedures, and Domain Model uses objects with behavior and data.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which design pattern is used to decouple the abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Bridge",
      "Adapter",
      "Composite",
      "Facade"
    ],
    "answer": "Bridge",
    "explanation": "The Bridge pattern separates an abstraction from its implementation, allowing both to be modified independently without affecting each other. Adapter makes incompatible interfaces work together.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which pattern involves separating the request for an action from the action itself to allow for different trigger mechanisms?",
    "options": [
      "Command Pattern",
      "Mediator Pattern",
      "Iterator Pattern",
      "Interpreter Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern encapsulates a request as an object, allowing for parameterization, queuing, and logging. Mediator reduces coupling between communicating objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is a key characteristic of the 'Transaction Script' pattern?",
    "options": [
      "It organizes business logic into a single procedure that handles all steps of a use case.",
      "It maps database relationships directly to object relationships.",
      "It relies heavily on complex inheritance hierarchies.",
      "It separates the read model from the write model."
    ],
    "answer": "It organizes business logic into a single procedure that handles all steps of a use case.",
    "explanation": "Transaction Script is a procedural design where a single method (or class) handles all the logic for a specific business transaction from start to finish.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which Structural pattern uses sharing to support large numbers of fine-grained objects efficiently?",
    "options": [
      "Flyweight",
      "Proxy",
      "Decorator",
      "Composite"
    ],
    "answer": "Flyweight",
    "explanation": "The Flyweight pattern reduces the cost of complex object models by sharing common state among many objects, rather than storing it in every object.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "In the context of SOA (Service-Oriented Architecture), what acts as the primary interface for consumers?",
    "options": [
      "Service Contract",
      "Database Schema",
      "HTML View",
      "Business Layer"
    ],
    "answer": "Service Contract",
    "explanation": "In SOA, services interact via contracts (often WSDL or OpenAPI). The contract defines the methods and inputs/outputs, hiding internal implementation details.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which pattern defines a distributed add-on structure to help add features to objects dynamically without altering their code?",
    "options": [
      "Decorator",
      "Bridge",
      "Composite",
      "Adapter"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. It provides a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the main trade-off when using a Monolithic architecture compared to Microservices?",
    "options": [
      "Monolithic architectures are easier to deploy initially but become difficult to scale and maintain as the codebase grows.",
      "Monolithic architectures are highly scalable but difficult to test.",
      "Monolithic architectures have zero coupling between modules.",
      "Monolithic architectures require a distributed database to function."
    ],
    "answer": "Monolithic architectures are easier to deploy initially but become difficult to scale and maintain as the codebase grows.",
    "explanation": "Monoliths are simple for early development but hinder scalability and deployment velocity because the entire application must be deployed together, unlike Microservices.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which Gang of Four pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator",
      "Visitor",
      "Memento",
      "Command"
    ],
    "answer": "Iterator",
    "explanation": "The Iterator pattern provides a method to access elements of an aggregate object sequentially without exposing its internal structure. Visitor separates an algorithm from the object structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which pattern best describes an object that intercepts and filters requests to a web application before they reach the core business logic?",
    "options": [
      "Intercepting Filter",
      "Front Controller",
      "View Helper",
      "Dispatcher"
    ],
    "answer": "Intercepting Filter",
    "explanation": "The Intercepting Filter pattern allows pre-processing and post-processing of a request (e.g., authentication, logging) before it reaches the core controller.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which pattern creates a chain of receiver objects for a request, passing the request along the chain until an object handles it?",
    "options": [
      "Chain of Responsibility",
      "Observer",
      "Mediator",
      "State"
    ],
    "answer": "Chain of Responsibility",
    "explanation": "Chain of Responsibility passes a request along a chain of handlers. The request stops when a handler processes it. Observer broadcasts to all listeners.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which Creational pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations?",
    "options": [
      "Builder",
      "Factory Method",
      "Abstract Factory",
      "Prototype"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. Factory Method creates objects via inheritance, and Abstract Factory creates families of related objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "The 'Open/Closed Principle' states that:",
    "options": [
      "Software entities should be open for extension but closed for modification.",
      "Classes should inherit from base classes rather than implementing interfaces.",
      "All methods in a class must be public.",
      "Objects should be loosely coupled but tightly cohesive."
    ],
    "answer": "Software entities should be open for extension but closed for modification.",
    "explanation": "This principle means that a class should be extendable without modifying its existing code, usually via inheritance or interfaces, minimizing bugs.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which pattern uses a shared object to manage communication between multiple objects to prevent tight coupling?",
    "options": [
      "Mediator",
      "Observer",
      "Facade",
      "Adapter"
    ],
    "answer": "Mediator",
    "explanation": "The Mediator pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which design pattern decouples the abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Decorator Pattern",
      "Proxy Pattern"
    ],
    "answer": "Bridge Pattern",
    "explanation": "The Bridge pattern separates abstraction from implementation, allowing both to be modified without affecting the other. Adapter makes incompatible interfaces work together post-hoc. Decorator adds behavior dynamically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In the context of CQRS (Command Query Responsibility Segregation), what is the primary technical trade-off?",
    "options": [
      "Increased latency due to synchronous read/write operations",
      "Simpler data consistency models using ACID transactions only",
      "Complex eventual consistency management between read and write models",
      "Reduced scalability due to shared database schemas"
    ],
    "answer": "Complex eventual consistency management between read and write models",
    "explanation": "CQRS splits read and write models, introducing complexity in synchronizing data (eventual consistency) rather than simplifying it. It improves scalability but complicates transactional integrity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which creational pattern is best utilized when a system must be independent of how its objects are created, composed, and represented, specifically when there are multiple families of related objects?",
    "options": [
      "Builder",
      "Factory Method",
      "Abstract Factory",
      "Prototype"
    ],
    "answer": "Abstract Factory",
    "explanation": "Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes. Factory Method creates a single instance, while Builder focuses on step-by-step construction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which behavioral pattern allows you to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Strategy",
      "Command",
      "Chain of Responsibility",
      "Memento"
    ],
    "answer": "Command",
    "explanation": "The Command pattern turns a request into a stand-alone object containing all information about the request. Strategy encapsulates algorithms, while Memento captures internal state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the specific role of the 'Unit of Work' pattern in enterprise data access?",
    "options": [
      "To abstract the database schema from the business logic",
      "To track changes to objects during a transaction and write them out atomically",
      "To map database rows to object instances dynamically",
      "To provide a read-only view of data to the presentation layer"
    ],
    "answer": "To track changes to objects during a transaction and write them out atomically",
    "explanation": "Unit of Work maintains a list of objects affected by a business transaction and coordinates the writing out of changes. Repository abstracts data access, while Unit of Work manages transaction consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In the Model-View-Controller (MVC) pattern, how is the View technically characterized in a strict passive implementation?",
    "options": [
      "It handles user input logic directly",
      "It modifies the Model based on user actions",
      "It is read-only and strictly renders data provided by the Controller",
      "It contains the business logic for the application"
    ],
    "answer": "It is read-only and strictly renders data provided by the Controller",
    "explanation": "In strict passive MVC, the View displays data but does not process input or directly modify the Model; the Controller handles input and updates the Model. Active MVC patterns may allow the View to pull data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which structural pattern attaches additional responsibilities to an object dynamically at runtime without altering its structure, providing a flexible alternative to subclassing for extending functionality?",
    "options": [
      "Composite",
      "Decorator",
      "Proxy",
      "Adapter"
    ],
    "answer": "Decorator",
    "explanation": "Decorator adds behavior to individual objects dynamically without affecting other objects. Adapter converts interfaces, and Proxy controls access. Subclassing is static.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which pattern ensures that a class has only one instance and provides a global point of access to it, often requiring careful handling in multi-threaded environments?",
    "options": [
      "Monostate",
      "Singleton",
      "Service Locator",
      "Prototype"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. Monostate achieves similar behavior via static fields but technically allows multiple instances with shared state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "When using the Repository pattern, what is the primary technical purpose of separating the data access logic from the business logic?",
    "options": [
      "To increase the speed of database queries",
      "To provide a collection-like interface for accessing domain objects",
      "To automatically generate database schemas",
      "To eliminate the need for an ORM"
    ],
    "answer": "To provide a collection-like interface for accessing domain objects",
    "explanation": "The Repository pattern mimics a collection of domain objects, abstracting the underlying data store and persistence logic. It decouples the domain from data mapping technologies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which behavioral pattern defines a skeleton of an algorithm in a base class, deferring some steps to subclasses without changing the algorithm's structure?",
    "options": [
      "Strategy",
      "Template Method",
      "Builder",
      "State"
    ],
    "answer": "Template Method",
    "explanation": "Template Method defines the algorithm steps in a base class but lets subclasses override the implementation of specific steps. Strategy encapsulates the entire algorithm.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In the context of Enterprise Architecture patterns, what is the specific advantage of the Hexagonal (Ports and Adapters) architecture regarding testing?",
    "options": [
      "It automatically generates unit tests for the codebase",
      "It allows the core domain logic to be tested by swapping adapters for mocks",
      "It enforces a strict database schema requirement",
      "It removes the need for a presentation layer"
    ],
    "answer": "It allows the core domain logic to be tested by swapping adapters for mocks",
    "explanation": "Hexagonal architecture isolates the core logic from external concerns (UI, DB, services) via ports. This allows easy substitution of real adapters with mocks or stubs for testing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which GoF design pattern provides a unified interface to a set of interfaces in a subsystem, effectively defining a higher-level interface that makes the subsystem easier to use?",
    "options": [
      "Facade",
      "Adapter",
      "Bridge",
      "Proxy"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a simplified interface to a complex library, API, or set of classes. Adapter wraps an existing interface to match another, while Bridge decouples abstraction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the primary technical distinction between the 'Strategy' and 'State' patterns?",
    "options": [
      "Strategy is a creational pattern, while State is behavioral",
      "State allows an object to alter its behavior when its internal state changes, while Strategy defines a family of algorithms",
      "Strategy is only used for sorting algorithms",
      "State is used for database transactions, while Strategy is used for UI rendering"
    ],
    "answer": "State allows an object to alter its behavior when its internal state changes, while Strategy defines a family of algorithms",
    "explanation": "State pattern involves the object changing its class (or behavior delegation) based on internal state. Strategy allows the client to swap algorithms explicitly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which structural pattern composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions of objects uniformly?",
    "options": [
      "Decorator",
      "Composite",
      "Flyweight",
      "Chain of Responsibility"
    ],
    "answer": "Composite",
    "explanation": "Composite allows you to treat a group of objects (composites) and individual objects (leaves) identically. Decorator adds behavior, while Flyweight shares intrinsic state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which enterprise pattern is strictly defined as an object that carries data between processes to reduce the number of method calls?",
    "options": [
      "Data Access Object (DAO)",
      "Data Transfer Object (DTO)",
      "Value Object",
      "Entity"
    ],
    "answer": "Data Transfer Object (DTO)",
    "explanation": "A DTO is used to transfer data between layers or processes, often aggregating data to minimize remote call overhead. A Value Object is defined by its attributes equality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In a layered architecture, what is the primary enforcement rule regarding dependencies between layers?",
    "options": [
      "Layers can depend on layers above or below them freely",
      "Upper layers can depend on lower layers, but lower layers must not depend on upper layers",
      "Only the database layer can be accessed by the presentation layer",
      "Dependencies are circular to ensure data consistency"
    ],
    "answer": "Upper layers can depend on lower layers, but lower layers must not depend on upper layers",
    "explanation": "Strict layered architecture enforces that dependencies flow downwards (Presentation -> Business -> Persistence). A lower layer depending on an upper layer creates tight coupling and circular dependencies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which pattern acts as a surrogate or placeholder for another object to control access to it, commonly used for lazy loading, access control, or logging?",
    "options": [
      "Proxy",
      "Decorator",
      "Prototype",
      "Flyweight"
    ],
    "answer": "Proxy",
    "explanation": "The Proxy pattern provides a representative object to control access to another object. Decorator adds responsibility, while Proxy manages access or instantiation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which creational pattern creates new objects by cloning a prototype instance rather than creating them from scratch, useful when creating a new object is expensive?",
    "options": [
      "Builder",
      "Prototype",
      "Singleton",
      "Factory Method"
    ],
    "answer": "Prototype",
    "explanation": "The Prototype pattern specifies the kinds of objects to create using a prototypical instance. Cloning the prototype is more efficient than resource-intensive initialization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which behavioral pattern avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request?",
    "options": [
      "Command",
      "Chain of Responsibility",
      "Mediator",
      "Observer"
    ],
    "answer": "Chain of Responsibility",
    "explanation": "Chain of Responsibility passes a request along a chain of potential receivers until one handles it. Command encapsulates a specific request.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the primary technical motivation for using the 'Data Mapper' pattern over 'Active Record'?",
    "options": [
      "Data Mapper is easier to implement for simple applications",
      "Data Mapper separates the in-memory object from the database schema completely",
      "Active Record provides better support for complex domain logic",
      "Data Mapper requires the domain object to inherit from a base class"
    ],
    "answer": "Data Mapper separates the in-memory object from the database schema completely",
    "explanation": "Data Mapper moves data between objects and a database while keeping them independent of each other. Active Record couples the object and the schema, often mixing business logic with SQL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly?",
    "options": [
      "Facade",
      "Mediator",
      "Observer",
      "Bridge"
    ],
    "answer": "Mediator",
    "explanation": "The Mediator pattern centralizes communication between colleague objects. Facade simplifies a single subsystem interface, while Mediator manages interaction between multiple objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which behavioral pattern represents an operation to be performed on the elements of an object structure, allowing you to define a new operation without changing the classes of the elements on which it operates?",
    "options": [
      "Visitor",
      "Iterator",
      "Command",
      "Interpreter"
    ],
    "answer": "Visitor",
    "explanation": "The Visitor pattern separates an algorithm from the object structure it operates on. Iterator just traverses the structure; Visitor adds operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "In the context of Microservices architecture, which pattern addresses the problem of querying data from multiple services efficiently by maintaining a separate read-only view?",
    "options": [
      "Database per Service",
      "Shared Database",
      "API Gateway",
      "CQRS with Read Replica"
    ],
    "answer": "CQRS with Read Replica",
    "explanation": "In Microservices, CQRS is often used where a service (or an aggregate) has a separate optimized read model to handle complex queries joining data from other services, avoiding direct DB access across services.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which structural pattern uses sharing to support large numbers of fine-grained objects efficiently, reducing memory usage by sharing intrinsic state?",
    "options": [
      "Flyweight",
      "Proxy",
      "Composite",
      "Decorator"
    ],
    "answer": "Flyweight",
    "explanation": "Flyweight minimizes memory usage by sharing data (intrinsic state) with other similar objects. Composite structures objects; Flyweight optimizes storage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which pattern is specifically designed to intercept and manage method calls to an object to implement features like declarative transaction management or security checks in a framework?",
    "options": [
      "Decorator",
      "Proxy",
      "Adapter",
      "Bridge"
    ],
    "answer": "Proxy",
    "explanation": "Specifically the Dynamic Proxy pattern (or JDK/CGLIB proxies) is used to wrap classes to inject cross-cutting concerns like transactions or security transparently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "In the context of Domain-Driven Design (DDD), which pattern represents a conceptual whole that can be treated as a single unit regarding data changes?",
    "options": [
      "Value Object",
      "Entity",
      "Aggregate",
      "Repository"
    ],
    "answer": "Aggregate",
    "explanation": "An Aggregate is a cluster of domain objects that can be treated as a single unit. It enforces consistency boundaries (invariants) within itself.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which behavioral pattern allows a number of observer objects to see an event (notify) and automatically update themselves when the state of a subject object changes?",
    "options": [
      "Observer",
      "Mediator",
      "State",
      "Visitor"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern defines a subscription mechanism to notify multiple objects about events. Mediator encapsulates how objects interact.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which creational pattern is specifically aimed at separating the construction of a complex object from its representation, allowing the same construction process to create different representations?",
    "options": [
      "Abstract Factory",
      "Builder",
      "Prototype",
      "Factory Method"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. Abstract Factory focuses on families of objects, while Builder focuses on step-by-step construction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the primary technical disadvantage of using the 'Monolithic Architecture' pattern compared to 'Microservices' regarding scalability?",
    "options": [
      "Monolithic applications are always slower to write",
      "The entire application must be scaled as a whole even if only one component is under load",
      "Monolithic applications cannot use databases",
      "Microservices cannot be deployed independently"
    ],
    "answer": "The entire application must be scaled as a whole even if only one component is under load",
    "explanation": "In a Monolith, scalability is applied to the entire application stack rather than specific bottlenecks. Microservices allow scaling specific services independently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which pattern is used to defer the instantiation of an object until it is actually needed, and is often implemented using a virtual proxy?",
    "options": [
      "Lazy Loading",
      "Eager Loading",
      "Object Pool",
      "Singleton"
    ],
    "answer": "Lazy Loading",
    "explanation": "Lazy Loading delays initialization. The Proxy pattern is the standard mechanism to achieve this transparently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "In a strictly typed language, which design pattern allows incompatible interfaces to work together without modifying their source code?",
    "options": [
      "Bridge",
      "Decorator",
      "Adapter",
      "Facade"
    ],
    "answer": "Adapter",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. Facade simplifies an interface but does not typically adapt for incompatibility.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which architectural pattern defines a mechanism that transforms a request into a stand-alone object that contains all information about the request, facilitating queuing and logging?",
    "options": [
      "Service Locator",
      "Command",
      "Dispatcher",
      "Interceptor"
    ],
    "answer": "Command",
    "explanation": "This is the core definition of the Command pattern, allowing requests to be issued, stored, and processed later.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What distinguishes a 'Value Object' in DDD from a standard Entity?",
    "options": [
      "A Value Object has an identity that persists over time, while an Entity does not",
      "A Value Object is identified by its attributes rather than a specific identity",
      "Value Objects are always mutable",
      "Entities are immutable"
    ],
    "answer": "A Value Object is identified by its attributes rather than a specific identity",
    "explanation": "Value Objects are immutable and defined by their attributes (e.g., Date, Money). Entities are defined by a unique ID regardless of their attribute changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which anti-pattern occurs when a UI component (like a Controller in MVC) directly contains business logic instead of delegating it to a service layer?",
    "options": [
      "Shotgun Surgery",
      "Golden Hammer",
      "Transaction Script",
      "Anemic Domain Model"
    ],
    "answer": "Transaction Script",
    "explanation": "Transaction Script organizes business logic primarily as a single procedure (often in a controller). While a valid pattern for simple logic, it is an anti-pattern in complex domains compared to Domain Models.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which design principle (SOLID) is most directly supported by the 'Dependency Injection' and 'Service Locator' patterns?",
    "options": [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Dependency Inversion Principle",
      "Liskov Substitution Principle"
    ],
    "answer": "Dependency Inversion Principle",
    "explanation": "The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. DI and Service Locator facilitate this by injecting dependencies rather than hard-coding them.",
    "difficulty": "Intermediate"
  }
]