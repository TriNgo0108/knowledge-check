[
  {
    "id": 1,
    "question": "What is the primary benefit of the React Compiler introduced in the text?",
    "options": [
      "It automatically writes unit tests for components",
      "It handles memoization and performance tuning automatically at build time",
      "It converts React code into Vue or Svelte automatically",
      "It replaces the need for TypeScript in large applications"
    ],
    "answer": "It handles memoization and performance tuning automatically at build time",
    "explanation": "The React Compiler optimizes code by handling memoization and performance tuning automatically during the build process. This removes the need for developers to manually implement many performance optimizations, allowing them to focus on writing straightforward components.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "According to the 2026 trends described, which manual optimization pattern is considered legacy?",
    "options": [
      "Using CSS for styling",
      "Writing functional components",
      "Manually using useMemo, useCallback, and React.memo",
      "Using arrow functions for event handlers"
    ],
    "answer": "Manually using useMemo, useCallback, and React.memo",
    "explanation": "With the release of the React Compiler, manually using hooks like useMemo and useCallback, or the higher-order component React.memo, is viewed as a legacy optimization. The compiler now handles these tasks automatically.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "How does the React Compiler affect the developer experience for newcomers?",
    "options": [
      "It forces them to learn complex optimization patterns immediately",
      "It removes the need to learn JavaScript syntax",
      "It allows them to focus on behavior and structure instead of optimization",
      "It automatically generates the entire application code"
    ],
    "answer": "It allows them to focus on behavior and structure instead of optimization",
    "explanation": "The compiler lowers the barrier for new developers by handling performance optimizations automatically. This allows newcomers to concentrate on the behavior and structure of the application without worrying about fine-tuning performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "When was the React Compiler v1.0 released?",
    "options": [
      "October 2024",
      "October 2025",
      "January 2026",
      "December 2023"
    ],
    "answer": "October 2025",
    "explanation": "The source text states that the React Compiler v1.0 was released in October 2025, leading to increased adoption and integration into major platforms.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is a primary advantage of using React Server Components?",
    "options": [
      "They allow the browser to handle all database queries",
      "They fetch data and render UI on the server with zero client-side JavaScript for those parts",
      "They eliminate the need for a backend server entirely",
      "They force the entire application to run on the client's GPU"
    ],
    "answer": "They fetch data and render UI on the server with zero client-side JavaScript for those parts",
    "explanation": "React Server Components enable data fetching and UI rendering on the server. This means that specific parts of the UI can be sent to the client without sending the corresponding JavaScript, improving performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which runtime are developers increasingly leaning on when using React Server Components?",
    "options": [
      "Browser runtimes",
      "Mainframe runtimes",
      "Edge runtimes",
      "Mobile runtimes"
    ],
    "answer": "Edge runtimes",
    "explanation": "Developers are increasingly relying on edge runtimes to execute server functions and components, allowing for faster data processing closer to the user.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "In the context of modern web development, what has become a 'first-class design decision'?",
    "options": [
      "Choosing the color palette for the UI",
      "Deciding 'what runs where' (client vs. server)",
      "Selecting the font family for the website",
      "Deciding whether to use a mouse or a keyboard"
    ],
    "answer": "Deciding 'what runs where' (client vs. server)",
    "explanation": "With the rise of Server Components and edge computing, determining which code runs on the client and which runs on the server is now a primary design decision rather than an afterthought.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What performance improvement did case studies report when adopting Server Components alongside Next.js?",
    "options": [
      "Initial render times dropping from 2.4s to 0.8s",
      "Application size increasing by 50%",
      "Database query times doubling",
      "Load times staying exactly the same"
    ],
    "answer": "Initial render times dropping from 2.4s to 0.8s",
    "explanation": "Case studies indicated a significant performance boost, with initial render times dropping from about 2.4 seconds to 0.8 seconds (a ~67% improvement) when adopting Server Components.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "How is the loading state handled when using the `use()` hook with Suspense?",
    "options": [
      "It requires manual `isLoading` state variables",
      "It is handled automatically by the Suspense boundary",
      "It displays a native browser alert",
      "It causes the application to crash until data is loaded"
    ],
    "answer": "It is handled automatically by the Suspense boundary",
    "explanation": "When using the `use()` hook for data fetching, the Suspense boundary automatically manages the loading state, removing the need for developers to manually track `isLoading` variables.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which mechanism handles error states automatically when using the `use()` hook?",
    "options": [
      "Try/catch blocks inside the component",
      "Error Boundaries",
      "Manual `error` state variables",
      "The browser's console log"
    ],
    "answer": "Error Boundaries",
    "explanation": "The `use()` hook pattern relies on Error Boundaries to handle error states automatically, similar to how Suspense handles loading states.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "According to the text, when is `useEffect` the appropriate hook to use?",
    "options": [
      "For fetching data in Server Components",
      "For reading context conditionally",
      "For subscriptions and event listeners",
      "For managing loading states with Suspense"
    ],
    "answer": "For subscriptions and event listeners",
    "explanation": "While `use()` is preferred for data fetching, `useEffect` remains the correct tool for setting up subscriptions, event listeners, and synchronizing with non-React systems.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What common issue associated with `useEffect` does the `use()` hook help avoid?",
    "options": [
      "Type errors",
      "Race conditions",
      "Syntax errors",
      "Memory leaks in server components"
    ],
    "answer": "Race conditions",
    "explanation": "The `use()` hook, combined with Suspense, automatically handles race conditions that often occur with data fetching in `useEffect`, which usually requires manual cleanup to prevent.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Is the `use()` hook compatible with React Server Components?",
    "options": [
      "No, it only works in client components",
      "Yes, it works seamlessly",
      "Only with strict configuration",
      "Only for legacy React applications"
    ],
    "answer": "Yes, it works seamlessly",
    "explanation": "Unlike `useEffect`, which is client-only, the `use()` hook works seamlessly with Server Components, making it suitable for modern data fetching patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "How do React official docs describe `useEffect` in the current paradigm?",
    "options": [
      "The primary way to fetch data",
      "An escape hatch from the React paradigm",
      "The preferred method for all state management",
      "A required hook for every component"
    ],
    "answer": "An escape hatch from the React paradigm",
    "explanation": "The official React documentation describes `useEffect` as an 'escape hatch' to be used for specific side effects like subscriptions, rather than the default method for data fetching.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which React Hook is inspired by Redux and used for managing complex state logic?",
    "options": [
      "useState",
      "useEffect",
      "useReducer",
      "useContext"
    ],
    "answer": "useReducer",
    "explanation": "`useReducer` is a Hook inspired by Redux. It is specifically designed to manage complex state logic that involves multiple sub-values or intricate update transitions.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "When is `useReducer` preferred over `useState`?",
    "options": [
      "For storing simple string values",
      "When state logic is complex with multiple sub-values",
      "For rendering static HTML content",
      "When you need to perform automatic network requests"
    ],
    "answer": "When state logic is complex with multiple sub-values",
    "explanation": "`useReducer` is preferred when the state logic involves multiple sub-values or when the next state depends on the previous one, making it better suited for complexity than `useState`.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What potential bug can occur when using `setState` in async handlers with stale state?",
    "options": [
      "The state updates too quickly",
      "The component unmounts unexpectedly",
      "Updates rely on old state values and may be lost",
      "The application becomes offline-only"
    ],
    "answer": "Updates rely on old state values and may be lost",
    "explanation": "In async handlers, if you read state directly to set the next state, the state value might be stale (old) by the time the update runs. This can lead to bugs where updates are overwritten or ignored.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "How does `useReducer` update the state?",
    "options": [
      "By directly modifying the state variable",
      "By calling a server endpoint",
      "Through a reducer function",
      "By using a CSS animation"
    ],
    "answer": "Through a reducer function",
    "explanation": "`useReducer` updates state by passing the current state and an action to a reducer function, which then returns the new state. This ensures predictable state updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is tRPC an example of in the context of 2026 web trends?",
    "options": [
      "A database management system",
      "A styling library",
      "End-to-end type safety without schemas to sync",
      "A cloud hosting provider"
    ],
    "answer": "End-to-end type safety without schemas to sync",
    "explanation": "tRPC allows frontend code to call backend functions with full type inference, removing the need to manually sync API schemas or maintain separate types.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What role does TypeScript play in the convergence of frontend and backend?",
    "options": [
      "It is used exclusively for CSS animations",
      "It is a key enabler for scaling typed functions across client and server",
      "It replaces the need for HTML",
      "It is only used for writing unit tests"
    ],
    "answer": "It is a key enabler for scaling typed functions across client and server",
    "explanation": "TypeScript is crucial for the backend/frontend convergence because it allows developers to express backends as typed functions, ensuring type safety across the entire stack.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What does the analogy 'pushing more work into the back kitchen' refer to?",
    "options": [
      "Hiring more chefs to code",
      "Moving data fetching and rendering to the server",
      "Using faster computers for development",
      "Writing more CSS on the client side"
    ],
    "answer": "Moving data fetching and rendering to the server",
    "explanation": "The analogy refers to Server Components and server-side logic. By doing the heavy lifting (data fetching/rendering) on the server ('back kitchen'), the client ('front of house') stays calm and responsive.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "How has AI-assisted development changed in 2026 according to the text?",
    "options": [
      "It has become a novelty that no one uses",
      "It has moved from a novelty to a standard appliance",
      "It is only used for debugging",
      "It has been banned by major tech companies"
    ],
    "answer": "It has moved from a novelty to a standard appliance",
    "explanation": "AI tools like GitHub Copilot and v0 have transitioned from experimental novelties to standard appliances in the developer workflow.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the function of `React.memo`?",
    "options": [
      "To store component history",
      "To memoize a component to prevent unnecessary re-renders",
      "To automatically generate API documentation",
      "To convert functional components to class components"
    ],
    "answer": "To memoize a component to prevent unnecessary re-renders",
    "explanation": "`React.memo` is a higher-order component that memoizes the result, meaning if props haven't changed, React skips rendering the component. However, the compiler is making this manual step less necessary.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What UI pattern is used to display a fallback while a component using `use()` is waiting for data?",
    "options": [
      "Error Boundary",
      "Suspense boundary",
      "Strict Mode",
      "Concurrent Mode"
    ],
    "answer": "Suspense boundary",
    "explanation": "A Suspense boundary wraps components that use the `use()` hook for data fetching. It displays a fallback UI (like a loading spinner) while the data is being loaded.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What happens to all components consuming a Context when the context value changes?",
    "options": [
      "Only the first component re-renders",
      "Only the last component re-renders",
      "All components consuming that context re-render",
      "No components re-render to save performance"
    ],
    "answer": "All components consuming that context re-render",
    "explanation": "A performance note in the text states that all components consuming a context will re-render whenever the context value changes, which is an important consideration for large applications.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the specific purpose of the `useCallback` hook?",
    "options": [
      "To memoize a function reference between renders",
      "To fetch data from an API",
      "To manage the DOM directly",
      "To handle form submissions"
    ],
    "answer": "To memoize a function reference between renders",
    "explanation": "`useCallback` returns a memoized callback function that only changes if one of its dependencies changes. Like `useMemo`, the React Compiler reduces the need for manual `useCallback` usage.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the specific purpose of the `useMemo` hook?",
    "options": [
      "To memoize a calculated value between renders",
      "To manage complex state logic",
      "To handle side effects like API calls",
      "To create references to DOM elements"
    ],
    "answer": "To memoize a calculated value between renders",
    "explanation": "`useMemo` is used to cache the result of a calculation so that it is only recomputed when specific dependencies change. The text notes this is becoming a legacy pattern due to the compiler.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What do AI tools like GitHub Copilot and Vercel v0 primarily generate to save developer time?",
    "options": [
      "Final product marketing strategies",
      "Boilerplate components, routes, and tests",
      "Database server hardware",
      "Legal contracts for software licensing"
    ],
    "answer": "Boilerplate components, routes, and tests",
    "explanation": "AI tools are used to generate repetitive boilerplate code such as components, routes, and tests, allowing developers to spend more time on architecture and logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Why does the text say the React Compiler lowers the barrier for new developers?",
    "options": [
      "It writes code for them without any input",
      "It allows them to focus on behavior and structure",
      "It removes the need to learn JavaScript",
      "It makes the application run without a server"
    ],
    "answer": "It allows them to focus on behavior and structure",
    "explanation": "Because the compiler handles performance optimizations, new developers don't need to immediately learn complex optimization patterns. They can focus on learning the core behavior and structure of React components.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which of the following platforms has integrated the React Compiler into their tooling?",
    "options": [
      "WordPress and Drupal",
      "Next.js, Vite, and Expo",
      "Angular and Vue",
      "Laravel and Django"
    ],
    "answer": "Next.js, Vite, and Expo",
    "explanation": "Major platforms in the React ecosystem, specifically Next.js 16, Vite, and Expo, have integrated the React Compiler to make it part of the default setup.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "According to the text, roughly what percentage of professional front-end usage does React account for?",
    "options": [
      "Over 40%",
      "Less than 10%",
      "Exactly 25%",
      "About 90%"
    ],
    "answer": "Over 40%",
    "explanation": "The text states that React accounts for over 40% of professional front-end usage, highlighting its dominance and importance in the job market.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which framework formalized features such as Partial Prerendering and Cache Components?",
    "options": [
      "Angular",
      "Svelte",
      "Next.js 16",
      "React Native"
    ],
    "answer": "Next.js 16",
    "explanation": "Next.js 16 formalized features like Partial Prerendering and Cache Components, which help blend static shells with dynamic regions.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is Partial Prerendering?",
    "options": [
      "Rendering only half of a component",
      "Blending static shells with dynamic regions in a single route",
      "Pre-rendering the application only on mobile devices",
      "Deleting parts of the code to make it faster"
    ],
    "answer": "Blending static shells with dynamic regions in a single route",
    "explanation": "Partial Prerendering is a feature that allows developers to serve a static shell (the static part) immediately while streaming dynamic content (the dynamic region) as it becomes ready.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What does tRPC allow frontend developers to do regarding backend functions?",
    "options": [
      "Call backend functions with full type inference",
      "Rewrite backend functions in Python",
      "Ignore backend function return types",
      "Only call backend functions via HTTP URLs"
    ],
    "answer": "Call backend functions with full type inference",
    "explanation": "tRPC enables the frontend to call backend functions as if they were local functions, with full type inference ensuring that the types match automatically.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Do AI tools remove the need for developers to understand state, data flow, performance, and security?",
    "options": [
      "Yes, AI handles all of this automatically",
      "No, they only make it easier to express those decisions",
      "Yes, developers can forget about security completely",
      "No, but AI will eventually replace developers entirely"
    ],
    "answer": "No, they only make it easier to express those decisions",
    "explanation": "The text emphasizes that AI tools do not remove the need to understand core concepts like state and security; they simply reduce the boilerplate required to implement them.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "According to the 2026 trends described, what is the primary impact of the React Compiler on everyday development patterns involving `useMemo` and `useCallback`?",
    "options": [
      "It enforces strict mandatory usage of these hooks in all components",
      "It renders manual usage of these hooks largely unnecessary for everyday optimization",
      "It automatically refactors all class components to use these hooks",
      "It deprecates these hooks and removes them from the React API entirely"
    ],
    "answer": "It renders manual usage of these hooks largely unnecessary for everyday optimization",
    "explanation": "With the release of the React Compiler, memoization and performance tuning are handled automatically at build time. This allows developers to write simpler code without manually wrapping every function or value in `useMemo` or `useCallback`, treating these manual optimizations as legacy patterns for specific edge cases rather than daily requirements.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "A team adopts React Server Components and reports that the initial render time for a specific route dropped from 2.4s to 0.8s. What is the approximate percentage improvement in performance?",
    "options": [
      "33%",
      "50%",
      "67%",
      "75%"
    ],
    "answer": "67%",
    "explanation": "The case studies in the text highlight a ~67% improvement in initial render times (dropping from 2.4s to 0.8s) when teams adopt Server Components alongside frameworks like Next.js. This significant gain is achieved by fetching data and rendering UI on the server, sending zero client-side JavaScript for those static parts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When using the new `use()` API for data fetching compared to `useEffect`, how is the loading state managed?",
    "options": [
      "It requires a manual `isLoading` boolean state variable",
      "It is handled automatically by the nearest Suspense boundary",
      "It uses a global loading spinner defined in the root component",
      "It is inferred from the promise's pending status via a custom hook"
    ],
    "answer": "It is handled automatically by the nearest Suspense boundary",
    "explanation": "The `use()` API is designed to work with Suspense. Unlike `useEffect`, which requires manual state management for loading (e.g., `const [isLoading, setIsLoading] = useState(true)`), `use()` lets Suspense handle the loading state automatically, reducing boilerplate and race condition complexity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is a primary benefit of using tRPC to express the backend as typed functions rather than traditional REST services?",
    "options": [
      "It eliminates the need for a database",
      "It ensures end-to-end type safety without manual schema syncing",
      "It automatically caches all responses on the client forever",
      "It allows the backend to run directly in the user's browser"
    ],
    "answer": "It ensures end-to-end type safety without manual schema syncing",
    "explanation": "tRPC allows the frontend to call backend functions with full type inference. This removes the need to maintain separate API schemas or manual types; the client and server scale together guided by the same TypeScript system, preventing an entire class of API contract mismatches.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In the context of `useState` vs `useReducer`, when is it specifically recommended to use `useReducer`?",
    "options": [
      "When managing simple, independent boolean flags",
      "When state logic is complex with multiple sub-values or intricate update logic",
      "When you need to optimize the re-rendering of child components via props",
      "When the state consists of a single string or number value"
    ],
    "answer": "When state logic is complex with multiple sub-values or intricate update logic",
    "explanation": "`useReducer` is preferred when the next state depends on the previous one, or when the state structure is complex (e.g., multiple sub-values). It is inspired by Redux and helps manage complex state transitions more predictably than multiple `useState` calls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the specific behavior issue that can occur when using `setCount(count + 1)` inside an asynchronous handler compared to using the functional update form?",
    "options": [
      "It causes the component to unmount immediately",
      "It leads to stale state bugs if the handler reads an old `count` value from the closure",
      "It prevents the component from re-rendering entirely",
      "It triggers an infinite loop of re-renders"
    ],
    "answer": "It leads to stale state bugs if the handler reads an old `count` value from the closure",
    "explanation": "In async handlers (like setTimeout or API responses), reading `count` directly captures the value at the time the handler was created (stale closure). If multiple updates happen, they may all read the same initial value. The functional update form `setCount(c => c + 1)` ensures the update is based on the most recent state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "How does Partial Prerendering (PPR) in Next.js 16 combine static and dynamic content?",
    "options": [
      "It renders the entire page on the client side using JavaScript",
      "It serves a static shell while streaming dynamic regions as they become ready",
      "It forces all dynamic regions to load before the static shell is visible",
      "It separates static and dynamic content into completely different HTML files"
    ],
    "answer": "It serves a static shell while streaming dynamic regions as they become ready",
    "explanation": "Partial Prerendering blends static shells with dynamic regions in a single route. It serves the static HTML immediately (improving Time to First Byte) while the dynamic parts are streamed in as they finish processing, effectively keeping the 'front of house calm' while work happens 'in the back kitchen'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Why is `useEffect` now considered an 'escape hatch' rather than the primary tool for data fetching in modern React?",
    "options": [
      "Because `useEffect` does not support asynchronous functions",
      "Because data fetching is better handled by the `use()` API and Server Components to avoid manual boilerplate and race conditions",
      "Because `useEffect` is deprecated and removed from React 19",
      "Because `useEffect` cannot handle errors in API calls"
    ],
    "answer": "Because data fetching is better handled by the `use()` API and Server Components to avoid manual boilerplate and race conditions",
    "explanation": "The React community has shifted away from `useEffect` for data fetching because it requires manual management of loading states, error states, and cleanup for race conditions. The `use()` API combined with Suspense and Server Components handles these concerns automatically at the framework level.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which specific programming pattern allows for reading context values conditionally without violating the Rules of Hooks?",
    "options": [
      "useReducer",
      "useContext",
      "use()",
      "useState"
    ],
    "answer": "use()",
    "explanation": "Unlike `useContext`, which must be called unconditionally at the top level, the `use()` API allows for conditional reading of context and resources. This provides more flexibility in component logic while maintaining the benefits of React's reactivity system.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the main architectural shift implied by 'Server-first' architectures in 2026 regarding decision making?",
    "options": [
      "Deciding where code runs (server vs client) is an afterthought",
      "Deciding 'what runs where' is a first-class design decision",
      "Running absolutely all code on the server to minimize client bandwidth",
      "Running absolutely all code on the client to reduce server load"
    ],
    "answer": "Deciding 'what runs where' is a first-class design decision",
    "explanation": "With the rise of Server Components and Edge runtimes, developers must consciously decide which parts of an application run on the server versus the client. This allocation is now a fundamental architectural choice that affects performance, interactivity, and data flow.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "When should a developer still prefer `useEffect` over the `use()` API?",
    "options": [
      "For fetching data in Server Components",
      "For reading context values inside a loop",
      "For subscriptions and event listeners that need cleanup",
      "For managing complex state objects derived from props"
    ],
    "answer": "For subscriptions and event listeners that need cleanup",
    "explanation": "While `use()` is excellent for data fetching and resources, `useEffect` remains the correct tool for side effects that involve the external browser environment, such as setting up event listeners, subscriptions, or manually manipulating the DOM, which require explicit cleanup logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "How does the React Compiler specifically lower the barrier to entry for newer developers?",
    "options": [
      "By writing the entire application code for them",
      "By removing the need to learn TypeScript",
      "By allowing them to focus on behavior and structure rather than optimization patterns",
      "By automatically fixing all logical bugs in the code"
    ],
    "answer": "By allowing them to focus on behavior and structure rather than optimization patterns",
    "explanation": "Previously, developers needed deep knowledge of memoization (`useMemo`, `React.memo`) to avoid performance pitfalls. The Compiler handles these optimizations automatically, allowing newer developers to write straightforward, idiomatic React code without worrying about premature optimization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is a common performance consideration when using React Context in large applications?",
    "options": [
      "Context values are immutable and cannot be updated",
      "All components consuming a context re-render when the context value changes",
      "Context can only hold string values",
      "Context providers automatically debounce updates to improve performance"
    ],
    "answer": "All components consuming a context re-render when the context value changes",
    "explanation": "A common performance pitfall of Context is that any component consuming it will re-render whenever the provider's value changes, even if the specific piece of data it cares about didn't change. For large apps, it is often recommended to split contexts or use external state management libraries to mitigate unnecessary renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which of the following accurately describes the error handling mechanism of `use()` + Suspense compared to `useEffect`?",
    "options": [
      "`use()` requires try/catch blocks in every component",
      "`useEffect` relies on Error Boundaries, while `use()` requires manual error state",
      "`use()` relies on Error Boundaries, while `useEffect` requires manual error state",
      "Both methods handle errors identically using manual state"
    ],
    "answer": "`use()` relies on Error Boundaries, while `useEffect` requires manual error state",
    "explanation": "When using `use()`, errors are thrown and caught by the nearest React Error Boundary, allowing for centralized error UI. With `useEffect`, developers must manually catch errors and set an `error` state variable to conditionally render an error message.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In the 2026 ecosystem, which tooling platforms have integrated the React Compiler as part of the default setup?",
    "options": [
      "Create React App and Gatsby",
      "Next.js 16, Vite, and Expo",
      "Angular CLI and Vue CLI",
      "Webpack and Parcel only"
    ],
    "answer": "Next.js 16, Vite, and Expo",
    "explanation": "Major platforms like Next.js 16, Vite, and Expo have moved to integrate the React Compiler directly into their toolchains. This makes the compiler a standard part of the default setup for new applications rather than an experimental add-on.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "Why might a developer choose to use `useReducer` even if the state logic isn't strictly complex?",
    "options": [
      "Because it is always faster than useState",
      "Because the reducer function makes it easier to test state transitions in isolation",
      "Because it allows accessing the previous state without a functional update",
      "Because it automatically persists state to local storage"
    ],
    "answer": "Because the reducer function makes it easier to test state transitions in isolation",
    "explanation": "A key benefit of `useReducer` (and Redux patterns) is that state update logic is encapsulated in a pure reducer function. This allows developers to test state transitions easily by passing a specific state and action to the reducer and asserting on the output, without needing to render the component.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What does the text identify as the unifying patterns across major frameworks (React, Vue, Angular, Svelte) in 2026?",
    "options": [
      "Class-based components, manual DOM manipulation, and jQuery integration",
      "Fine-grained reactivity, server-first architectures, compiler optimizations, and AI assistance",
      "Virtual DOM, WebAssembly, and GraphQL",
      "Prop drilling, component inheritance, and mixins"
    ],
    "answer": "Fine-grained reactivity, server-first architectures, compiler optimizations, and AI assistance",
    "explanation": "The text highlights that these four patterns—fine-grained reactivity, server-first architectures, compiler-driven optimizations, and AI-assisted workflows—are converging across the major JavaScript frameworks, defining the landscape of web development in 2026.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the role of AI-assisted tools (like GitHub Copilot or v0) in the 2026 development workflow?",
    "options": [
      "They replace the need for developers to write any code",
      "They handle boilerplate generation so developers can focus on architecture",
      "They automatically audit code for security vulnerabilities in real-time",
      "They deploy applications to production without human intervention"
    ],
    "answer": "They handle boilerplate generation so developers can focus on architecture",
    "explanation": "AI tools are used to generate standard boilerplate components, routes, and tests. This shifts the developer's role from writing repetitive wiring code to focusing on higher-level architecture, state management, and business logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What happens to the client-side JavaScript payload when using React Server Components effectively?",
    "options": [
      "It increases significantly to support server communication",
      "It decreases to zero for the parts of the UI rendered on the server",
      "It remains exactly the same as a standard Client Component",
      "It is moved entirely to WebAssembly"
    ],
    "answer": "It decreases to zero for the parts of the UI rendered on the server",
    "explanation": "React Server Components render to HTML on the server. For those specific parts of the UI, no corresponding JavaScript is sent to the client to render them, drastically reducing the client-side bundle size for static or data-driven content.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Why is TypeScript described as 'key' to the backend-as-functions pattern mentioned in the text?",
    "options": [
      "It compiles Python code to JavaScript",
      "It enables shared types between frontend and backend, ensuring contracts are always in sync",
      "It is the only language that Edge Runtimes support",
      "It automatically generates SQL queries for the database"
    ],
    "answer": "It enables shared types between frontend and backend, ensuring contracts are always in sync",
    "explanation": "TypeScript allows the backend to be expressed as typed functions that the frontend can import directly. This shared type system ensures that if the backend signature changes, the frontend will know immediately, removing the 'API contract' mismatch problem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the primary disadvantage of using `useEffect` for data fetching that `use()` with Suspense solves?",
    "options": [
      "`useEffect` cannot handle asynchronous operations",
      "Significant boilerplate code for loading, error, and race condition management",
      "`useEffect` causes the browser to crash on network errors",
      "`useEffect` is incompatible with TypeScript"
    ],
    "answer": "Significant boilerplate code for loading, error, and race condition management",
    "explanation": "Using `useEffect` for data fetching requires the developer to manually implement `isLoading` flags, `try/catch` blocks for errors, and cleanup functions or abort controllers to handle race conditions. The `use()` API integrates with Suspense to handle these concerns implicitly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "How does the React Compiler handle code optimization differently than manual memoization?",
    "options": [
      "It operates at runtime on every user interaction",
      "It analyzes and optimizes code at build time",
      "It requires developers to annotate every function with a special comment",
      "It only optimizes components written in JavaScript, not TypeScript"
    ],
    "answer": "It analyzes and optimizes code at build time",
    "explanation": "The React Compiler optimizes code during the build process. It verifies the dependencies of hooks and components automatically, ensuring that re-renders are skipped when values haven't actually changed, without the developer needing to manually specify dependency arrays.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "When is it explicitly appropriate to still use `React.memo` despite the availability of the React Compiler?",
    "options": [
      "For every component in the application",
      "For components that rely heavily on external non-React state or refs",
      "Only for components defined in a separate file",
      "Never, it is completely removed from the library"
    ],
    "answer": "For components that rely heavily on external non-React state or refs",
    "explanation": "While the compiler handles most re-rendering optimization, edge cases involving external systems or refs that the compiler cannot fully analyze may still require `React.memo`. However, for standard everyday development, the text suggests it is largely unnecessary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is 'Partial Prerendering' in the context of Next.js 16?",
    "options": [
      "A method to render only half of the CSS",
      "Blending a static shell with dynamic regions in a single route",
      "Rendering the page only on mobile devices first",
      "Caching the entire page in the service worker"
    ],
    "answer": "Blending a static shell with dynamic regions in a single route",
    "explanation": "Partial Prerendering allows developers to define parts of a route as static (prerendered) and other parts as dynamic. This enables the static parts to load instantly while the dynamic parts are fetched and streamed in, improving perceived performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which of the following best describes 'fine-grained reactivity' as a trend in 2026?",
    "options": [
      "Re-rendering the entire application on every state change",
      "Updating only the specific DOM nodes affected by a state change",
      "Using only variables that are 'fine' in size",
      "Avoiding state management entirely"
    ],
    "answer": "Updating only the specific DOM nodes affected by a state change",
    "explanation": "Fine-grained reactivity refers to frameworks and patterns (often seen in Solid.js or React's compiler optimizations) that track dependencies precisely, so a state update only triggers re-renders for the specific components or DOM elements that actually use that data, rather than large component trees.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the 'Escape Hatch' analogy referring to in the official React documentation regarding `useEffect`?",
    "options": [
      "A way to quickly exit the application",
      "A mechanism to step outside the standard React data flow to synchronize with external systems",
      "A method to speed up rendering times",
      "A security feature to prevent XSS attacks"
    ],
    "answer": "A mechanism to step outside the standard React data flow to synchronize with external systems",
    "explanation": "The docs describe `useEffect` as an escape hatch because it allows you to synchronize React components with systems outside of React (like browser APIs, timers, or third-party libraries). It is 'outside' the standard rendering flow and should be used sparingly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "How does the text describe the role of AI in learning new frameworks?",
    "options": [
      "It eliminates the need to learn framework syntax",
      "It makes learning new frameworks less daunting by highlighting shared underlying patterns",
      "It allows developers to ignore framework updates entirely",
      "It automatically translates code from one framework to another perfectly"
    ],
    "answer": "It makes learning new frameworks less daunting by highlighting shared underlying patterns",
    "explanation": "The text suggests that recognizing the four shared patterns (reactivity, server-first, compilers, AI) makes new framework releases feel less like learning a completely new technology. While AI helps with boilerplate, understanding these unifying patterns is key to adapting to the ecosystem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Why is the manual usage of `useCallback` considered a 'legacy optimization' in 2026?",
    "options": [
      "Because it causes memory leaks",
      "Because the React Compiler automatically memoizes functions where necessary",
      "Because it is too difficult to teach to new developers",
      "Because JavaScript engines have become too fast to care about function allocation"
    ],
    "answer": "Because the React Compiler automatically memoizes functions where necessary",
    "explanation": "The React Compiler analyzes component logic and automatically preserves function references when doing so prevents unnecessary re-renders. This makes manual wrapping of functions in `useCallback` redundant in most scenarios.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What distinguishes the `use()` API's handling of promises from standard async/await in a component body?",
    "options": [
      "`use()` can be called conditionally, while async/await cannot be used at the top level",
      "There is no difference; they are identical",
      "`use()` returns the error instead of throwing it",
      "`use()` does not support promises, only context"
    ],
    "answer": "`use()` can be called conditionally, while async/await cannot be used at the top level",
    "explanation": "Components cannot be `async`, so you cannot use top-level `await`. The `use()` API bridges this gap, allowing components to read promises (and context) and interact with Suspense. Additionally, `use()` can be used inside conditions like `if` blocks, which violates standard Hooks rules.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is a 'Cache Component' in the context of Next.js 16 and Server Components?",
    "options": [
      "A component that stores all user input in local storage",
      "A mechanism to reuse the result of a data fetch or render operation across requests",
      "A component that prevents the browser from caching the page",
      "A legacy component from Next.js 12"
    ],
    "answer": "A mechanism to reuse the result of a data fetch or render operation across requests",
    "explanation": "Cache Components (or caching mechanisms in Next.js) allow the results of expensive data fetches or rendered segments to be reused. This works alongside Partial Prerendering to ensure that dynamic parts of the page don't always require a full re-fetch or re-render, improving performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "When designing a reusable component that relies on Context, what helps maintain consistency according to the text?",
    "options": [
      "Prop drilling every value",
      "Establishing a design system",
      "Using only global variables",
      "Avoiding the use of TypeScript"
    ],
    "answer": "Establishing a design system",
    "explanation": "When building reusable components that rely on context, establishing a design system helps maintain consistency. This provides a standardized way for consumers of the components to interact with the context data, preventing fragmented implementations across a large application.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the benefit of using Edge Runtimes in conjunction with Server Functions?",
    "options": [
      "They allow code to run closer to the user, reducing latency",
      "They force all code to run in the user's main thread",
      "They replace the need for a database",
      "They only support static file serving"
    ],
    "answer": "They allow code to run closer to the user, reducing latency",
    "explanation": "Edge Runtimes allow server-side logic (server functions) to execute in data centers distributed geographically closer to the user. This reduces network latency for dynamic calculations or data fetching that cannot be fully cached.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which statement accurately reflects the state management philosophy in 2026 regarding Server vs Client?",
    "options": [
      "All state must be managed in Redux",
      "State should be pushed to the server where possible (Server Components) and kept on the client only for interactivity",
      "All state must be managed in the client for speed",
      "State management is no longer necessary"
    ],
    "answer": "State should be pushed to the server where possible (Server Components) and kept on the client only for interactivity",
    "explanation": "The 'Server-first' trend advocates for keeping data fetching and state management on the server (via Server Components) to reduce client-side JavaScript. Client-side state is reserved strictly for user interactions and UI interactivity that cannot be handled on the server.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "How does the React Compiler verify the correctness of a component's logic?",
    "options": [
      "By reading the developer's comments",
      "By checking if the dependencies listed in hooks like `useEffect` match the variables used inside the effect",
      "By running every component in a virtual machine",
      "By enforcing strict mode only"
    ],
    "answer": "By checking if the dependencies listed in hooks like `useEffect` match the variables used inside the effect",
    "explanation": "The React Compiler performs an automated build-time step to verify that the dependencies specified in hooks accurately reflect the code's usage. It can automatically fix or flag dependency arrays, ensuring that components behave correctly and re-render when they should.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the `useState` vs `useReducer` comparison, what is a scenario where `useState` is sufficient and preferred?",
    "options": [
      "When the next state depends on the previous state in complex ways",
      "When managing a simple toggle (true/false) or a text input string",
      "When you need to dispatch actions from nested components deep in the tree",
      "When you need to maintain a history of state changes for undo functionality"
    ],
    "answer": "When managing a simple toggle (true/false) or a text input string",
    "explanation": "`useState` is preferred for simpler, independent state primitives like booleans, strings, or numbers where the update logic is straightforward. `useReducer` introduces overhead (action types, reducer functions) that is unnecessary for these simple cases.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "According to 2026 trends, why has the manual usage of `useMemo`, `useCallback`, and `React.memo` diminished in everyday React development?",
    "options": [
      "React now forbids the use of these APIs to enforce stricter code standards",
      "The React Compiler automatically handles memoization and performance tuning at build time",
      "These APIs were deprecated in React 19 in favor of class-based components",
      "Modern browsers have optimized JavaScript execution enough to make memoization obsolete"
    ],
    "answer": "The React Compiler automatically handles memoization and performance tuning at build time",
    "explanation": "The React Compiler, released in v1.0 in late 2025, analyzes code at build time to automatically apply memoization where necessary. This removes the burden from developers to manually optimize using `useMemo`, `useCallback`, and `React.memo`, allowing them to focus on business logic rather than performance micro-optimizations. These manual patterns are now considered legacy optimizations.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary advantage of using the `use` hook with Suspense for data fetching compared to the traditional `useEffect` pattern?",
    "options": [
      "`use` eliminates the need for Error Boundaries by handling errors internally",
      "`use` reduces code complexity by handling loading and error states declaratively through Suspense",
      "`use` allows data fetching to run only on the client-side for faster browser execution",
      "`use` automatically caches responses in the browser's local storage without configuration"
    ],
    "answer": "`use` reduces code complexity by handling loading and error states declaratively through Suspense",
    "explanation": "The `use` hook integrated with Suspense removes the need for manual `isLoading` and `error` state variables, which are required in `useEffect` patterns. Suspense handles the loading UI (fallbacks) and Error Boundaries handle error states, significantly reducing boilerplate and the risk of race conditions or memory leaks associated with manual subscription cleanup in `useEffect`.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In the context of React Server Components (RSC), what specific performance benefit is achieved by fetching data and rendering UI on the server?",
    "options": [
      "It reduces the bandwidth cost by sending zero client-side JavaScript for the server-rendered parts",
      "It allows the client browser to perform garbage collection more aggressively",
      "It ensures that all components are re-rendered instantly upon any state change",
      "It automatically enables Service Workers to cache the entire application offline"
    ],
    "answer": "It reduces the bandwidth cost by sending zero client-side JavaScript for the server-rendered parts",
    "explanation": "React Server Components render on the server and stream HTML to the client. For these specific parts of the UI, no corresponding JavaScript bundle is sent to the browser. This significantly reduces the client-side bundle size and improves initial load times, as reported by case studies showing render time drops from 2.4s to 0.8s.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the technical reason that calling `setCount(count + 1)` twice in quick succession within an asynchronous handler may only increment the state once?",
    "options": [
      "React batches state updates automatically to prevent re-renders",
      "The asynchronous handler captures the initial value of `count` in a closure, causing both updates to read the same stale value",
      "The `useState` hook enforces a cooldown period between state updates",
      "JavaScript engines optimize the function by removing duplicate function calls"
    ],
    "answer": "The asynchronous handler captures the initial value of `count` in a closure, causing both updates to read the same stale value",
    "explanation": "In asynchronous operations, the variables inside the callback closure capture the state at the moment the callback was created. If the state hasn't updated yet when the callback runs, both calls to `setCount(count + 1)` read the same original `count` value. The correct approach for sequential updates based on previous state is to use the functional update form: `setCount(c => c + 1)`.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When managing complex state logic with multiple sub-values, why is `useReducer` generally preferred over `useState`?",
    "options": [
      "useReducer automatically persists state to local storage",
      "useReducer avoids the need for a reducer function by using default values",
      "useReducer centralizes state transition logic, making it easier to manage complex updates and test state transitions",
      "useReducer provides better performance by preventing any re-renders of child components"
    ],
    "answer": "useReducer centralizes state transition logic, making it easier to manage complex updates and test state transitions",
    "explanation": "`useReducer` is designed for scenarios where state logic involves multiple sub-values or complex update logic (similar to Redux). By dispatching actions to a reducer function, the logic for *how* state changes is separated from the component logic. This predictability and centralization make complex state transitions easier to reason about and test compared to scattered `useState` setters.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What specific performance impact occurs when a Context value changes in a React application?",
    "options": [
      "Only the child component that directly consumes the value re-renders",
      "The virtual DOM diffing algorithm prevents any re-renders caused by Context changes",
      "All components consuming that context will re-render, even if they only use a part of the value that didn't change",
      "The component tree is completely destroyed and recreated from the Context Provider downwards"
    ],
    "answer": "All components consuming that context will re-render, even if they only use a part of the value that didn't change",
    "explanation": "React Context is a subscription mechanism. When a Context Provider's value changes, every component currently consuming that context is triggered to re-render. This can lead to performance bottlenecks in large apps if the context holds a large object and frequently updating parts of it cause unrelated consumers to re-render unnecessarily.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How does Next.js 16's 'Partial Prerendering' feature improve the architectural strategy of web applications?",
    "options": [
      "It forces the entire application to be statically generated at build time",
      "It requires developers to write separate codebases for static and dynamic routes",
      "It allows blending of a static shell with dynamic regions in a single route, enabling immediate static HTML with streaming dynamic content",
      "It eliminates the need for server-side rendering by moving all computation to the edge client"
    ],
    "answer": "It allows blending of a static shell with dynamic regions in a single route, enabling immediate static HTML with streaming dynamic content",
    "explanation": "Partial Prerendering (PPR) represents a hybrid architecture. It serves a static shell immediately (like a cached site) while simultaneously streaming dynamic, personalized content (like user-specific data) into that same shell. This balances the SEO and speed of static sites with the personalization of dynamic rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Why is `useEffect` described in the modern React documentation as an 'escape hatch'?",
    "options": [
      "Because it is the only way to perform asynchronous operations in React",
      "Because it allows developers to step outside React's declarative paradigm to synchronize with external systems",
      "Because it is deprecated and will be removed in future versions of React",
      "Because it automatically handles all memory leaks without developer intervention"
    ],
    "answer": "Because it allows developers to step outside React's declarative paradigm to synchronize with external systems",
    "explanation": "React's primary paradigm is data-driven rendering (UI = f(state)). `useEffect` is an 'escape hatch' because it is used for imperative side effects—syncing with non-React APIs, subscriptions, or timers—that exist outside this direct data flow. Overusing it for data fetching (when `use`/Suspense is available) is discouraged because it adds complexity and imperative logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the critical distinction between `use` and `useEffect` regarding error handling during asynchronous operations?",
    "options": [
      "Both require manual try-catch blocks to handle errors",
      "`useEffect` relies on Error Boundaries, while `use` requires manual error state variables",
      "`use` relies on Error Boundaries, while `useEffect` typically requires manual error state variables",
      "Neither pattern supports error handling; errors must be caught by the global window error handler"
    ],
    "answer": "`use` relies on Error Boundaries, while `useEffect` typically requires manual error state variables",
    "explanation": "When using the `use` hook (with Suspense for resources), if a Promise rejects or a read fails, React expects the nearest Error Boundary to catch it. In contrast, `useEffect` patterns require the developer to manually track an `error` state variable (e.g., `const [error, setError] = useState(null)`) and conditionally render an error UI.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "In the context of 2026 web development, what characterizes the shift towards 'Fine-Grained Reactivity'?",
    "options": [
      "Re-rendering the entire page whenever any data changes to ensure absolute consistency",
      "Moving all state management to global variables to avoid prop drilling",
      "Frameworks updating only the specific DOM nodes or text values that changed, rather than re-rendering entire component trees",
      "Using WebSockets exclusively for all state updates to ensure real-time consistency"
    ],
    "answer": "Frameworks updating only the specific DOM nodes or text values that changed, rather than re-rendering entire component trees",
    "explanation": "Fine-grained reactivity (a trend seen in frameworks like Solid or Qwik, and influencing React) aims to reduce the cost of rendering. Instead of React's traditional approach of re-running a component function (render) to generate a Virtual DOM tree to diff, fine-grained systems track dependencies precisely and update only the changed values in the DOM, minimizing computational overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the primary benefit of using a tool like tRPC in a full-stack TypeScript application?",
    "options": [
      "It replaces the need for a database by using the browser's IndexedDB",
      "It eliminates the need to define API schemas and manually maintain types between client and server",
      "It automatically optimizes the CSS bundle for the frontend application",
      "It converts React Server Components into Client Components automatically"
    ],
    "answer": "It eliminates the need to define API schemas and manually maintain types between client and server",
    "explanation": "tRPC enables end-to-end type safety by allowing the frontend to call backend functions as if they were local. Since the backend is defined as typed functions, the frontend infers types directly from them. This removes the need for separate API schemas, Swagger definitions, or manual type syncing, ensuring the client and server contracts always match.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does the React Compiler handle the optimization of components that were previously manually memoized with `React.memo`?",
    "options": [
      "It throws an error if `React.memo` is detected to force manual cleanup",
      "It ignores `React.memo` and only optimizes components using hooks",
      "It treats manual memoization as a hint but generally takes over the responsibility of memoization automatically",
      "It requires developers to remove all `React.memo` usage before the compiler will run"
    ],
    "answer": "It treats manual memoization as a hint but generally takes over the responsibility of memoization automatically",
    "explanation": "The React Compiler is designed to analyze code and apply optimizations automatically. While manual memoization (legacy code) still works, the compiler's ability to optimize means that maintaining manual `useMemo`, `useCallback`, or `React.memo` is largely unnecessary. The compiler determines when re-renders can be skipped more effectively than manual heuristics in most cases.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What architectural limitation prevents React Server Components from having direct interactivity, such as `onClick` handlers?",
    "options": [
      "Server Components do not support JavaScript execution",
      "Server Components cannot access the browser's event loop or DOM API",
      "Interactivity in Server Components is disabled to prevent cross-site scripting (XSS)",
      "Server Components are streamed as HTML, making event listeners impossible to attach"
    ],
    "answer": "Server Components cannot access the browser's event loop or DOM API",
    "explanation": "React Server Components render exclusively on the server. Since they have no presence in the browser's JavaScript runtime, they cannot define event listeners or use browser APIs (like `window` or `document`). Interactivity requires using 'use client' to define the boundary where a component runs in the browser.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "When optimizing Context performance in a large-scale application, what strategy effectively prevents unnecessary re-renders of consumers?",
    "options": [
      "Merging all application state into a single Context Provider to avoid prop drilling",
      "Wrapping the entire application tree in a single `React.memo` component",
      "Splitting state into multiple smaller contexts based on usage frequency and update rates",
      "Replacing Context with the `use` hook for all data fetching operations"
    ],
    "answer": "Splitting state into multiple smaller contexts based on usage frequency and update rates",
    "explanation": "Because a Context update triggers all consumers to re-render, a common optimization strategy is 'splitting contexts.' By separating frequently changing state (e.g., user input) from rarely changing state (e.g., theme/user ID), you ensure that components consuming the static context do not re-render when the dynamic context changes.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "In the `use` + Suspense data fetching pattern, how is the 'loading' state conceptually handled?",
    "options": [
      "The component renders a `null` value until the data arrives",
      "A boolean `isLoading` variable is toggled within the component logic",
      "The nearest Suspense boundary above the component displays a fallback UI while the resource is pending",
      "The browser displays a native loading spinner until the promise resolves"
    ],
    "answer": "The nearest Suspense boundary above the component displays a fallback UI while the resource is pending",
    "explanation": "Suspense introduces a declarative way to handle loading states. Instead of managing `isLoading` state inside the component, the component simply 'throws' a promise or reads a resource. React catches this and suspends the component, replacing it with the `fallback` UI defined in the nearest `<Suspense>` ancestor until the data is ready.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Why does the source material suggest that using `useEffect` for data fetching results in 'significant boilerplate' compared to `use`?",
    "options": [
      "Because `useEffect` requires extensive configuration in the webpack build process",
      "Because developers must manually manage `isLoading`, `isError`, and `isSuccess` states and their corresponding effects",
      "Because `useEffect` cannot handle asynchronous functions without a polyfill",
      "Because `useEffect` forces the use of class-based components for data fetching"
    ],
    "answer": "Because developers must manually manage `isLoading`, `isError`, and `isSuccess` states and their corresponding effects",
    "explanation": "The `useEffect` approach is imperative: you initiate the fetch, check if it's loading, catch errors, update state variables, and render different UI based on those variables. The `use` + Suspense approach is declarative: you read the data. The boilerplate of state flags and conditional rendering logic is abstracted away into the Suspense mechanism and Error Boundaries.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the result of the convergence on 'Server-First' architectures in the React ecosystem?",
    "options": [
      "Client-side JavaScript bundles have increased in size to handle server logic",
      "Developers treat 'what runs where' (server vs client) as a first-class design decision",
      "All logic is moved to the client to reduce server costs",
      "Server Components have completely replaced Client Components in all applications"
    ],
    "answer": "Developers treat 'what runs where' (server vs client) as a first-class design decision",
    "explanation": "The trend towards Server-First architecture doesn't mean eliminating the client, but optimizing the distribution of work. Developers now intentionally decide which parts of the UI belong on the server (for data fetching, SEO, and zero-JS payload) and which belong on the client (interactivity), rather than defaulting to a monolithic client-side bundle.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the role of AI-assisted tools like GitHub Copilot and v0 in the 2026 React workflow?",
    "options": [
      "They replace the need for developers to understand React state management and security",
      "They generate boilerplate code and components, allowing developers to focus on high-level architecture",
      "They automatically audit and fix all security vulnerabilities in production code",
      "They rewrite existing React class components into functional components instantly"
    ],
    "answer": "They generate boilerplate code and components, allowing developers to focus on high-level architecture",
    "explanation": "AI tools in 2026 are viewed as standard appliances for generating the repetitive 'wiring' of applications—boilerplate components, routes, and tests. They do not replace the need for architectural knowledge, security awareness, or understanding of data flow, but they speed up the implementation of these decisions.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "When adopting React Server Components alongside frameworks like Next.js, what is the reported approximate improvement in initial render times?",
    "options": [
      "~20% improvement",
      "~40% improvement",
      "~67% improvement",
      "~95% improvement"
    ],
    "answer": "~67% improvement",
    "explanation": "Case studies referenced in the material report that adopting Server Components can drop initial render times from about 2.4 seconds to 0.8 seconds. This represents a roughly 67% improvement, driven by reduced JavaScript bundles and server-side data fetching.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the behavior of the `use` hook when reading from a Context that is conditionally rendered?",
    "options": [
      "It throws an error because hooks cannot be called conditionally",
      "It allows reading context conditionally, unlike `useContext` which must be called unconditionally",
      "It returns `undefined` if the context provider is not found",
      "It forces the entire component tree to re-render regardless of dependencies"
    ],
    "answer": "It allows reading context conditionally, unlike `useContext` which must be called unconditionally",
    "explanation": "One of the specific distinctions mentioned for the `use` API is its ability to read context conditionally. Standard React Hooks (Rules of Hooks) must be called unconditionally at the top level. While `use` still generally follows hook usage patterns, its design (specifically in the context of `use(context)`) is noted for enabling conditional reading scenarios in the provided source text.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "How does the React Compiler impact the cognitive load on developers regarding performance optimization?",
    "options": [
      "It increases cognitive load by requiring developers to learn a new configuration language for the compiler",
      "It lowers cognitive load by allowing developers to write straightforward code without manual memoization patterns",
      "It shifts the focus to micro-optimizing JavaScript variable declarations",
      "It requires developers to manually annotate functions for the compiler to work"
    ],
    "answer": "It lowers cognitive load by allowing developers to write straightforward code without manual memoization patterns",
    "explanation": "By automating memoization at build time, the compiler allows developers to write components that focus on behavior and structure. They no longer need to mentally track dependency arrays or worry about unnecessarily wrapping functions in `useCallback`, making the code easier to reason about.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the primary architectural benefit of expressing the backend as 'typed functions' rather than long-lived services?",
    "options": [
      "It allows the backend to run exclusively on the client browser for offline support",
      "It improves type inference and API contract maintenance as frontend and backend scale together",
      "It removes the need for a database by storing state in function memory",
      "It ensures that the backend code is written in Python instead of JavaScript"
    ],
    "answer": "It improves type inference and API contract maintenance as frontend and backend scale together",
    "explanation": "Treating the backend as a collection of typed functions (often utilized via tRPC or similar) creates a unified type system. This eliminates the 'API boundary' problem where frontend and backend types drift apart. As the backend changes, types are automatically reflected on the frontend, ensuring contracts remain valid during scaling.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "In a distributed React application using Server Components, what does 'Partial Prerendering' specifically cache?",
    "options": [
      "The user-specific private data stream",
      "The dynamic API responses from external services",
      "The static shell parts of the route that do not change per user",
      "The client-side JavaScript bundle for the entire application"
    ],
    "answer": "The static shell parts of the route that do not change per user",
    "explanation": "Partial Prerendering works by caching the static parts of a page (the shell, navigation, layout) while serving dynamic parts (user data, personalized content) via streaming. This allows the static content to be served instantly from cache, while the dynamic content is fetched and injected.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the correct functional update syntax to increment a counter state `count` by 1 safely, avoiding stale closure issues?",
    "options": [
      "setCount(count + 1)",
      "setCount(currentCount => currentCount + 1)",
      "count = count + 1",
      "setCount(state.count + 1)"
    ],
    "answer": "setCount(currentCount => currentCount + 1)",
    "explanation": "Using the functional update form `setCount(c => c + 1)` ensures that React queues the update using the *most current* state value at the time the update is applied, regardless of when the setter was called or what closures captured it. This prevents bugs caused by stale state in async handlers or rapid successive calls.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Why are subscriptions and event listeners still appropriate use cases for `useEffect` rather than the `use` hook?",
    "options": [
      "Because `use` does not support cleaning up resources automatically",
      "Because `useEffect` provides a dedicated cleanup mechanism (return function) for imperative side effects",
      "Because `use` can only be used inside Server Components",
      "Because `useEffect` is faster than `use` for client-side operations"
    ],
    "answer": "Because `useEffect` provides a dedicated cleanup mechanism (return function) for imperative side effects",
    "explanation": "While `use` handles data and resources well, `useEffect` remains the correct place for imperative side effects like subscribing to WebSockets, window resize listeners, or timers. This is primarily because `useEffect` offers a predictable cleanup phase (the return function) to tear down these side effects when the component unmounts or dependencies change.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Which ecosystem trend implies that developers must decide between 'Consistency' (CP) and 'Availability' (AP) when designing distributed state for React apps?",
    "options": [
      "The React Compiler adoption",
      "The CAP Theorem applied to distributed state stores",
      "The use of functional components",
      "The shift to CSS-in-JS"
    ],
    "answer": "The CAP Theorem applied to distributed state stores",
    "explanation": "While not explicitly detailed in the main text provided, the prompt's reference examples highlight the CAP theorem. In the context of advanced React architecture involving distributed state or backend-for-frontend (BFF) patterns, understanding that you can only simultaneously provide two of Consistency, Availability, and Partition Tolerance is a key architectural consideration.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the implication of 'Zero Client-Side JavaScript' for Server Components regarding hydration?",
    "options": [
      "The client must still download the component code to hydrate the HTML",
      "The HTML is sent to the client without any corresponding JavaScript bundle for those components",
      "The components are hydrated using WebAssembly instead of JavaScript",
      "The browser re-renders the entire page using JavaScript after the initial load"
    ],
    "answer": "The HTML is sent to the client without any corresponding JavaScript bundle for those components",
    "explanation": "One of the key features of React Server Components is that the rendered HTML is not accompanied by a JS bundle to 'hydrate' that specific part of the tree on the client. The interactivity is handled only by the specific Client Components ('use client'), while the rest is purely static HTML output from the server.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "How does the introduction of the React Compiler change the barrier to entry for newer React developers?",
    "options": [
      "It raises the barrier by requiring knowledge of compiler internals",
      "It lowers the barrier by allowing them to focus on behavior and structure instead of optimization patterns",
      "It has no effect on the barrier to entry",
      "It increases the barrier by removing class components which are easier to learn"
    ],
    "answer": "It lowers the barrier by allowing them to focus on behavior and structure instead of optimization patterns",
    "explanation": "Previously, developers had to learn complex memoization patterns (`useMemo`, `useCallback`) to avoid performance pitfalls. The compiler automates this, allowing beginners to write 'naive' code that is performant. This lets them focus on learning React's core paradigms—component structure and state flow—without being overwhelmed by performance engineering.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is a consequence of the 'pushing work into the back kitchen' (Server Components) pattern on the client-side JavaScript bundle size?",
    "options": [
      "The bundle size increases because server logic is transpiled to client JS",
      "The bundle size decreases significantly as heavy logic and library dependencies stay on the server",
      "The bundle size remains the same, but network latency decreases",
      "The bundle size is transferred to the Service Worker instead"
    ],
    "answer": "The bundle size decreases significantly as heavy logic and library dependencies stay on the server",
    "explanation": "By moving data fetching and heavy computation to Server Components, the dependencies required for those tasks (e.g., large data formatting libraries, ORM logic) are never sent to the browser. Only the interactive parts of the app are bundled, resulting in a much smaller payload for the user to download.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "When using Suspense for data fetching, what happens if a Promise passed to the `use` hook rejects?",
    "options": [
      "The component renders `null` and logs an error to the console",
      "The nearest Error Boundary above the component catches the error and renders a fallback UI",
      "The application crashes and displays a blank white screen",
      "The `use` hook catches the error and returns `undefined`"
    ],
    "answer": "The nearest Error Boundary above the component catches the error and renders a fallback UI",
    "explanation": "React integrates Suspense with Error Boundaries for error handling. If a resource read by `use` fails (rejects), React looks up the component tree for the nearest Error Boundary and renders its fallback UI. This provides a consistent, declarative way to handle failures across the application.",
    "difficulty": "Advanced"
  }
]