[
  {
    "id": 1,
    "question": "Which design pattern defines a skeleton of an algorithm in a base class but lets subclasses override specific steps without changing the algorithm's structure?",
    "options": [
      "Strategy Pattern",
      "Template Method Pattern",
      "Builder Pattern",
      "Facade Pattern"
    ],
    "answer": "Template Method Pattern",
    "explanation": "The Template Method pattern defines the algorithm's steps in a base class and requires subclasses to implement the abstract steps. Strategy pattern delegates the entire algorithm to an implementation, whereas Template Method only delegates specific steps.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In the context of creational patterns, what is the primary intent of the Abstract Factory pattern?",
    "options": [
      "To create a single instance of a class",
      "To separate the construction of a complex object from its representation",
      "To create families of related or dependent objects without specifying their concrete classes",
      "To interface to an existing object without changing its implementation"
    ],
    "answer": "To create families of related or dependent objects without specifying their concrete classes",
    "explanation": "Abstract Factory provides an interface for creating families of related objects. Builder is for complex construction steps, Singleton is for single instances, and Adapter is for structural compatibility.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which behavioral design pattern allows a group of objects to be notified automatically when a state change occurs in one object?",
    "options": [
      "Observer Pattern",
      "Mediator Pattern",
      "Command Pattern",
      "State Pattern"
    ],
    "answer": "Observer Pattern",
    "explanation": "The Observer pattern establishes a one-to-many dependency between objects so that when one changes state, all dependents are notified. Mediator reduces direct communication between colleagues, Command encapsulates requests, and State alters behavior based on internal state.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which structural design pattern is used to convert the interface of a class into another interface clients expect, enabling classes with incompatible interfaces to work together?",
    "options": [
      "Decorator Pattern",
      "Adapter Pattern",
      "Facade Pattern",
      "Proxy Pattern"
    ],
    "answer": "Adapter Pattern",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. A Facade simplifies an existing interface, a Proxy controls access, and a Decorator adds responsibilities dynamically.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the defining characteristic of the Repository pattern as described in Patterns of Enterprise Application Architecture?",
    "options": [
      "It mediates between the domain and data mapping layers, acting like an in-memory domain object collection",
      "It creates a separation between the presentation layer and the business logic layer",
      "It ensures that a class has only one instance and provides a global point of access to it",
      "It defines a skeleton of an algorithm in a superclass but lets subclasses override specific steps"
    ],
    "answer": "It mediates between the domain and data mapping layers, acting like an in-memory domain object collection",
    "explanation": "The Repository pattern abstracts data access by mimicking a collection of domain objects. Layering (option B) is architectural, Singleton (option C) is creational, and Template Method (option D) is behavioral.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which design pattern attaches additional responsibilities to an object dynamically without affecting other objects of the same class?",
    "options": [
      "Composite Pattern",
      "Strategy Pattern",
      "Decorator Pattern",
      "Proxy Pattern"
    ],
    "answer": "Decorator Pattern",
    "explanation": "The Decorator pattern provides a flexible alternative to subclassing for extending functionality dynamically. Composite treats individuals and groups uniformly, Strategy swaps algorithms, and Proxy controls access.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "In the Model-View-Controller (MVC) architectural pattern, what is the primary role of the Controller?",
    "options": [
      "To encapsulate the application state and business logic",
      "To present data to the user and handle user interface logic",
      "To act as an intermediary between the Model and View, handling user input and updating the state",
      "To manage the persistence and retrieval of data from the database"
    ],
    "answer": "To act as an intermediary between the Model and View, handling user input and updating the state",
    "explanation": "The Controller processes input and converts it to commands for the Model or View. The Model handles logic/state (A), the View handles display (B), and data persistence (D) is typically handled by infrastructure or repository layers.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which design pattern allows you to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Memento Pattern",
      "Command Pattern",
      "Observer Pattern",
      "Chain of Responsibility Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern turns a request into a stand-alone object. Memento captures state, Observer notifies listeners, and Chain of Responsibility passes a request along a chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which Enterprise Architecture pattern is characterized by separating the read and write operations of a data store, often using different models for each?",
    "options": [
      "Service-Oriented Architecture (SOA)",
      "Layered Architecture",
      "Command Query Responsibility Segregation (CQRS)",
      "Event-Driven Architecture"
    ],
    "answer": "Command Query Responsibility Segregation (CQRS)",
    "explanation": "CQRS specifically splits read (Query) and write (Command) operations. SOA is about services, Layered is about tiers, and Event-Driven is about reacting to events.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the primary purpose of the Strategy pattern?",
    "options": [
      "To define a family of algorithms, encapsulate each one, and make them interchangeable",
      "To provide a unified interface to a set of interfaces in a subsystem",
      "To dynamically add new behavior to an object",
      "To restrict a class to a single instance"
    ],
    "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable",
    "explanation": "The Strategy pattern lets the algorithm vary independently from clients that use it. Facade simplifies interfaces (B), Decorator adds behavior (C), and Singleton restricts instances (D).",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which GoF design pattern provides a surrogate or placeholder to control access to another object?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Proxy Pattern",
      "Flyweight Pattern"
    ],
    "answer": "Proxy Pattern",
    "explanation": "A Proxy acts as a placeholder to control access, manage creation, or log usage. Adapter changes interfaces, Bridge decouples abstraction from implementation, and Flyweight shares state for efficiency.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "In the context of Dependency Injection (DI), which type of injection involves passing dependencies into a class through its constructor?",
    "options": [
      "Setter Injection",
      "Interface Injection",
      "Field Injection",
      "Constructor Injection"
    ],
    "answer": "Constructor Injection",
    "explanation": "Constructor Injection supplies dependencies via the class constructor, ensuring the object is fully initialized on creation. Setter injection uses methods, Field injection directly sets fields, and Interface injection uses a provider.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which pattern suggests that a class should have only one reason to change, thereby adhering to a specific principle of object-oriented design?",
    "options": [
      "Single Responsibility Principle (SRP)",
      "Open/Closed Principle (OCP)",
      "Liskov Substitution Principle (LSP)",
      "Dependency Inversion Principle (DIP)"
    ],
    "answer": "Single Responsibility Principle (SRP)",
    "explanation": "SRP states a class should have one job. OCP focuses on extension over modification, LSP on subtype substitutability, and DIP on depending on abstractions.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which pattern is specifically designed to compose objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly?",
    "options": [
      "Composite Pattern",
      "Decorator Pattern",
      "Flyweight Pattern",
      "Proxy Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite pattern allows uniform treatment of individual and grouped objects in a tree structure. Decorator adds behavior, Flyweight shares state, and Proxy controls access.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the key difference between the Factory Method and Abstract Factory patterns?",
    "options": [
      "Factory Method creates objects via inheritance; Abstract Factory creates objects via composition",
      "Factory Method is creational; Abstract Factory is structural",
      "Factory Method works with single objects; Abstract Factory works with families of related objects",
      "Factory Method uses interfaces; Abstract Factory uses abstract classes"
    ],
    "answer": "Factory Method creates objects via inheritance; Abstract Factory creates objects via composition",
    "explanation": "Factory Method relies on subclasses to decide what class to instantiate (inheritance). Abstract Factory provides an interface for creating families of related objects without specifying their concrete classes (composition/object aggregation).",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which design pattern reduces the chaotic dependencies between objects by centralizing communication through a mediator object?",
    "options": [
      "Observer Pattern",
      "Mediator Pattern",
      "Facade Pattern",
      "Adapter Pattern"
    ],
    "answer": "Mediator Pattern",
    "explanation": "The Mediator pattern promotes loose coupling by preventing objects from referring to each other explicitly. Observer is for notifications, Facade simplifies interfaces, and Adapter bridges interfaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "In Martin Fowler's Patterns of Enterprise Application Architecture, which pattern describes a method where business logic is organized as a single procedure for each user interaction?",
    "options": [
      "Domain Model",
      "Table Module",
      "Transaction Script",
      "Service Layer"
    ],
    "answer": "Transaction Script",
    "explanation": "Transaction Script organizes business logic into procedures where each procedure handles a single request from the UI. Domain Model uses objects with logic and state, and Table Module organizes logic around database tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which behavioral pattern lets an object alter its behavior when its internal state changes, appearing to change its class?",
    "options": [
      "Strategy Pattern",
      "State Pattern",
      "Visitor Pattern",
      "Command Pattern"
    ],
    "answer": "State Pattern",
    "explanation": "The State pattern allows an object to change its behavior based on its internal state. Strategy changes behavior explicitly via context, Visitor separates algorithms from structures, and Command encapsulates requests.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which pattern describes a mechanism to handle a request by passing it along a chain of processing objects until one handles it?",
    "options": [
      "Observer Pattern",
      "Chain of Responsibility",
      "Command Pattern",
      "Mediator Pattern"
    ],
    "answer": "Chain of Responsibility",
    "explanation": "Chain of Responsibility passes a request along a chain until it is processed. Observer broadcasts events, Command encapsulates single requests, and Mediator centralizes communication.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which structural pattern decouples an abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Composite Pattern",
      "Facade Pattern"
    ],
    "answer": "Bridge Pattern",
    "explanation": "The Bridge pattern separates abstraction (interface) from implementation (details) to allow independent evolution. Adapter makes incompatible interfaces work, Composite builds trees, and Facade simplifies complexity.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which pattern is best described as an architectural approach where the application is built as a suite of small services, each running in its own process and communicating with lightweight mechanisms?",
    "options": [
      "Layered Architecture",
      "Microservices Architecture",
      "Monolithic Architecture",
      "Service-Oriented Architecture (SOA)"
    ],
    "answer": "Microservices Architecture",
    "explanation": "Microservices structures the app as small, independent services. Layered is tier-based, Monolithic is a single deployable unit, and SOA focuses on enterprise service integration typically via an ESB.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the primary advantage of using the Flyweight pattern?",
    "options": [
      "It reduces the cost of creating complex objects",
      "It minimizes memory usage by sharing as much data as possible with similar objects",
      "It adds functionality to objects dynamically",
      "It provides a unified interface to a set of interfaces"
    ],
    "answer": "It minimizes memory usage by sharing as much data as possible with similar objects",
    "explanation": "Flyweight optimizes memory by sharing intrinsic state among many objects. Builder reduces creation cost (A), Decorator adds behavior (C), and Facade unifies interfaces (D).",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which design pattern is used to restore an object to its previous state without violating encapsulation?",
    "options": [
      "Command Pattern",
      "Memento Pattern",
      "State Pattern",
      "Prototype Pattern"
    ],
    "answer": "Memento Pattern",
    "explanation": "The Memento pattern captures and externalizes an object's internal state to allow rollback. Command encapsulates actions, State changes behavior, and Prototype clones objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which design pattern defines a new operation to a class without changing the structure of the class itself?",
    "options": [
      "Visitor Pattern",
      "Decorator Pattern",
      "Strategy Pattern",
      "Composite Pattern"
    ],
    "answer": "Visitor Pattern",
    "explanation": "The Visitor pattern separates an algorithm from the object structure it operates on. Decorator adds responsibilities, Strategy swaps algorithms, and Composite structures objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "In the context of Hexagonal Architecture (Ports and Adapters), what is the primary purpose of an Adapter?",
    "options": [
      "To convert the interface of a class into another interface",
      "To facilitate data transformation between the application core and external tools or databases",
      "To add responsibilities to an object dynamically",
      "To create a single instance of a service"
    ],
    "answer": "To facilitate data transformation between the application core and external tools or databases",
    "explanation": "In Hexagonal Architecture, Adapters translate data between the external world (DB, UI) and the application's Ports. While it uses the Adapter concept, the specific goal is isolating the core logic from external concerns.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which pattern involves separating the construction of a complex object from its representation, allowing the same construction process to create different representations?",
    "options": [
      "Abstract Factory",
      "Builder Pattern",
      "Prototype Pattern",
      "Factory Method"
    ],
    "answer": "Builder Pattern",
    "explanation": "The Builder pattern separates construction (steps) from representation (product). Abstract Factory creates families, Prototype clones, and Factory Method defers instantiation to subclasses.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which architectural pattern emphasizes the production and consumption of events, leading to high scalability and loose coupling but introducing complexity in debugging flow?",
    "options": [
      "Layered Architecture",
      "Microservices",
      "Event-Driven Architecture",
      "Hexagonal Architecture"
    ],
    "answer": "Event-Driven Architecture",
    "explanation": "Event-Driven Architecture relies on asynchronous events for communication, enabling loose coupling. Layered is synchronous/tiered, Microservices is a structural deployment style, and Hexagonal focuses on core isolation.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which creational pattern creates new objects by cloning a prototype instance rather than creating them from scratch?",
    "options": [
      "Builder Pattern",
      "Prototype Pattern",
      "Singleton Pattern",
      "Factory Method Pattern"
    ],
    "answer": "Prototype Pattern",
    "explanation": "The Prototype pattern creates objects by copying an existing instance. Builder uses steps, Singleton restricts instances, and Factory Method uses factory classes.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which design pattern allows a series of related elements to be accessed sequentially without exposing its underlying representation?",
    "options": [
      "Iterator Pattern",
      "Composite Pattern",
      "Visitor Pattern",
      "Command Pattern"
    ],
    "answer": "Iterator Pattern",
    "explanation": "The Iterator pattern provides a way to access elements of an aggregate object sequentially. Composite treats parts and groups uniformly, Visitor performs operations, and Command encapsulates requests.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the primary function of the Interpreter design pattern?",
    "options": [
      "To translate a high-level language into machine code",
      "To define a representation for the grammar of a language and an interpreter to interpret sentences",
      "To encapsulate a request as an object",
      "To convert the interface of a class into another interface"
    ],
    "answer": "To define a representation for the grammar of a language and an interpreter to interpret sentences",
    "explanation": "The Interpreter pattern defines a grammar and an interpreter for that grammar. It is not for machine code translation (A), which is a compiler role.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "In Layered Architecture, which layer is primarily responsible for exposing an API to the user interface or external consumers?",
    "options": [
      "Data Access Layer",
      "Business Logic Layer",
      "Presentation Layer",
      "Service Layer"
    ],
    "answer": "Presentation Layer",
    "explanation": "The Presentation Layer handles UI and interaction with the user. Data Access handles storage, Business Logic handles rules, and Service Layer (often part of Logic) defines boundaries.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which pattern uses a shared object to support a large number of fine-grained objects efficiently by sharing intrinsic state?",
    "options": [
      "Flyweight Pattern",
      "Proxy Pattern",
      "Singleton Pattern",
      "Facade Pattern"
    ],
    "answer": "Flyweight Pattern",
    "explanation": "Flyweight shares common state (intrinsic) to reduce memory usage for many small objects. Proxy controls access, Singleton limits instances, and Facade simplifies interfaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "In the context of the Front Controller pattern, what is the primary benefit?",
    "options": [
      "It delegates request handling to multiple controllers",
      "It centralizes request handling and provides a shared entry point for all requests",
      "It separates business logic from the user interface",
      "It encapsulates database access logic"
    ],
    "answer": "It centralizes request handling and provides a shared entry point for all requests",
    "explanation": "Front Controller consolidates all request handling (e.g., a Servlet or Middleware) to a single component. Delegation (A) implies Page Controller, Separation (C) is MVC, and Encapsulation (D) is Repository.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which creational pattern ensures that a class has only one instance and provides a global point of access to it?",
    "options": [
      "Factory Method",
      "Abstract Factory",
      "Singleton",
      "Builder"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern restricts instantiation to one object. Factory and Abstract Factory create multiple instances, and Builder constructs complex objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which architectural trade-off is most commonly associated with Microservices compared to a Monolithic architecture?",
    "options": [
      "Decreased scalability",
      "Increased complexity in deployment and network communication",
      "Tighter coupling between components",
      "Slower technology adoption"
    ],
    "answer": "Increased complexity in deployment and network communication",
    "explanation": "Microservices introduce distributed system complexity (network latency, service discovery, deployment orchestration). They increase scalability and allow faster tech adoption, not slower.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which design pattern is most effective for decoupling the creation of a complex object from its representation, allowing the same construction process to create different representations?",
    "options": [
      "Abstract Factory",
      "Builder",
      "Prototype",
      "Factory Method"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. Abstract Factory focuses on families of related objects, while Prototype clones existing objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In the context of Enterprise Architecture, what is the primary benefit of the Hexagonal Architecture (Ports and Adapters) regarding testability?",
    "options": [
      "It eliminates the need for a database layer.",
      "It allows the core application logic to be tested without external infrastructure dependencies.",
      "It automatically generates unit tests for the UI.",
      "It enforces a strict UI framework choice."
    ],
    "answer": "It allows the core application logic to be tested without external infrastructure dependencies.",
    "explanation": "Hexagonal Architecture isolates the core logic from external concerns (databases, UIs) via ports. This allows mocking adapters for testing without requiring actual infrastructure connectivity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which statement accurately describes the trade-off between the Layered Architecture pattern and the Microservices Architecture pattern regarding scalability?",
    "options": [
      "Layered architecture scales vertically, while Microservices scale horizontally.",
      "Layered architecture scales independently per component, while Microservices scale as a single unit.",
      "Microservices require vertical scaling only.",
      "Layered architecture allows independent database scaling for every layer."
    ],
    "answer": "Layered architecture scales vertically, while Microservices scale horizontally.",
    "explanation": "Layered architectures are typically deployed as a single unit (monolith), requiring vertical scaling (more power). Microservices deploy independently, enabling horizontal scaling (more instances) of specific services.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When implementing the Repository pattern, what specific problem regarding the Domain and Data Mapping layers is being solved?",
    "options": [
      "It creates an in-memory domain object interface, hiding the details of data storage and query logic.",
      "It maps database tables directly to HTTP endpoints.",
      "It enables real-time data synchronization across distributed nodes.",
      "It replaces the need for transaction management."
    ],
    "answer": "It creates an in-memory domain object interface, hiding the details of data storage and query logic.",
    "explanation": "The Repository pattern mimics a collection of domain objects, abstracting the underlying data source (SQL, NoSQL, API). It decouples the domain model from persistence logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the defining characteristic of the CQRS (Command Query Responsibility Segregation) pattern?",
    "options": [
      "Using a single database model for all operations.",
      "Separating the model that updates information from the model that reads information.",
      "Segregating commands based on user roles.",
      "Ensuring all queries are write operations."
    ],
    "answer": "Separating the model that updates information from the model that reads information.",
    "explanation": "CQRS splits the application into two parts: the command side (write/updates) and the query side (reads). This allows independent optimization and scaling of each side.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In the Strategy pattern, how does the context object interact with the strategy?",
    "options": [
      "The context inherits from the strategy.",
      "The context delegates the work to a concrete strategy interface.",
      "The context encapsulates the strategy and creates it via cloning.",
      "The context is composed of multiple strategies that execute sequentially."
    ],
    "answer": "The context delegates the work to a concrete strategy interface.",
    "explanation": "The context object maintains a reference to a strategy interface and delegates the specific algorithm execution to the concrete strategy object. This allows the algorithm to vary independently from clients that use it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which behavioral pattern is best utilized to implement a publish-subscribe mechanism where a single subject notifies multiple observers of state changes without knowing specific details about them?",
    "options": [
      "Mediator",
      "Observer",
      "Visitor",
      "Command"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern defines a one-to-many dependency between objects. When the subject changes state, all dependents are notified and updated automatically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "How does the Event-Driven architectural pattern primarily improve system flexibility compared to a traditional layered synchronous request/response model?",
    "options": [
      "By using a single centralized database for all services.",
      "By ensuring all services run on the same server instance.",
      "By enabling loose coupling between services through asynchronous message exchange.",
      "By removing the need for API documentation."
    ],
    "answer": "By enabling loose coupling between services through asynchronous message exchange.",
    "explanation": "Event-driven architectures allow services to emit events without knowing who consumes them. This asynchronous decoupling allows consumers to be added, modified, or removed without affecting the producer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which Enterprise Pattern is defined as 'A method to break a complex transaction into a sequence of smaller transactions that can be rolled back if compensating actions are not performed'?",
    "options": [
      "Unit of Work",
      "Saga",
      "Two-Phase Commit",
      "Repository"
    ],
    "answer": "Saga",
    "explanation": "A Saga pattern manages distributed transactions by breaking them into a sequence of local transactions coordinated by messages. If one step fails, compensating transactions undo the previous steps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In the Gang of Four creational patterns, what is the key distinction between the Abstract Factory and the Factory Method?",
    "options": [
      "Factory Method creates families of products; Abstract Factory creates single products.",
      "Abstract Factory composes objects; Factory Method inherits object creation.",
      "Factory Method is a singleton; Abstract Factory is a prototype.",
      "Abstract Factory uses inheritance; Factory Method uses composition."
    ],
    "answer": "Abstract Factory composes objects; Factory Method inherits object creation.",
    "explanation": "Factory Method relies on inheritance (subclasses decide what to instantiate). Abstract Factory relies on object composition (delegate creation to a factory object that creates families of related products).",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "When applying the Decorator pattern, what is the structural relationship between the Decorator and the ConcreteComponent?",
    "options": [
      "The Decorator inherits from the ConcreteComponent.",
      "The Decorator aggregates the ConcreteComponent via composition.",
      "The Decorator replaces the ConcreteComponent at runtime.",
      "The Decorator and ConcreteComponent are siblings."
    ],
    "answer": "The Decorator aggregates the ConcreteComponent via composition.",
    "explanation": "The Decorator maintains a reference to a Component object (composition) and conforms to the Component's interface. This allows adding responsibilities dynamically without altering the component's structure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the primary role of the 'Presentation Layer' in a strict Layered Architecture?",
    "options": [
      "To execute business rules and validation.",
      "To persist data to the database.",
      "To handle user interface logic and browser communication.",
      "To manage external API integrations."
    ],
    "answer": "To handle user interface logic and browser communication.",
    "explanation": "In Layered Architecture, the Presentation Layer is responsible for displaying data to the user and capturing user inputs, while delegating business logic processing to the layer beneath it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which design pattern provides a unified interface to a set of interfaces in a subsystem, effectively defining a higher-level interface that makes the subsystem easier to use?",
    "options": [
      "Adapter",
      "Facade",
      "Proxy",
      "Bridge"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a simplified interface to a library, a framework, or any other complex set of classes. It decouples the client code from the subsystem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In the context of Domain-Driven Design (DDD), which pattern defines a boundary around a specific domain model, ensuring that concepts within the boundary remain valid?",
    "options": [
      "Repository",
      "Bounded Context",
      "Unit of Work",
      "Factory"
    ],
    "answer": "Bounded Context",
    "explanation": "A Bounded Context is a central pattern in DDD. It creates a semantic boundary where a specific domain model applies and is valid, preventing the confusion of mixing concepts from different domains.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which scenario strictly requires the use of the Prototype pattern over other creational patterns?",
    "options": [
      "When the object to be created is specified by a class name.",
      "When the cost of creating a new object is expensive and it is more efficient to copy an existing one.",
      "When families of related objects need to be created together.",
      "When only one instance of a class must exist."
    ],
    "answer": "When the cost of creating a new object is expensive and it is more efficient to copy an existing one.",
    "explanation": "The Prototype pattern is used when object creation is expensive. It clones a prototypical instance instead of building a new one from scratch, bypassing expensive initialization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the primary disadvantage of using the Microservices architecture pattern compared to a Monolithic Layered architecture?",
    "options": [
      "Scalability is limited to a single server.",
      "Deployment requires taking down the entire system.",
      "Increased complexity in distributed systems management (networking, latency, consistency).",
      "Inability to use different technologies for different services."
    ],
    "answer": "Increased complexity in distributed systems management (networking, latency, consistency).",
    "explanation": "Microservices introduce operational complexity, including distributed transactions, service discovery, and network latency, which are not present in a monolith.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In the Model-View-Controller (MVC) pattern, which component is primarily responsible for handling user input and updating the Model?",
    "options": [
      "View",
      "Controller",
      "Model",
      "Observer"
    ],
    "answer": "Controller",
    "explanation": "The Controller accepts user inputs, interprets them, and updates the Model state. The View is responsible for displaying the Model's data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which structural pattern allows you to treat individual objects and compositions of objects uniformly?",
    "options": [
      "Decorator",
      "Composite",
      "Flyweight",
      "Proxy"
    ],
    "answer": "Composite",
    "explanation": "The Composite pattern composes objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the primary function of the Adapter pattern?",
    "options": [
      "To add new functionality to an object dynamically.",
      "To match interfaces of different classes so they can work together despite incompatible interfaces.",
      "To restrict access to an object.",
      "To separate an abstraction from its implementation."
    ],
    "answer": "To match interfaces of different classes so they can work together despite incompatible interfaces.",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. It converts the interface of a class into another interface clients expect.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How does the Proxy pattern differ from the Decorator pattern?",
    "options": [
      "Proxy controls access to an object; Decorator adds behavior.",
      "Proxy inherits from the object; Decorator composes the object.",
      "Proxy creates new objects; Decorator clones objects.",
      "Proxy is creational; Decorator is structural."
    ],
    "answer": "Proxy controls access to an object; Decorator adds behavior.",
    "explanation": "While they have similar structures, the Proxy pattern manages access (lazy loading, access control), whereas the Decorator pattern adds responsibilities dynamically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In a Service-Oriented Architecture (SOA), what is the role of the 'Enterprise Service Bus' (ESB)?",
    "options": [
      "To store the permanent state of the business entities.",
      "To act as a middleware for routing, transforming, and mediating communication between services.",
      "To serve the frontend user interface.",
      "To replace the database layer."
    ],
    "answer": "To act as a middleware for routing, transforming, and mediating communication between services.",
    "explanation": "The ESB facilitates communication between disparate services by handling routing, protocol conversion, and message transformation, acting as a central backbone.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which GoF pattern encapsulates a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Memento",
      "Command",
      "Chain of Responsibility",
      "State"
    ],
    "answer": "Command",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods, queue operations, and support undo.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "When implementing the 'Unit of Work' pattern, what is the specific outcome regarding database transactions?",
    "options": [
      "Every single database operation is committed immediately.",
      "A series of database operations are committed together as a single transaction or rolled back entirely.",
      "Only read operations are transactional.",
      "The database connection is kept open indefinitely."
    ],
    "answer": "A series of database operations are committed together as a single transaction or rolled back entirely.",
    "explanation": "The Unit of Work pattern tracks changes to business objects during a transaction and writes all changes out at the end of the transaction, ensuring atomicity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which pattern is most suitable for managing the state of an object when the object's behavior depends on its state, and the object must change its behavior at runtime when its state changes?",
    "options": [
      "Strategy",
      "State",
      "Visitor",
      "Iterator"
    ],
    "answer": "State",
    "explanation": "The State pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. Strategy is for interchangeable algorithms, not state-dependent behavior.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In the context of software architecture, what does 'Horizontal Scaling' refer to?",
    "options": [
      "Increasing the resources (CPU/RAM) of a single server.",
      "Adding more server instances to the system to distribute the load.",
      "Splitting the application into different layers.",
      "Upgrading the database schema."
    ],
    "answer": "Adding more server instances to the system to distribute the load.",
    "explanation": "Horizontal scaling (scaling out) involves adding more nodes to a pool, whereas vertical scaling (scaling up) involves adding more power to an existing machine.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which anti-pattern describes a situation where changes to one part of the software require changes to other, seemingly unrelated parts?",
    "options": [
      "Golden Hammer",
      "Spaghetti Code",
      "Lava Flow",
      "Shotgun Surgery"
    ],
    "answer": "Shotgun Surgery",
    "explanation": "Shotgun Surgery occurs when a single feature or change requires touching many different files or modules. This contrasts with code that is modular or isolated in scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "The Bridge pattern is primarily used to:",
    "options": [
      "Decouple an abstraction from its implementation so that the two can vary independently.",
      "Connect two different databases.",
      "Provide a simplified interface to a complex subsystem.",
      "Separate the UI from the data source."
    ],
    "answer": "Decouple an abstraction from its implementation so that the two can vary independently.",
    "explanation": "The Bridge pattern separates the abstract interface (Abstraction) from the implementation details (Implementor). This allows changing implementation without changing the client code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which Enterprise Application pattern suggests using a 'Separate Class' to handle business logic for a specific user interaction or transaction, rather than spreading logic across the UI?",
    "options": [
      "Active Record",
      "Transaction Script",
      "Domain Model",
      "Table Module"
    ],
    "answer": "Transaction Script",
    "explanation": "Transaction Script organizes business logic by procedures where each procedure handles a single request from the UI. It places the logic in a separate class rather than embedding it in the UI.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How does the Flyweight pattern reduce memory usage?",
    "options": [
      "By compressing objects using gzip.",
      "By sharing common state among multiple objects instead of storing it in each object.",
      "By storing data on disk instead of RAM.",
      "By deleting unused objects immediately."
    ],
    "answer": "By sharing common state among multiple objects instead of storing it in each object.",
    "explanation": "The Flyweight pattern minimizes memory usage by sharing intrinsic state (common data) among multiple objects, rather than keeping duplicate copies in every object instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the core responsibility of the 'Data Mapper' pattern?",
    "options": [
      "To move data from the database to the UI.",
      "To transfer data between database tables automatically.",
      "To separate the in-memory objects from the database schema, ensuring independence.",
      "To map SQL queries to HTTP endpoints."
    ],
    "answer": "To separate the in-memory objects from the database schema, ensuring independence.",
    "explanation": "Data Mapper is a layer of software that separates the in-memory objects from the database. Its responsibility is to transfer data between the two and to keep them independent of each other.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "In the Chain of Responsibility pattern, how is a request processed?",
    "options": [
      "All handlers in the chain process the request simultaneously.",
      "The request is passed along a chain until a handler handles it or the chain ends.",
      "The request is broadcast to all handlers.",
      "The first handler always processes the request."
    ],
    "answer": "The request is passed along a chain until a handler handles it or the chain ends.",
    "explanation": "The pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What distinguishes the 'Active Record' pattern from the 'Data Mapper' pattern?",
    "options": [
      "Active Record merges domain logic and data access logic in a single class.",
      "Data Mapper does not use a database.",
      "Active Record is only for NoSQL databases.",
      "Data Mapper is always faster than Active Record."
    ],
    "answer": "Active Record merges domain logic and data access logic in a single class.",
    "explanation": "In Active Record, an object carries both data and behavior (CRUD operations). Data Mapper separates them, having a specific mapper class handle persistence while the domain object handles business logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which design principle is most directly violated by the 'God Object' anti-pattern?",
    "options": [
      "DRY (Don't Repeat Yourself)",
      "Single Responsibility Principle (SRP)",
      "Liskov Substitution Principle",
      "Dependency Inversion Principle"
    ],
    "answer": "Single Responsibility Principle (SRP)",
    "explanation": "A God Object knows too much or does too much, effectively controlling all other parts of the system. This directly violates the Single Responsibility Principle, which states a class should have one reason to change.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In the Interpreter pattern, what is the primary purpose?",
    "options": [
      "To translate code from one language to another.",
      "To define a grammatical representation for a language and an interpreter to process sentences.",
      "To parse XML files.",
      "To optimize bytecode execution."
    ],
    "answer": "To define a grammatical representation for a language and an interpreter to process sentences.",
    "explanation": "The Interpreter pattern specifies how to evaluate sentences in a language. It involves defining an expression interface and implementing the interpretation for specific grammar rules.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "When using the 'Template Method' pattern, what part of the algorithm is typically invariant?",
    "options": [
      "The primitive operations that must be overridden.",
      "The skeleton of the algorithm defining the steps.",
      "The specific implementation details of the steps.",
      "The return type of the method."
    ],
    "answer": "The skeleton of the algorithm defining the steps.",
    "explanation": "The Template Method defines the skeleton of an algorithm in the base class, deferring some steps to subclasses. The overall structure (order of steps) remains invariant.",
    "difficulty": "Intermediate"
  }
]