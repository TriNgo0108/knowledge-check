[
  {
    "id": 1,
    "question": "What is the primary function of the Global Interpreter Lock (GIL) in standard CPython implementations?",
    "options": [
      "To manage memory allocation on the heap",
      "To ensure only one thread executes Python bytecode at a time",
      "To prevent race conditions in database connections",
      "To compile Python code to machine code"
    ],
    "answer": "To ensure only one thread executes Python bytecode at a time",
    "explanation": "The GIL is a mutex that prevents multiple native threads from executing Python bytecodes simultaneously, simplifying memory management. It does not manage heap allocation directly, nor does it compile code.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which of the following data types is immutable in Python?",
    "options": [
      "List",
      "Dictionary",
      "Tuple",
      "Set"
    ],
    "answer": "Tuple",
    "explanation": "Tuples cannot be modified after creation (immutable). Lists, dictionaries, and sets are mutable data structures that can be altered in place.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In CPython memory management, what happens when an object's reference count drops to zero?",
    "options": [
      "The object is moved to a generation 2 garbage collection pool",
      "The memory is immediately deallocated and returned to the system heap",
      "The object is marked for deletion during the next system shutdown",
      "The reference count is reset to 1 to prevent data loss"
    ],
    "answer": "The memory is immediately deallocated and returned to the system heap",
    "explanation": "CPython primarily uses reference counting; when the count hits zero, the resources are released immediately. Generational garbage collection is a separate mechanism for handling circular references.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the output of the comparison: `type([]) is list`?",
    "options": [
      "True",
      "False",
      "Error",
      "None"
    ],
    "answer": "True",
    "explanation": "`[]` creates a list instance. `type([])` returns the class `list`, and the `is` operator checks if they are the same object, which evaluates to True.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which operator is used for floor division in Python?",
    "options": [
      "/",
      "//",
      "%",
      "%%"
    ],
    "answer": "//",
    "explanation": "The `//` operator performs floor division, rounding down to the nearest integer. `/` is true division, and `%` is the modulus operator.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the correct syntax for creating a function that accepts a variable number of positional arguments?",
    "options": [
      "def func(*args):",
      "def func(...):",
      "def func(&args):",
      "def func(**args):"
    ],
    "answer": "def func(*args):",
    "explanation": "The `*args` syntax allows a function to accept a variable number of positional arguments, packed into a tuple. `**kwargs` is used for keyword arguments.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which of the following is a requirement for a dictionary key?",
    "options": [
      "It must be an integer",
      "It must be a string",
      "It must be hashable",
      "It must be immutable"
    ],
    "answer": "It must be hashable",
    "explanation": "Dictionary keys must be hashable so their hash values can be computed for constant-time lookups. While immutable types (like strings and tuples) are usually hashable, custom objects can be mutable and hashable, but 'hashable' is the strict requirement.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "How does the GIL affect CPU-bound multi-threaded programs in CPython?",
    "options": [
      "It allows them to run faster on multi-core systems",
      "It forces threads to run sequentially, limiting parallelism",
      "It causes immediate deadlock if more than one core is used",
      "It has no effect on CPU-bound tasks"
    ],
    "answer": "It forces threads to run sequentially, limiting parallelism",
    "explanation": "The GIL ensures only one thread runs bytecode at a time. This effectively serializes CPU-bound threads, negating the benefits of multiple cores for heavy computation.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the result of `bool('False')`?",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "answer": "True",
    "explanation": "Non-empty strings are always truthy in Python. Only the empty string `''` evaluates to `False`.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which method is used to add an element to the end of a list?",
    "options": [
      "push()",
      "append()",
      "add()",
      "insert()"
    ],
    "answer": "append()",
    "explanation": "`append()` adds a single item to the end of a list. `insert()` adds at an index, `push()` is not a list method, and `add()` is used for sets or math.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the purpose of the `pass` keyword in Python?",
    "options": [
      "To skip the next iteration of a loop",
      "To indicate a placeholder where code is required",
      "To exit a function immediately",
      "To ignore an exception"
    ],
    "answer": "To indicate a placeholder where code is required",
    "explanation": "`pass` is a null operation used where syntactically code is required (like in an empty function or class) but no action is needed.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What character is used to denote a comment in Python?",
    "options": [
      "//",
      "#",
      "/*",
      "--"
    ],
    "answer": "#",
    "explanation": "The hash symbol `#` denotes a single-line comment. `//` is used in JavaScript/Java, and `/* */` is used for multi-line comments in C-style languages.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which of the following correctly defines a set?",
    "options": [
      "my_set = (1, 2, 3)",
      "my_set = {1, 2, 3}",
      "my_set = [1, 2, 3]",
      "my_set = {'key': 'value'}"
    ],
    "answer": "my_set = {1, 2, 3}",
    "explanation": "Sets are defined using curly braces with comma-separated values. Parentheses indicate tuples, brackets indicate lists, and key-value pairs indicate dictionaries.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Why are circular references problematic for Python's reference counting mechanism?",
    "options": [
      "They cause the GIL to lock indefinitely",
      "They cause reference counts never to reach zero, creating memory leaks",
      "They prevent threads from releasing the GIL",
      "They make objects read-only"
    ],
    "answer": "They cause reference counts never to reach zero, creating memory leaks",
    "explanation": "If objects reference each other, their reference counts remain non-zero even if no external references exist, preventing reference counting from reclaiming the memory.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the output of `print(10 // 3)`?",
    "options": [
      "3.33",
      "3",
      "4",
      "1"
    ],
    "answer": "3",
    "explanation": "`//` is floor division, which divides and rounds down to the nearest whole number.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which module provides the ability to create lightweight pseudo-threaded tasks for concurrency?",
    "options": [
      "threading",
      "multiprocessing",
      "asyncio",
      "concurrent"
    ],
    "answer": "asyncio",
    "explanation": "`asyncio` provides a framework for writing single-threaded concurrent code using coroutines (async/await). `threading` and `multiprocessing` use OS threads and processes respectively.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What does the `__init__` method do in a class?",
    "options": [
      "Initializes the class instance attributes",
      "Destroys the instance",
      "Inherits from another class",
      "Returns a value"
    ],
    "answer": "Initializes the class instance attributes",
    "explanation": "`__init__` is the constructor method called after the instance is created to initialize attributes, similar to constructors in other languages.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the result of the expression: `3 * 'a'`?",
    "options": [
      "'aaa'",
      "Error",
      "'3a'",
      "3"
    ],
    "answer": "'aaa'",
    "explanation": "Multiplying a sequence (string, list) by an integer repeats the sequence that many times.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which statement is used to iterate through a sequence (list, tuple, string) in Python?",
    "options": [
      "for",
      "while",
      "foreach",
      "loop"
    ],
    "answer": "for",
    "explanation": "Python uses the `for` loop (often `for item in sequence`) to iterate over iterables. `while` loops based on a condition.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the name of the Python memory management strategy that deals specifically with circular references?",
    "options": [
      "Reference Counting",
      "Mark and Sweep Garbage Collection",
      "Biased Reference Counting",
      "Pointer Swizzling"
    ],
    "answer": "Mark and Sweep Garbage Collection",
    "explanation": "While Reference Counting is the primary mechanism, it cannot handle cycles. The generational garbage collector (cycle detector) uses a mark-and-sweep algorithm to resolve them.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "How do you create a single-element tuple?",
    "options": [
      "my_tuple = (1)",
      "my_tuple = 1,",
      "my_tuple = (1,)",
      "my_tuple = tuple[1]"
    ],
    "answer": "my_tuple = (1,)",
    "explanation": "A trailing comma is required to distinguish a tuple from parentheses used for mathematical grouping. `my_tuple = 1,` is also valid.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which keyword is used to handle exceptions in Python?",
    "options": [
      "handle",
      "try",
      "catch",
      "throw"
    ],
    "answer": "try",
    "explanation": "The `try` block contains code that might raise an exception, followed by `except` blocks to handle them. `catch` is used in Java/C++.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the output of `list(range(2, 5))`?",
    "options": [
      "[2, 3, 4, 5]",
      "[2, 3, 4]",
      "[3, 4, 5]",
      "[5, 4, 3, 2]"
    ],
    "answer": "[2, 3, 4]",
    "explanation": "The `range(start, stop)` function generates numbers starting at `start` up to (but not including) `stop`.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "In the context of the GIL, which type of task benefits most from Python's `threading` module?",
    "options": [
      "CPU-bound tasks (e.g., matrix multiplication)",
      "I/O-bound tasks (e.g., network requests)",
      "Memory-intensive tasks (e.g., image processing)",
      "All tasks benefit equally"
    ],
    "answer": "I/O-bound tasks (e.g., network requests)",
    "explanation": "The GIL is released during I/O operations, allowing other threads to run. This makes threading effective for I/O-bound tasks, unlike CPU-bound tasks where the GIL restricts parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which function is used to open a file in Python?",
    "options": [
      "open()",
      "file()",
      "read()",
      "File()"
    ],
    "answer": "open()",
    "explanation": "The built-in `open()` function returns a file object, allowing interaction with file resources. `file()` was removed in Python 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is a 'generator' in Python?",
    "options": [
      "A function that returns a list",
      "A function that uses `yield` to produce values one at a time",
      "A class that generates random numbers",
      "A special type of list"
    ],
    "answer": "A function that uses `yield` to produce values one at a time",
    "explanation": "Generators are iterators defined using functions and the `yield` keyword, lazily producing items rather than storing the whole sequence in memory.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the syntax for a list comprehension that squares the numbers in `[1, 2, 3]`?",
    "options": [
      "[x*x for x in [1, 2, 3]]",
      "map(x*x, [1, 2, 3])",
      "[x^2 | x <- [1, 2, 3]]",
      "list(x*x for [1, 2, 3])"
    ],
    "answer": "[x*x for x in [1, 2, 3]]",
    "explanation": "List comprehensions use the syntax `[expression for item in iterable]`. `^` is XOR, not a power operator.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which type of error occurs when you try to access an index that does not exist in a list?",
    "options": [
      "KeyError",
      "IndexError",
      "ValueError",
      "AttributeError"
    ],
    "answer": "IndexError",
    "explanation": "`IndexError` is raised when a sequence subscript is out of range. `KeyError` is raised for missing dictionary keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the difference between `==` and `is`?",
    "options": [
      "`==` checks identity, `is` checks equality",
      "`==` checks equality, `is` checks identity",
      "They are functionally identical",
      "`is` checks for value, `==` checks for type"
    ],
    "answer": "`==` checks equality, `is` checks identity",
    "explanation": "`==` compares the values of objects, while `is` checks if two variables point to the exact same object in memory.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which feature of Python allows it to dynamically determine the type of a variable at runtime?",
    "options": [
      "Static Typing",
      "Strong Typing",
      "Dynamic Typing",
      "Duck Typing"
    ],
    "answer": "Dynamic Typing",
    "explanation": "Dynamic typing means variable types are determined at runtime, not declaration. You can reassign a variable to a different type.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the output of `1 and 0` in Python?",
    "options": [
      "1",
      "0",
      "True",
      "False"
    ],
    "answer": "0",
    "explanation": "The `and` operator returns the first falsy value or the last value if all are truthy. Since `0` is falsy, it returns `0`.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "How do you write a lambda function that adds two numbers?",
    "options": [
      "def add(x, y): return x + y",
      "lambda x, y: x + y",
      "lambda {x, y} return x + y",
      "function(x, y) { x + y }"
    ],
    "answer": "lambda x, y: x + y",
    "explanation": "Python uses `lambda arguments: expression`. It creates an anonymous function.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which built-in function returns the length of an object?",
    "options": [
      "length()",
      "size()",
      "len()",
      "count()"
    ],
    "answer": "len()",
    "explanation": "`len()` is the standard built-in function to return the number of items in a container.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of the `finally` block in exception handling?",
    "options": [
      "To execute code only if no exception occurs",
      "To execute code only if an exception occurs",
      "To execute code regardless of whether an exception occurred or not",
      "To suppress the exception"
    ],
    "answer": "To execute code regardless of whether an exception occurred or not",
    "explanation": "The `finally` block is always executed, providing a cleanup mechanism (like closing a file) regardless of the `try` or `except` outcome.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In Python 3, what does the `print()` function return?",
    "options": [
      "The printed string",
      "None",
      "True",
      "Integer 0"
    ],
    "answer": "None",
    "explanation": "`print()` is a function that performs a side effect (output to stdout) and returns `None`.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In CPython, what is the primary consequence of the Global Interpreter Lock (GIL) on a multi-core system for CPU-bound tasks?",
    "options": [
      "It causes deadlocks if multiple threads attempt to access the same memory address.",
      "It prevents multiple native threads from executing Python bytecodes in parallel, effectively limiting CPU usage to one core.",
      "It forces the interpreter to use a single process for all operations, regardless of the `threading` module usage.",
      "It automatically distributes the bytecode execution across available cores using a round-robin scheduler."
    ],
    "answer": "It prevents multiple native threads from executing Python bytecodes in parallel, effectively limiting CPU usage to one core.",
    "explanation": "The GIL is a mutex that allows only one thread to hold the control of the Python interpreter. This means that CPU-bound programs in CPython can only effectively use one CPU core, regardless of how many cores are present.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Why does CPython use reference counting as its primary memory management strategy?",
    "options": [
      "It eliminates the need for a garbage collector entirely.",
      "It allows memory to be reclaimed immediately when an object is no longer referenced, rather than waiting for a collection cycle.",
      "It prevents memory leaks caused by circular references without requiring a separate cycle detector.",
      "It allows objects to be stored in a contiguous memory block to improve cache locality."
    ],
    "answer": "It allows memory to be reclaimed immediately when an object is no longer referenced, rather than waiting for a collection cycle.",
    "explanation": "Reference counting deallocates memory the moment the reference count hits zero. This provides immediate memory reclamation, unlike mark-and-sweep garbage collectors which must run a pass to identify free memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How does Python's garbage collector handle circular references (reference cycles)?",
    "options": [
      "It ignores them, relying exclusively on reference counting to eventually free the memory.",
      "It uses a generational collector that periodically identifies and breaks cycles of container objects.",
      "It forces the programmer to manually call `gc.collect()` to prevent memory leaks.",
      "It converts the circular references into weak references automatically."
    ],
    "answer": "It uses a generational collector that periodically identifies and breaks cycles of container objects.",
    "explanation": "Reference counting cannot handle cycles because the count never reaches zero. The cyclic garbage detector runs periodically to identify and collect groups of objects that reference only each other.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of Python 3.13's effort to remove the GIL (PEP 703), what is 'Biased Reference Counting'?",
    "options": [
      "A method where the reference count is only updated in the thread that 'owns' the object to reduce atomic operation overhead.",
      "A technique to bias the garbage collector towards objects that have been recently created.",
      "A system where reference counts are ignored for immutable objects like integers and strings.",
      "A way of counting references that prefers the main thread over background threads to ensure priority."
    ],
    "answer": "A method where the reference count is only updated in the thread that 'owns' the object to reduce atomic operation overhead.",
    "explanation": "In a free-threaded Python (no GIL), every reference count change would require an expensive atomic operation. Biased reference counting allows the 'owning' thread to modify the count locally and without locks, while other threads use a shared count or deferred decrements.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "When does a Python thread release the GIL?",
    "options": [
      "Only when the thread explicitly calls `thread.release()`.",
      "During I/O operations (like reading a file or network socket) and after a specified number of bytecode instructions.",
      "When it encounters a syntax error or runtime exception.",
      "Never; the GIL is held until the thread completes execution."
    ],
    "answer": "During I/O operations (like reading a file or network socket) and after a specified number of bytecode instructions.",
    "explanation": "The GIL is released during blocking I/O operations, allowing other threads to run. It is also periodically released (e.g., every 1000 bytecodes or 'check interval') to allow thread switching in CPU-bound tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the fundamental difference between `multiprocessing` and `threading` in Python?",
    "options": [
      "`threading` creates multiple processes, while `multiprocessing` creates lightweight threads within a single process.",
      "`multiprocessing` creates separate memory spaces for each process, bypassing the GIL, whereas `threading` shares memory but is limited by the GIL.",
      "`multiprocessing` is used for I/O-bound tasks, while `threading` is strictly for CPU-bound tasks.",
      "`threading` is only available on Unix-based systems, while `multiprocessing` is cross-platform."
    ],
    "answer": "`multiprocessing` creates separate memory spaces for each process, bypassing the GIL, whereas `threading` shares memory but is limited by the GIL.",
    "explanation": "Multiprocessing spawns distinct Python processes, each with its own GIL and memory space, enabling true parallelism for CPU-bound tasks. Threading shares memory but threads contend for the GIL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the role of `__slots__` in a Python class definition?",
    "options": [
      "To define private methods that cannot be accessed outside the class.",
      "To prevent the creation of a `__dict__` for each instance, thereby saving memory.",
      "To overload the slot operator in the class.",
      "To specify the order in which attributes are initialized."
    ],
    "answer": "To prevent the creation of a `__dict__` for each instance, thereby saving memory.",
    "explanation": "By default, instances store attributes in a dynamic dictionary. `__slots__` declares a fixed set of attributes, reserving space for them statically and eliminating the memory overhead of the instance dictionary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "How does the `yield` keyword affect function execution in Python?",
    "options": [
      "It returns a value and terminates the function immediately.",
      "It pauses the function, saving its state, and resumes execution when `next()` is called on the returned generator.",
      "It converts the function into a coroutine that runs on a separate thread.",
      "It executes the function in a non-blocking loop."
    ],
    "answer": "It pauses the function, saving its state, and resumes execution when `next()` is called on the returned generator.",
    "explanation": "`yield` transforms a function into a generator. When called, execution pauses at `yield`, yielding a value. Local state is preserved until the generator is resumed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the Method Resolution Order (MRO) in Python, specifically regarding C3 linearization?",
    "options": [
      "A depth-first search algorithm that prioritizes the leftmost parent class.",
      "A monotonic algorithm that calculates the order in which classes are searched for attributes and methods in multiple inheritance.",
      "A random ordering of parent classes to prevent diamond inheritance issues.",
      "A mechanism that prevents multiple inheritance by forcing the use of interfaces."
    ],
    "answer": "A monotonic algorithm that calculates the order in which classes are searched for attributes and methods in multiple inheritance.",
    "explanation": "C3 linearization (used in Python 3) ensures a consistent and monotonic MRO. It respects inheritance order while ensuring that a parent class is always searched before its children, resolving the diamond problem deterministically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In a free-threaded (no-GIL) CPython build, why is 'Stop-the-World' garbage collection necessary?",
    "options": [
      "To ensure that the Garbage Collector (GC) has a consistent view of object references without them being modified by other threads.",
      "To allow the CPU to enter a low-power state while the GC runs.",
      "To prevent the main thread from crashing if the GC encounters an error.",
      "To ensure that the GC runs on a dedicated core separate from the application threads."
    ],
    "answer": "To ensure that the Garbage Collector (GC) has a consistent view of object references without them being modified by other threads.",
    "explanation": "Without the GIL, other threads can mutate objects while the GC is inspecting them. Stop-the-world pauses all application threads so the GC can safely traverse the object graph.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the behavior of the `super()` function in Python 3?",
    "options": [
      "It returns an instance of the base class, ignoring dynamic method dispatch.",
      "It returns a proxy object that delegates method calls to the parent or sibling class of the current type, respecting the MRO.",
      "It automatically imports the superclass from a different module.",
      "It creates a new thread to execute the parent class method."
    ],
    "answer": "It returns a proxy object that delegates method calls to the parent or sibling class of the current type, respecting the MRO.",
    "explanation": "`super()` provides a delegate object that routes calls to the appropriate class in the Method Resolution Order (MRO), facilitating cooperative multiple inheritance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which of the following statements best describes Python's `asyncio` library?",
    "options": [
      "It utilizes multiple threads to execute blocking I/O operations concurrently.",
      "It uses an event loop to manage and schedule coroutines for concurrent single-threaded execution.",
      "It is a high-level wrapper around the `multiprocessing` module for CPU-bound tasks.",
      "It automatically converts synchronous functions into asynchronous ones."
    ],
    "answer": "It uses an event loop to manage and schedule coroutines for concurrent single-threaded execution.",
    "explanation": "`asyncio` provides an event loop that runs asynchronous tasks (coroutines) on a single thread. It achieves concurrency by yielding control to the loop during I/O waits, not via parallelism.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What happens when a generator expression is passed to a function that consumes an iterator (e.g., `list()`, `sum()`)?",
    "options": [
      "The generator is fully evaluated into a tuple before the function processes it.",
      "The function iterates over the generator lazily, processing one item at a time until exhausted.",
      "The generator raises a SyntaxError because it must be assigned to a variable first.",
      "The interpreter converts the generator into a standard function."
    ],
    "answer": "The function iterates over the generator lazily, processing one item at a time until exhausted.",
    "explanation": "Generator expressions are lazy iterables. When passed to a consuming function, the function pulls values as needed, meaning memory is not used to store the entire sequence at once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is a closure in Python?",
    "options": [
      "A function that has been garbage collected.",
      "A function object that remembers values in enclosing scopes even if they are not present in memory.",
      "A method that is private to a class.",
      "A variable defined inside a function."
    ],
    "answer": "A function object that remembers values in enclosing scopes even if they are not present in memory.",
    "explanation": "A closure occurs when a nested function references a value from its enclosing scope. The nested function maintains a reference to the enclosing scope's variables, extending their lifetime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Why might one use `functools.wraps` on a decorator?",
    "options": [
      "To automatically wrap the returned value in a tuple.",
      "To ensure the decorated function retains the metadata (name, docstring, etc.) of the original function.",
      "To make the decorator execute faster by using C-level optimizations.",
      "To handle exceptions raised within the decorated function."
    ],
    "answer": "To ensure the decorated function retains the metadata (name, docstring, etc.) of the original function.",
    "explanation": "Decorators replace the original function with a wrapper. `functools.wraps` copies metadata from the original function to the wrapper, preserving introspection capabilities.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the difference between `is` and `==` in Python?",
    "options": [
      "`is` checks for value equality, while `==` checks for memory address identity.",
      "`is` checks for object identity (memory address), while `==` checks for value equality.",
      "`is` is used for integers, while `==` is used for strings.",
      "`is` returns `True` for immutable objects, while `==` returns `True` for mutable objects."
    ],
    "answer": "`is` checks for object identity (memory address), while `==` checks for value equality.",
    "explanation": "`is` compares the `id()` of two objects (do they point to the same object?). `==` calls the object's `__eq__` method to compare contents.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does Python manage integer interning?",
    "options": [
      "All integers are stored in a global cache to optimize performance.",
      "Python automatically caches small integers (typically -5 to 256) and reuses the same object instances.",
      "Integers are never interned; every integer creation results in a new memory allocation.",
      "Only negative integers are interned to save memory."
    ],
    "answer": "Python automatically caches small integers (typically -5 to 256) and reuses the same object instances.",
    "explanation": "CPython pre-allocates an array of small integers. References to these integers point to the same object, which explains why `a is b` might be true for small numbers but false for large ones.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the result of attempting to modify a local variable declared as `global` inside a function?",
    "options": [
      "A SyntaxError is raised because global variables cannot be modified inside functions.",
      "The modification affects the global variable in the module scope.",
      "The modification creates a new local variable that shadows the global one.",
      "A `RuntimeWarning` is issued, but the modification succeeds."
    ],
    "answer": "The modification affects the global variable in the module scope.",
    "explanation": "The `global` keyword instructs Python to refer to the variable in the module scope, allowing the function to modify the existing global object rather than creating a local one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which of the following is a characteristic of the `finally` block in exception handling?",
    "options": [
      "It executes only if no exception occurs in the `try` block.",
      "It executes only if an exception occurs in the `try` block.",
      "It always executes, regardless of whether an exception occurred or a `return` statement was encountered.",
      "It is executed before the `except` block."
    ],
    "answer": "It always executes, regardless of whether an exception occurred or a `return` statement was encountered.",
    "explanation": "The `finally` clause is guaranteed to run. Even if the `try` block contains a `return`, `finally` executes before the function actually returns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is a descriptor in Python?",
    "options": [
      "A docstring attached to a class attribute.",
      "An object attribute with binding behavior, one of whose methods (`__get__`, `__set__`, or `__delete__`) is overridden.",
      "A special type of generator used for file I/O.",
      "A tool for inspecting the bytecode of a function."
    ],
    "answer": "An object attribute with binding behavior, one of whose methods (`__get__`, `__set__`, or `__delete__`) is overridden.",
    "explanation": "Descriptors are the mechanism behind properties, methods, and class methods. They define how attribute access is handled via `__get__`, `__set__`, and `__delete__`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Why is `pickle` generally considered unsafe for untrusted data?",
    "options": [
      "It compresses data inefficiently, leading to Denial of Service (DoS).",
      "It can execute arbitrary code during the unpickling process by importing modules and calling functions.",
      "It does not preserve object types, leading to type confusion errors.",
      "It encrypts data using a weak algorithm that is easily cracked."
    ],
    "answer": "It can execute arbitrary code during the unpickling process by importing modules and calling functions.",
    "explanation": "The `pickle` protocol allows for the serialization of arbitrary objects. Unpickling can trigger `__reduce__` methods that import libraries and run commands, making it a vector for code injection.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the `__call__` method used for?",
    "options": [
      "To initialize a class instance when `__init__` is not defined.",
      "To allow an instance of a class to be called as if it were a function.",
      "To define the string representation of an object.",
      "To handle the deletion of an object."
    ],
    "answer": "To allow an instance of a class to be called as if it were a function.",
    "explanation": "Defining `__call__` in a class makes instances callable. It is invoked when the instance name is followed by parentheses (e.g., `obj()`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "How does the `@classmethod` decorator differ from the `@staticmethod` decorator?",
    "options": [
      "`@classmethod` receives the class (`cls`) as the first argument, while `@staticmethod` receives no implicit first argument.",
      "`@classmethod` can be used to override static methods in subclasses.",
      "`@staticmethod` modifies the instance state, while `@classmethod` modifies the class state.",
      "`@classmethod` cannot be called on an instance, only on the class."
    ],
    "answer": "`@classmethod` receives the class (`cls`) as the first argument, while `@staticmethod` receives no implicit first argument.",
    "explanation": "A class method receives the class itself as an implicit argument, allowing access to class attributes. A static method behaves like a regular function but belongs to the class namespace, receiving no instance or class reference.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the behavior of list slicing `list[::-1]`?",
    "options": [
      "It returns a shallow copy of the list in reverse order.",
      "It returns a deep copy of the list.",
      "It reverses the list in-place.",
      "It returns an empty list."
    ],
    "answer": "It returns a shallow copy of the list in reverse order.",
    "explanation": "The slice step `-1` iterates backwards. Since slicing creates a new list object, this returns a new list containing elements in reverse order.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In Python 3.6+, what is the order of keyword arguments (`**kwargs`) passed to a function?",
    "options": [
      "Undefined and random.",
      "Sorted alphabetically by key.",
      "The order in which they were inserted (preserved insertion order).",
      "The order defined in the function signature."
    ],
    "answer": "The order in which they were inserted (preserved insertion order).",
    "explanation": "As of Python 3.6 (officially 3.7), dictionaries preserve insertion order. Consequently, `**kwargs` maintains the order in which arguments were passed to the function.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the `buffer` protocol (or buffer interface) in Python?",
    "options": [
      "A mechanism for handling network latency in socket programming.",
      "A C-level protocol that allows Python objects to expose a raw memory pointer for efficient data access.",
      "A logging protocol used to debug memory leaks.",
      "A method to queue data before writing to disk."
    ],
    "answer": "A C-level protocol that allows Python objects to expose a raw memory pointer for efficient data access.",
    "explanation": "The buffer protocol allows an object to export its internal data (like a byte array) without copying, enabling libraries like NumPy to manipulate memory efficiently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Why might you use `sys.getrefcount(obj)`?",
    "options": [
      "To determine the size of the object in bytes.",
      "To check the number of references pointing to the object (noting the temporary increment from passing the object to the function itself).",
      "To count the number of methods defined in the object.",
      "To verify if the object is thread-safe."
    ],
    "answer": "To check the number of references pointing to the object (noting the temporary increment from passing the object to the function itself).",
    "explanation": "This function returns the reference count. Note that it is usually 1 higher than expected because the function call creates a temporary reference to the object passed as an argument.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the primary use of the `with` statement (Context Manager)?",
    "options": [
      "To simplify exception handling by automatically invoking `__enter__` and `__exit__` methods.",
      "To create a scope where variables are strictly private.",
      "To indicate that the following block is thread-safe.",
      "To implicitly convert variables to a specific type."
    ],
    "answer": "To simplify exception handling by automatically invoking `__enter__` and `__exit__` methods.",
    "explanation": "The `with` statement calls `__enter__` on the context manager before the block and guarantees `__exit__` is called after, even if an exception occurs, ensuring resources (files, locks) are cleaned up.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What does the `nonlocal` statement do inside a nested function?",
    "options": [
      "It allows the function to access global variables.",
      "It indicates that the variable refers to a variable in the enclosing (non-global) scope, allowing assignment to it.",
      "It prevents the variable from being garbage collected.",
      "It imports a module from a non-standard library path."
    ],
    "answer": "It indicates that the variable refers to a variable in the enclosing (non-global) scope, allowing assignment to it.",
    "explanation": "Without `nonlocal`, assigning to a variable inside a function creates a new local variable. `nonlocal` tells Python to look for the variable in the enclosing scope (closure) and bind it there.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In the context of Python's `threading` module, what is a 'race condition'?",
    "options": [
      "A situation where two threads race to finish first, improving performance.",
      "An error where the outcome depends on the relative timing of uncontrollable events, often leading to inconsistent data.",
      "A specific type of exception raised when a thread fails to start.",
      "The condition used to stop a thread."
    ],
    "answer": "An error where the outcome depends on the relative timing of uncontrollable events, often leading to inconsistent data.",
    "explanation": "A race condition occurs when threads access shared data concurrently without proper synchronization, causing the final state to depend on the unpredictable order of execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is `collections.namedtuple` primarily used for?",
    "options": [
      "Creating dictionaries with faster lookup times.",
      "Defining immutable, tuple-like objects with named fields for better code readability.",
      "Creating mutable sequences that can be resized.",
      "Naming variables dynamically at runtime."
    ],
    "answer": "Defining immutable, tuple-like objects with named fields for better code readability.",
    "explanation": "`namedtuple` generates a class that subclasses `tuple`, allowing access to fields via attribute names (e.g., `obj.x`) while maintaining the immutability and memory efficiency of tuples.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "How does Python's `__init__.py` file affect a directory?",
    "options": [
      "It prevents Python from importing modules from that directory for security reasons.",
      "It marks the directory as a Python package, allowing it to be imported.",
      "It initializes the global interpreter lock for the directory.",
      "It specifies which compiler to use for the code within."
    ],
    "answer": "It marks the directory as a Python package, allowing it to be imported.",
    "explanation": "The presence of `__init__.py` (even if empty) signals to Python that the directory should be treated as a package or subpackage, enabling imports like `import package.module`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the output of `print(True + True)` in Python?",
    "options": [
      "True",
      "2",
      "RuntimeError",
      "TrueTrue"
    ],
    "answer": "2",
    "explanation": "In Python, `bool` is a subclass of `int`. `True` equals `1` and `False` equals `0`. Therefore, `True + True` evaluates to `1 + 1`, which is `2`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the difference between a 'shallow copy' and a 'deep copy'?",
    "options": [
      "A shallow copy creates a new object but references the same nested objects; a deep copy creates a new object and recursively copies nested objects.",
      "A shallow copy copies the memory address of the original; a deep copy copies the variable name.",
      "A shallow copy only works on immutable types; a deep copy only works on mutable types.",
      "A shallow copy is faster for all types because it uses C pointers; a deep copy is implemented purely in Python."
    ],
    "answer": "A shallow copy creates a new object but references the same nested objects; a deep copy creates a new object and recursively copies nested objects.",
    "explanation": "Shallow copies (e.g., `list.copy()`) construct a new compound object and insert references to the original's contents. Deep copies (`copy.deepcopy`) recursively copy the contents, creating independent copies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which module is commonly used for high-performance, zero-copy operations on large arrays of binary data in Python?",
    "options": [
      "csv",
      "array",
      "struct",
      "mmap"
    ],
    "answer": "mmap",
    "explanation": "The `mmap` (memory map) module allows for memory-mapped file access, enabling zero-copy access to large files by mapping them directly into virtual memory, rather than reading them into a buffer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of CPython 3.13's experimental \"nogil\" mode, what mechanism replaces the standard atomic reference counting to reduce synchronization overhead?",
    "options": [
      "Deferred reference counting",
      "Biased reference counting",
      "Cycle-collected reference counting",
      "Thread-local garbage collection"
    ],
    "answer": "Biased reference counting",
    "explanation": "Biased reference counting assumes an object is owned by a single thread, allowing non-atomic local increments/decrements. Atomic operations are only required when ownership is transferred to another thread.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "How does the garbage collection implementation in CPython's \"nogil\" branch differ fundamentally from the standard CPython implementation regarding generations?",
    "options": [
      "It introduces a fourth generation for long-lived objects",
      "It is non-generational, scanning all objects on the heap during every cycle",
      "It relies exclusively on reference counting, disabling the cycle detector",
      "It separates the heap into semi-spaces"
    ],
    "answer": "It is non-generational, scanning all objects on the heap during every cycle",
    "explanation": "To simplify thread-safety in the absence of the GIL, the new GC implementation removes generational separation. It performs a full heap scan (stop-the-world) instead of scanning specific generations based on thresholds.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which specific attribute definition distinguishes a *data descriptor* from a *non-data descriptor* in Python's attribute lookup protocol?",
    "options": [
      "Implementation of `__get__`",
      "Implementation of `__set__` or `__delete__`",
      "Implementation of `__set_name__`",
      "Being a class attribute rather than an instance attribute"
    ],
    "answer": "Implementation of `__set__` or `__delete__`",
    "explanation": "A data descriptor defines both `__get__` and `__set__` (or `__delete__`). Data descriptors take precedence over instance dictionaries during attribute lookup, whereas non-data descriptors (which only define `__get__`) can be shadowed by instance attributes.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "During a stop-the-world garbage collection pause in CPython's \"nogil\" build, how are threads in the `DETACHED` state transitioned to the `GC` state?",
    "options": [
      "They are sent a UNIX signal (e.g., SIGUSR1)",
      "They transition via an atomic compare-and-swap operation on their status field",
      "They voluntarily check a global flag at the next bytecode instruction",
      "They are forcibly paused by the operating system scheduler"
    ],
    "answer": "They transition via an atomic compare-and-swap operation on their status field",
    "explanation": "The GC thread can safely transition `DETACHED` threads (which are not actively running Python code) to the `GC` state using an atomic CAS. `ATTACHED` threads (running code) must use the eval breaker to pause themselves.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In CPython, which method can be defined in a metaclass to customize the namespace mapping used during class creation?",
    "options": [
      "`__new__`",
      "`__init__`",
      "`__prepare__`",
      "`__call__`"
    ],
    "answer": "`__prepare__`",
    "explanation": "`__prepare__` is called before `__new__` and `__init__` to create the mapping object (usually a dict) that will hold the class body attributes. This allows, for example, the use of an `OrderedDict` to preserve attribute definition order.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "How does the `@contextlib.contextmanager` decorator handle exceptions raised within the `with` block?",
    "options": [
      "Exceptions are suppressed and logged to sys.stderr",
      "The exception is caught and re-raised in the yield statement within the generator",
      "The generator must implement a specific `__exit__` method to handle it",
      "The `with` block is aborted, but the generator code after `yield` executes regardless"
    ],
    "answer": "The exception is caught and re-raised in the yield statement within the generator",
    "explanation": "If an exception occurs in the block, the generator is resumed at the `yield` point, and the exception is raised there. This allows cleanup code in the generator to handle it or let it propagate.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the behavior of `asyncio.shield(aw)` if the awaiting coroutine is cancelled?",
    "options": [
      "The inner awaitable `aw` is cancelled immediately",
      "The inner awaitable `aw` continues to run, but the `shield` call raises `CancelledError`",
      "The `CancelledError` is suppressed and the inner awaitable completes",
      "Both the inner and outer coroutines become immune to cancellation"
    ],
    "answer": "The inner awaitable `aw` continues to run, but the `shield` call raises `CancelledError`",
    "explanation": "Shield protects the inner task from cancellation. If the outer awaiter is cancelled, the cancellation propagates to the awaiter of the shield, but the wrapped task continues running in the background.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "To implement a custom import mechanism that retrieves modules from a database, which protocol must you implement?",
    "options": [
      "`SourceLoader`",
      "`MetaPathFinder` (implementing `find_spec`)",
      "`ResourceReader`",
      "`ImportHook`"
    ],
    "answer": "`MetaPathFinder` (implementing `find_spec`)",
    "explanation": "Custom importers must implement the Finder protocol (specifically `find_spec` or legacy `find_module`) and be added to `sys.meta_path`. `SourceLoader` is a sub-protocol for loading from file-like sources.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which macro must be used in a CPython C-extension to release the Global Interpreter Lock (GIL) around a long-running or blocking operation?",
    "options": [
      "`PyEval_ReleaseLock()`",
      "`Py_BEGIN_ALLOW_THREADS`",
      "`Py_UNLOCK()",
      "`Py_DECREF()`"
    ],
    "answer": "`Py_BEGIN_ALLOW_THREADS`",
    "explanation": "`Py_BEGIN_ALLOW_THREADS` releases the GIL and `Py_END_ALLOW_THREADS` reacquires it. This allows other Python threads to run while the C code performs I/O or heavy computation.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What determines when CPython's standard generational garbage collector triggers a collection cycle?",
    "options": [
      "A fixed time interval",
      "The number of object allocations in a specific generation exceeding a threshold",
      "A reduction in available system memory below 10%",
      "Manual invocation via `gc.enable()` only"
    ],
    "answer": "The number of object allocations in a specific generation exceeding a threshold",
    "explanation": "The GC tracks allocations for each generation (Gen 0, 1, 2). When the allocation count for a generation surpasses its threshold (e.g., `gc.get_threshold()`), a cycle collection is triggered for that generation.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the primary effect of defining `__slots__` in a class regarding its instances?",
    "options": [
      "It allows dynamic addition of any attributes at runtime",
      "It prevents the creation of a `__dict__` for each instance, saving memory",
      "It forces the use of weak references for all attributes",
      "It automatically serializes the instance to a disk format"
    ],
    "answer": "It prevents the creation of a `__dict__` for each instance, saving memory",
    "explanation": "`__slots__` allocates space for a fixed set of attributes directly in the instance struct. This prevents the creation of the instance `__dict__`, significantly reducing memory overhead per instance.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which algorithm does CPython use to calculate the Method Resolution Order (MRO) for multiple inheritance?",
    "options": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "C3 Linearization",
      "Left-to-Right Depth-First"
    ],
    "answer": "C3 Linearization",
    "explanation": "Python uses C3 Linearization to compute the MRO. This algorithm ensures monotonicity (preserving local precedence orders) and prevents a class from appearing before its ancestors in the inheritance list.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In CPython, which strings are automatically interned (deduplicated) at compile time?",
    "options": [
      "All string literals",
      "Only strings that are identifiers (variable names, function names)",
      "Only strings shorter than 20 characters",
      "Strings defined in the global scope only"
    ],
    "answer": "Only strings that are identifiers (variable names, function names)",
    "explanation": "While all literals are technically candidates, CPython aggressively interns strings that look like identifiers to optimize dictionary lookups for attribute/variable access. Arbitrary string literals are not always interned unless explicitly requested.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "According to PEP 703 (Making the GIL Optional), which external memory allocator is adopted to allow the garbage collector to find objects without a linked list and improve concurrency?",
    "options": [
      "jemalloc",
      "tcmalloc",
      "mimalloc",
      "hdjemalloc"
    ],
    "answer": "mimalloc",
    "explanation": "PEP 703 specifies the use of `mimalloc`. Its internal structures allow the GC to traverse and find all Python objects without maintaining a separate linked list, and it enables thread-local operations that reduce locking.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "In Python's data model, how are small integers (typically -5 to 256) handled differently than large integers?",
    "options": [
      "They are stored as primitive C types, not Python objects",
      "They are pre-allocated singleton objects reused by all references",
      "They are always passed by value instead of by reference",
      "They use a custom variable-width integer encoding"
    ],
    "answer": "They are pre-allocated singleton objects reused by all references",
    "explanation": "CPython pre-creates an array of integer objects for this range. Any operation resulting in an integer in this range returns a reference to the existing singleton object rather than creating a new one.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Where are the variables captured by a closure stored?",
    "options": [
      "In the `__globals__` dictionary of the function",
      "In the `__code__` object as co_freevars",
      "In the `__closure__` tuple of the function object",
      "In the `__locals__` attribute of the frame"
    ],
    "answer": "In the `__closure__` tuple of the function object",
    "explanation": "The captured values are stored as cells in the `__closure__` tuple. The `__code__` object stores the *names* of the captured variables (`co_freevars`), while `__closure__` holds the actual runtime values.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does the zero-argument form of `super()` determine the class and instance arguments in Python 3?",
    "options": [
      "It searches the global namespace for the current class",
      "It relies on a compiler-generated `__class__` closure variable",
      "It inspects the stack frame to determine the caller's context",
      "It defaults to the first base class of the current module"
    ],
    "answer": "It relies on a compiler-generated `__class__` closure variable",
    "explanation": "The compiler injects a closure variable named `__class__` into methods. `super()` uses this variable to determine the correct class and the first argument (usually `self`) to bind the methods.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What happens to a Python thread's execution when it performs an I/O operation (e.g., `time.sleep` or socket read) under the standard CPython GIL?",
    "options": [
      "The GIL remains locked, blocking all other threads",
      "The GIL is released, allowing other threads to acquire it and run",
      "The thread is terminated and restarted after I/O completes",
      "The operation is moved to a separate kernel process"
    ],
    "answer": "The GIL is released, allowing other threads to acquire it and run",
    "explanation": "I/O-bound operations in CPython explicitly release the GIL while waiting for the OS. This prevents blocking the entire interpreter, allowing other threads to perform CPU work during the wait time.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the purpose of the `ma_version_tag` in CPython's dictionary implementation?",
    "options": [
      "To store the hash value of the keys",
      "To detect concurrent modifications during iteration",
      "To optimize lookups for integer keys",
      "To trigger dictionary resizing"
    ],
    "answer": "To detect concurrent modifications during iteration",
    "explanation": "The version tag increments every time the dictionary is structurally modified (insertion/deletion). Iterators check this tag to raise a `RuntimeError` if the dictionary changes during iteration.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does `typing.Protocol` differ from standard Abstract Base Classes (ABCs) regarding type checking?",
    "options": [
      "ABCs perform static type checking; Protocols perform runtime checking",
      "Protocols support structural subtyping (duck typing), while ABCs require nominal subtyping",
      "Protocols cannot be instantiated, whereas ABCs can",
      "Protocols are deprecated in favor of ABCs"
    ],
    "answer": "Protocols support structural subtyping (duck typing), while ABCs require nominal subtyping",
    "explanation": "A class is considered a subtype of a `Protocol` if it implements the required methods/attributes, even if it doesn't explicitly inherit from it. ABCs require explicit inheritance (`isinstance` checks).",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "Which method allows an object to customize how it is serialized by the `pickle` module?",
    "options": [
      "`__reduce__`",
      "`__serialize__`",
      "`__dict__`",
      "`__deepcopy__`"
    ],
    "answer": "`__reduce__`",
    "explanation": "`__reduce__` (and `__reduce_ex__`) returns a tuple describing how to reconstruct the object. Alternatives include `__getstate__` and `__setstate__`, but `__reduce__` is the primary interface for customizing the pickle protocol.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the default behavior of the Global Interpreter Lock (GIL) in CPython 3.13?",
    "options": [
      "It is removed entirely and cannot be enabled",
      "It is enabled by default but can be disabled at compile-time (`--disable-gil`)",
      "It is automatically disabled for I/O-bound threads",
      "It is replaced by a per-module lock"
    ],
    "answer": "It is enabled by default but can be disabled at compile-time (`--disable-gil`)",
    "explanation": "In Python 3.13, the GIL remains the default behavior for backward compatibility. The \"nogil\" mode (free-threaded build) is an experimental feature requiring a specific compilation flag.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How are signals (e.g., KeyboardInterrupt via SIGINT) handled in the CPython interpreter loop?",
    "options": [
      "The signal handler runs immediately, interrupting the current bytecode instruction",
      "The signal handler sets a flag checked at the next bytecode evaluation interval",
      "Signals are queued and processed only at the end of the main script",
      "Signals are ignored unless the `signal` module is imported"
    ],
    "answer": "The signal handler sets a flag checked at the next bytecode evaluation interval",
    "explanation": "Actual signal handling in C is deferred to avoid corrupting state. A flag is set, and the main interpreter loop checks this flag at regular intervals (\"check interval\") to raise the Python exception.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the \"nogil\" CPython implementation, what mechanism is used to pause threads that are in the `ATTACHED` state (running Python bytecode) during a stop-the-world GC?",
    "options": [
      "Atomic compare-and-swap",
      "The eval breaker mechanism",
      "A global mutex lock",
      "Thread priority elevation"
    ],
    "answer": "The eval breaker mechanism",
    "explanation": "Threads running bytecode must be polled to stop safely. The GC uses the \"eval breaker\" mechanism to request these threads to pause and transition to the `GC` state.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Which bytecode instruction is optimized for accessing local variables because it uses an array index rather than a dictionary lookup?",
    "options": [
      "`LOAD_NAME`",
      "`LOAD_GLOBAL`",
      "`LOAD_FAST`",
      "`LOAD_CONST`"
    ],
    "answer": "`LOAD_FAST`",
    "explanation": "`LOAD_FAST` accesses the `fastlocals` array (an array of PyObject pointers) using a constant index offset. This is significantly faster than `LOAD_NAME` or `LOAD_GLOBAL`, which involve dictionary lookups.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the primary distinction between `asyncio.Task` and `asyncio.Future`?",
    "options": [
      "Tasks are cancellable; Futures are not",
      "Tasks wrap coroutines and drive their execution on the event loop; Futures represent a low-level awaitable result",
      "Tasks are for I/O; Futures are for CPU computation",
      "Tasks can be awaited multiple times; Futures cannot"
    ],
    "answer": "Tasks wrap coroutines and drive their execution on the event loop; Futures represent a low-level awaitable result",
    "explanation": "A `Task` is a subclass of `Future` that specifically schedules and executes a coroutine. A `Future` is just a container for a result that will arrive later, typically used by library authors.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "In the context of Python's GIL, why is reference counting difficult to make thread-safe without the GIL?",
    "options": [
      "Because reference counts are stored on disk",
      "Because `__del__` methods are not thread-safe",
      "Because virtually every operation modifies a reference count, requiring expensive atomic instructions",
      "Because integers are immutable"
    ],
    "answer": "Because virtually every operation modifies a reference count, requiring expensive atomic instructions",
    "explanation": "Every object assignment or function call affects reference counts. Without the GIL, protecting these counts with atomic operations or locks creates massive contention and overhead, severely degrading performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Which fields are mandatory in the `PyObject` structure definition in CPython?",
    "options": [
      "`ob_refcnt` and `ob_type`",
      "`ob_size` and `ob_digit`",
      "`ob_dict` and `ob_weaklist`",
      "`ob_gc_bits` and `ob_gc_next`"
    ],
    "answer": "`ob_refcnt` and `ob_type`",
    "explanation": "Every Python object begins with a reference count (`ob_refcnt`) and a pointer to its type object (`ob_type`). Other fields (like `ob_size` for variable-sized objects) follow depending on the type.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "How does `sys.setswitchinterval(seconds)` affect the Python interpreter?",
    "options": [
      "It changes the time quantum for the OS process scheduler",
      "It adjusts the number of bytecode instructions executed before a thread switch check",
      "It sets the maximum wait time for I/O operations",
      "It configures the interval for asynchronous task checking"
    ],
    "answer": "It adjusts the number of bytecode instructions executed before a thread switch check",
    "explanation": "The switch interval determines how often the interpreter checks if it should release the GIL or switch to another thread. It translates to a target time, but implementation-wise, it triggers a check after N bytecode instructions.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the specific memory safety issue that \"Biased Reference Counting\" in the \"nogil\" build aims to solve?",
    "options": [
      "Memory leaks in circular references",
      "Race conditions when multiple threads increment/decrement the same reference count simultaneously",
      "Fragmentation of the heap",
      "Lack of type safety in C extensions"
    ],
    "answer": "Race conditions when multiple threads increment/decrement the same reference count simultaneously",
    "explanation": "Standard reference counting is not thread-safe. Biased counting optimizes for the common case where an object is used by one thread, removing the need for atomic synchronization until the object is shared.",
    "difficulty": "Advanced"
  }
]