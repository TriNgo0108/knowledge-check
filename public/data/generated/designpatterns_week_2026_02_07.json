[
  {
    "id": 1,
    "question": "What is the primary distinction between an Architecture Pattern and a Design Pattern in enterprise software?",
    "options": [
      "Architecture patterns manage data storage, while design patterns manage user interfaces.",
      "Architecture patterns define the high-level structure of the system, while design patterns address specific problems within components.",
      "Architecture patterns are used for frontend development, while design patterns are used for backend logic.",
      "Design patterns are written in HTML, while architecture patterns are written in Java."
    ],
    "answer": "Architecture patterns define the high-level structure of the system, while design patterns address specific problems within components.",
    "explanation": "Architecture patterns operate at the macro level, dictating the overall system structure (e.g., Microservices). Design patterns operate at the micro level, solving specific implementation issues within code modules.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which Design Pattern category does the 'Singleton' pattern belong to?",
    "options": [
      "Structural",
      "Behavioral",
      "Creational",
      "Architectural"
    ],
    "answer": "Creational",
    "explanation": "The Singleton pattern is part of the Creational category because it deals with object creation mechanisms, ensuring a class has only one instance.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In the context of Layered Architecture, which layer is responsible for executing business rules and logic?",
    "options": [
      "Presentation Layer",
      "Database Layer",
      "Business Layer",
      "Persistence Layer"
    ],
    "answer": "Business Layer",
    "explanation": "The Business Layer contains the logic that executes specific business rules, distinct from the Presentation (UI) or Persistence (data storage) layers.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the core purpose of the Repository pattern?",
    "options": [
      "To create a visual representation of database tables.",
      "To mediate between the domain and data mapping layers, acting like an in-memory collection of domain objects.",
      "To allow multiple users to edit code simultaneously.",
      "To schedule background jobs for data processing."
    ],
    "answer": "To mediate between the domain and data mapping layers, acting like an in-memory collection of domain objects.",
    "explanation": "The Repository pattern abstracts the data access logic, providing a more object-oriented view of the persistence layer and mimicking a collection of objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which enterprise architecture pattern structures an application as a collection of loosely coupled, independently deployable services?",
    "options": [
      "Monolithic Architecture",
      "Layered Architecture",
      "Microservices Architecture",
      "Single-Page Application Architecture"
    ],
    "answer": "Microservices Architecture",
    "explanation": "Microservices architecture structures the application as a set of small services, each running in its own process and communicating via lightweight mechanisms, allowing independent deployment.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which component in the Model-View-Controller (MVC) pattern is responsible for handling user input and updating the Model?",
    "options": [
      "The View",
      "The Controller",
      "The Model",
      "The Repository"
    ],
    "answer": "The Controller",
    "explanation": "The Controller accepts user inputs and commands the Model to perform actions based on that input. The View is strictly for displaying data.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the main benefit of using the Strategy design pattern?",
    "options": [
      "It enforces that a class can only have one instance.",
      "It allows a family of algorithms to be defined and encapsulated, making them interchangeable at runtime.",
      "It provides a unified interface to a set of interfaces in a subsystem.",
      "It defers the exact steps of an algorithm to a subclass."
    ],
    "answer": "It allows a family of algorithms to be defined and encapsulated, making them interchangeable at runtime.",
    "explanation": "The Strategy pattern defines a group of algorithms, encapsulates each one, and makes them interchangeable, letting the algorithm vary independently from clients that use it.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "In an Event-Driven Architecture, how do components typically interact?",
    "options": [
      "Through direct synchronous method calls.",
      "By sharing a common memory block.",
      "Via the production and detection of events.",
      "By tightly coupling their interfaces."
    ],
    "answer": "Via the production and detection of events.",
    "explanation": "In Event-Driven Architecture, components communicate asynchronously through events, allowing for loose coupling and high scalability.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which pattern involves separating the read (query) operations from the write (update) operations of a data store?",
    "options": [
      "Layered Architecture",
      "CQRS (Command Query Responsibility Segregation)",
      "Repository Pattern",
      "Singleton Pattern"
    ],
    "answer": "CQRS (Command Query Responsibility Segregation)",
    "explanation": "CQRS separates the responsibility of handling commands (writes) from queries (reads), allowing them to be optimized and scaled independently.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the primary role of the Data Transfer Object (DTO) pattern?",
    "options": [
      "To execute complex SQL queries.",
      "To transfer data between software application subsystems or layers with fewer method calls.",
      "To secure user passwords via encryption.",
      "To manage database transactions."
    ],
    "answer": "To transfer data between software application subsystems or layers with fewer method calls.",
    "explanation": "A DTO is an object that carries data between processes to reduce the number of method calls, primarily used to aggregate data for transfer.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which creational pattern uses a separate 'builder' object to construct a complex object step by step?",
    "options": [
      "Factory Method",
      "Abstract Factory",
      "Builder",
      "Prototype"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified?",
    "options": [
      "Observer",
      "Mediator",
      "Memento",
      "Visitor"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern establishes a subscription mechanism to notify multiple objects about any events that happen to the object they are observing.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the 'Separation of Concerns' principle?",
    "options": [
      "Mixing business logic with UI code for faster performance.",
      "Separating a computer program into distinct sections, where each section addresses a separate concern.",
      "Writing all code in a single file to simplify deployment.",
      "Ensuring all developers work on the same module."
    ],
    "answer": "Separating a computer program into distinct sections, where each section addresses a separate concern.",
    "explanation": "Separation of Concerns involves dividing a system into distinct features that overlap in functionality as little as possible, improving manageability and modularity.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "In Hexagonal Architecture, what is the primary goal?",
    "options": [
      "To arrange servers in a physical hexagon shape.",
      "To isolate the core application logic from external concerns like UI, database, and external services.",
      "To use six different databases for high availability.",
      "To restrict the application to only web-based interfaces."
    ],
    "answer": "To isolate the core application logic from external concerns like UI, database, and external services.",
    "explanation": "Hexagonal Architecture (Ports and Adapters) aims to create a loosely coupled application by isolating the core (domain) logic from the outside world through defined ports.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which enterprise pattern involves organizing business logic as a single procedure for each user action?",
    "options": [
      "Domain Model",
      "Transaction Script",
      "Service Layer",
      "Active Record"
    ],
    "answer": "Transaction Script",
    "explanation": "Transaction Script organizes business logic primarily as a single procedure (script) for each specific use case or transaction, distinguishing it from object-oriented Domain Models.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the function of the Adapter design pattern?",
    "options": [
      "To add new functionality to an object dynamically.",
      "To allow incompatible interfaces to work together.",
      "To restrict the creation of instances of a class.",
      "To provide a simplified interface to a complex subsystem."
    ],
    "answer": "To allow incompatible interfaces to work together.",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces, enabling classes to work together that couldn't otherwise due to interface mismatch.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which of the following best describes the 'Unit of Work' pattern?",
    "options": [
      "A pattern that tracks all changes to a set of objects and writes them to the database in a single transaction.",
      "A pattern where a single developer works on a unit of code.",
      "A pattern that defines a 1:1 relationship between a class and a database table.",
      "A pattern for separating read and write operations."
    ],
    "answer": "A pattern that tracks all changes to a set of objects and writes them to the database in a single transaction.",
    "explanation": "The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates the writing out of changes as a single atomic action.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which pattern is best described as a structural pattern that composes objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Decorator",
      "Composite",
      "Facade",
      "Flyweight"
    ],
    "answer": "Composite",
    "explanation": "The Composite pattern allows clients to treat individual objects and compositions of objects uniformly, creating tree structures of objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the key characteristic of a Monolithic architecture pattern?",
    "options": [
      "Applications are divided into hundreds of micro-deployments.",
      "The user interface, business logic, and data access code are combined into a single unified program.",
      "Data is stored exclusively in flat files.",
      "It requires a service-oriented architecture for communication."
    ],
    "answer": "The user interface, business logic, and data access code are combined into a single unified program.",
    "explanation": "Monolithic architecture packages the application as a single deployable unit containing all functionality, sharing a single codebase and memory space.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which design pattern restricts the instantiation of a class to one object and provides a global point of access to it?",
    "options": [
      "Factory Method",
      "Singleton",
      "Builder",
      "Prototype"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern ensures a class has only one instance and provides a global point of access to that instance, often used for logging or configuration.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which pattern provides a unified interface to a set of interfaces in a subsystem, making the subsystem easier to use?",
    "options": [
      "Facade",
      "Adapter",
      "Decorator",
      "Proxy"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a higher-level interface that makes a subsystem easier to use by reducing complexity and hiding the communication dependencies of its internal components.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "In the context of API Gateway pattern, what is the Gateway's primary role?",
    "options": [
      "To act as a reverse proxy routing requests to specific microservices.",
      "To permanently store all user data.",
      "To replace the need for a database.",
      "To compile source code on the client side."
    ],
    "answer": "To act as a reverse proxy routing requests to specific microservices.",
    "explanation": "An API Gateway acts as a single entry point for all clients, routing requests to the appropriate backend microservices and handling cross-cutting concerns like authentication.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which pattern allows an object to alter its behavior when its internal state changes, appearing to change its class?",
    "options": [
      "State",
      "Strategy",
      "Command",
      "Iterator"
    ],
    "answer": "State",
    "explanation": "The State pattern allows an object to change its behavior when its internal state changes, effectively replacing conditional logic with polymorphism.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the 'SOLID' principle 'O' an acronym for?",
    "options": [
      "Open/Closed Principle",
      "Object-Oriented Principle",
      "Original Class Principle",
      "Operator Overloading Principle"
    ],
    "answer": "Open/Closed Principle",
    "explanation": "The 'O' in SOLID stands for the Open/Closed Principle, which states that software entities should be open for extension but closed for modification.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which design pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses?",
    "options": [
      "Template Method",
      "Strategy",
      "Builder",
      "Factory Method"
    ],
    "answer": "Template Method",
    "explanation": "The Template Method pattern defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses without changing the algorithm's structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which pattern is useful for postponing the expensive creation of an object until it is actually needed?",
    "options": [
      "Lazy Loading",
      "Eager Loading",
      "Singleton",
      "Factory"
    ],
    "answer": "Lazy Loading",
    "explanation": "Lazy Loading is a design pattern that delays the initialization of an object until the point at which it is needed, improving performance and resource utilization.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which structural pattern involves attaching additional responsibilities to an object dynamically?",
    "options": [
      "Decorator",
      "Proxy",
      "Adapter",
      "Bridge"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which pattern acts as a surrogate or placeholder for another object to control access to it?",
    "options": [
      "Proxy",
      "Facade",
      "Observer",
      "Decorator"
    ],
    "answer": "Proxy",
    "explanation": "The Proxy pattern provides a representative or surrogate object that controls access to another object, often used for lazy loading or access control.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the primary advantage of using Service-Oriented Architecture (SOA)?",
    "options": [
      "Tight coupling of services.",
      "Use of monolithic deployment.",
      "Service reuse and interoperability.",
      "Elimination of the need for APIs."
    ],
    "answer": "Service reuse and interoperability.",
    "explanation": "SOA promotes service reuse and interoperability by packaging business functions as interoperable services, though it can add complexity with service contracts.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which pattern encapsulates a request as an object, thereby allowing you to parameterize clients with different requests?",
    "options": [
      "Command",
      "Strategy",
      "State",
      "Observer"
    ],
    "answer": "Command",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request, enabling queuing, logging, and undoable operations.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "In a 'Layered Architecture', which rule typically governs the direction of dependencies?",
    "options": [
      "Dependencies can flow in any direction.",
      "Dependencies only flow downwards (Upper layers depend on lower layers).",
      "Dependencies only flow upwards.",
      "There are no dependency rules."
    ],
    "answer": "Dependencies only flow downwards (Upper layers depend on lower layers).",
    "explanation": "Layered Architecture enforces a strict dependency rule where upper layers (like Presentation) depend on lower layers (like Business), but lower layers should not depend on upper layers.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which behavioral pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator",
      "Visitor",
      "Mediator",
      "Memento"
    ],
    "answer": "Iterator",
    "explanation": "The Iterator pattern provides a uniform way to traverse various aggregate structures (like lists) without exposing the internal structure of the aggregate.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the primary purpose of the Prototype pattern?",
    "options": [
      "To create new objects by cloning an existing instance.",
      "To separate the construction of a complex object from its representation.",
      "To define an interface for creating an object, but let subclasses decide which class to instantiate.",
      "To convert the interface of a class into another interface clients expect."
    ],
    "answer": "To create new objects by cloning an existing instance.",
    "explanation": "The Prototype pattern specifies the kinds of objects to create using a prototypical instance and creates new objects by copying this prototype.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which design pattern lets you define a family of algorithms, encapsulate each one, and make them interchangeable?",
    "options": [
      "Strategy",
      "Template Method",
      "Observer",
      "Facade"
    ],
    "answer": "Strategy",
    "explanation": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable, letting the algorithm vary independently from clients that use it.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In the context of Enterprise patterns, what does the acronym DTO stand for?",
    "options": [
      "Data Transfer Object",
      "Dynamic Type Object",
      "Database Transaction Order",
      "Direct Thread Operation"
    ],
    "answer": "Data Transfer Object",
    "explanation": "DTO stands for Data Transfer Object. It is an object used to carry data between processes to reduce the number of method calls.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which design pattern ensures a class has only one instance and provides a global point of access to it?",
    "options": [
      "Factory Method",
      "Singleton",
      "Builder",
      "Prototype"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. Factory Method and Builder are creational patterns designed for creating multiple or varying objects, not enforcing a single instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In the Strategy pattern, how is the algorithm selected at runtime?",
    "options": [
      "The context class contains conditional logic to select the algorithm",
      "The client passes a concrete strategy object to the context",
      "The algorithm is determined by the return type of the method",
      "A factory dynamically subclasses the context to swap behavior"
    ],
    "answer": "The client passes a concrete strategy object to the context",
    "explanation": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. The context delegates the work to the strategy interface implementation provided by the client.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary responsibility of the Controller in the Model-View-Controller (MVC) pattern?",
    "options": [
      "Directly rendering the user interface HTML",
      "Managing the business rules and data persistence",
      "Handling input logic and updating the Model",
      "Maintaining the state of the View between requests"
    ],
    "answer": "Handling input logic and updating the Model",
    "explanation": "The Controller acts as an intermediary that processes user input, manipulates the Model, and selects the View. The View handles rendering, and the Model manages data and business logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which pattern decouples the abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Adapter",
      "Bridge",
      "Proxy",
      "Facade"
    ],
    "answer": "Bridge",
    "explanation": "The Bridge pattern separates abstraction (interface) from implementation (details), allowing them to evolve independently. Adapter merely makes incompatible interfaces work together without this structural decoupling.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In a Layered Architecture, which direction is the dependency rule typically enforced?",
    "options": [
      "Dependencies can flow in any direction as long as they are interfaces",
      "Dependencies must flow strictly downwards, from upper layers to lower layers",
      "Dependencies are inverted, with lower layers depending on upper layers",
      "Layers are independent and share no dependencies"
    ],
    "answer": "Dependencies must flow strictly downwards, from upper layers to lower layers",
    "explanation": "Layered architecture enforces that higher-level layers (like Presentation) depend on lower-level layers (like Business Logic and Data), but not vice versa.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the core benefit of using the Repository pattern?",
    "options": [
      "It provides a mechanism for real-time data synchronization between databases",
      "It acts as a mediator between the domain and data mapping layers, presenting a collection-like interface",
      "It creates a separate read model to optimize query performance",
      "It eliminates the need for transaction management in enterprise applications"
    ],
    "answer": "It acts as a mediator between the domain and data mapping layers, presenting a collection-like interface",
    "explanation": "The Repository pattern abstracts the data source, treating it as an in-memory collection. CQRS focuses on read/write separation, while the Repository focuses on data access encapsulation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which pattern allows you to add new functionality to an existing object dynamically without altering its structure?",
    "options": [
      "Proxy",
      "Decorator",
      "Composite",
      "Adapter"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically at runtime. Proxy controls access, while Composite treats individual objects and compositions uniformly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What distinguishes the Factory Method pattern from the Abstract Factory pattern?",
    "options": [
      "Factory Method creates objects via inheritance; Abstract Factory creates objects via composition",
      "Factory Method is a creational pattern; Abstract Factory is a structural pattern",
      "Factory Method uses a class to delegate object creation; Abstract Factory uses interfaces only",
      "There is no difference; they are synonymous names for the same pattern"
    ],
    "answer": "Factory Method creates objects via inheritance; Abstract Factory creates objects via composition",
    "explanation": "Factory Method relies on subclasses to decide which class to instantiate (inheritance). Abstract Factory provides an interface for creating families of related objects without specifying their concrete classes (composition of factories).",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the context of CQRS (Command Query Responsibility Segregation), what is the primary driver for splitting models?",
    "options": [
      "To reduce the number of database servers required",
      "To allow independent scaling and optimization of read and write operations",
      "To enforce strict ACID properties on all database transactions",
      "To separate the user interface from the business logic"
    ],
    "answer": "To allow independent scaling and optimization of read and write operations",
    "explanation": "CQRS separates read and write models to optimize performance and scalability. It allows using different data schemas for reads (denormalized) and writes (normalized).",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which pattern defines a skeleton of an algorithm in a base class, deferring some steps to subclasses?",
    "options": [
      "Strategy",
      "Template Method",
      "Builder",
      "Facade"
    ],
    "answer": "Template Method",
    "explanation": "The Template Method pattern defines the program structure of an algorithm but lets subclasses override specific steps. The Strategy pattern encapsulates the entire algorithm.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the primary disadvantage of a tightly coupled Monolithic architecture compared to Microservices?",
    "options": [
      "It is difficult to scale individual components independently",
      "It cannot support a user interface",
      "It requires a polyglot programming environment",
      "It eliminates the need for a database"
    ],
    "answer": "It is difficult to scale individual components independently",
    "explanation": "Monolithic architectures package all functionality together; scaling one feature requires scaling the entire application. Microservices allow independent scaling.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "The Observer pattern is primarily used to establish which type of relationship?",
    "options": [
      "One-to-one dependency between objects",
      "One-to-many dependency between objects",
      "Many-to-one dependency between objects",
      "Hierarchical inheritance between classes"
    ],
    "answer": "One-to-many dependency between objects",
    "explanation": "The Observer pattern defines a subscription mechanism where multiple observers are notified when a subject changes state. It creates a one-to-many relationship.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which design pattern provides a unified interface to a set of interfaces in a subsystem?",
    "options": [
      "Facade",
      "Adapter",
      "Bridge",
      "Proxy"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a simplified, high-level interface to a complex subsystem. Adapter makes two *existing* interfaces compatible; Facade defines a *new* interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In the context of Enterprise patterns, what is the primary role of a Data Transfer Object (DTO)?",
    "options": [
      "To encapsulate database access logic for a specific table",
      "To transfer data between processes (layers) to reduce the number of method calls",
      "To validate user input before it reaches the controller",
      "To handle database transactions automatically"
    ],
    "answer": "To transfer data between processes (layers) to reduce the number of method calls",
    "explanation": "A DTO is an object that carries data between processes to aggregate multiple values into a single transfer, reducing network or method invocation overhead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which pattern is best suited for handling a request by passing it along a chain of potential handlers?",
    "options": [
      "Command",
      "Chain of Responsibility",
      "Mediator",
      "Observer"
    ],
    "answer": "Chain of Responsibility",
    "explanation": "Chain of Responsibility passes a request sequentially along a chain. The request stops propagating once a handler processes it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "Which SOLID principle dictates that high-level modules should not depend on low-level modules, but both should depend on abstractions?",
    "options": [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Liskov Substitution Principle",
      "Dependency Inversion Principle"
    ],
    "answer": "Dependency Inversion Principle",
    "explanation": "The Dependency Inversion Principle (DIP) decouples high-level logic from low-level details by relying on abstractions. Single Responsibility focuses on one reason to change.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is the key characteristic of the Prototype pattern?",
    "options": [
      "It creates new objects by cloning an existing instance",
      "It separates the construction of a complex object from its representation",
      "It restricts a class to a single instance",
      "It converts the interface of a class into another interface clients expect"
    ],
    "answer": "It creates new objects by cloning an existing instance",
    "explanation": "The Prototype pattern specifies the kind of objects to create using a prototypical instance and creates new objects by copying this prototype.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "In Microservices architecture, how does the 'Shared Database' pattern impact deployment independence?",
    "options": [
      "It increases independence by standardizing the schema",
      "It creates a tight coupling, reducing the ability of services to evolve independently",
      "It has no impact on deployment strategies",
      "It ensures ACID compliance across all services"
    ],
    "answer": "It creates a tight coupling, reducing the ability of services to evolve independently",
    "explanation": "Sharing a database couples services at the data layer; a schema change in one service can break others. True independence requires separate databases or schemas per service.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which design pattern allows you to encapsulate a request as an object, thereby allowing parameterization of clients with different requests?",
    "options": [
      "State",
      "Command",
      "Memento",
      "Iterator"
    ],
    "answer": "Command",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the primary function of the Unit of Work pattern in data persistence?",
    "options": [
      "To map database tables to application objects",
      "To maintain a list of objects affected by a transaction and coordinate the writing out of changes",
      "To create complex database queries dynamically",
      "To separate read and write operations to different databases"
    ],
    "answer": "To maintain a list of objects affected by a transaction and coordinate the writing out of changes",
    "explanation": "The Unit of Work pattern tracks changes to business objects during a transaction and writes them out as a single batch, ensuring consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which structural pattern composes objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Decorator",
      "Flyweight",
      "Composite",
      "Bridge"
    ],
    "answer": "Composite",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly. Decorator adds behavior; Flyweight reduces memory usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What distinguishes the Proxy pattern from the Adapter pattern?",
    "options": [
      "Adapter changes the interface of an object; Proxy controls access to an object",
      "Proxy changes the interface; Adapter adds functionality",
      "Adapter is structural; Proxy is behavioral",
      "There is no difference; they are interchangeable"
    ],
    "answer": "Adapter changes the interface of an object; Proxy controls access to an object",
    "explanation": "A Proxy acts as a placeholder to control access (lazy loading, access control). An Adapter acts as a translator between incompatible interfaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which behavioral pattern defines an object that encapsulates how a set of objects interact?",
    "options": [
      "Mediator",
      "Observer",
      "Memento",
      "Strategy"
    ],
    "answer": "Mediator",
    "explanation": "The Mediator pattern promotes loose coupling by keeping objects from referring to each other explicitly, letting them communicate through a central mediator.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "In the context of Event-Driven Architecture, what is the role of an Event Bus?",
    "options": [
      "To persist all events to a database immediately",
      "To act as a channel that broadcasts events to subscribed consumers without the producer knowing who is listening",
      "To convert synchronous calls into asynchronous database queries",
      "To filter out duplicate events based on timestamp"
    ],
    "answer": "To act as a channel that broadcasts events to subscribed consumers without the producer knowing who is listening",
    "explanation": "The Event Bus decouples producers from consumers. Producers publish events to the bus, and the bus delivers them to registered subscribers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which pattern allows an object to alter its behavior when its internal state changes?",
    "options": [
      "Strategy",
      "State",
      "Command",
      "Visitor"
    ],
    "answer": "State",
    "explanation": "The State pattern allows an object to appear to change its class by delegating behavior to different state objects. Strategy typically sets behavior statically or contextually.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the primary purpose of the Flyweight pattern?",
    "options": [
      "To reduce memory usage by sharing common parts of state between similar objects",
      "To add new behaviors dynamically",
      "To control access to an expensive object",
      "To simplify the interface of a complex subsystem"
    ],
    "answer": "To reduce memory usage by sharing common parts of state between similar objects",
    "explanation": "Flyweight minimizes memory usage by sharing intrinsic state across many objects. Decorator adds behavior; Proxy controls access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which pattern involves a class that has only one instance and uses a private constructor?",
    "options": [
      "Builder",
      "Prototype",
      "Singleton",
      "Factory Method"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern requires a private constructor to prevent direct instantiation and a static mechanism to return the single instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "How does the Adapter pattern relate to the Facade pattern?",
    "options": [
      "Adapter simplifies a complex subsystem; Facade converts interfaces",
      "Adapter makes two existing interfaces work together; Facade provides a new simplified interface",
      "They are identical patterns with different names",
      "Adapter is for runtime changes; Facade is for compile-time changes"
    ],
    "answer": "Adapter makes two existing interfaces work together; Facade provides a new simplified interface",
    "explanation": "Adapter reconciles two incompatible interfaces. Facade defines a completely new interface to reduce complexity of an existing subsystem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which Enterprise Architecture pattern is characterized by 'Ports' and 'Adapters' to isolate the core logic from external concerns?",
    "options": [
      "Hexagonal Architecture",
      "Layered Architecture",
      "Microservices Architecture",
      "Serverless Architecture"
    ],
    "answer": "Hexagonal Architecture",
    "explanation": "Hexagonal Architecture (Ports and Adapters) isolates the application core by using interfaces (Ports) and implementations (Adapters) for IO, ensuring core logic is independent of technology.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In the Visitor pattern, where is the logic for operation execution defined?",
    "options": [
      "Within the element classes being visited",
      "Within a separate visitor object for each operation",
      "In a central controller class",
      "In the database schema"
    ],
    "answer": "Within a separate visitor object for each operation",
    "explanation": "The Visitor pattern separates operations from the object structure by defining operations in a separate Visitor class, rather than modifying the Element classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is a defining characteristic of the 'Transaction Script' pattern?",
    "options": [
      "Business logic is organized as a single procedure per user request",
      "It relies heavily on inheritance to share logic",
      "It creates a domain model that maps directly to the database",
      "It separates read and write models to improve performance"
    ],
    "answer": "Business logic is organized as a single procedure per user request",
    "explanation": "Transaction Script organizes business logic as a single procedure (often in a single method) that handles the request from start to finish.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which SOLID principle is violated if a class has too many reasons to change?",
    "options": [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Liskov Substitution Principle",
      "Interface Segregation Principle"
    ],
    "answer": "Single Responsibility Principle",
    "explanation": "The Single Responsibility Principle (SRP) states that a class should have one reason to change. Multiple reasons imply multiple responsibilities.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which pattern is used to provide a serialized view of an object's state to allow rollback to that state?",
    "options": [
      "Memento",
      "Command",
      "State",
      "Observer"
    ],
    "answer": "Memento",
    "explanation": "The Memento pattern captures and externalizes an object's internal state without violating encapsulation, allowing the object to be restored to this state later.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which interface design principle states that clients should not be forced to depend on interfaces they do not use?",
    "options": [
      "Interface Segregation Principle",
      "Dependency Inversion Principle",
      "Liskov Substitution Principle",
      "Open/Closed Principle"
    ],
    "answer": "Interface Segregation Principle",
    "explanation": "The Interface Segregation Principle (ISP) advocates for splitting large interfaces into smaller, specific ones so clients only depend on the methods they use.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "How does the 'Blackboard' pattern fundamentally differ from the 'Mediator' pattern?",
    "options": [
      "Blackboard involves multiple specialized modules collaborating on a shared data store; Mediator coordinates objects via direct method calls",
      "Mediator is for AI systems; Blackboard is for UI systems",
      "Blackboard uses a central controller; Mediator does not",
      "There is no functional difference"
    ],
    "answer": "Blackboard involves multiple specialized modules collaborating on a shared data store; Mediator coordinates objects via direct method calls",
    "explanation": "The Blackboard pattern is defined by a shared common data space that solvers modify. Mediator facilitates communication between objects but they do not necessarily share a single mutable state repository.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What is the primary distinction between the 'Abstract Factory' and 'Factory Method' patterns regarding object creation?",
    "options": [
      "Abstract Factory creates objects through inheritance, while Factory Method uses composition.",
      "Factory Method creates single objects, while Abstract Factory creates families of related or dependent objects.",
      "Factory Method defers instantiation to subclasses, whereas Abstract Factory exposes a singleton instance for creation.",
      "Abstract Factory is a creational pattern, whereas Factory Method is a structural pattern."
    ],
    "answer": "Factory Method creates single objects, while Abstract Factory creates families of related or dependent objects.",
    "explanation": "Factory Method defines a method for creating a single object, letting subclasses decide which class to instantiate. Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In the context of CQRS (Command Query Responsibility Segregation), what is the primary trade-off when implementing a separate read model?",
    "options": [
      "Strong consistency is guaranteed between the read and write models at the cost of higher latency.",
      "Eventual consistency must be managed, as data synchronization between write and read models is asynchronous.",
      "The read model cannot be optimized for specific queries and must mirror the write database schema exactly.",
      "Write operations become significantly slower because the database must update two separate tables simultaneously."
    ],
    "answer": "Eventual consistency must be managed, as data synchronization between write and read models is asynchronous.",
    "explanation": "CQRS separates writes and reads, often allowing them to scale independently. This typically results in eventual consistency for the read model, which accepts stale data in exchange for high throughput and reduced read latency.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which pattern is most appropriate for decoupling the internal logic of a subsystem from its interface, allowing the implementation to be replaced without affecting clients?",
    "options": [
      "Adapter",
      "Bridge",
      "Facade",
      "Decorator"
    ],
    "answer": "Bridge",
    "explanation": "The Bridge pattern separates an objectâ€™s abstraction (interface) from its implementation so that the two can vary independently. Adapter converts one interface to another, and Facade simplifies an existing interface, but does not decouple implementation from abstraction in the design phase.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "In a Microservices architecture, which pattern facilitates the propagation of a state change across multiple services without them directly invoking each other?",
    "options": [
      "Service Registry",
      "Circuit Breaker",
      "Event Choreography",
      "Database per Service"
    ],
    "answer": "Event Choreography",
    "explanation": "Event Choreography uses events to trigger updates in other services, ensuring loose coupling. Services emit events when state changes, and other services react to those events without knowing the source.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the specific intent of the 'Memento' pattern?",
    "options": [
      "To encapsulate a request as an object, thereby allowing parameterization of clients with different requests.",
      "To capture and externalize an object's internal state without violating encapsulation so that it can be restored later.",
      "To provide a unified interface to a set of interfaces in a subsystem.",
      "To attach additional responsibilities to an object dynamically."
    ],
    "answer": "To capture and externalize an object's internal state without violating encapsulation so that it can be restored later.",
    "explanation": "Memento is used to implement state-saving mechanisms like undo/rollback. Command pattern encapsulates requests, and Decorator adds responsibilities.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "When implementing the 'Unit of Work' pattern, what is the core responsibility regarding database interaction?",
    "options": [
      "To map database rows to domain objects using an ORM.",
      "To manage a list of objects affected by a business transaction and coordinate the writing out of changes.",
      "To abstract the underlying database connection details to provide a generic query interface.",
      "To ensure that every read operation hits the cache before querying the database."
    ],
    "answer": "To manage a list of objects affected by a business transaction and coordinate the writing out of changes.",
    "explanation": "The Unit of Work pattern tracks changes to business objects during a transaction. It commits these changes as a single atomic action, ensuring consistency and minimizing database calls.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which structural pattern allows incompatible interfaces with similar functionality to work together by acting as a translator?",
    "options": [
      "Decorator",
      "Adapter",
      "Proxy",
      "Composite"
    ],
    "answer": "Adapter",
    "explanation": "The Adapter pattern converts the interface of a class into another interface clients expect. Proxy controls access, Decorator adds behavior, and Composite treats individual objects uniformly.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "How does the 'Sidecar' pattern facilitate application deployment in containerized architectures?",
    "options": [
      "By deploying the application logic and the monitoring/logging libraries in the same container instance.",
      "By placing a utility process in a separate container alongside the main application container, sharing the same lifecycle and host.",
      "By running a reverse proxy in front of the application container to handle incoming traffic routing.",
      "By splitting the application into two distinct services that communicate via synchronous HTTP calls."
    ],
    "answer": "By placing a utility process in a separate container alongside the main application container, sharing the same lifecycle and host.",
    "explanation": "The Sidecar pattern runs supporting features (like logging, monitoring, or networking) in a separate container within the same Pod. It promotes separation of concerns while sharing the execution environment.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the context of the 'Strategy' pattern, which scenario invalidates its use?",
    "options": [
      "When you have multiple algorithms for a specific task that need to be interchangeable at runtime.",
      "When a class has a massive conditional operator (switch) that switches between different behaviors.",
      "When the algorithms being swapped are completely unrelated to the context using them.",
      "When clients need to be aware of the specific strategies being implemented to pass data correctly."
    ],
    "answer": "When the algorithms being swapped are completely unrelated to the context using them.",
    "explanation": "Strategy relies on a common interface for interchangeable algorithms. If the algorithms are unrelated (share no interface/signature), the pattern cannot be applied effectively.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the main advantage of using the 'Repository' pattern over direct Data Access Object (DAO) usage?",
    "options": [
      "Repositories eliminate the need for a database connection pool.",
      "Repositories provide a collection-like interface for accessing domain objects, abstracting the underlying data source.",
      "DAOs allow querying, whereas Repositories only allow Create, Read, Update, and Delete (CRUD) operations.",
      "Repositories automatically cache all queries in memory to reduce database load."
    ],
    "answer": "Repositories provide a collection-like interface for accessing domain objects, abstracting the underlying data source.",
    "explanation": "The Repository pattern treats the data store as an in-memory collection, focusing on domain model access. DAOs are typically lower-level, closer to the database schema, and handle data mapping.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In a Distributed System, what issue does the 'Outbox' pattern specifically solve?",
    "options": [
      "It prevents data loss by persisting messages in the same database transaction as the business state.",
      "It creates a backup database to ensure read availability during write failures.",
      "It encrypts outgoing messages to ensure secure data transmission.",
      "It buffers high-velocity incoming traffic to protect the database from overload."
    ],
    "answer": "It prevents data loss by persisting messages in the same database transaction as the business state.",
    "explanation": "The Outbox pattern ensures atomicity by writing a message to an 'outbox' table within the same DB transaction as the business update. A separate process then reads the outbox and publishes the event.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which behavioral pattern allows you to define a new operation without changing the classes of the elements on which it operates?",
    "options": [
      "Iterator",
      "Visitor",
      "Command",
      "Observer"
    ],
    "answer": "Visitor",
    "explanation": "The Visitor pattern separates an algorithm from the object structure it operates on. It allows adding new operations to existing object structures without modifying the structures themselves.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What distinguishes the 'Active Record' pattern from the 'Data Mapper' pattern?",
    "options": [
      "Active Record uses XML for mapping, whereas Data Mapper uses annotations.",
      "Active Record couples the domain object with the database access logic, while Data Mapper separates them.",
      "Active Record is valid only for NoSQL databases, while Data Mapper is for relational databases.",
      "Data Mapper requires the domain object to inherit from a base mapper class."
    ],
    "answer": "Active Record couples the domain object with the database access logic, while Data Mapper separates them.",
    "explanation": "Active Record objects contain CRUD methods and knowledge of the database. Data Mapper creates a layer of Mappers that move data between objects and a database while keeping them independent.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In the 'Saga' pattern for distributed transactions, what mechanism handles the failure of a transaction in a long-running business process?",
    "options": [
      "Two-Phase Commit (2PC) protocol to roll back all resources.",
      "Compensating transactions to undo the changes made by preceding transactions.",
      "A global lock manager that blocks all subsequent operations.",
      "A retry loop that runs indefinitely until the transaction succeeds."
    ],
    "answer": "Compensating transactions to undo the changes made by preceding transactions.",
    "explanation": "Unlike ACID transactions, Sagas manage failures by executing a sequence of compensating transactions (logic that reverses the effect of the previous transaction) to maintain data consistency.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which pattern is best utilized to aggregate data from multiple disparate sources into a unified, simplified interface for a client?",
    "options": [
      "Bridge",
      "Facade",
      "Adapter",
      "Proxy"
    ],
    "answer": "Facade",
    "explanation": "The Facade pattern provides a unified interface to a set of interfaces in a subsystem. It defines a higher-level interface that makes the subsystem easier to use by aggregating complex interactions.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the primary purpose of the 'Intercepting Filter' pattern in web presentation architecture?",
    "options": [
      "To transform the response data into different formats like JSON or XML.",
      "To pre-process and post-process requests and responses, allowing for pluggable logic like logging or authentication.",
      "To intercept SQL queries and optimize them before execution.",
      "To filter out malicious SQL injection attacks from the user input."
    ],
    "answer": "To pre-process and post-process requests and responses, allowing for pluggable logic like logging or authentication.",
    "explanation": "Intercepting Filter enables the modular processing of a request/response chain. It allows developers to add/remove concerns (auth, logging, compression) by chaining filters.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Which design principle states that \"Software entities should be open for extension but closed for modification\"?",
    "options": [
      "Liskov Substitution Principle",
      "Open/Closed Principle",
      "Dependency Inversion Principle",
      "Interface Segregation Principle"
    ],
    "answer": "Open/Closed Principle",
    "explanation": "The Open/Closed Principle (OCP) dictates that a system should be architected so that new functionality can be added via extensions (polymorphism, inheritance) rather than changing existing, tested code.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the 'Flux' architecture pattern, what is the role of the Dispatcher?",
    "options": [
      "To query the data from the backend services.",
      "To act as a central hub that manages all data flow and ensures that no callback is missed.",
      "To store the application state and notify the views of changes.",
      "To render the UI components based on the current state."
    ],
    "answer": "To act as a central hub that manages all data flow and ensures that no callback is missed.",
    "explanation": "In Flux, the Dispatcher receives actions (payloads of data) and broadcasts them to all registered callbacks (Stores). It is the single point of control for the data flow.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which Creational pattern uses cloning to create new objects, bypassing the complexity and cost of standard instantiation ('new')?",
    "options": [
      "Builder",
      "Prototype",
      "Singleton",
      "Factory Method"
    ],
    "answer": "Prototype",
    "explanation": "The Prototype pattern creates new objects by cloning an existing instance (the prototype). This avoids creating subclasses or complex initialization logic associated with the Factory or Builder patterns.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does the 'Circuit Breaker' pattern improve system stability in distributed architectures?",
    "options": [
      "By routing traffic to the nearest data center to reduce latency.",
      "By detecting failures and preventing cascading failures by failing fast when a service is down.",
      "By automatically restarting services that have crashed due to unhandled exceptions.",
      "By encrypting traffic between microservices to prevent man-in-the-middle attacks."
    ],
    "answer": "By detecting failures and preventing cascading failures by failing fast when a service is down.",
    "explanation": "The Circuit Breaker wraps a protected function call. If the failure rate exceeds a threshold, it 'trips' and blocks calls for a duration, allowing the downstream service to recover and preventing resource exhaustion.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In the 'Mediator' pattern, how does it affect the coupling between colleague objects?",
    "options": [
      "It increases coupling by adding a dependency to the mediator class for all colleagues.",
      "It replaces direct dependencies between colleagues with a loose dependency on the mediator.",
      "It removes all coupling, allowing colleagues to function completely independently.",
      "It couples colleagues tightly to the specific implementation details of other colleagues."
    ],
    "answer": "It replaces direct dependencies between colleagues with a loose dependency on the mediator.",
    "explanation": "Mediator promotes loose coupling by preventing objects from referring to each other explicitly. Instead, they refer to the Mediator object, which handles the communication logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the main structural difference between 'Proxy' and 'Decorator' patterns?",
    "options": [
      "Proxy hides the real object's complexity, while Decorator adds behavior transparently.",
      "Proxy changes the object's interface, while Decorator keeps it identical.",
      "Decorator is used for instantiation, while Proxy is used for access control.",
      "Proxy is creational, whereas Decorator is structural."
    ],
    "answer": "Proxy hides the real object's complexity, while Decorator adds behavior transparently.",
    "explanation": "Both structurally wrap an object. However, a Proxy manages the lifecycle/access to the object (lazy loading, access control), while a Decorator adds responsibilities to the object dynamically.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "When using the 'Strangler Fig' pattern for system migration, what is the core strategy?",
    "options": [
      "Replacing the entire monolithic database with a distributed ledger in one release.",
      "Gradually creating a new system alongside the legacy one, redirecting traffic incrementally until the legacy is decommissioned.",
      "Rewriting the entire application from scratch in a different language.",
      "Deploying the new microservices behind a complex load balancer that splits traffic 50/50."
    ],
    "answer": "Gradually creating a new system alongside the legacy one, redirecting traffic incrementally until the legacy is decommissioned.",
    "explanation": "Strangler Fig involves incrementally building a new system around the edges of the old. A facade (often a reverse proxy) routes specific requests to the new system, eventually 'strangling' the old one.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Which pattern is defined by: 'Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically'?",
    "options": [
      "Observer",
      "Mediator",
      "Chain of Responsibility",
      "Publish-Subscribe"
    ],
    "answer": "Observer",
    "explanation": "This is the classic definition of the Observer pattern (also known as Dependents or Publish-Subscribe, though Pub/Sub often implies message middleware).",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In Hexagonal Architecture (Ports and Adapters), what constitutes an 'Inbound Port'?",
    "options": [
      "A specific database driver implementation.",
      "An API provided by the application (Primary Adapter) that interacts with the Application Core.",
      "An interface definition in the Core defining how external actors trigger the application logic.",
      "The infrastructure code responsible for sending emails."
    ],
    "answer": "An interface definition in the Core defining how external actors trigger the application logic.",
    "explanation": "In Hexagonal Architecture, the Core (domain) defines Ports (interfaces). An Inbound Port defines the operations the application can perform (API), which is implemented by Controllers (Primary Adapters) outside the core.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the role of the 'Ambient Context' pattern, often found in logging or session management frameworks?",
    "options": [
      "To provide a global state accessible via a static accessor, usually scoped to the current thread or request context.",
      "To pass data explicitly through every layer of the application stack.",
      "To encapsulate database connections within a specific transaction scope.",
      "To dynamically switch between different implementations of an interface at runtime."
    ],
    "answer": "To provide a global state accessible via a static accessor, usually scoped to the current thread or request context.",
    "explanation": "Ambient Context (e.g., HttpContext, ThreadLocal) makes 'implicit' information available globally without passing it as parameters, though this can complicate testing and hide dependencies.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which Enterprise Integration Pattern is used to transform a message from one data format to another to satisfy the requirements of a target system?",
    "options": [
      "Message Router",
      "Translator",
      "Channel Adapter",
      "Splitter"
    ],
    "answer": "Translator",
    "explanation": "A Message Translator converts a message from the format of the sending system to the format of the receiving system. Routers direct messages, Splitters break them apart.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the primary disadvantage of using the 'Monolithic' architecture pattern?",
    "options": [
      "It is difficult to deploy because there are too many separate services.",
      "The codebase can become unmanageable as complexity grows, creating a tight coupling and slow build/deploy cycles.",
      "It cannot handle high levels of traffic.",
      "It requires complex inter-service communication protocols."
    ],
    "answer": "The codebase can become unmanageable as complexity grows, creating a tight coupling and slow build/deploy cycles.",
    "explanation": "Monolithic applications bundle all functionality into a single unit. This leads to tight coupling, where a change in one module requires testing and redeploying the entire system.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "In the 'Chain of Responsibility' pattern, what happens if no handler in the chain processes the request?",
    "options": [
      "The request is automatically retried by the first handler.",
      "The request is dropped and the chain terminates.",
      "An exception is thrown by the chain manager.",
      "The request is returned to the client as a failure response."
    ],
    "answer": "The request is dropped and the chain terminates.",
    "explanation": "In standard Chain of Responsibility, if the request reaches the end of the chain without being handled, it simply falls through the end. Handling the unprocessed case is a specific implementation choice.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "Which pattern allows an application to switch between algorithms or data structures dynamically at runtime without recompilation?",
    "options": [
      "State",
      "Strategy",
      "Builder",
      "Bridge"
    ],
    "answer": "Strategy",
    "explanation": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. The application (context) delegates the work to the concrete strategy object at runtime.",
    "difficulty": "Advanced"
  }
]