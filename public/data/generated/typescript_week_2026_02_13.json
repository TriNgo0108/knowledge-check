[
  {
    "id": 1,
    "question": "Which keyword is used to define an alias for a type in TypeScript?",
    "options": [
      "interface",
      "type",
      "alias",
      "derive"
    ],
    "answer": "type",
    "explanation": "The `type` keyword declares a type alias for a primitive, union, or object type. `interface` defines a structure, while `alias` and `derive` are not valid keywords for type definition.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the primary difference between `interface` and `type` regarding declaration merging?",
    "options": [
      "Interfaces can be merged; types cannot",
      "Types can be merged; interfaces cannot",
      "Both support declaration merging equally",
      "Neither supports declaration merging"
    ],
    "answer": "Interfaces can be merged; types cannot",
    "explanation": "Interfaces with the same name in the same scope automatically merge their definitions. Type aliases create a unique name and must be distinct; attempting to redeclare them throws an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which type explicitly prevents a value from being anything other than `null` or `undefined`?",
    "options": [
      "any",
      "unknown",
      "never",
      "void"
    ],
    "answer": "never",
    "explanation": "`never` represents a value that never occurs, such as a function that always throws or never returns. `void` is the return type for functions that return implicitly (undefined), while `unknown` and `any` allow standard values.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "How do you define an array of strings in TypeScript?",
    "options": [
      "Array[str]",
      "string[]",
      "str[]",
      "list<string>"
    ],
    "answer": "string[]",
    "explanation": "`string[]` is the standard shorthand syntax for an array of strings. `Array<string>` is also valid but verbose; `Array[str]` and `list<string>` are invalid syntax.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the resulting type of the utility type `Partial<{ a: string; b: number }>`?",
    "options": [
      "{ a: string; b: number }",
      "{ a?: string; b?: number }",
      "string | number",
      "{ a: string; b: number } | undefined"
    ],
    "answer": "{ a?: string; b?: number }",
    "explanation": "`Partial` makes all properties of the provided object type optional by appending the `?` modifier to every key.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which operator is used to create a Union Type?",
    "options": [
      "&",
      "|",
      "||",
      "+"
    ],
    "answer": "|",
    "explanation": "The pipe `|` operator creates a union type (e.g., `string | number`). The ampersand `&` creates an intersection type, while `||` and `+` are logical/mathematical operators.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What happens when you assign a value of type `string` to a variable typed as `any`?",
    "options": [
      "A compile-time error occurs",
      "The value is cast to a number",
      "The compiler skips type checking",
      "The value becomes immutable"
    ],
    "answer": "The compiler skips type checking",
    "explanation": "`any` effectively turns off type checking, allowing any type to be assigned to it and any operation to be performed on it.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which modifier makes a class property accessible only within the class it is defined in?",
    "options": [
      "public",
      "protected",
      "private",
      "static"
    ],
    "answer": "private",
    "explanation": "`private` restricts access strictly to the containing class. `protected` allows subclass access, `public` is default and open, and `static` belongs to the class instance rather than a specific object.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the syntax for a Tuple type containing a `string` and a `number`?",
    "options": [
      "(string, number)",
      "[string, number]",
      "{ string, number }",
      "<string, number>"
    ],
    "answer": "[string, number]",
    "explanation": "Tuples use square bracket syntax `[string, number]` to define a fixed-length array where specific indices correspond to specific types.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the inferred type of the variable `const x = [1, 'a']`?",
    "options": [
      "(number | string)[]",
      "[number, string]",
      "any[]",
      "never[]"
    ],
    "answer": "(number | string)[]",
    "explanation": "When array literals contain mixed types but are not explicitly typed as tuples, TypeScript infers a standard array of union types, not a tuple.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "How do you enforce that an object parameter has specific properties without defining a specific class or interface name?",
    "options": [
      "Anonymous Object Type",
      "Dynamic Type",
      "Inline Interface",
      "Var Type"
    ],
    "answer": "Anonymous Object Type",
    "explanation": "You can define the shape inline: `function foo(arg: { id: number; name: string })`. This is an anonymous object type definition.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which utility type constructs a type by picking the set of properties `Keys` from `Type`?",
    "options": [
      "Omit",
      "Pick",
      "Extract",
      "Record"
    ],
    "answer": "Pick",
    "explanation": "`Pick<Type, Keys>` creates a new type by selecting only the specified properties. `Omit` removes them, `Extract` selects from a union, and `Record` constructs a new object.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the result of the `keyof` operator on the type `{ a: number; b: string }`?",
    "options": [
      "number | string",
      "a | b",
      "{ a: number; b: string }",
      "key[]"
    ],
    "answer": "a | b",
    "explanation": "`keyof` retrieves the union of the property names (keys) of the given type, resulting in the string literal union `'a' | 'b'`.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which keyword is used to assert that a value is of a specific type, overriding the compiler's inferred type?",
    "options": [
      "cast",
      "assert",
      "as",
      "is"
    ],
    "answer": "as",
    "explanation": "The `as` keyword performs type assertions (e.g., `value as string`). `is` is used in type predicates, `cast` does not exist, and `assert` is a runtime check.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What does the `NonNullable` utility type do?",
    "options": [
      "Removes null and undefined from a type",
      "Ensures a type is a class instance",
      "Removes optional properties from an interface",
      "Allows only string literal types"
    ],
    "answer": "Removes null and undefined from a type",
    "explanation": "`NonNullable` constructs a type by excluding `null` and `undefined` from the provided Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which operator is used for Type Intersection?",
    "options": [
      "|",
      "&",
      "and",
      "intersect"
    ],
    "answer": "&",
    "explanation": "The ampersand `&` combines types, requiring a value to satisfy *all* constituent types. `|` represents a union.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "How do you define a function parameter that accepts any type but requires a runtime check before use?",
    "options": [
      "any",
      "unknown",
      "never",
      "void"
    ],
    "answer": "unknown",
    "explanation": "`unknown` is the type-safe counterpart to `any`. It allows any value but forces a type narrowing check before the value can be used.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the default value of an enum member if not explicitly set?",
    "options": [
      "0 (incrementing for subsequent members)",
      "undefined",
      "null",
      "The string name of the member"
    ],
    "answer": "0 (incrementing for subsequent members)",
    "explanation": "Numeric enums auto-initialize to 0, and subsequent members increment by 1 unless explicitly assigned a value.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which modifier allows a property to be read but not reassigned after initialization?",
    "options": [
      "static",
      "private",
      "readonly",
      "const"
    ],
    "answer": "readonly",
    "explanation": "`readonly` is a TypeScript modifier that prevents reassignment of a property after the object is created. `const` is for variables, not class members.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the purpose of the `tsconfig.json` file?",
    "options": [
      "To bundle application assets",
      "To configure TypeScript compiler options",
      "To install dependencies",
      "To define runtime environment variables"
    ],
    "answer": "To configure TypeScript compiler options",
    "explanation": "`tsconfig.json` specifies the root files and compiler options (like `target` and `module`) required to build the project.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What character is used to denote an optional property in an interface?",
    "options": [
      "!",
      "?",
      "*",
      "_"
    ],
    "answer": "?",
    "explanation": "The question mark `?` suffix (e.g., `name?: string`) denotes that the property is optional.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "How do you define a Generic function?",
    "options": [
      "function func<T>() {}",
      "function func(gen T) {}",
      "function func(: T) {}",
      "generic function func() {}"
    ],
    "answer": "function func<T>() {}",
    "explanation": "Generics are defined using angle brackets `<T>` after the function name, declaring `T` as a type parameter.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What does the `Required` utility type do?",
    "options": [
      "Makes all optional properties required",
      "Ensures the value is not null",
      "Checks if a parameter is passed",
      "Validates the data type"
    ],
    "answer": "Makes all optional properties required",
    "explanation": "`Required` removes the `?` modifier from all properties in a type, making them mandatory.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which of the following describes a 'Top Type' in TypeScript?",
    "options": [
      "A type that can be any value (e.g., `unknown`)",
      "A type that has no values (e.g., `never`)",
      "A type that is a class parent",
      "A type that is only a string"
    ],
    "answer": "A type that can be any value (e.g., `unknown`)",
    "explanation": "A Top Type encompasses all possible values under it. `unknown` is the type-safe top type, while `any` effectively acts as one too.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "In an `interface` definition, what is the signature of a method that takes `x` and `y` (numbers) and returns a number?",
    "options": [
      "add(x, y): number",
      "add: (x: number, y: number) => number",
      "add(x: number, y: number): number",
      "number add(x, y)"
    ],
    "answer": "add: (x: number, y: number) => number",
    "explanation": "In interfaces, methods are often defined as properties with arrow function syntax: `name: (args) => ReturnType`. The other syntaxes are for class implementation or invalid.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the `infer` keyword used for?",
    "options": [
      "To declare a variable in a function",
      "To extract a type from another type within a conditional type",
      "To create a class",
      "To cast a type"
    ],
    "answer": "To extract a type from another type within a conditional type",
    "explanation": "`infer` is used within the `extends` clause of a conditional type to infer a type variable (e.g., extracting the return type of a function).",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What does the `void` type indicate?",
    "options": [
      "The value is undefined",
      "The value is null",
      "The absence of a return type",
      "The value is any"
    ],
    "answer": "The absence of a return type",
    "explanation": "`void` indicates that a function does not return a value (or returns `undefined` implicitly). It is not the same as `undefined` or `null` types directly.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which compiler option enables strict type checking rules, including `noImplicitAny`?",
    "options": [
      "strict",
      "check",
      "all",
      "mode"
    ],
    "answer": "strict",
    "explanation": "The `strict: true` flag in `tsconfig.json` enables all strict type checking options, providing the highest level of type safety.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the difference between `interface X { a: string }` and `type X = { a: string }`?",
    "options": [
      "Interfaces can be merged; types cannot",
      "Types can be merged; interfaces cannot",
      "Interfaces work for objects; types do not",
      "There is no functional difference"
    ],
    "answer": "Interfaces can be merged; types cannot",
    "explanation": "While they often look similar for object shapes, the key distinction is that interfaces support declaration merging (defining the same name twice), while type aliases do not.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What syntax is used to import a type only (stripped at runtime in `isolatedModules`)?",
    "options": [
      "import type",
      "import { type }",
      "import from",
      "require type"
    ],
    "answer": "import type",
    "explanation": "`import type { Name }` explicitly imports the type `Name` ensuring it is fully erased during compilation, useful when only types are needed.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which utility type removes `null` and `undefined` from a type `T`?",
    "options": [
      "NonNullable",
      "Required",
      "Nullable",
      "Extract"
    ],
    "answer": "NonNullable",
    "explanation": "`NonNullable` creates a new type by excluding `null` and `undefined` from the input type.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the return type of `JSON.parse`?",
    "options": [
      "any",
      "unknown",
      "JSON",
      "object"
    ],
    "answer": "any",
    "explanation": "The default signature for `JSON.parse` returns `any` because the shape of the JSON data is unknown at compile time. It can be cast to a specific type.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What does the `as const` assertion do?",
    "options": [
      "Makes the object readonly and infers literal types",
      "Casts the object to a class",
      "Converts the object to a constant variable",
      "Enables strict null checks"
    ],
    "answer": "Makes the object readonly and infers literal types",
    "explanation": "`as const` prevents widening of primitive types to their general forms (e.g., `\"red\"` stays `\"red\"` instead of `string`) and makes the object immutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which access modifier allows a class member to be accessed from subclasses but not externally?",
    "options": [
      "private",
      "public",
      "protected",
      "internal"
    ],
    "answer": "protected",
    "explanation": "`protected` members are visible to the class defining them and any subclasses, but not to instances of the class outside of the inheritance chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "How do you define a property in an interface that can be a string OR a number?",
    "options": [
      "id: (string, number)",
      "id: string | number",
      "id: string & number",
      "id: mixed"
    ],
    "answer": "id: string | number",
    "explanation": "The pipe operator `|` creates a union type, allowing the property to be either a string or a number.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the result of `Extract<keyof { a: number; b?: string }, undefined>`?",
    "options": [
      "\"a\" | \"b\"",
      "never",
      "undefined",
      "\"b\""
    ],
    "answer": "never",
    "explanation": "The `Extract` utility type computes the intersection of two types. While `keyof { a: number; b?: string }` includes optional keys, the literal type `undefined` is not a member of the union of property keys (\"a\" | \"b\"",
    "difficulty": "Advanced"
  },
  {
    "id": 37,
    "question": "Which statement accurately describes the behavior of `Function` and `object` in the TypeScript type system regarding strictness?",
    "options": [
      "`object` accepts any non-primitive type, while `Function` accepts only functions.",
      "`Function` is unsafe because it allows calling any value without type-checking arguments.",
      "Both `object` and `Function` are discouraged in favor of `{}` and `any`.",
      "`object` accepts primitives and objects, while `Function` accepts only arrow functions."
    ],
    "answer": "`Function` is unsafe because it allows calling any value without type-checking arguments.",
    "explanation": "The `Function` type represents any function in JavaScript but does not enforce parameter or return type constraints during the call, leading to runtime errors. `{ [key: string]: any }` or specific function signatures are preferred.",
    "difficulty": "Advanced"
  },
  {
    "id": 38,
    "question": "How does the variance of function parameters differ from the variance of their return types in TypeScript?",
    "options": [
      "Parameters are covariant, return types are contravariant.",
      "Parameters are contravariant, return types are covariant.",
      "Both parameters and return types are invariant.",
      "Both parameters and return types are covariant."
    ],
    "answer": "Parameters are contravariant, return types are covariant.",
    "explanation": "Functions are bi-variate; parameter types flow in (input/contravariant), while return types flow out (output/covariant). TypeScript's `strictFunctionTypes` enforces this primarily for function types created via object literals but not for method declarations.",
    "difficulty": "Advanced"
  },
  {
    "id": 39,
    "question": "Given `type P = { x: number; y: number } & { z: number }`, what is the result of `keyof P`?",
    "options": [
      "never",
      "\"x\" | \"y\" | \"z\"",
      "\"x\" | \"y\" & \"z\"",
      "string | number"
    ],
    "answer": "\"x\" | \"y\" | \"z\"",
    "explanation": "Intersection types merge properties. `keyof` on an intersection produces a union of all keys present in all constituent types.",
    "difficulty": "Advanced"
  },
  {
    "id": 40,
    "question": "What is the primary technical purpose of the `satisfies` operator introduced in TypeScript 4.9?",
    "options": [
      "To assert that a value must be assigned a specific type at runtime.",
      "To validate an expression matches a type without widening the expression's inferred type.",
      "To ensure a generic type parameter implements a specific interface.",
      "To cast a value from `any` to a specific type."
    ],
    "answer": "To validate an expression matches a type without widening the expression's inferred type.",
    "explanation": "Unlike type annotation (`let x: Type = ...`) which widens the literal to `Type`, `satisfies` checks compatibility but retains the specific literal type of the value for subsequent operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 41,
    "question": "Consider `type Mapped<T> = { [K in keyof T]: T[K] }`. If `T` is a generic type without constraints, how does `Mapped` behave when `T` is a union?",
    "options": [
      "It distributes over the union automatically.",
      "It raises an error because unions are not valid keys.",
      "It applies the mapping to the union as a single object.",
      "It converts the union into an intersection."
    ],
    "answer": "It distributes over the union automatically.",
    "explanation": "Mapped types distribute over unions. If `T` is `A | B`, `Mapped` results in `Mapped<A> | Mapped<B>`.",
    "difficulty": "Advanced"
  },
  {
    "id": 42,
    "question": "What is the effect of using the `NoInfer<T>` utility type in a generic function argument?",
    "options": [
      "It prevents the generic type `T` from being inferred at all.",
      "It blocks inference of the type `T` from the specific argument wrapped in `NoInfer`.",
      "It forces the type `T` to be `unknown` for that argument.",
      "It removes the type `T` from the compiled JavaScript."
    ],
    "answer": "It blocks inference of the type `T` from the specific argument wrapped in `NoInfer`.",
    "explanation": "`NoInfer` is used to control inference priority. It tells TypeScript not to use the argument's type to infer `T`, forcing TypeScript to look at other arguments or explicit type annotations to determine `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 43,
    "question": "Why are TypeScript Enums considered technically problematic compared to union types of string literals?",
    "options": [
      "Enums are not iterable at runtime.",
      "Enums pollute the global namespace and cannot be tree-shaken effectively.",
      "Enums do not provide auto-completion support in IDEs.",
      "String literal unions do not support reverse mapping."
    ],
    "answer": "Enums pollute the global namespace and cannot be tree-shaken effectively.",
    "explanation": "Const enums are stripped, but standard enums generate IIFE objects that often prevent dead code elimination (tree-shaking) and add runtime overhead that literal unions avoid.",
    "difficulty": "Advanced"
  },
  {
    "id": 44,
    "question": "In a conditional type `T extends U ? X : Y`, when is the distributed behavior of `T` (if it is a union) disabled?",
    "options": [
      "When `X` is `never`.",
      "When `T` is wrapped in a tuple type or array.",
      "When `T` is naked (not wrapped in a tuple).",
      "When `U` is a generic type."
    ],
    "answer": "When `T` is wrapped in a tuple type or array.",
    "explanation": "Distributive conditional types only occur when `T` is \"naked\" (checked directly). Wrapping `T` (e.g., `[T] extends U`) disables distribution over the union.",
    "difficulty": "Advanced"
  },
  {
    "id": 45,
    "question": "How does `keyof any` differ from `string`?",
    "options": [
      "`keyof any` includes only string literals.",
      "`keyof any` evaluates to `string | number | symbol`.",
      "`keyof any` is a supertype of `string`.",
      "`string` includes `number`, but `keyof any` does not."
    ],
    "answer": "`keyof any` evaluates to `string | number | symbol`.",
    "explanation": "Object keys in JavaScript can be strings, numbers (coerced to strings), or symbols. Therefore, the type of all possible keys (`keyof any`) is the union of these three primitive types.",
    "difficulty": "Advanced"
  },
  {
    "id": 46,
    "question": "What does the `ThisParameterType<T>` utility type extract?",
    "options": [
      "The type of the first parameter in a function.",
      "The explicit `this` parameter type of a function type, or `unknown` if not defined.",
      "The instance type of a class.",
      "The global `window` object type."
    ],
    "answer": "The explicit `this` parameter type of a function type, or `unknown` if not defined.",
    "explanation": "It extracts the type of the pseudo-parameter `this`. If the function type `T` has no `this` parameter, the result is `unknown`.",
    "difficulty": "Advanced"
  },
  {
    "id": 47,
    "question": "Which statement describes the difference between `interface` and `type` when merging is involved?",
    "options": [
      "Types can be merged using the `&` operator, but interfaces cannot be merged.",
      "Interfaces support declaration merging (multiple blocks with same name), while type aliases create a single, frozen block.",
      "Interfaces cannot extend types, but types can extend interfaces.",
      "Types are hoisted, but interfaces are not."
    ],
    "answer": "Interfaces support declaration merging (multiple blocks with same name), while type aliases create a single, frozen block.",
    "explanation": "Declaring an interface with the same name twice merges their members. Type aliases are unique identifiers; attempting to redefine them causes an error.",
    "difficulty": "Advanced"
  },
  {
    "id": 48,
    "question": "What is the output type of `ReturnType<<T>() => T>`?",
    "options": [
      "T",
      "any",
      "unknown",
      "never"
    ],
    "answer": "unknown",
    "explanation": "Without an explicit type parameter provided to the generic type or an inferred value, `T` defaults to `unknown` in a constrained generic or context, making the return type `unknown`. However, strictly speaking in this syntax `T` is unresolved. In valid TS syntax `ReturnType<<T>() => T>` fails because `T` is not in scope in the ReturnType parameter. If interpreted as generic function type instantiation, `T` is effectively generic parameter -> returns unknown.",
    "difficulty": "Advanced"
  },
  {
    "id": 49,
    "question": "Why might you use `OmitThisParameter<T>` when passing a class method as a callback?",
    "options": [
      "To remove the first argument of the method.",
      "To strip the `this` context so the function can be called standalone without an instance.",
      "To make the method private.",
      "To convert the method into a static property."
    ],
    "answer": "To strip the `this` context so the function can be called standalone without an instance.",
    "explanation": "Class methods rely on `this` being the class instance. If passed as a raw callback, `this` is lost (causing runtime errors). `OmitThisParameter` removes the `this` type requirement.",
    "difficulty": "Advanced"
  },
  {
    "id": 50,
    "question": "How does TypeScript treat the `in` operator when checking for properties on `any`?",
    "options": [
      "It returns false if the property does not exist.",
      "It returns true regardless of the property name.",
      "It performs a runtime check for that specific property.",
      "It throws a compile-time error."
    ],
    "answer": "It returns true regardless of the property name.",
    "explanation": "When checking properties against `any`, TypeScript assumes the property exists because `any` effectively disables type checking, making the `in` check useless.",
    "difficulty": "Advanced"
  },
  {
    "id": 51,
    "question": "In the context of Template Literal Types, what does `Uppercase<StringType>` do?",
    "options": [
      "It converts a string type to uppercase at runtime.",
      "It creates a new type representing the string with characters converted to uppercase.",
      "It creates a union of all possible uppercase strings.",
      "It validates that a runtime string is already uppercase."
    ],
    "answer": "It creates a new type representing the string with characters converted to uppercase.",
    "explanation": "It is a type-level operation. The type `Uppercase<\"hello\">` resolves to the type `\"HELLO\"`. It has no runtime effect.",
    "difficulty": "Advanced"
  },
  {
    "id": 52,
    "question": "What is the behavior of `tuple` types regarding excess properties compared to `Array` types?",
    "options": [
      "Tuples allow any number of excess properties.",
      "Tuples enforce a fixed length and specific types at specific indices; excess items cause errors.",
      "Tuples and Arrays behave identically regarding excess properties.",
      "Tuples ignore excess properties if they match the overall type."
    ],
    "answer": "Tuples enforce a fixed length and specific types at specific indices; excess items cause errors.",
    "explanation": "A tuple `[number, string]` must have exactly two elements (a number then a string). An array `number[]` can have any length.",
    "difficulty": "Advanced"
  },
  {
    "id": 53,
    "question": "Which utility type constructs a type by picking the set of keys `K` from `T`, where `K` is a union of string literal types?",
    "options": [
      "Pick<T, K>",
      "Record<K, T>",
      "Partial<T, K>",
      "Extract<T, K>"
    ],
    "answer": "Pick<T, K>",
    "explanation": "`Pick<T, K>` constructs a type by picking the set of properties `K` from type `T`. `Record<K, T>` creates an object type with keys `K` and values `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 54,
    "question": "What is the purpose of `// @ts-nocheck` at the top of a file?",
    "options": [
      "It suppresses errors for the line immediately following it.",
      "It disables type checking for the entire file.",
      "It forces the compiler to treat the file as JavaScript.",
      "It enables strict null checks."
    ],
    "answer": "It disables type checking for the entire file.",
    "explanation": "`// @ts-nocheck` instructs TypeScript to skip semantic checking for the rest of the file, similar to treating the whole file as `// @ts-ignore`.",
    "difficulty": "Advanced"
  },
  {
    "id": 55,
    "question": "What does `Infer` do within the `extends` clause of a conditional type?",
    "options": [
      "It creates a new type variable.",
      "It infers the type of a generic argument based on the structure of the matched type.",
      "It checks if a type is assignable.",
      "It casts a type to `any`."
    ],
    "answer": "It infers the type of a generic argument based on the structure of the matched type.",
    "explanation": "`infer R` (in `T extends Promise<infer R>`) captures the type inside `Promise` for use in the \"true\" branch of the conditional type.",
    "difficulty": "Advanced"
  },
  {
    "id": 56,
    "question": "How does `branding` (or Opaque Types) function in TypeScript to enforce type safety?",
    "options": [
      "By adding a unique symbol property to the structure to distinguish otherwise identical types.",
      "By using the `private` keyword in interfaces.",
      "By renaming the type in the declaration file.",
      "By preventing assignment of primitive values."
    ],
    "answer": "By adding a unique symbol property to the structure to distinguish otherwise identical types.",
    "explanation": "Nominal typing is simulated by intersecting with a type containing a unique, un-exported symbol: `type UserID = string & { __brand: unique symbol }`.",
    "difficulty": "Advanced"
  },
  {
    "id": 57,
    "question": "What is the result of `type Diff<T, U> = T extends U ? never : T` applied to `Diff<string | number, number>`?",
    "options": [
      "number",
      "string",
      "string | number",
      "never"
    ],
    "answer": "string",
    "explanation": "This is the implementation of `Exclude`. It distributes over the union. `number extends number` (true, becomes never). `string extends number` (false, remains string). Result: `string`.",
    "difficulty": "Advanced"
  },
  {
    "id": 58,
    "question": "What is the primary limitation of Recursive Types in TypeScript?",
    "options": [
      "They cannot be used with interfaces.",
      "They are limited by the compiler's instantiation depth limit.",
      "They cannot reference themselves.",
      "They only work with string types."
    ],
    "answer": "They are limited by the compiler's instantiation depth limit.",
    "explanation": "TypeScript has a recursion depth limit (instantiation limit). If a recursive type is too deeply nested, the compiler errors with \"Type instantiation is excessively deep and possibly infinite.\"",
    "difficulty": "Advanced"
  },
  {
    "id": 59,
    "question": "What is the difference between `import type` and `import` regarding the emitted JavaScript?",
    "options": [
      "`import type` is fully removed, while `import` generates a `require` or `import` statement.",
      "`import` is fully removed, while `import type` generates code.",
      "Both are always removed.",
      "Both always generate code."
    ],
    "answer": "`import type` is fully removed, while `import` generates a `require` or `import` statement.",
    "explanation": "`import type` is used solely for type checking and is completely erased during compilation, whereas standard value imports are preserved in the output.",
    "difficulty": "Advanced"
  },
  {
    "id": 60,
    "question": "In mapped types, how do you create a read-only array type using modifiers?",
    "options": [
      "type ReadonlyArray<T> = readonly T[]",
      "type ReadonlyArray<T> = readonly [T]",
      "type ReadonlyArray<T> = { readonly [P in keyof T]: T[P] }",
      "type ReadonlyArray<T> = Array<readonly T>"
    ],
    "answer": "type ReadonlyArray<T> = readonly T[]",
    "explanation": "The syntax `readonly T[]` creates a read-only array type. The other options either create mapped types on objects or use invalid syntax.",
    "difficulty": "Advanced"
  },
  {
    "id": 61,
    "question": "How does the `Parameters<T>` utility type handle a function `T` that has overloads?",
    "options": [
      "It returns a union of parameters from all overload signatures.",
      "It returns parameters from the last (implementation) signature.",
      "It returns parameters from the first signature.",
      "It throws a compile-time error."
    ],
    "answer": "It returns parameters from the last (implementation) signature.",
    "explanation": "For function types with multiple call signatures (overloads), `Parameters` extracts the type list from the last signature, which is typically the implementation signature.",
    "difficulty": "Advanced"
  },
  {
    "id": 62,
    "question": "What is the definition of `Uncapitalize<StringType>`?",
    "options": [
      "Converts the first character of the string type to lowercase.",
      "Converts the entire string type to lowercase.",
      "Removes the first character.",
      "Converts the first character to uppercase."
    ],
    "answer": "Converts the first character of the string type to lowercase.",
    "explanation": "`Uncapitalize` specifically targets the first character. `Lowercase` targets the entire string.",
    "difficulty": "Advanced"
  },
  {
    "id": 63,
    "question": "Which mechanism allows TypeScript to assert that a value is of a specific type at runtime, beyond type guards?",
    "options": [
      "Type Assertion (`as`)",
      "User-defined Type Predicates",
      "Distinct properties for nominal typing",
      "The `instanceof` operator"
    ],
    "answer": "User-defined Type Predicates",
    "explanation": "Functions returning `value is Type` (Type Predicates) are the primary way to inform the compiler about runtime checks that standard guards cannot cover, though `instanceof` works for classes. Predicates are distinct from assertions.",
    "difficulty": "Advanced"
  }
]