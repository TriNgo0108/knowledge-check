[
  {
    "id": 1,
    "question": "What is the primary purpose of React Fiber introduced in React 16?",
    "options": [
      "To provide a built-in state management library replacing Redux",
      "To enable asynchronous rendering and incremental updates for better concurrency",
      "To automatically optimize CSS animations and transitions",
      "To convert JSX code into HTML directly in the browser"
    ],
    "answer": "To enable asynchronous rendering and incremental updates for better concurrency",
    "explanation": "Fiber is a reimplementation of the reconciliation algorithm designed to support incremental rendering and prioritization. Previous options are incorrect because Fiber is internal rendering logic, not a state manager, CSS engine, or JSX compiler.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which term describes React's algorithm for determining the differences between two UI states to update the DOM efficiently?",
    "options": [
      "Reconciliation",
      "Virtualization",
      "Hoisting",
      "Memoization"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation (or diffing) is the algorithm React uses to compare the current element tree with the new one. Virtualization is a general performance concept, Hoisting is a compiler scope concept, and Memoization is an optimization technique.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the technical function of the 'key' prop when rendering lists of elements in React?",
    "options": [
      "To encrypt the list items for security purposes",
      "To automatically sort the list items alphabetically",
      "To help React identify which items have changed, been added, or been removed",
      "To serve as a unique identifier for CSS styling hooks"
    ],
    "answer": "To help React identify which items have changed, been added, or been removed",
    "explanation": "Keys help React make efficient decisions when updating the DOM by stabilizing element identity. They do not provide security, sorting, or styling capabilities.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In the context of React Fiber, what distinguishes the 'commit' phase from the 'render' phase?",
    "options": [
      "The commit phase is asynchronous, while the render phase is synchronous",
      "The commit phase applies changes to the DOM and cannot be interrupted",
      "The render phase updates the actual browser pixels",
      "The commit phase calculates the new Virtual DOM tree"
    ],
    "answer": "The commit phase applies changes to the DOM and cannot be interrupted",
    "explanation": "The commit phase is synchronous and applies the calculated changes to the DOM/host tree. The render (or reconciliation) phase is where work is prepared and can be interrupted/interrupted in Fiber.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which concept allows React to prioritize user interactions (like typing) over less urgent updates (like data fetching) in Concurrent Mode?",
    "options": [
      "Event Bubbling",
      "Suspense",
      "Prioritization",
      "Lazy Loading"
    ],
    "answer": "Prioritization",
    "explanation": "Prioritization allows React to schedule high-priority work (like input) before low-priority work (like rendering a list). Event Bubbling is DOM related, Suspense handles data dependency waiting, and Lazy Loading is for code splitting.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the standard output of a Functional Component in React?",
    "options": [
      "A class instance",
      "A React Element (JSX/VDOM node)",
      "A string representation of HTML",
      "A modified copy of the previous state"
    ],
    "answer": "A React Element (JSX/VDOM node)",
    "explanation": "Functional components return React Elements (describing the UI). They do not return class instances, raw HTML strings, or state copies.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which Hook is specifically designed to handle side effects such as data fetching, subscriptions, or manually changing the DOM?",
    "options": [
      "useState",
      "useContext",
      "useEffect",
      "useReducer"
    ],
    "answer": "useEffect",
    "explanation": "useEffect is the dedicated Hook for performing side effects after renders. useState manages state, useContext consumes context, and useReducer manages complex state logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What happens when you pass a dependency array (empty array []) as the second argument to useEffect?",
    "options": [
      "The effect runs after every render",
      "The effect runs only once when the component mounts",
      "The effect runs only when the component unmounts",
      "The effect is skipped entirely"
    ],
    "answer": "The effect runs only once when the component mounts",
    "explanation": "An empty dependency array signals React that the effect does not depend on any props or state, so it never needs to re-run after the initial mount.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which feature serves as a 'unit of work' in the React Fiber architecture, capable of holding component state and props?",
    "options": [
      "A Fiber Node",
      "A Virtual DOM Instance",
      "A Context Provider",
      "A Synthetic Event"
    ],
    "answer": "A Fiber Node",
    "explanation": "A Fiber Node represents a unit of work in the Fiber tree, holding state, props, and queue information. Virtual DOM is the tree concept, Context is for data passing, and Synthetic Events are wrappers for browser events.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Why must you not mutate the React state directly (e.g., `state.count = 5`)?",
    "options": [
      "It violates the encapsulation of the component class",
      "It bypasses React's rendering and reconciliation logic",
      "It causes a memory leak in the browser",
      "It automatically triggers an infinite loop of re-renders"
    ],
    "answer": "It bypasses React's rendering and reconciliation logic",
    "explanation": "Direct mutation prevents React from knowing the state changed, so it won't trigger a re-render or update the UI. React requires state updates through setter functions to schedule updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the purpose of the `React.cloneElement` method?",
    "options": [
      "To create a deep copy of the entire component tree",
      "To duplicate a component instance for server-side rendering",
      "To clone an element and pass new props to it while preserving its original structure",
      "To convert a JavaScript object into a React component"
    ],
    "answer": "To clone an element and pass new props to it while preserving its original structure",
    "explanation": "This method creates a copy of a React element, allowing you to merge new props into the existing element (common in older HOC patterns). It does not duplicate component trees or convert objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "In React, what is 'prop drilling'?",
    "options": [
      "A technique to optimize database queries",
      "Passing data through multiple layers of components to reach a deeply nested child",
      "Automatically generating unique IDs for props",
      "Debugging props using the React DevTools"
    ],
    "answer": "Passing data through multiple layers of components to reach a deeply nested child",
    "explanation": "Prop drilling is the manual process of passing data down the component tree. It is often solved by Context API or state management libraries.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which Hook allows you to optimize performance by memoizing a calculated value to avoid re-computation on every render?",
    "options": [
      "useCallback",
      "useMemo",
      "useReducer",
      "useRef"
    ],
    "answer": "useMemo",
    "explanation": "useMemo memoizes the result of a function. useCallback memoizes the function itself (to prevent reference changes), useReducer is for state, and useRef persists values without re-rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What does the `useRef` Hook return?",
    "options": [
      "A mutable ref object whose `.current` property is initialized to the passed argument",
      "A stateful value that triggers a re-render when changed",
      "A reference to the functional component itself",
      "A deep copy of the Virtual DOM tree"
    ],
    "answer": "A mutable ref object whose `.current` property is initialized to the passed argument",
    "explanation": "useRef returns a plain JavaScript object with a `current` property. Changing `current` does not trigger a re-render, unlike `useState`.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the main advantage of using React Fragments (`<>...</>` or `<React.Fragment>`) over a generic `div` wrapper?",
    "options": [
      "Fragments automatically apply CSS Grid layout",
      "Fragments allow grouping of children without adding extra nodes to the DOM",
      "Fragments improve the runtime performance of JavaScript execution",
      "Fragments prevent memory leaks in the application"
    ],
    "answer": "Fragments allow grouping of children without adding extra nodes to the DOM",
    "explanation": "Fragments let you group a list of children without adding an extra HTML element (like a div), keeping the DOM tree cleaner and avoiding invalid HTML nesting.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which Hook is best suited for managing complex state logic involving multiple sub-values or when the next state depends on the previous one?",
    "options": [
      "useState",
      "useContext",
      "useReducer",
      "useLayoutEffect"
    ],
    "answer": "useReducer",
    "explanation": "useReducer is preferred for complex state logic, especially when state transitions depend on the previous state, whereas useState is simpler for independent state variables.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the specific behavior of `StrictMode` in development regarding effects?",
    "options": [
      "It runs effects only once to save performance",
      "It mounts components twice (invoking effects twice) to detect side effects",
      "It prevents effects from running until the user interacts with the page",
      "It disables all console warnings within the component tree"
    ],
    "answer": "It mounts components twice (invoking effects twice) to detect side effects",
    "explanation": "StrictMode intentionally double-invokes functions (like component render, constructor, and effects) in development to help find impure side effects or unsafe lifecycles.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the primary function of the `useDeferredValue` Hook in React Concurrent features?",
    "options": [
      "To debounce user input by a fixed number of milliseconds",
      "To defer re-rendering a non-critical part of the UI until urgent updates complete",
      "To cache API responses indefinitely",
      "To prevent the component from unmounting during navigation"
    ],
    "answer": "To defer re-rendering a non-critical part of the UI until urgent updates complete",
    "explanation": "useDeferredValue allows you to keep the UI responsive by treating specific updates as low-priority, delaying their processing until more urgent work (like typing) is finished.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "In the context of JSX, how are expressions embedded within the markup?",
    "options": [
      "Using double curly braces {{ expression }}",
      "Using single curly braces { expression }",
      "Using the dollar sign $expression",
      "Using the `eval` attribute on HTML tags"
    ],
    "answer": "Using single curly braces { expression }",
    "explanation": "Curly braces `{}` are the syntax in JSX to embed dynamic JavaScript expressions. Double braces `{{}}` are used for inline style objects (double curling), not general expressions.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which method allows a component to define code to run when it is about to be removed from the DOM (unmount)?",
    "options": [
      "componentDidUpdate in a Class Component",
      "The return function of useEffect in a Functional Component",
      "shouldComponentUpdate in a Class Component",
      "getDerivedStateFromProps in a Functional Component"
    ],
    "answer": "The return function of useEffect in a Functional Component",
    "explanation": "In functional components, returning a function from useEffect serves as the cleanup mechanism, running before the component unmounts.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is a 'Controlled Component' in React forms?",
    "options": [
      "An input element that manages its own internal state",
      "An input element whose value is controlled by React state",
      "A component that prevents user input entirely",
      "A component wrapped in the React.memo function"
    ],
    "answer": "An input element whose value is controlled by React state",
    "explanation": "In a controlled component, form data is handled by a React component state, making the single source of truth the state rather than the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the function of the `React.createContext` method?",
    "options": [
      "To create a new Virtual DOM tree",
      "To define a Context object that can be used to pass data through the component tree without prop drilling",
      "To initialize the global Redux store",
      "To generate unique IDs for accessibility attributes"
    ],
    "answer": "To define a Context object that can be used to pass data through the component tree without prop drilling",
    "explanation": "Context provides a way to pass data (like theme or user auth) through the component tree without manually passing props at every level.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which term describes the situation where a child component relies on specific data passed from a parent, making it difficult to reuse the child elsewhere?",
    "options": [
      "Tight Coupling",
      "Loose Coupling",
      "Separation of Concerns",
      "Immutability"
    ],
    "answer": "Tight Coupling",
    "explanation": "Tight coupling implies the child component is heavily dependent on the parent's specific implementation or data structure, reducing reusability.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the behavior of the `useLayoutEffect` Hook compared to `useEffect`?",
    "options": [
      "It runs asynchronously after the browser has painted",
      "It runs synchronously after all DOM mutations but before the browser paints",
      "It runs only on the server during Server-Side Rendering",
      "It runs only when the component is first created"
    ],
    "answer": "It runs synchronously after all DOM mutations but before the browser paints",
    "explanation": "useLayoutEffect fires synchronously after DOM changes but before paint, allowing the browser to calculate layout only once. useEffect runs after paint.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "In React Fiber, what is the 'current' tree versus the 'workInProgress' tree?",
    "options": [
      "The 'current' tree is the backup, while 'workInProgress' is the live tree",
      "The 'current' tree represents what is on screen, while 'workInProgress' is the buffer being calculated for the next update",
      "The 'current' tree is for mobile, 'workInProgress' is for desktop",
      "There is no difference; they are aliases for the same object"
    ],
    "answer": "The 'current' tree represents what is on screen, while 'workInProgress' is the buffer being calculated for the next update",
    "explanation": "React maintains two trees: `current` (what is currently rendered) and `workInProgress` (the draft of changes). When work finishes, React swaps them.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What does the `useCallback` Hook return?",
    "options": [
      "The result of a memoized calculation",
      "A memoized callback function that only changes if one of its dependencies changes",
      "A reference to the DOM node of the component",
      "The previous state value of the component"
    ],
    "answer": "A memoized callback function that only changes if one of its dependencies changes",
    "explanation": "useCallback returns a memoized version of the callback that only changes if dependencies change, useful for passing stable functions to optimized child components.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the technical reason React recommends using the 'key' prop with stable identifiers rather than array indices?",
    "options": [
      "Array indices cannot be serialized by the browser",
      "Using indices causes components to lose internal state if the list order changes",
      "Indices cannot be accessed within the map function",
      "React requires keys to be strings for hashing"
    ],
    "answer": "Using indices causes components to lose internal state if the list order changes",
    "explanation": "Using indices as keys can lead to UI bugs and state mismatch if items are reordered, inserted, or removed. Stable IDs ensure React tracks the identity of items correctly.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which Hook is utilized to mark a state update as a 'transition', allowing React to interrupt it if more urgent work comes in?",
    "options": [
      "useDeferredValue",
      "useTransition",
      "useId",
      "useSyncExternalStore"
    ],
    "answer": "useTransition",
    "explanation": "useTransition lets you mark state updates as non-urgent transitions, keeping the UI responsive during heavy rendering tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the rule of Hooks in React?",
    "options": [
      "Hooks can only be called inside regular JavaScript functions",
      "Hooks can only be called at the top level of a React function or custom Hook",
      "You must use at least one Hook in every component",
      "Hooks cannot be used in conjunction with Class Components"
    ],
    "answer": "Hooks can only be called at the top level of a React function or custom Hook",
    "explanation": "Hooks must be called unconditionally at the top level to ensure the order of Hooks is preserved between renders. Option D is true but not the 'rule of Hooks', Option A is false, Option C is false.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is a 'Synthetic Event' in React?",
    "options": [
      "A mock event created for unit testing",
      "A cross-browser wrapper around the browser's native event",
      "An event generated purely by CSS animations",
      "A custom event type specific to Internet Explorer"
    ],
    "answer": "A cross-browser wrapper around the browser's native event",
    "explanation": "SyntheticEvents wrap native browser events to ensure consistent behavior across different browsers (e.g., for `onChange`, `onClick`).",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "How does React determine if a component needs to re-render?",
    "options": [
      "By checking if the component's internal variables have changed",
      "By comparing the previous Virtual DOM with the new Virtual DOM (Reconciliation)",
      "By automatically re-rendering every component on a timer",
      "By sending a network request to the server for verification"
    ],
    "answer": "By comparing the previous Virtual DOM with the new Virtual DOM (Reconciliation)",
    "explanation": "React uses reconciliation to diff the new VDOM against the old one to determine the minimal set of changes required.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the purpose of `React.memo`?",
    "options": [
      "To memoize the result of a function passed to it",
      "To prevent a functional component from re-rendering if its props have not changed",
      "To cache the JSX syntax in memory",
      "To handle side effects without using useEffect"
    ],
    "answer": "To prevent a functional component from re-rendering if its props have not changed",
    "explanation": "React.memo is a higher-order component that memoizes the result. If props are shallowly equal, React skips rendering the component.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which mechanism allows React to break rendering work into chunks (units) and schedule it effectively?",
    "options": [
      "The Stack Reconciler",
      "The Scheduler",
      "The Babel Transpiler",
      "The Web Worker API"
    ],
    "answer": "The Scheduler",
    "explanation": "The Scheduler (introduced with Fiber) manages the timing and priority of units of work, allowing the browser to yield control back to the main thread.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the definition of 'Lifting State Up' in React?",
    "options": [
      "Moving state from a child component to a parent component to share it with other siblings",
      "Using the 'z-index' CSS property to make an element appear on top",
      "Migrating state management from Class components to Functional components",
      "Optimizing performance by deleting old state variables"
    ],
    "answer": "Moving state from a child component to a parent component to share it with other siblings",
    "explanation": "Lifting state up involves moving the 'source of truth' to the closest common ancestor so multiple children can be synchronized or share data.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the output of JSX compilation regarding the 'className' attribute?",
    "options": [
      "It creates a CSS class named 'className' in the stylesheet",
      "It is converted to the 'class' attribute in the HTML DOM",
      "It is ignored and removed from the DOM element",
      "It is used as a JavaScript object key for styling"
    ],
    "answer": "It is converted to the 'class' attribute in the HTML DOM",
    "explanation": "In JSX, `className` is used instead of `class` (because `class` is a reserved JS keyword), and it compiles down to the standard HTML `class` attribute.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "How does the Fiber architecture differ fundamentally from the previous Stack reconciler regarding execution flow?",
    "options": [
      "Fiber uses a recursive algorithm that blocks the main thread until completion.",
      "Fiber implements a linked list traversal allowing the rendering process to be paused, aborted, and resumed.",
      "Fiber eliminates the Virtual DOM to directly manipulate the browser's DOM for faster updates.",
      "Fiber processes all updates synchronously to ensure state consistency regardless of priority."
    ],
    "answer": "Fiber implements a linked list traversal allowing the rendering process to be paused, aborted, and resumed.",
    "explanation": "The Stack reconciler used the call stack recursively, making it impossible to interrupt. Fiber uses a linked list of unit works (fibers) and a scheduler, enabling React to yield execution back to the main browser loop (time slicing).",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In React's Fiber reconciliation process, which phase is considered interruptible and asynchronous?",
    "options": [
      "The Commit phase.",
      "The Pre-commit phase.",
      "The Render (Reconciliation) phase.",
      "The Passive Effects phase."
    ],
    "answer": "The Render (Reconciliation) phase.",
    "explanation": "React can interrupt the 'Render' phase to prioritize higher-priority work (like user input) before finishing the full tree calculation. The 'Commit' phase is always synchronous to ensure the DOM remains consistent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary purpose of the `useDeferredValue` hook in React 18?",
    "options": [
      "To defer the unmounting of a component until an asynchronous operation completes.",
      "To force a component to re-render even if props have not changed.",
      "To keep a value responsive by deferring expensive updates to a secondary, lower-priority render.",
      "To prevent memory leaks by cleaning up side effects in asynchronous functions."
    ],
    "answer": "To keep a value responsive by deferring expensive updates to a secondary, lower-priority render.",
    "explanation": "It allows React to keep the current (stale) value on the screen while a heavy background update is processing, similar to debouncing but handled by the renderer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which statement accurately describes the behavior of Automatic Batching in React 18?",
    "options": [
      "Batching only occurs within event handlers, not in promises or setTimeout.",
      "All state updates are batched across all asynchronous operations, including promises, setTimeout, and native events.",
      "State updates are never batched to ensure immediate UI feedback.",
      "Batching must be manually enabled using the `unstable_batchedUpdates` API."
    ],
    "answer": "All state updates are batched across all asynchronous operations, including promises, setTimeout, and native events.",
    "explanation": "React 18 introduces automatic batching by default via the createRoot API, grouping state updates even outside event handlers (e.g., in fetch callbacks or timeouts) to minimize re-renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Why is it important to provide a stable `key` prop when rendering lists of components in React?",
    "options": [
      "It allows React to optimize the CSS layout calculation for the list items.",
      "It ensures that the component state is preserved across re-renders and helps React identify which items have changed.",
      "It is required for React to determine the z-index stacking order of the elements.",
      "It automatically enables virtual scrolling for large datasets."
    ],
    "answer": "It ensures that the component state is preserved across re-renders and helps React identify which items have changed.",
    "explanation": "Keys help React identify which elements have changed, been added, or been removed. Without stable keys (like an index that changes), React may destroy and recreate component instances unnecessarily, resetting their state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the functional difference between `useEffect` and `useLayoutEffect`?",
    "options": [
      "`useEffect` runs synchronously after DOM mutations, while `useLayoutEffect` runs asynchronously.",
      "`useLayoutEffect` runs synchronously after DOM mutations but before the browser paints, while `useEffect` runs asynchronously after the paint.",
      "`useEffect` is deprecated in favor of `useLayoutEffect` for all side effects.",
      "There is no difference; they are aliases for the same hook."
    ],
    "answer": "`useLayoutEffect` runs synchronously after DOM mutations but before the browser paints, while `useEffect` runs asynchronously after the paint.",
    "explanation": "`useLayoutEffect` blocks the browser from painting until the effect completes, which is useful for reading layout from the DOM. `useEffect` does not block the paint, making it better for I/O and non-blocking operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "When using the `startTransition` API, how are updates marked as 'transitions' treated differently from urgent updates?",
    "options": [
      "Transition updates are discarded if a new urgent update occurs before the transition completes.",
      "Transition updates are prioritized over urgent updates to ensure smooth animations.",
      "Transition updates are marked as lower priority, allowing React to interrupt them if higher-priority user input arrives.",
      "Transition updates run on a separate background thread to avoid blocking the main UI."
    ],
    "answer": "Transition updates are marked as lower priority, allowing React to interrupt them if higher-priority user input arrives.",
    "explanation": "This feature of Concurrent React allows the UI to remain responsive to typing or clicking by pausing non-urgent rendering work (like filtering a large list) to handle the user's immediate interaction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In the context of React Fiber, what does the 'alternate' field on a Fiber node represent?",
    "options": [
      "A backup node used for error handling if the primary node fails to render.",
      "The work-in-progress tree node that reflects the queued updates for the next render.",
      "A reference to the parent Fiber node in the tree hierarchy.",
      "An alternative component to render if the primary component is lazy loaded."
    ],
    "answer": "The work-in-progress tree node that reflects the queued updates for the next render.",
    "explanation": "Fiber maintains two trees: the 'current' tree (what is on screen) and the 'work-in-progress' tree. The 'alternate' pointer links nodes between these two trees to facilitate double buffering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which lifecycle method is intentionally unsafe to use in Concurrent Mode due to potential multiple invocations?",
    "options": [
      "componentDidMount",
      "getSnapshotBeforeUpdate",
      "componentWillMount",
      "componentDidUpdate"
    ],
    "answer": "componentWillMount",
    "explanation": "Legacy methods like `componentWillMount` (and `componentWillReceiveProps`) are unsafe in Concurrent Mode because the render phase can be paused and restarted, causing them to be called multiple times before a commit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What happens when a component throws an error during the 'Render' phase in a Concurrent React application?",
    "options": [
      "The entire application crashes and displays a white screen.",
      "React attempts to recover by retrying the render one level above the error boundary.",
      "The error is caught by the nearest Error Boundary component.",
      "The render phase ignores the error and commits the partial tree."
    ],
    "answer": "The error is caught by the nearest Error Boundary component.",
    "explanation": "React traverses the tree during the render phase; if an error is thrown, it abandons rendering that subtree, pops up the stack to the nearest Error Boundary, and invokes that boundary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the specific utility of `useRef` compared to creating a standard instance variable in a class component?",
    "options": [
      "`useRef` triggers a re-render when its value changes, unlike instance variables.",
      "`useRef` can only store DOM nodes, whereas instance variables can store any data.",
      "`useRef` returns a mutable ref object that persists for the full lifetime of the component without triggering re-renders.",
      "`useRef` is strictly for functional components and cannot be used in class components."
    ],
    "answer": "`useRef` returns a mutable ref object that persists for the full lifetime of the component without triggering re-renders.",
    "explanation": "Unlike `useState`, changing a `.current` property on a ref does not trigger a re-render. This mimics instance variables in classes or allows direct DOM manipulation without the render cycle cost.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "How does Strict Mode in React 18 help detect side effects in development?",
    "options": [
      "It performs a static analysis of the code to identify impure functions.",
      "It mounts the component twice and invokes effects twice to ensure they are resilient to re-running logic.",
      "It throws an error whenever `useEffect` is used without a dependency array.",
      "It automatically fixes memory leaks in event listeners."
    ],
    "answer": "It mounts the component twice and invokes effects twice to ensure they are resilient to re-running logic.",
    "explanation": "To prepare for the 'render-and-commit' nature of Concurrent features (where a render might be abandoned), Strict Mode double-invokes state updaters and effects in Dev Mode to highlight unsafe cleanup logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the 'reconciliation' algorithm in React primarily responsible for?",
    "options": [
      "Calculating the CSS layout and painting pixels to the screen.",
      "Diffing the new Virtual DOM tree against the previous one to determine the minimal set of changes.",
      "Fetching data from APIs and updating the component state.",
      "Managing the browser's history stack for routing."
    ],
    "answer": "Diffing the new Virtual DOM tree against the previous one to determine the minimal set of changes.",
    "explanation": "Reconciliation is the process React uses to determine which parts of the UI need to be updated. It compares the new element tree with the previous one and calculates the most efficient DOM operation set.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Why is using the `dangerouslySetInnerHTML` prop considered a security risk?",
    "options": [
      "It allows arbitrary HTML execution, making the application vulnerable to Cross-Site Scripting (XSS) attacks if the data is not sanitized.",
      "It bypasses React's rendering optimization, causing performance degradation.",
      "It allows other components to overwrite the inner HTML of the component.",
      "It forces synchronous rendering, blocking the main thread."
    ],
    "answer": "It allows arbitrary HTML execution, making the application vulnerable to Cross-Site Scripting (XSS) attacks if the data is not sanitized.",
    "explanation": "The prop name is intentionally scary to warn developers. Passing unsanitized user input strings (containing `<script>` tags, for example) will execute that code in the user's browser.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the main benefit of `React.memo` for a functional component?",
    "options": [
      "It automatically memoizes the return value of a function passed to the component.",
      "It performs a shallow comparison of props and skips re-rendering the component if props have not changed.",
      "It converts a functional component into a class component to improve performance.",
      "It allows the component to render on the server side only."
    ],
    "answer": "It performs a shallow comparison of props and skips re-rendering the component if props have not changed.",
    "explanation": "`React.memo` is a Higher-Order Component (HOC). If a component is wrapped in it, React will skip rendering it and reuse the last rendered result if the props are referentially equal.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In the context of React reconciliation, what happens when the `type` of an element changes between two renders (e.g., from `<div>` to `<span>`)?",
    "options": [
      "React attempts to patch the existing DOM node with the new type.",
      "React reuses the old DOM node and simply changes the tag name using `document.renameNode`.",
      "React destroys the old DOM node and builds a new one from scratch.",
      "React throws a warning and refuses to update the DOM."
    ],
    "answer": "React destroys the old DOM node and builds a new one from scratch.",
    "explanation": "If the element type changes, React assumes the entire tree structure is different. It tears down the old tree (including unmounting children) and builds the new DOM tree.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does `useCallback` improve performance in a React application?",
    "options": [
      "It automatically memoizes the result of a function call, preventing expensive calculations.",
      "It ensures a function has a stable identity across renders, preventing child components from re-rendering unnecessarily if they depend on that function as a prop.",
      "It converts a synchronous function into an asynchronous one to prevent blocking the UI.",
      "It reduces the memory footprint of the component by deleting the function after it is executed."
    ],
    "answer": "It ensures a function has a stable identity across renders, preventing child components from re-rendering unnecessarily if they depend on that function as a prop.",
    "explanation": "Functions are recreated on every render. If a function is passed to a memoized child component, the child re-renders because the function reference changes. `useCallback` keeps the reference stable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the purpose of the `key` prop specifically when using `React.cloneElement`?",
    "options": [
      "To preserve the original key of the element being cloned to avoid reconciliation issues.",
      "To overwrite the existing key of the element to force a re-mount.",
      "To identify which component is the parent in the cloning operation.",
      "To merge the props of the parent and child components."
    ],
    "answer": "To preserve the original key of the element being cloned to avoid reconciliation issues.",
    "explanation": "While `React.cloneElement` can merge new props, it automatically preserves the `key` and `ref` from the original element unless explicitly overridden. This is crucial for React's list diffing to work correctly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which phase of the Fiber reconciliation algorithm commits changes to the host environment (e.g., the DOM)?",
    "options": [
      "The Reconciliation phase.",
      "The Scheduler phase.",
      "The Commit phase.",
      "The Diffing phase."
    ],
    "answer": "The Commit phase.",
    "explanation": "The Commit phase is the final step where React applies the calculated changes to the DOM (or other host environment). This phase is synchronous and cannot be interrupted.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is a common use case for `useId` hook introduced in React 18?",
    "options": [
      "To generate a unique ID for DOM elements that is stable across server and client, specifically for accessibility attributes.",
      "To create a unique identifier for database records.",
      "To track the identity of components in the Fiber tree for debugging purposes.",
      "To force a component to re-render by changing its ID."
    ],
    "answer": "To generate a unique ID for DOM elements that is stable across server and client, specifically for accessibility attributes.",
    "explanation": "SSR (Server-Side Rendering) can cause hydration mismatches if random IDs are generated differently on server vs client. `useId` ensures the ID generation is deterministic and consistent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "When passing callbacks to child components that rely on state from the parent, what is the primary mechanism to ensure the callback always has access to the current state?",
    "options": [
      "Storing the state in a global variable.",
      "Using the `useCallback` hook with the state in its dependency array.",
      "Using the `useReducer` hook and passing the `dispatch` function.",
      "Using the `useMemo` hook without a dependency array."
    ],
    "answer": "Using the `useReducer` hook and passing the `dispatch` function.",
    "explanation": "The `dispatch` function from `useReducer` has a stable identity and always has access to the latest state, eliminating the need for dependency arrays in callbacks, unlike `setState` based patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What distinguishes a 'Controlled Component' from an 'Uncontrolled Component' in React?",
    "options": [
      "Controlled components are managed by the DOM, while uncontrolled components are managed by React state.",
      "Controlled components derive their input value from React state, while uncontrolled components maintain their own internal state.",
      "Controlled components cannot have default values, while uncontrolled components must have them.",
      "Controlled components are class components, while uncontrolled components are functional components."
    ],
    "answer": "Controlled components derive their input value from React state, while uncontrolled components maintain their own internal state.",
    "explanation": "In a controlled component, form data is handled by a React component (single source of truth). In an uncontrolled component, the DOM handles the state itself, accessed via refs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "How does `Suspense` handle data fetching when combined with Concurrent Mode?",
    "options": [
      "It blocks the entire UI thread until the data fetching is complete.",
      "It shows a fallback UI while waiting for the promise to resolve, allowing React to hide the content until ready.",
      "It automatically retries the data fetching request if it fails.",
      "It converts the asynchronous data fetching into a synchronous operation."
    ],
    "answer": "It shows a fallback UI while waiting for the promise to resolve, allowing React to hide the content until ready.",
    "explanation": "`Suspense` lets components 'wait' for async operations (like data fetching or code splitting) by catching a Promise thrown by the data-fetching library and displaying a loading state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the behavior of the `flushSync` function in React DOM?",
    "options": [
      "It flushes all pending asynchronous events in the event loop.",
      "It forces React to apply the state updates synchronously and flush the resulting work immediately, blocking any other updates.",
      "It clears the component state and resets it to initial values.",
      "It optimizes the rendering pipeline by combining multiple updates into one."
    ],
    "answer": "It forces React to apply the state updates synchronously and flush the resulting work immediately, blocking any other updates.",
    "explanation": "It forces React to execute the passed callback and apply its state updates synchronously, bypassing the usual batching/concurrency heuristics, often needed to measure DOM layout immediately.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In React's reconciliation heuristic, why is moving an element within an array expensive without a `key`?",
    "options": [
      "React must destroy the DOM node and recreate it because it relies on index to match elements.",
      "React has to download the JavaScript bundle for the element again.",
      "React cannot detect the movement and leaves the element in its original position.",
      "React performs a deep equality check on every property of the object."
    ],
    "answer": "React must destroy the DOM node and recreate it because it relies on index to match elements.",
    "explanation": "Without keys, React uses the index to match list items. If an item moves, React sees the new item at the old index as a different component, unmounts the old one, and mounts the new one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the specific function of `React.Children.only`?",
    "options": [
      "It verifies that `children` has only one child and returns it; otherwise, it throws an error.",
      "It iterates over all children and renders only the first one.",
      "It converts a single child into an array to standardize the children structure.",
      "It clones a single child to add additional props to it."
    ],
    "answer": "It verifies that `children` has only one child and returns it; otherwise, it throws an error.",
    "explanation": "This utility is used to enforce that a component accepts a single child (similar to how Vue's slots work or enforcing a specific child structure) and throws in development/production if violated.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Regarding component composition, which term describes passing JSX elements as props to a child component?",
    "options": [
      "Render Props.",
      "Higher-Order Components (HOCs).",
      "Prop Drilling.",
      "Compound Components."
    ],
    "answer": "Render Props.",
    "explanation": "The 'render props' technique involves passing a function (that returns JSX) as a prop to a component, allowing the component to dynamically render content based on its internal state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the primary limitation of Error Boundaries in React?",
    "options": [
      "They cannot catch errors in event handlers or asynchronous code (e.g., setTimeout).",
      "They only work in development mode and are ignored in production builds.",
      "They cannot catch errors in class components, only functional components.",
      "They cause the entire application to reload when an error is caught."
    ],
    "answer": "They cannot catch errors in event handlers or asynchronous code (e.g., setTimeout).",
    "explanation": "Error Boundaries only catch errors during rendering, in lifecycle methods, and in constructors. They do not catch errors in event handlers, async code, or server-side errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How does `React.forwardRef` differ syntactically from a standard functional component?",
    "options": [
      "It accepts a `ref` as the second argument and must return a React element.",
      "It returns a class component instead of a functional component.",
      "It automatically creates a ref for every child component.",
      "It merges multiple refs into a single callback function."
    ],
    "answer": "It accepts a `ref` as the second argument and must return a React element.",
    "explanation": "Standard functional components receive `props` as the first argument; the `ref` is not accessible. `forwardRef` exposes the `ref` as the second parameter to the wrapped function.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the main implication of 'Client-Side Routing' (e.g., React Router) vs. traditional server-side routing?",
    "options": [
      "Client-side routing requires a full page reload for every URL change.",
      "Client-side routing manipulates the browser's History API to change the UI without a full document request.",
      "Client-side routing is slower because it fetches HTML from the server for every route.",
      "Client-side routing cannot support the browser's back button."
    ],
    "answer": "Client-side routing manipulates the browser's History API to change the UI without a full document request.",
    "explanation": "Client-side routers intercept link clicks, use `pushState`/`replaceState` to update the URL, and conditionally render components to match that URL, preventing the browser from requesting a new HTML document.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "In the context of React Profiler, what does the 'commit time' metric represent?",
    "options": [
      "The time it takes for the user to commit their code to the repository.",
      "The time React spends calculating the next state (render phase).",
      "The time React spends applying changes to the DOM (commit phase).",
      "The total time the application takes to load the initial bundle."
    ],
    "answer": "The time React spends applying changes to the DOM (commit phase).",
    "explanation": "The Profiler splits work into 'render' (calculating) and 'commit' (writing to DOM). 'Commit time' specifically measures the duration of the synchronous write operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the purpose of the `static getDerivedStateFromProps` lifecycle method?",
    "options": [
      "To fetch initial data from an API when the component mounts.",
      "To update the state in response to changes in props over time, ensuring the state is synchronized.",
      "To calculate a new state object based on props before the render method is called.",
      "To clear the state when the component is about to unmount."
    ],
    "answer": "To calculate a new state object based on props before the render method is called.",
    "explanation": "It is a static method invoked right before rendering. It returns an object to update state or null to update nothing, used primarily for deriving state from props without side effects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which technique is used to pass data deeply through the component tree without manually passing props at every level?",
    "options": [
      "Prop Drilling.",
      "Component Composition.",
      "React Context.",
      "Render Props."
    ],
    "answer": "React Context.",
    "explanation": "Context provides a way to pass data through the component tree without having to pass props down manually at every level, solving the 'prop drilling' problem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the technical reason `React.PureComponent` can negatively impact performance if used incorrectly?",
    "options": [
      "It automatically makes all methods within the component asynchronous.",
      "It performs a shallow comparison of props and state, which adds overhead if the component renders frequently with the same data.",
      "It prevents any child components from updating.",
      "It enforces Strict Mode, causing components to render twice."
    ],
    "answer": "It performs a shallow comparison of props and state, which adds overhead if the component renders frequently with the same data.",
    "explanation": "The cost of the shallow comparison (checking every prop) might exceed the cost of re-rendering the component, especially if the render logic is very cheap.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What occurs during the 'Hydration' phase in a Server-Side Rendered (SSR) React application?",
    "options": [
      "React generates HTML on the server and sends it to the client.",
      "React takes over the static HTML generated by the server and attaches event listeners to make the page interactive.",
      "React rebuilds the entire Virtual DOM from scratch on the client side.",
      "React performs a garbage collection of unused DOM nodes."
    ],
    "answer": "React takes over the static HTML generated by the server and attaches event listeners to make the page interactive.",
    "explanation": "Hydration is the client-side process where React reuses the existing DOM structure from the server and 'breathes life' into it by binding event listeners and initializing state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the React Fiber architecture, what distinguishes the 'Render' phase from the 'Commit' phase?",
    "options": [
      "The Render phase is synchronous and blocks the main thread, while the Commit phase is asynchronous.",
      "The Render phase calculates changes without mutating the DOM and can be interrupted, while the Commit phase applies those changes and is synchronous.",
      "The Render phase applies mutations to the host tree, while the Commit phase builds the virtual DOM.",
      "The Render phase handles user events, while the Commit phase handles server-side data fetching."
    ],
    "answer": "The Render phase calculates changes without mutating the DOM and can be interrupted, while the Commit phase applies those changes and is synchronous.",
    "explanation": "The Render phase (Reconciliation) creates the effect list and work-in-progress tree; it is interruptible and non-destructive. The Commit phase is the final, synchronous step where React mutates the host environment (DOM) and updates refs.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary purpose of a 'Fiber' node in React's internal architecture?",
    "options": [
      "To replace the Virtual DOM entirely with a more efficient tree structure.",
      "To serve as a JavaScript object representing a unit of work that holds component state, props, and side-effect queues.",
      "To act as a Web Worker that handles rendering off the main thread.",
      "To provide a mechanism for CSS-in-JS injection directly into the component layer."
    ],
    "answer": "To serve as a JavaScript object representing a unit of work that holds component state, props, and side-effect queues.",
    "explanation": "A Fiber is a JavaScript object that represents a unit of work. It contains data about the component's props, state, and the queue of work to be done (effects), enabling React to track, schedule, and pause rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does React's reconciliation algorithm handle changes to the type of a DOM element?",
    "options": [
      "It attempts to patch the existing element to match the new type.",
      "It reuses the existing DOM node and only updates the attributes.",
      "It destroys the old subtree and builds a new one from scratch.",
      "It throws an error if the element type changes between renders."
    ],
    "answer": "It destroys the old subtree and builds a new one from scratch.",
    "explanation": "If the element type changes (e.g., from `<div>` to `<span>`), React assumes the entire subtree structure is different. It destroys the old DOM nodes and creates new ones, as patching is deemed impossible or inefficient.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the function of the `return` pointer in a Fiber node?",
    "options": [
      "It points to the parent Fiber node, allowing React to return to the parent after processing children.",
      "It stores the value returned by the component function.",
      "It indicates the next sibling Fiber to process.",
      "It holds the reference to the previous Virtual DOM tree."
    ],
    "answer": "It points to the parent Fiber node, allowing React to return to the parent after processing children.",
    "explanation": "The `return` field in a Fiber node links back to the parent. This single-linked list structure allows React to traverse the tree, process a child, and then return (`return`) to the parent to process the next sibling or complete the work.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "Which condition causes React to unmount a component and remount it during reconciliation?",
    "options": [
      "Changing the `key` prop of the component.",
      "Updating the component's state.",
      "Changing a prop that is a primitive value (string or number).",
      "The parent component re-rendering."
    ],
    "answer": "Changing the `key` prop of the component.",
    "explanation": "The `key` prop helps React identify which items have changed, been added, or been removed. If a `key` changes, React treats the element as a completely new entity, destroying the old instance (unmount) and creating a new one (mount).",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the behavior of `useLayoutEffect` compared to `useEffect` regarding browser painting?",
    "options": [
      "`useLayoutEffect` runs asynchronously after the paint, while `useEffect` runs synchronously before paint.",
      "`useLayoutEffect` runs synchronously after all DOM mutations but before the browser paints, while `useEffect` runs after paint.",
      "Both run synchronously before paint, but `useLayoutEffect` has higher priority.",
      "`useLayoutEffect` is deprecated in favor of `useEffect` in React 18."
    ],
    "answer": "`useLayoutEffect` runs synchronously after all DOM mutations but before the browser paints, while `useEffect` runs after paint.",
    "explanation": "`useLayoutEffect` blocks the browser from painting until the effect completes, allowing for synchronous DOM reads/writes. `useEffect` defers the effect until after the layout and paint are complete.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of React Concurrent Features, what does `startTransition` allow you to do?",
    "options": [
      "Immediately abort a slow data fetch request.",
      "Mark specific state updates as non-urgent, allowing React to interrupt them for higher-priority updates.",
      "Force a component to render on a separate background thread.",
      "Transition between different routing views instantly."
    ],
    "answer": "Mark specific state updates as non-urgent, allowing React to interrupt them for higher-priority updates.",
    "explanation": "`startTransition` marks state updates inside the callback as 'transitions'. These updates are given lower priority (background), allowing React to keep the interface responsive to urgent interactions (like typing) by interrupting the transition work.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Why must the `key` prop be unique among siblings, but not globally unique within the entire application?",
    "options": [
      "React only compares siblings during the diffing phase to determine insertion, deletion, or reordering.",
      "Global uniqueness would cause a memory leak in the Fiber tree.",
      "Keys are hashed using the parent component's ID to ensure global stability.",
      "Sibling uniqueness is a legacy constraint from React 15 that is no longer required in Fiber."
    ],
    "answer": "React only compares siblings during the diffing phase to determine insertion, deletion, or reordering.",
    "explanation": "Reconciliation operates on the list of children within a parent. The `key` is used solely to match elements in the new list with elements in the old list; keys in different parent subtrees are never compared.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is a 'Stale Closure' in the context of React Hooks?",
    "options": [
      "When a component function fails to return a JSX element.",
      "When a callback or effect captures props or state from a previous render, leading to outdated data usage.",
      "When the `useCallback` dependency array is empty.",
      "When the garbage collector fails to remove unused event listeners."
    ],
    "answer": "When a callback or effect captures props or state from a previous render, leading to outdated data usage.",
    "explanation": "If a Hook's dependency array is incorrectly omitted, the function created during the initial render closes over the initial state/props. Subsequent renders do not update the function's scope, so it continues to reference the 'stale' old values.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "How does `React.memo` optimize a functional component?",
    "options": [
      "It automatically converts the component into a PureComponent class.",
      "It performs a shallow comparison of previous and current props; if they are equal, it skips rendering the component.",
      "It memoizes the return value of the component forever, preventing any re-renders.",
      "It implements a deep equality check of all props to determine if an update is needed."
    ],
    "answer": "It performs a shallow comparison of previous and current props; if they are equal, it skips rendering the component.",
    "explanation": "`React.memo` is a Higher-Order Component (HOC). It memoizes the result; if props have not changed (shallow comparison), React skips rendering the component and reuses the last rendered result.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the primary consequence of omitting the dependency array in `useEffect`?",
    "options": [
      "The effect runs only once when the component mounts.",
      "The effect runs after every single render of the component.",
      "The effect never runs.",
      "The component throws a runtime error."
    ],
    "answer": "The effect runs after every single render of the component.",
    "explanation": "Omitting the dependency array tells React that the effect has no dependencies and therefore needs to run after every render cycle. This is a common source of performance issues and infinite loops.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In React's synthetic event system, what is 'Event Pooling' (prior to React 17) and why was it removed?",
    "options": [
      "Pooling recycled event objects to reduce garbage collection; it was removed because it prevented asynchronous access to event properties.",
      "Pooling multiple events into a single batch update; removed because it caused UI lag.",
      "Pooling event listeners on the document level; removed to support multiple React roots.",
      "Pooling native DOM events to prevent memory leaks; removed because browsers improved their own memory management."
    ],
    "answer": "Pooling recycled event objects to reduce garbage collection; it was removed because it prevented asynchronous access to event properties.",
    "explanation": "React used to nullify event properties after an event handler ran to reuse the object. This made reading `event.target` asynchronously (e.g., in a promise) impossible, so pooling was deprecated in React 17 to support standard browser behavior.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the purpose of the `current` tree versus the `workInProgress` tree in Fiber?",
    "options": [
      "The `current` tree is used for server-side rendering, while `workInProgress` is for client-side.",
      "The `current` tree represents the UI currently on screen, while `workInProgress` is the draft buffer being calculated for the next state.",
      "The `current` tree holds all uncommitted changes, while `workInProgress` is the committed state.",
      "There is no difference; they are swapped on every render frame."
    ],
    "answer": "The `current` tree represents the UI currently on screen, while `workInProgress` is the draft buffer being calculated for the next state.",
    "explanation": "React maintains two trees. The `current` tree is what the user sees. When an update occurs, React builds a `workInProgress` tree. Once finished, React swaps the pointers, making `workInProgress` the new `current`.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What happens when a component throws an error during the Render phase?",
    "options": [
      "The entire application crashes and the white screen of death appears.",
      "The error is caught by the nearest Error Boundary component above it in the tree.",
      "The component is skipped, and rendering continues with the rest of the tree.",
      "The `componentDidCatch` method is called on the component that threw the error."
    ],
    "answer": "The error is caught by the nearest Error Boundary component above it in the tree.",
    "explanation": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the crashed component tree.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How does `useReducer` hook optimization differ from `useState` when dealing with complex state logic?",
    "options": [
      "`useReducer` is faster than `useState` because it uses WebAssembly.",
      "`useReducer` allows you to separate the state update logic from the component, preventing stale closure issues in callbacks dispatching updates.",
      "`useState` automatically batches all updates, while `useReducer` requires manual batching.",
      "`useReducer` is the only hook that can handle object state."
    ],
    "answer": "`useReducer` allows you to separate the state update logic from the component, preventing stale closure issues in callbacks dispatching updates.",
    "explanation": "In `useReducer`, the dispatch function identity is stable and doesn't change on re-renders. This allows passing `dispatch` down to deeply nested components without causing them to re-render, unlike passing a callback created via `useState` setters.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What technical mechanism does `Suspense` use to trigger its fallback state?",
    "options": [
      "It listens for a specific event emitted by the data fetching library.",
      "It checks if a Promise thrown in a child component is pending.",
      "It polls the component's state every 100ms.",
      "It relies on the `isLoading` boolean prop."
    ],
    "answer": "It checks if a Promise thrown in a child component is pending.",
    "explanation": "React Suspense works by letting a data-fetching wrapper throw a Promise. React catches this Promise and renders the nearest Suspense parent's fallback until that Promise resolves.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In React Server Components (RSC), why is it illegal to import client-side hooks like `useState` into a Server Component?",
    "options": [
      "Server Components use a different JavaScript runtime that does not support hooks.",
      "Server Components render on the server where React's client-side interactivity features (reconciliation) do not exist.",
      "`useState` requires a browser to access the LocalStorage API.",
      "Server Components are strictly typed with TypeScript, which prevents hook usage."
    ],
    "answer": "Server Components render on the server where React's client-side interactivity features (reconciliation) do not exist.",
    "explanation": "Server Components render once on the server to generate static UI/JSON. Hooks like `useState` and `useEffect` rely on the React runtime on the client to manage state and side effects over time, which is missing in the server execution environment.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the fundamental difference between `useRef` and creating a generic property on a component instance (e.g., `this.myVar` in classes)?",
    "options": [
      "`useRef` is specific to functional components and persists across re-renders without triggering re-renders itself, whereas instance properties do not exist in functions.",
      "`useRef` automatically synchronizes with the DOM, while instance properties do not.",
      "`useRef` values are immutable, while instance properties are mutable.",
      "There is no difference; `useRef` is a class component polyfill."
    ],
    "answer": "`useRef` is specific to functional components and persists across re-renders without triggering re-renders itself, whereas instance properties do not exist in functions.",
    "explanation": "Functional components don't have instances. `useRef` creates a plain JavaScript object via `useEffect` logic where the `.current` property persists for the full lifetime of the component, acting like an instance variable.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the 'Lane' model in React 18+ concurrency?",
    "options": [
      "A replacement for the 'Key' prop in lists.",
      "A representation of priority levels used to schedule work, allowing high-priority updates (like typing) to interrupt low-priority work.",
      "A technique for splitting the DOM into multiple lanes for parallel rendering.",
      "A way to restrict state updates to specific component branches."
    ],
    "answer": "A representation of priority levels used to schedule work, allowing high-priority updates (like typing) to interrupt low-priority work.",
    "explanation": "Lanes are a model defining the priority of updates. They replace the older expiration-time model, allowing React to distinguish between discrete (urgent) and continuous (background) updates and schedule them accordingly.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When using `forwardRef`, how does the second parameter `ref` differ from standard props?",
    "options": [
      "It is treated as a prop that triggers a re-render if changed.",
      "It is a reserved keyword that is passed as a second argument specifically to bypass prop expansion.",
      "It is automatically destructured by the component function.",
      "It can only be used on DOM elements, not other components."
    ],
    "answer": "It is a reserved keyword that is passed as a second argument specifically to bypass prop expansion.",
    "explanation": "`forwardRef` creates a component where the `ref` (passed from the parent) is provided as a distinct second argument to the render function, separating it from standard `props` to prevent it from being read as a custom attribute (e.g., `props.ref`).",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What specific problem does `useInsertionEffect` solve for CSS-in-JS libraries?",
    "options": [
      "It allows CSS to be injected asynchronously after the paint.",
      "It runs synchronously before React mutates the DOM, allowing styles to be injected before layout calculations read them.",
      "It blocks the thread until the CSS file is downloaded from the server.",
      "It automatically adds vendor prefixes to CSS strings."
    ],
    "answer": "It runs synchronously before React mutates the DOM, allowing styles to be injected before layout calculations read them.",
    "explanation": "Standard `useLayoutEffect` or `useEffect` fires too late to inject dynamic styles before the browser reads layout. `useInsertionEffect` fires before browser layout paint but after React determines changes, preventing layout thrashing.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In Automatic Batching (React 18), why are state updates inside `fetch` or `setTimeout` batched, whereas they were not in React 17?",
    "options": [
      "React 18 wraps event handlers implicitly in `unstable_batchedUpdates`.",
      "React 18 introduces a rendering concept that checks for pending work regardless of the execution context.",
      "React 18 uses a global variable to track all pending state changes.",
      "Browsers added a new API that allows React to detect asynchronous contexts."
    ],
    "answer": "React 18 introduces a rendering concept that checks for pending work regardless of the execution context.",
    "explanation": "React 17 only batched updates inside React event handlers. React 18 uses updates that are batched automatically whenever they occur (events, promises, timeouts), ensuring consistent performance behavior.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the specific output of `useId` designed to ensure?",
    "options": [
      "Unique IDs across all tabs and windows of the browser.",
      "Stable IDs that match between server and client to avoid hydration mismatches.",
      "Sequential IDs that increment by 1 for every component rendered.",
      "Cryptographically unique IDs for security purposes."
    ],
    "answer": "Stable IDs that match between server and client to avoid hydration mismatches.",
    "explanation": "If a server generates a random ID (e.g., `Math.random()`) and the client generates a different one, hydration fails. `useId` ensures the algorithm generates the exact same ID string on both sides.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What occurs when a 'Hydration Mismatch' error is logged in the console?",
    "options": [
      "The server crashed while generating HTML.",
      "The client-side React renderer generated a tree different from the server's HTML string.",
      "The user's internet connection is too slow.",
      "The component used `useEffect` during the server render pass."
    ],
    "answer": "The client-side React renderer generated a tree different from the server's HTML string.",
    "explanation": "Hydration is the process of attaching event listeners to existing HTML. If the server HTML does not match what React expects the Virtual DOM to look like on the client, React cannot reconcile the difference and throws a hydration mismatch error.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "How does the `children` prop behave implicitly in React components?",
    "options": [
      "It is always an array, regardless of the number of children.",
      "It is undefined if no children are passed, otherwise an array.",
      "It is a single child if only one child is passed, or an array if multiple children are passed.",
      "It is a string representation of the inner HTML."
    ],
    "answer": "It is a single child if only one child is passed, or an array if multiple children are passed.",
    "explanation": "React does not always wrap children in an array. If there is exactly one child, `props.children` is that child element directly (e.g., a node or string). If there are multiple, it is an array.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the consequence of mutating `state` directly (e.g., `state.count = 5`) in a React component?",
    "options": [
      "The component will re-render, but the previous state will be lost.",
      "The component will not re-render, because React uses `Object.is` comparison to detect changes and the reference remains the same.",
      "It throws an immediate error in React 18.",
      "It causes a memory leak that can only be fixed by unmounting the component."
    ],
    "answer": "The component will not re-render, because React uses `Object.is` comparison to detect changes and the reference remains the same.",
    "explanation": "React determines if a re-render is needed by checking if the state reference has changed. Direct mutation modifies the object in place, so the reference remains identical, and React assumes nothing changed.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Why is it recommended to lift state up to the closest common ancestor?",
    "options": [
      "To reduce the bundle size by deleting unused state variables.",
      "To make the state accessible to all components that need it and allow two-way data binding.",
      "To facilitate state synchronization between sibling components.",
      "To ensure that the state is persisted to LocalStorage."
    ],
    "answer": "To facilitate state synchronization between sibling components.",
    "explanation": "React data flows down. To share state between siblings, the state must live in the parent (common ancestor) so it can be passed down to both, keeping them in sync.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of the Virtual DOM, what is 'diffing'?",
    "options": [
      "The process of converting JSX into HTML strings.",
      "The algorithm used to reconcile the current Virtual DOM tree with the new Virtual DOM tree to find the minimum number of changes.",
      "The process of downloading new assets from the server.",
      "The method React uses to compress JavaScript code before execution."
    ],
    "answer": "The algorithm used to reconcile the current Virtual DOM tree with the new Virtual DOM tree to find the minimum number of changes.",
    "explanation": "Diffing (or reconciliation) compares two Virtual DOM trees. React calculates the difference (diff) and applies only those specific changes to the real DOM, rather than re-rendering the entire page.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the technical reason for the 'Key Warning' when using array indices as keys for a list that can be reordered?",
    "options": [
      "Indices are always strings, causing type mismatch errors.",
      "Using indices creates unstable identities; if an item is inserted/removed, the index shifts, causing React to mistakenly reuse/destroy DOM elements for other items.",
      "React cannot read numeric keys; keys must start with a letter.",
      "Indices are not unique in JavaScript arrays."
    ],
    "answer": "Using indices creates unstable identities; if an item is inserted/removed, the index shifts, causing React to mistakenly reuse/destroy DOM elements for other items.",
    "explanation": "Keys should be stable. If key 1 refers to 'Item A' and then an item is inserted at the top, 'Item A' becomes key 2. React might repurpose the DOM node for key 1 (the new item) instead of creating a new one, leading to UI bugs.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "How does `useCallback` prevent unnecessary re-renders in child components?",
    "options": [
      "By caching the result of the function call.",
      "By maintaining referential equality of the function across re-renders, satisfying `React.memo` shallow comparison.",
      "By automatically converting the function into a Web Worker.",
      "By preventing the function from being executed unless dependencies change."
    ],
    "answer": "By maintaining referential equality of the function across re-renders, satisfying `React.memo` shallow comparison.",
    "explanation": "Without `useCallback`, a new function instance is created every render. If passed to a memoized child (`React.memo`), the child sees a 'new' prop and re-renders. `useCallback` returns the same function instance unless dependencies change.",
    "difficulty": "Advanced"
  }
]