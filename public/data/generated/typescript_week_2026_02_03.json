[
  {
    "id": 1,
    "question": "Which TypeScript keyword is used to assert that a value is not null or undefined when the compiler cannot guarantee it?",
    "options": [
      "!",
      "?",
      "&",
      "||"
    ],
    "answer": "!",
    "explanation": "The non-null assertion operator (!) tells the compiler to treat the operand as non-null and non-undefined. The optional chaining operator (?.) is for safe access, not assertion.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the resulting type of the following utility type transformation? `type T = Partial<{ a: number; b: string }>;",
    "options": [
      "{ a: number; b: string; }",
      "{ a?: number; b?: string; }",
      "number | string",
      "{ a: number; }"
    ],
    "answer": "{ a?: number; b?: string; }",
    "explanation": "The `Partial` utility type makes all properties of the provided type optional. It maps keys to their values with the `?` modifier.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which statement correctly differentiates an `interface` from a `type` alias in TypeScript?",
    "options": [
      "Interfaces cannot define function types, but type aliases can.",
      "Interfaces support declaration merging, while type aliases do not.",
      "Type aliases support extending other types, but interfaces do not.",
      "Interfaces are strictly for runtime objects, while types are for compile-time only."
    ],
    "answer": "Interfaces support declaration merging, while type aliases do not.",
    "explanation": "Interfaces can be declared multiple times with the same name, and their declarations will be merged. Type aliases cannot be merged; attempting to redeclare them throws an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary purpose of the `keyof` operator?",
    "options": [
      "To retrieve the value type of a specific object key.",
      "To create a union type of all known keys of a type.",
      "To iterate over array indices.",
      "To convert a primitive type to an object key."
    ],
    "answer": "To create a union type of all known keys of a type.",
    "explanation": "`keyof T` generates a union type consisting of the property names (keys) of type `T`. It is analogous to `Object.keys` but operates at the type level.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Given `type Person = { name: string; age: number }`, which utility type removes `age` from the type?",
    "options": [
      "Omit<Person, 'age'>",
      "Exclude<Person, 'age'>",
      "Pick<Person, 'name'>",
      "Partial<Person, 'age'>"
    ],
    "answer": "Omit<Person, 'age'>",
    "explanation": "`Omit` constructs a type by picking all properties from `T` and then removing `K`. `Exclude` removes specific types from a union, not object properties.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "In the context of Generics, what does `extends` constraint in `function log<T extends string>(arg: T)` do?",
    "options": [
      "It creates a new type that inherits from T.",
      "It ensures T is assignable to string, limiting the generic to strings.",
      "It makes T optional.",
      "It allows T to be any type except string."
    ],
    "answer": "It ensures T is assignable to string, limiting the generic to strings.",
    "explanation": "Generic constraints (`extends`) restrict the type parameter `T` to be a subtype of the specified type (here, `string`), ensuring type safety within the function.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the output type of `type T = Exclude<'a' | 'b' | 'c', 'a'>`?",
    "options": [
      "'a'",
      "'b' | 'c'",
      "'a' | 'b' | 'c'",
      "never"
    ],
    "answer": "'b' | 'c'",
    "explanation": "`Exclude` removes types from a union that are assignable to the second argument. It removes `'a'` from the union, leaving `'b' | 'c'`.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which access modifier allows a property to be accessed within the same class but NOT from subclasses or external instances?",
    "options": [
      "public",
      "protected",
      "private",
      "static"
    ],
    "answer": "private",
    "explanation": "`private` restricts access strictly to the defining class. `protected` allows subclass access, and `public` allows access from anywhere.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the result of using the `Readonly` utility type on `{ x: number; y: number; }`?",
    "options": [
      "The object properties become immutable and cannot be reassigned.",
      "The object properties become optional.",
      "The object properties can be deleted but not modified.",
      "The object is deep-cloned."
    ],
    "answer": "The object properties become immutable and cannot be reassigned.",
    "explanation": "`Readonly` maps all properties to be `readonly`. TypeScript prevents assignment to these properties at compile-time.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "How do you define a Tuple type in TypeScript?",
    "options": [
      "By using the `Tuple` keyword.",
      "By specifying an array with fixed element types, e.g., `[string, number]`.",
      "By using the `<>` generics syntax on a class.",
      "By defining an interface with numeric keys."
    ],
    "answer": "By specifying an array with fixed element types, e.g., `[string, number]`.",
    "explanation": "Tuples are expressed as arrays with specific types at specific indices, e.g., `let x: [string, number]`. Standard arrays are homogeneous; tuples are heterogeneous.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the difference between `unknown` and `any`?",
    "options": [
      "`unknown` allows any operation, `any` requires type assertions.",
      "`any` disables type checking, `unknown` enforces type checking before use.",
      "`unknown` is for objects only, `any` is for primitives.",
      "There is no difference; they are aliases."
    ],
    "answer": "`any` disables type checking, `unknown` enforces type checking before use.",
    "explanation": "`any` effectively turns off type checking. `unknown` is the top type (like `any`), but you must perform a type narrowing check to use the value.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What does the `as` keyword signify in TypeScript?",
    "options": [
      "Loop iteration",
      "Type Assertion",
      "Interface Implementation",
      "Class Extension"
    ],
    "answer": "Type Assertion",
    "explanation": "`as` is used for Type Assertions, telling the compiler to treat a value as a specific type. It overrides the inferred type without performing code generation.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which built-in utility type constructs a type by picking the set of properties `K` from type `T`?",
    "options": [
      "Pick<T, K>",
      "Extract<T, K>",
      "Omit<T, K>",
      "Record<K, T>"
    ],
    "answer": "Pick<T, K>",
    "explanation": "`Pick<T, K>` creates a new type by selecting the specific keys `K` from `T`. `Omit` does the inverse (removing keys).",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which TypeScript feature allows defining a function signature without implementing the body, enabling classes to enforce specific structure?",
    "options": [
      "Abstract Class",
      "Interface",
      "Namespace",
      "Type Alias"
    ],
    "answer": "Interface",
    "explanation": "While abstract classes can do this, interfaces are the primary structural contract for defining shapes that classes must implement. Classes can implement multiple interfaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the type of `const x = [1, 'hello', true]`?",
    "options": [
      "any[]",
      "number[]",
      "[number, string, boolean]",
      "(number | string | boolean)[]"
    ],
    "answer": "[number, string, boolean]",
    "explanation": "When initializing an array with values of specific types in const context, TypeScript infers a Tuple type representing the exact order and types of elements.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is a 'Mapped Type' in TypeScript?",
    "options": [
      "A type that maps values to an object.",
      "A type that iterates over keys to create a new type transformation.",
      "A type map for memory allocation.",
      "A type that maps runtime classes to interfaces."
    ],
    "answer": "A type that iterates over keys to create a new type transformation.",
    "explanation": "Mapped types use the syntax `[K in keyof T]: T[K]` to iterate over properties and modify their structure (e.g., making them optional or readonly).",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which operator is used for optional chaining in TypeScript?",
    "options": [
      "?.",
      "??",
      "&&",
      "::"
    ],
    "answer": "?.",
    "explanation": "The optional chaining operator `?.` stops evaluation if the reference is `null` or `undefined`, returning `undefined` instead of throwing an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the return type of a function that never returns (e.g., always throws or has an infinite loop)?",
    "options": [
      "undefined",
      "null",
      "void",
      "never"
    ],
    "answer": "never",
    "explanation": "`never` represents the type of values that never occur. It is used for functions that throw exceptions or loop infinitely.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How do you type a variable that can hold specific string literal values 'small' | 'medium' | 'large'?",
    "options": [
      "type Size = string;",
      "type Size = 'small' | 'medium' | 'large';",
      "type Size = array('small', 'medium', 'large');",
      "type Size = enum['small', 'medium', 'large'];"
    ],
    "answer": "type Size = 'small' | 'medium' | 'large';",
    "explanation": "Union types allow you to list specific literal values. `type Size = 'small' | 'medium' | 'large';` restricts the assignment to only those three strings.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What does `tsconfig.json` control?",
    "options": [
      "The runtime behavior of the JavaScript output.",
      "The TypeScript compiler options and project root.",
      "The package dependencies installation.",
      "The HTML template generation."
    ],
    "answer": "The TypeScript compiler options and project root.",
    "explanation": "`tsconfig.json` defines the root files and the compiler options required to compile the project.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which statement accurately describes structural typing (duck typing) in TypeScript?",
    "options": [
      "Types must match by name.",
      "Types are compatible if their structure (properties) matches.",
      "Classes must explicitly inherit from the same parent.",
      "Types are checked only at runtime."
    ],
    "answer": "Types are compatible if their structure (properties) matches.",
    "explanation": "TypeScript uses structural typing; an object is considered a type if it has the required properties, regardless of the explicit class/interface name.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the `Record<Keys, Type>` utility used for?",
    "options": [
      "To log keyboard events.",
      "To construct an object type with specific keys and value types.",
      "To record audio input.",
      "To create a dictionary of string keys only."
    ],
    "answer": "To construct an object type with specific keys and value types.",
    "explanation": "`Record<K, T>` creates an object type where property keys are `K` and property values are `T`. It is useful for mapping keys to value types.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "In a generic type `type Box = { value: T }`, what does `T` represent?",
    "options": [
      "A generic number type",
      "A type placeholder that is supplied later",
      "A tuple type",
      "The class constructor"
    ],
    "answer": "A type placeholder that is supplied later",
    "explanation": "`T` is a Generic Type Parameter. It acts as a variable for types that allows the type definition to be reusable with different concrete types.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the `NonNullable` utility type do?",
    "options": [
      "Removes `null` and `undefined` from type `T`.",
      "Ensures a value is not `void`.",
      "Converts `any` to `unknown`.",
      "Validates input at runtime."
    ],
    "answer": "Removes `null` and `undefined` from type `T`.",
    "explanation": "`NonNullable` creates a new type by excluding `null` and `undefined` from `T`.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "How do you specify the return type of an arrow function explicitly?",
    "options": [
      "() => number {}",
      "(): number => {}",
      "function (): number {}",
      "() => return number"
    ],
    "answer": "(): number => {}",
    "explanation": "The syntax for explicitly typing an arrow function return value places the type before the fat arrow: `(args): ReturnType => {}`.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which type represents a function that takes a string and returns a number?",
    "options": [
      "Function",
      "string => number",
      "(s: string) => number",
      "number(string)"
    ],
    "answer": "(s: string) => number",
    "explanation": "TypeScript function types explicitly list arguments and the return type separated by `=>`. `(s: string) => number` is the correct syntax.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What does the `infer` keyword do inside a conditional type?",
    "options": [
      "It creates a generic type constraint.",
      "It infers a type variable from a successful condition match.",
      "It checks if a type is valid.",
      "It logs types to the console."
    ],
    "answer": "It infers a type variable from a successful condition match.",
    "explanation": "`infer` is used in conditional types (e.g., `T extends Promise ? infer U : never`) to capture a type (like the resolved type of a Promise) dynamically.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which of the following is a valid way to declare a numeric enum?",
    "options": [
      "enum Color { Red, Green, Blue }",
      "const enum Color = ['Red', 'Green', 'Blue']",
      "enum Color = { Red: 0, Green: 1 }",
      "NumericEnum Color { Red, Green }"
    ],
    "answer": "enum Color { Red, Green, Blue }",
    "explanation": "Enums are defined using the `enum` keyword with a block containing comma-separated members. Numeric enums auto-increment from 0 if not initialized.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the output of `type T1 = Uppercase<'hello'>`?",
    "options": [
      "'hello'",
      "'HELLO'",
      "Error",
      "'H'"
    ],
    "answer": "'HELLO'",
    "explanation": "`Uppercase` is a built-in Template Literal Type that transforms a string literal type to its uppercase equivalent.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "How do you define a property in a class that belongs to the class itself rather than instances?",
    "options": [
      "let property",
      "const property",
      "static property",
      "public property"
    ],
    "answer": "static property",
    "explanation": "The `static` keyword defines a static member, which is accessed on the class constructor (e.g., `MyClass.prop`) rather than on instances (`new MyClass().prop`).",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What happens when you set `strict: true` in `tsconfig.json`?",
    "options": [
      "The code compiles to strict mode JavaScript.",
      "It enables `strictNullChecks`, `noImplicitAny`, and other strict type-checking flags.",
      "It prevents using any external libraries.",
      "It formats the code according to strict style guides."
    ],
    "answer": "It enables `strictNullChecks`, `noImplicitAny`, and other strict type-checking flags.",
    "explanation": "`strict` enables a suite of options that enforce the strongest type-checking possible, making the development process safer by catching more errors.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the `Required` utility type used for?",
    "options": [
      "To force a variable to be defined.",
      "To make all properties of `T` required (removing optional modifiers).",
      "To ensure a class has all methods.",
      "To check imports are resolved."
    ],
    "answer": "To make all properties of `T` required (removing optional modifiers).",
    "explanation": "`Required` constructs a type consisting of all properties of `T` set to required. It is the opposite of `Partial`.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which operator combines two types, requiring the result to contain members from both?",
    "options": [
      "Pipe (|)",
      "Ampersand (&)",
      "Plus (+)",
      "Equals (=)"
    ],
    "answer": "Ampersand (&)",
    "explanation": "The Intersection operator (`&`) combines types. `A & B` creates a type that has all members of `A` and all members of `B`.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In TypeScript, what is a Type Guard?",
    "options": [
      "A method that protects code from unauthorized access.",
      "A runtime check that ensures the type of a variable.",
      "A class that cannot be instantiated.",
      "A comment explaining types."
    ],
    "answer": "A runtime check that ensures the type of a variable.",
    "explanation": "Type guards are expressions (like `typeof x === 'string'` or `x instanceof Animal`) that perform runtime checks to narrow the type within a code block.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the utility type `Parameters` used for?",
    "options": [
      "To extract the parameter types of a function type.",
      "To set default parameters.",
      "To validate parameters at runtime.",
      "To bind parameters to a specific scope."
    ],
    "answer": "To extract the parameter types of a function type.",
    "explanation": "`Parameters<T>` constructs a tuple type of the parameter types of a function type `T`. It is useful for typing generic higher-order functions.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which utility type constructs a type by picking the set of properties `K` from type `T`?",
    "options": [
      "`Extract<T, K>`",
      "`Omit<T, K>`",
      "`Pick<T, K>`",
      "`Partial<T>`"
    ],
    "answer": "`Pick<T, K>`",
    "explanation": "`Pick<T, K>` creates a new type by extracting the specific set of keys `K` from `T`. `Extract` is used for Unions, `Omit` removes keys, and `Partial` makes all properties optional.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the result type of `typeof function returns() { return { x: 10, y: 20 }; } extends infer R ? R : never`?",
    "options": [
      "{ x: number; y: number; }",
      "number",
      "() => { x: number; y: number; }",
      "any"
    ],
    "answer": "() => { x: number; y: number; }",
    "explanation": "The `typeof` operator applied to a function returns the function's signature type, not its return value. To get the return type, one must use `ReturnType<typeof returns>`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In TypeScript, what is the primary structural difference between `interface` and `type` aliases regarding extensibility?",
    "options": [
      "Interfaces support declaration merging; type aliases do not.",
      "Type aliases support declaration merging; interfaces do not.",
      "Interfaces cannot extend primitive types; type aliases can.",
      "Type aliases cannot use generics; interfaces can."
    ],
    "answer": "Interfaces support declaration merging; type aliases do not.",
    "explanation": "Interfaces allow multiple declarations with the same name to be merged into a single definition. Type aliases cannot be merged; attempting to redeclare them throws an error.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Given `type User = { id: number; name: string; }`, what is the result of `keyof User`?",
    "options": [
      "`number | string`",
      "`'id' | 'name'`",
      "`{ id: number; name: string; }`",
      "`'id'`"
    ],
    "answer": "`'id' | 'name'`",
    "explanation": "The `keyof` operator produces a union of the known public property names of the input type. It extracts the keys as a string literal union, not the types of the values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "How does the `satisfies` operator differ from a standard type annotation?",
    "options": [
      "`satisfies` validates that a value matches a type but retains the value's specific inferred shape.",
      "`satisfies` is used for runtime type checking, while type annotations are compile-time only.",
      "Type annotations allow wider types, whereas `satisfies` requires exact primitive matches.",
      "`satisfies` can only be used on interfaces, not type aliases."
    ],
    "answer": "`satisfies` validates that a value matches a type but retains the value's specific inferred shape.",
    "explanation": "Unlike type annotations (which widen the expression to the assigned type), `satisfies` ensures the value is compatible with the type while preserving the more specific type of the value for subsequent operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the output of the following conditional type? `type Result<T> = T extends string ? 'A' : 'B'; type Test = Result<number | string>;`",
    "options": [
      "`'A' | 'B'`",
      "`'B'`",
      "`'A'`",
      "`never`"
    ],
    "answer": "`'A' | 'B'`",
    "explanation": "Conditional types distribute over unions. Since `number` extends `string` is false (resulting in 'B') and `string` extends `string` is true (resulting in 'A'), the result is the union `'A' | 'B'`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which utility type makes all properties in `T` optional recursively?",
    "options": [
      "`Partial<T>`",
      "`DeepPartial<T>`",
      "`Required<T>`",
      "`Readonly<T>`"
    ],
    "answer": "`DeepPartial<T>`",
    "explanation": "`Partial<T>` only affects the top-level properties. `DeepPartial` is a custom utility type (often implemented via recursion) that traverses nested objects to make all properties optional.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the purpose of the `unknown` type in TypeScript?",
    "options": [
      "It represents any value without type checking, similar to `any`.",
      "It represents a value that is strictly `null` or `undefined`.",
      "It is the top type for all values, requiring type narrowing before usage.",
      "It represents a value that has not yet been defined in the scope."
    ],
    "answer": "It is the top type for all values, requiring type narrowing before usage.",
    "explanation": "While `unknown` is the top type (meaning any value can be assigned to it), you cannot perform arbitrary operations on it without first asserting or narrowing its type, unlike `any`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which Mapped Type modifier removes the `readonly` attribute from all properties in `T`?",
    "options": [
      "`-readonly`",
      "`-?`",
      "`+readonly`",
      "`RemoveReadonly<T>`"
    ],
    "answer": "`-readonly`",
    "explanation": "In mapped types, the `-readonly` modifier explicitly removes the readonly status. Conversely, `+readonly` (or just `readonly`) adds it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What does the `Exclude<UnionType, ExcludedMembers>` utility type do?",
    "options": [
      "Removes properties from an object type.",
      "Constructs a type by excluding `ExcludedMembers` from `UnionType`.",
      "Sets all properties in `UnionType` to optional.",
      "Extracts the type of a nested property."
    ],
    "answer": "Constructs a type by excluding `ExcludedMembers` from `UnionType`.",
    "explanation": "`Exclude` filters a Union Type by removing any constituent types that are assignable to `ExcludedMembers`. It does not work on object properties directly (that would be `Omit`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In the context of Template Literal Types, what does `type EventName<T extends string> = \\`on\\${Capitalize<T>}\\`` produce for `EventName<'click'>`?",
    "options": [
      "`'onClick'`",
      "`'onclick'`",
      "`'On_click'`",
      "`'ONCLICK'`"
    ],
    "answer": "`'onClick'`",
    "explanation": "The `Capitalize` intrinsic type converts the first character of a string literal type to uppercase. Therefore, `'click'` becomes `'Click'`, and the template prepends `'on'`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the result of `type T = readonly string[]`?",
    "options": [
      "An array of strings that cannot have elements reassigned.",
      "An array reference that cannot be reassigned, but elements can be modified.",
      "An alias for `const string[]`.",
      "A tuple type."
    ],
    "answer": "An array of strings that cannot have elements reassigned.",
    "explanation": "Applying the `readonly` modifier to an array type prevents modifying the array's elements (e.g., `push`, `pop`, or index assignment) at runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which keyword is used to assert that a value is not `null` or `undefined` in the type system?",
    "options": [
      "`!` (Non-null assertion)",
      "`?` (Optional chaining)",
      "`??` (Nullish coalescing)",
      "`!!` (Double bang)"
    ],
    "answer": "`!` (Non-null assertion)",
    "explanation": "The postfix `!` operator tells the compiler to assume the value is not `null` or `undefined`. `?` accesses properties safely, and `??` provides a default value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the result of `type T = Parameters<(a: number, b: string) => void>`?",
    "options": [
      "`[number, string]`",
      "`number | string`",
      "`{ a: number; b: string; }`",
      "`void`"
    ],
    "answer": "`[number, string]`",
    "explanation": "The `Parameters` utility type extracts the parameter types of a function type into a tuple. It preserves the order and types of the arguments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which utility type creates a new type with all properties of `T` set to `required` (removing optional modifiers)?",
    "options": [
      "`Required<T>`",
      "`NonNullable<T>`",
      "`Assert<T>`",
      "`Strict<T>`"
    ],
    "answer": "`Required<T>`",
    "explanation": "`Required<T>` constructs a type consisting of all properties of `T` set to required, useful for reverting a `Partial` type or an interface with optional properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "How does TypeScript treat `interface A { x: number }` and `interface A { y: string }` in the same scope?",
    "options": [
      "A compilation error due to duplicate identifier.",
      "The second interface overwrites the first.",
      "They are merged into `interface A { x: number; y: string; }`.",
      "They are treated as separate entities based on declaration order."
    ],
    "answer": "They are merged into `interface A { x: number; y: string; }`.",
    "explanation": "TypeScript interfaces support declaration merging. Multiple declarations with the same name are aggregated into a single definition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is the purpose of `infer R` within a conditional type `T extends (...args: any[]) => infer R ? R : any`?",
    "options": [
      "To define a generic constraint for `T`.",
      "To infer the return type of the function `T`.",
      "To check if `T` is a function.",
      "To capture the arguments of `T`."
    ],
    "answer": "To infer the return type of the function `T`.",
    "explanation": "The `infer` keyword introduces a type variable that TypeScript infers from the `extends` clause. Here, `R` captures the return type of the function type `T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What distinguishes `enum` from `const enum`?",
    "options": [
      "`const enum` members are typed as strings.",
      "`const enum` members are inlined at use sites and generate no runtime code.",
      "`enum` cannot have computed members.",
      "`const enum` is accessible at runtime."
    ],
    "answer": "`const enum` members are inlined at use sites and generate no runtime code.",
    "explanation": "A `const enum` is completely erased during compilation, and its values are inlined where used. A standard `enum` generates a real object map at runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What does the `as const` assertion do to an object literal?",
    "options": [
      "It casts the object to the `any` type.",
      "It makes all properties readonly and infers literal types for values.",
      "It prevents the object from being extended.",
      "It checks for deep equality."
    ],
    "answer": "It makes all properties readonly and infers literal types for values.",
    "explanation": "The `as const` assertion creates an immutable expression, widening the type to the most specific literal representation (e.g., `'hello'` instead of `string`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which syntax correctly implements a type guard for `Fish`?",
    "options": [
      "`function isFish(pet: Fish | Bird): pet is Fish`",
      "`function isFish(pet: Fish | Bird): Fish`",
      "`function isFish(pet: Fish | Bird): boolean`",
      "`function isFish(pet: Fish | Bird): typeof Fish`"
    ],
    "answer": "`function isFish(pet: Fish | Bird): pet is Fish`",
    "explanation": "The syntax `parameterName is Type` is a type predicate. It tells the compiler that if the function returns true, the variable passed in is of the specified type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the output of `type T = 'a' | 'b' extends 'a' ? true : false`?",
    "options": [
      "`true`",
      "`false`",
      "`true | false`",
      "`never`"
    ],
    "answer": "`false`",
    "explanation": "This conditional type checks if the union `'a' | 'b'` is assignable to `'a'`. It is not (because 'b' is included), so the result is the false branch (`false`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What does the `NonNullable<T>` utility type do?",
    "options": [
      "It removes `null` and `undefined` from `T`.",
      "It ensures `T` is not `void`.",
      "It converts `T` to `any` if it is null.",
      "It checks for null at runtime."
    ],
    "answer": "It removes `null` and `undefined` from `T`.",
    "explanation": "`NonNullable` constructs a type by excluding `null` and `undefined` from the provided type `T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "In a mapped type `type Mapped<T> = { [K in keyof T]: T[K] }`, what is the result if `T` is a generic constraint?",
    "options": [
      "A type exactly equal to `T`",
      "A type with properties identical to `T` but with potentially different modifiers",
      "A type that removes the optional modifier",
      "A shallow copy of `T`'s structure"
    ],
    "answer": "A type exactly equal to `T`",
    "explanation": "Without modifiers (like `?` or `readonly`), a mapped type iterating over `keyof T` and returning `T[K]` results in a type homomorphic to `T` (same shape).",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the `Omit<Type, Keys>` utility type equivalent to, in terms of `Pick` and `Exclude`?",
    "options": [
      "`Pick<Type, Exclude<keyof Type, Keys>>`",
      "`Exclude<Pick<Type, Keys>, never>`",
      "`Pick<Type, Keys>`",
      "`Partial<Exclude<Type, Keys>>`"
    ],
    "answer": "`Pick<Type, Exclude<keyof Type, Keys>>`",
    "explanation": "To `Omit` keys, you first calculate the set of keys you want to keep (`Exclude` the unwanted keys from `all keys`), then `Pick` those properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What does `ThisType<T>` marker interface do?",
    "options": [
      "It statically forces the type of `this` within the object to be `T`.",
      "It casts the object to type `T`.",
      "It ensures `T` has no circular references.",
      "It creates a proxy for `this` binding at runtime."
    ],
    "answer": "It statically forces the type of `this` within the object to be `T`.",
    "explanation": "`ThisType<T>` does not transform the type; it serves as a hint to the compiler to infer `this` as type `T` inside methods of the object literal it decorates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How can you type an object that ensures specific keys exist, but allows any other string key of a specific type?",
    "options": [
      "Using an index signature alongside named properties.",
      "Using the `Any` type for properties.",
      "Using `Partial` combined with `Record`.",
      "TypeScript does not allow mixing fixed and dynamic properties."
    ],
    "answer": "Using an index signature alongside named properties.",
    "explanation": "You can define specific properties explicitly (e.g., `id: number`) and add an index signature (e.g., `[key: string]: any`) to allow additional properties. Note that the additional type usually must be compatible with the specific types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the behavior of `type P1 = Promise<string> extends Promise<infer T> ? T : never`?",
    "options": [
      "`T` resolves to `string`",
      "`T` resolves to `Promise<string>`",
      "It results in `never`",
      "It causes a circular reference error"
    ],
    "answer": "`T` resolves to `string`",
    "explanation": "The `infer` keyword infers the type argument `T` of the Promise. Since `Promise<string>` matches `Promise<infer T>`, `T` becomes `string`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What does `InstanceType<T>` return?",
    "options": [
      "The type of the instance created by a class constructor type `T`.",
      "The constructor function type `T`.",
      "The static methods of class `T`.",
      "The prototype of class `T`."
    ],
    "answer": "The type of the instance created by a class constructor type `T`.",
    "explanation": "`InstanceType` extracts the instance type of a constructor function type. If `T` is `typeof MyClass`, `InstanceType<T>` is the type of an object created via `new MyClass()`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which statement accurately describes function overloads in TypeScript?",
    "options": [
      "The implementation signature must be compatible with all overload signatures.",
      "The implementation signature is visible to callers.",
      "Only one overload signature is permitted.",
      "The implementation signature must match the first overload exactly."
    ],
    "answer": "The implementation signature must be compatible with all overload signatures.",
    "explanation": "The implementation signature is the actual function code and is hidden from the public API. It must be generic enough to handle all specific overload signatures defined above it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the type of `const arr = [1, 'hello']`?",
    "options": [
      "`(number | string)[]`",
      "`[number, string]`",
      "`any[]`",
      "`[string, number]`"
    ],
    "answer": "`(number | string)[]`",
    "explanation": "TypeScript infers this as an array of mixed types unless a specific tuple declaration is used or `as const` is applied. It widens the types to `number` and `string` rather than literals `1` and `'hello'`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "How do you enforce strict null checks for a specific variable without changing global `strictNullChecks`?",
    "options": [
      "By using a Type Predicate.",
      "By using the `NonNullable` utility type manually.",
      "By declaring the variable with `!`.",
      "You cannot; strict null checks are global."
    ],
    "answer": "By using the `NonNullable` utility type manually.",
    "explanation": "While `strictNullChecks` is a compiler flag, you can locally enforce a type to exclude null/undefined using `NonNullable` or unions like `string | undefined` manually.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the result of `type T = Record<string, number>`?",
    "options": [
      "An object type with string keys and number values.",
      "A Map type.",
      "A string literal type.",
      "An array of numbers."
    ],
    "answer": "An object type with string keys and number values.",
    "explanation": "`Record<K, T>` constructs an object type whose property keys are `K` and whose property values are `T`. `Record<string, number>` creates a dictionary-like object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the purpose of `declare` keyword in TypeScript?",
    "options": [
      "To create a variable that exists only in type definitions, not runtime.",
      "To declare a variable that cannot be changed.",
      "To force a type cast.",
      "To export a module."
    ],
    "answer": "To create a variable that exists only in type definitions, not runtime.",
    "explanation": "`declare` tells the compiler that a variable (type, function, module) exists elsewhere (ambient context), preventing code generation for it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which modifier is required in a mapped type to remove an optional (`?`) modifier from the original type?",
    "options": [
      "`-?`",
      "`+?`",
      "`readonly`",
      "`-readonly`"
    ],
    "answer": "`-?`",
    "explanation": "Just as `+?` (or `?`) adds optionality, the `-?` prefix in a mapped type removes the optional modifier from the original property keys.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Given `type Result = MyType extends OtherType ? true : false;`, how do you prevent distributivity over unions?",
    "options": [
      "Wrap the check type in `[]`",
      "Wrap the check type in `()`",
      "Use `Exclude`",
      "Use `infer`"
    ],
    "answer": "Wrap the check type in `[]`",
    "explanation": "Conditional types distribute over naked type parameters. To disable this behavior, wrap the checked type in a tuple, e.g., `[MyType] extends [OtherType]`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What is the behavior of a conditional type `T extends U ? X : Y` when `T` is a union type `A | B`?",
    "options": [
      "The condition is checked against the whole union `(A | B) extends U`",
      "The conditional type distributes over the union, becoming `(A extends U ? X : Y) | (B extends U ? X : Y)`",
      "The type resolves to `never` because unions cannot be used in conditional types",
      "The type resolves to `Y` by default to prevent type widening"
    ],
    "answer": "The conditional type distributes over the union, becoming `(A extends U ? X : Y) | (B extends U ? X : Y)`",
    "explanation": "Distributive conditional types automatically distribute over naked type parameters in unions. This allows individual mapping of union members, whereas wrapping the check in `T extends any ? ...` disables distribution.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In TypeScript mapped types, what is the purpose of the `as` clause during key remapping?",
    "options": [
      "To cast the resulting value type to a string",
      "To filter or transform the keys of the mapped type",
      "To enforce that the resulting type is a class",
      "To explicitly mark the property as optional"
    ],
    "answer": "To filter or transform the keys of the mapped type",
    "explanation": "The `as` clause allows for template literal types or conditional types to be applied to keys, enabling renaming (e.g., `get${Capitalize<K>}`) or filtering (e.g., returning `never` to exclude a key).",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which utility type construct allows you to extract the type of the `this` parameter within a function or method?",
    "options": [
      "ExtractThis",
      "NoThis",
      "ThisType",
      "TypeOfThis"
    ],
    "answer": "ThisType",
    "explanation": "`ThisType<T>` does not transform a type but serves as a marker for an object literal to signal to TypeScript that `this` inside its methods should refer to `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "How does the `Omit<Type, Keys>` utility type work?",
    "options": [
      "It iterates over all keys of `Type` and sets the specified `Keys` to `undefined`",
      "It constructs a type by picking all properties from `Type` and then removing the specified `Keys`",
      "It creates a new type excluding the prototype chain of `Type`",
      "It deletes the properties at runtime from instances of `Type`"
    ],
    "answer": "It constructs a type by picking all properties from `Type` and then removing the specified `Keys`",
    "explanation": "`Omit` is implemented as `Pick<T, Exclude<keyof T, K>>`. It effectively selects all properties and then removes the ones specified in the second argument.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When using the `infer` keyword in conditional types, what happens if the type extends multiple potential structures?",
    "options": [
      "It infers a union of all possible types that satisfy the condition",
      "It infers the first matching type only",
      "It throws a compilation error due to ambiguity",
      "It defaults to `unknown`"
    ],
    "answer": "It infers a union of all possible types that satisfy the condition",
    "explanation": "When `infer R` is used in a condition that matches multiple parts of a union (e.g., `T extends Array<infer R>`), `R` resolves to a union of the inferred element types.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the result of using `keyof` on a type that has an index signature (e.g., `{ [k: string]: number }`)?",
    "options": [
      "It returns `string | number`",
      "It returns `string` only",
      "It returns `number` only",
      "It returns `any` because index signatures make keys unpredictable"
    ],
    "answer": "It returns `string | number`",
    "explanation": "For a type with a string index signature, `keyof` returns `string | number`. This is because JavaScript object keys are always coerced to strings, effectively allowing number access as well.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which mechanism allows TypeScript to infer `never` for a generic type parameter when no candidate matches in a conditional type check?",
    "options": [
      "Type pruning",
      "Union elimination",
      "Distributive conditional types",
      "Non-distributive conditional types"
    ],
    "answer": "Distributive conditional types",
    "explanation": "In distributive conditional types, if a member of a union does not satisfy the `extends` constraint in the true branch, that member is effectively replaced by `never`, removing it from the final union.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the primary difference between `unknown` and `any`?",
    "options": [
      "`any` allows arbitrary assignments but forces type checking before usage",
      "`unknown` is the top type that forces type checking before arbitrary operations, while `any` disables checking",
      "`unknown` is strictly for objects, while `any` is for primitives",
      "There is no difference; they are aliases for each other"
    ],
    "answer": "`unknown` is the top type that forces type checking before arbitrary operations, while `any` disables checking",
    "explanation": "`unknown` is type-safe (the top type), requiring narrowing to perform actions. `any` effectively turns off the type system, allowing any operation without error.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What does the `Extract<Type, Union>` utility type accomplish?",
    "options": [
      "It extracts the runtime value of the property from the object",
      "It constructs a type by extracting from `Type` all union members that are assignable to `Union`",
      "It removes the specified `Union` members from `Type`",
      "It extracts the prototype methods of a class"
    ],
    "answer": "It constructs a type by extracting from `Type` all union members that are assignable to `Union`",
    "explanation": "`Extract<T, U>` filters `T` to only include types that are present in `Union`, acting as the opposite of `Exclude`.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "How can you achieve Nominal Typing in TypeScript, which is structurally typed by default?",
    "options": [
      "Using the `interface` keyword exclusively",
      "Adding a private `brand` property using a unique symbol and intersection types",
      "Using the `final` keyword on classes",
      "Declaring types with the `nominal` keyword"
    ],
    "answer": "Adding a private `brand` property using a unique symbol and intersection types",
    "explanation": "TypeScript uses structural typing, but you can simulate nominal typing by adding a unique, un-mappable property (a brand) to a type so it cannot be assigned to a similar type without that brand.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the result of the `Parameters<T>` utility type when `T` is not a function type?",
    "options": [
      "It returns `unknown`",
      "It returns `never`",
      "It returns an empty tuple `[]`",
      "It causes a compile-time error"
    ],
    "answer": "It returns `never`",
    "explanation": "If `T` does not resolve to a function type (or a tuple/function constructor), `Parameters<T`> results in `never`, as parameters cannot be extracted from non-functions.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What characterizes a 'Type Guard' function in TypeScript?",
    "options": [
      "It is a function that throws an error if a type is incorrect",
      "It is a function that returns a boolean and has a return type predicate of the form `arg is Type`",
      "It is a class method marked `protected`",
      "It is a generic function that uses `extends` to constrain types"
    ],
    "answer": "It is a function that returns a boolean and has a return type predicate of the form `arg is Type`",
    "explanation": "A type guard performs a runtime check but uses the `arg is Type` syntax to inform the compiler to narrow the type within the scope of the `if` block.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the output of `Uppercase<'foo'>` in the TypeScript type system?",
    "options": [
      "'FOO'",
      "'foo' (String types are immutable)",
      "`Uppercase<string>` (It only works on generic strings)",
      "Error: 'foo' is a literal type and cannot be manipulated"
    ],
    "answer": "'FOO'",
    "explanation": "Template Literal Types include intrinsic string manipulation types like `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize` which transform string literal types.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In a mapped type `{ [P in keyof T]: T[P] }`, how do you make specific properties optional based on a condition?",
    "options": [
      "By adding `?` after `P` in the iteration",
      "By using a conditional type in the value position: `{ [P in keyof T]: Condition ? T[P] : never }`",
      "By adding `-?` modifier",
      "By using `Partial<T>` inside the mapping"
    ],
    "answer": "By adding `?` after `P` in the iteration",
    "explanation": "The optional modifier is applied to the key mapping. To do this conditionally, one might use key remapping with `as`, e.g., `[P in keyof T as P extends Key ? P : never]?: T[P]`.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the definition of a 'Branded Property' in TypeScript?",
    "options": [
      "A property decorated with `@brand`",
      "A property added to a type via intersection that utilizes a `unique symbol` to ensure uniqueness",
      "A property that holds the brand name of the product",
      "A public static property on a class"
    ],
    "answer": "A property added to a type via intersection that utilizes a `unique symbol` to ensure uniqueness",
    "explanation": "Branding creates a phantom type by intersecting with a type containing a unique symbol property, making structurally identical types distinct.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which type operator is used to suppress the automatic distribution of a conditional type over a union?",
    "options": [
      "Wrapping the check type in `[]` (array)",
      "Wrapping the check type in `{}` (object)",
      "Using the `nodistribute` keyword",
      "Using the `unique` keyword"
    ],
    "answer": "Wrapping the check type in `[]` (array)",
    "explanation": "If `T` is wrapped in a tuple (e.g., `[T] extends U`), the conditional type treats `T` as a single unit rather than distributing over the union.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What does the `NonNullable<T>` utility type do?",
    "options": [
      "It removes `null` and `undefined` from `T`",
      "It ensures `T` is not `void`",
      "It converts `T` to `any` if it is null",
      "It checks at runtime if the value is null"
    ],
    "answer": "It removes `null` and `undefined` from `T`",
    "explanation": "`NonNullable` is a helper type that constructs a type excluding `null` and `undefined` from the given type `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "How does TypeScript handle the variance of function parameters when `strictFunctionTypes` is enabled?",
    "options": [
      "Parameters are covariant (allows widening)",
      "Parameters are bivariant (allows widening and narrowing)",
      "Parameters are contravariant (allows narrowing)",
      "Parameters are invariant"
    ],
    "answer": "Parameters are contravariant (allows narrowing)",
    "explanation": "Under `strictFunctionTypes`, parameters are checked contravariantly. However, method parameters remain bivariant for backward compatibility reasons.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the result of `keyof { [x: string]: number }`?",
    "options": [
      "string",
      "number",
      "string | number",
      "any"
    ],
    "answer": "string | number",
    "explanation": "When an index signature is of type `string`, `keyof` includes both `string` and `number` because `number` is always assignable to `string` in object access.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How do you implement a Recursive Type in TypeScript?",
    "options": [
      "By using the `recurse` keyword",
      "By having an interface or type alias directly or indirectly reference itself",
      "By using the `Recursive` utility type",
      "By defining a class that inherits from itself"
    ],
    "answer": "By having an interface or type alias directly or indirectly reference itself",
    "explanation": "TypeScript allows recursive type definitions (e.g., `type Json = string | number | boolean | null | Json[] | { [key: string]: Json }`) to model tree-like or nested structures.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the purpose of the `satisfies` operator introduced in TypeScript 4.9?",
    "options": [
      "To cast a value to a specific type regardless of compatibility",
      "To validate that an expression matches a type without changing the type of the expression",
      "To throw an error at runtime if a value does not satisfy a contract",
      "To implement interfaces in classes"
    ],
    "answer": "To validate that an expression matches a type without changing the type of the expression",
    "explanation": "Unlike type assertions, `satisfies` ensures the value matches the specific type but retains the specific inferred type of the value for better precision in subsequent operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which utility type constructs a type by excluding `null` and `undefined` from a type?",
    "options": [
      "ExcludeNull",
      "NonNullable",
      "NotNull",
      "StrictNull"
    ],
    "answer": "NonNullable",
    "explanation": "`NonNullable` acts as a utility to filter out `null` and `undefined` from a given type, often used to enforce the presence of a value.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the utility type used to extract the return type of a function type `T`?",
    "options": [
      "ReturnType",
      "ReturnOf",
      "ExtractReturn",
      "UnwrapReturn"
    ],
    "answer": "ReturnType",
    "explanation": "`ReturnType` takes a function type and extracts the type of the value returned by that function, inferred via conditional type logic on the `infer R` inside the function signature.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "When using template literal types, how do you create a union of all combinations of two string literal unions?",
    "options": [
      "`Combination<A, B>`",
      "`A | B`",
      "`${A | B}`",
      "`${A}${B}`"
    ],
    "answer": "`${A}${B}`",
    "explanation": "Template literal types distribute over unions. If `A` is 'x'|'y' and `B` is '1'|'2', `` `${A}${B}` `` produces 'x1' | 'x2' | 'y1' | 'y2'.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the effect of the `-readonly` modifier in a mapped type?",
    "options": [
      "It removes the `readonly` status from properties in the target type",
      "It makes properties non-optional",
      "It deletes the property from the type",
      "It prevents the property from being deleted at runtime"
    ],
    "answer": "It removes the `readonly` status from properties in the target type",
    "explanation": "Modifiers like `+readonly`/`-readonly` and `+?`/`-?` allow you to add or remove immutability and optionality in mapped types.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the behavior of `Record<Keys, Type>` if `Keys` is `never`?",
    "options": [
      "It creates an empty object type `{}`",
      "It creates a type accepting any string key",
      "It results in a compiler error",
      "It returns `never`"
    ],
    "answer": "It creates an empty object type `{}`",
    "explanation": "Since no property can be keyed by `never`, the resulting object type has no properties.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "How does TypeScript treat excess property checks on object literals assigned to variables with specific types?",
    "options": [
      "They are ignored for all object types",
      "They are performed when assigning to a variable with a concrete type, but not when passing to a function",
      "They are only performed if the object literal is assigned directly to a variable with the target type and the target type has no index signature",
      "They are performed only at runtime"
    ],
    "answer": "They are only performed if the object literal is assigned directly to a variable with the target type and the target type has no index signature",
    "explanation": "Excess property checking is a specific feature for fresh object literals to catch typos; it does not apply to variables that are already typed or passed through references.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the output of `ReturnType<() => void>`?",
    "options": [
      "undefined",
      "void",
      "any",
      "never"
    ],
    "answer": "void",
    "explanation": "The return type of a function returning nothing is `void`. While `undefined` is the runtime value often returned, the type is `void`.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What does the `Required` utility type do?",
    "options": [
      "It makes all optional properties in a type required, removing the `?` modifier",
      "It makes the object non-nullable",
      "It enforces that the value cannot be `undefined` at runtime",
      "It checks if all properties are present at runtime"
    ],
    "answer": "It makes all optional properties in a type required, removing the `?` modifier",
    "explanation": "`Required` creates a new type where every property of the input type is set to required, transforming `T?` into `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In the context of `infer` declarations, which syntax correctly captures the `this` type of a function?",
    "options": [
      "type ThisType = T extends (this: infer U, ...args: any[]) => any ? U : unknown;",
      "type ThisType = T extends (infer U, ...args: any[]) => any ? U : unknown;",
      "type ThisType = T extends (...args: any[]) => infer U ? U : unknown;",
      "type ThisType = infer this T;"
    ],
    "answer": "type ThisType = T extends (this: infer U, ...args: any[]) => any ? U : unknown;",
    "explanation": "To infer `this`, you must target the fake `this` parameter in the function signature position using `this: infer U`.",
    "difficulty": "Advanced"
  }
]