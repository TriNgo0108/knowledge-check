[
  {
    "id": 1,
    "question": "What is the output of `console.log(typeof null)` in JavaScript?",
    "options": [
      "\"null\"",
      "\"undefined\"",
      "\"object\"",
      "\"number\""
    ],
    "answer": "\"object\"",
    "explanation": "JavaScript returns \"object\" for `typeof null` due to a legacy bug in the original language implementation where type tags were used and null had the tag for objects. This behavior is preserved for backwards compatibility.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which of the following values is strictly NOT equal to itself in JavaScript?",
    "options": [
      "NaN",
      "undefined",
      "null",
      "Infinity"
    ],
    "answer": "NaN",
    "explanation": "NaN (Not-a-Number) is the only value in JavaScript that is not reflexively equal to itself (i.e., `NaN === NaN` is false). This is defined by the IEEE 754 floating-point standard.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What specific keyword behavior prevents a variable from being accessed before its declaration line within the current block scope?",
    "options": [
      "var",
      "let",
      "global",
      "static"
    ],
    "answer": "let",
    "explanation": "`let` and `const` variables are placed in a Temporal Dead Zone (TDZ) from the start of the block until the declaration is processed. Accessing them before the declaration line throws a ReferenceError.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary difference between `==` and `===` in JavaScript?",
    "options": [
      "`==` compares values, while `===` compares memory addresses",
      "`==` performs type coercion, while `===` checks for strict equality",
      "`==` is for objects, while `===` is for primitives",
      "`==` checks value and type, while `===` checks only value"
    ],
    "answer": "`==` performs type coercion, while `===` checks for strict equality",
    "explanation": "The abstract equality operator (`==`) attempts to convert operands to the same type before comparing. The strict equality operator (`===`) returns false if the types are different.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "When using `const` to declare an object, which operation is strictly forbidden?",
    "options": [
      "Adding a new property to the object",
      "Deleting a property from the object",
      "Reassigning the variable identifier to a new object",
      "Modifying the value of an existing property"
    ],
    "answer": "Reassigning the variable identifier to a new object",
    "explanation": "`const` creates an immutable binding to the memory reference. While the contents of the object (properties) can be mutated, the variable itself cannot be reassigned to point to a new memory address.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which array method iterates over elements and returns a new array with the results of calling a provided function on every element?",
    "options": [
      "Array.forEach()",
      "Array.map()",
      "Array.reduce()",
      "Array.filter()"
    ],
    "answer": "Array.map()",
    "explanation": "Array.map() creates a new array populated with the results of calling a provided function on every element in the calling array. forEach() returns undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the value of `this` inside an arrow function defined in the global scope?",
    "options": [
      "The global window object (in browsers)",
      "undefined",
      "The arrow function itself",
      "The enclosing lexical context's `this`"
    ],
    "answer": "The enclosing lexical context's `this`",
    "explanation": "Arrow functions do not have their own `this` context; they lexically bind `this` from the parent scope at the time they are defined.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What will `console.log(1 + \"1\")` output?",
    "options": [
      "2",
      "\"11\"",
      "NaN",
      "undefined"
    ],
    "answer": "\"11\"",
    "explanation": "The `+` operator triggers type coercion to string when one operand is a string. It concatenates the number 1 with the string \"1\".",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which statement correctly converts a JSON string into a JavaScript object?",
    "options": [
      "JSON.stringify()",
      "JSON.convert()",
      "JSON.parse()",
      "JSON.toObject()"
    ],
    "answer": "JSON.parse()",
    "explanation": "JSON.parse() parses a JSON string, constructing the JavaScript value or object described by the string. JSON.stringify() does the opposite.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What behavior describes 'Variable Hoisting' for `var` declarations?",
    "options": [
      "Variables are moved to the top of the file and initialized to 0",
      "Declarations are processed before code execution, but assignments remain in place",
      "Variables are deleted if not used within 10ms",
      "Variables are converted to `const` at runtime"
    ],
    "answer": "Declarations are processed before code execution, but assignments remain in place",
    "explanation": "During the compilation phase, `var` declarations are moved to the top of their function or global scope. The variable is initialized as `undefined` until the assignment line is reached.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which loop construct ensures that the code block executes at least once?",
    "options": [
      "while",
      "do...while",
      "for",
      "for...of"
    ],
    "answer": "do...while",
    "explanation": "The `do...while` loop checks the condition *after* the code block executes. This guarantees the block runs at least one time, even if the condition is false initially.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the default return value of a function that does not explicitly return anything?",
    "options": [
      "null",
      "undefined",
      "0",
      "NaN"
    ],
    "answer": "undefined",
    "explanation": "In JavaScript, if a return statement is missing or empty, the function implicitly returns `undefined`.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the purpose of the `new` keyword when calling a constructor function?",
    "options": [
      "To create a new function scope",
      "To automatically add a property to the window object",
      "To create an object instance and link its prototype to the constructor's prototype",
      "To convert the function into a class"
    ],
    "answer": "To create an object instance and link its prototype to the constructor's prototype",
    "explanation": "`new` creates a new object, binds `this` to that object, sets the internal [[Prototype]] link, and returns the object if the function doesn't return an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which operator combines the properties of two or more objects into a new object?",
    "options": [
      "Object.merge()",
      "Object.assign()",
      "Object.combine()",
      "Object.append()"
    ],
    "answer": "Object.assign()",
    "explanation": "Object.assign() copies all enumerable own properties from one or more source objects to a target object, returning the modified target object.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What happens if you attempt to access an array index that does not exist (e.g., `arr[10]` on a length-2 array)?",
    "options": [
      "RangeError is thrown",
      "SyntaxError is thrown",
      "undefined is returned",
      "null is returned"
    ],
    "answer": "undefined is returned",
    "explanation": "JavaScript arrays are sparse objects; accessing an out-of-bounds index does not throw an error but returns `undefined`.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "In `async/await` syntax, what keyword pauses the execution of an async function until a Promise is settled?",
    "options": [
      "wait",
      "await",
      "pause",
      "yield"
    ],
    "answer": "await",
    "explanation": "The `await` operator pauses the execution of the async function, waiting for the Promise to resolve, and then resumes the function with the resolved value.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which method removes the last element from an array and returns that element?",
    "options": [
      "shift()",
      "pop()",
      "push()",
      "slice()"
    ],
    "answer": "pop()",
    "explanation": "Array.pop() removes the last element. shift() removes the first. push() adds to the end. slice() extracts a section.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What does the `finally` block in a `try...catch...finally` statement do?",
    "options": [
      "It executes only if an error occurs",
      "It executes only if no error occurs",
      "It executes after the try and catch blocks, regardless of the result",
      "It catches asynchronous errors thrown later"
    ],
    "answer": "It executes after the try and catch blocks, regardless of the result",
    "explanation": "The `finally` block contains code to run after the try and catch blocks finish, regardless of whether an exception was thrown or caught.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How do you check if a variable `x` is an Array?",
    "options": [
      "typeof x",
      "x instanceof Array only",
      "Array.isArray(x)",
      "x.type === 'array'"
    ],
    "answer": "Array.isArray(x)",
    "explanation": "Array.isArray() is the most robust way to check if a value is an array, especially across different execution contexts (like iframes). `typeof` returns 'object'.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the output of `console.log(2 ** 3)`?",
    "options": [
      "6",
      "8",
      "9",
      "\"23\""
    ],
    "answer": "8",
    "explanation": "The `**` operator is the exponentiation operator. It calculates the base (2) to the power of the exponent (3), resulting in 8.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which of the following is NOT a valid JavaScript primitive type?",
    "options": [
      "Boolean",
      "Symbol",
      "Array",
      "BigInt"
    ],
    "answer": "Array",
    "explanation": "Arrays are Objects in JavaScript, not primitives. Primitives include String, Number, BigInt, Boolean, Undefined, Symbol, and Null.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the result of `true && \"Hello\"`?",
    "options": [
      "true",
      "false",
      "\"Hello\"",
      "undefined"
    ],
    "answer": "\"Hello\"",
    "explanation": "The `&&` (AND) operator returns the value of the first falsy operand; if all are truthy, it returns the last operand. Since both `true` and \"Hello\" are truthy, \"Hello\" is returned.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which statement best describes 'closures' in JavaScript?",
    "options": [
      "A function that has no access to parent variables",
      "A function bundled with its lexical environment",
      "A method to close a database connection",
      "The process of garbage collection"
    ],
    "answer": "A function bundled with its lexical environment",
    "explanation": "A closure allows a function to access variables from an outer function that has already returned, preserving the scope chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What will `Boolean(0)` and `Boolean(\"\")` return?",
    "options": [
      "true and true",
      "false and true",
      "false and false",
      "true and false"
    ],
    "answer": "false and false",
    "explanation": "In JavaScript, `0`, `null`, `undefined`, `NaN`, and empty strings (`\"\"`) are falsy values. The Boolean() constructor converts them to false.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which object represents the global scope in a Node.js module?",
    "options": [
      "window",
      "global",
      "this",
      "root"
    ],
    "answer": "global",
    "explanation": "In Node.js, the global object is `global`. In browsers, it is `window`. `this` behavior varies depending on strict mode and module type.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the correct syntax to import a specific function named `calculate` from a file `math.js`?",
    "options": [
      "import calculate from './math.js'",
      "import { calculate } from './math.js'",
      "require { calculate } from './math.js'",
      "include './math.js'"
    ],
    "answer": "import { calculate } from './math.js'",
    "explanation": "Named imports require curly braces. `import { calculate }` specifically extracts the named export `calculate` from the module.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which array method returns the index of the first element that satisfies a condition, or -1 if none is found?",
    "options": [
      "find()",
      "findIndex()",
      "indexOf()",
      "search()"
    ],
    "answer": "findIndex()",
    "explanation": "findIndex() executes a callback function once for each array element until it finds one where the callback returns a truthy value, then returns that index.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What happens when you call a Promise-based function without using `await` or `.then()`?",
    "options": [
      "The function executes synchronously and returns the result",
      "The function call returns a Promise object in a pending state",
      "The program crashes with a SyntaxError",
      "The Promise is automatically resolved by the garbage collector"
    ],
    "answer": "The function call returns a Promise object in a pending state",
    "explanation": "Calling an `async` function returns a Promise. Without `await` or `.then()`, the code continues executing synchronously, and the Promise settles in the background.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which method is used to prevent the default action of an event (e.g., stopping a form submission)?",
    "options": [
      "event.stopPropagation()",
      "event.stopImmediatePropagation()",
      "event.preventDefault()",
      "event.cancel()"
    ],
    "answer": "event.preventDefault()",
    "explanation": "preventDefault() cancels the event if it is cancelable, meaning that the default action that belongs to the event will not occur.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the result of `[1, 2, 3] === [1, 2, 3]`?",
    "options": [
      "true",
      "false",
      "undefined",
      "TypeError"
    ],
    "answer": "false",
    "explanation": "In JavaScript, Objects (including Arrays) are compared by reference, not value. These are two distinct array instances in memory, so they are not equal.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What feature allows you to extract values from arrays or properties from objects into distinct variables?",
    "options": [
      "Spreading",
      "Destructuring",
      "Parsing",
      "Mapping"
    ],
    "answer": "Destructuring",
    "explanation": "Destructuring assignment syntax unpacks values from arrays or properties from objects into distinct variables using a syntax that mirrors their construction.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which parameter syntax allows a function to accept an indefinite number of arguments as an array?",
    "options": [
      "default parameters",
      "rest parameters (...args)",
      "spread syntax",
      "arguments object"
    ],
    "answer": "rest parameters (...args)",
    "explanation": "The rest parameter syntax (`...args`) allows a function to accept an indefinite number of arguments as an array, whereas the `arguments` object is an array-like object.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What does the 'Strict Mode' directive (`\"use strict\";`) primarily enforce?",
    "options": [
      "Faster execution by V8",
      "Conversion of silent errors (bad syntax) into thrown errors",
      "Automatic semicolon insertion",
      "Allowing the use of reserved keywords as variable names"
    ],
    "answer": "Conversion of silent errors (bad syntax) into thrown errors",
    "explanation": "Strict mode catches common coding bloopers, throwing errors for unsafe actions (like assigning to non-writable properties) that were previously silent failures.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In the V8 engine, what specific role does the Ignition interpreter play in the compilation pipeline?",
    "options": [
      "It generates optimized machine code directly from JavaScript source.",
      "It compiles JavaScript into bytecode to enable fast startup and low memory footprint.",
      "It performs On-Stack Replacement (OSR) to optimize running loop bodies.",
      "It manages the generational garbage collection of heap objects."
    ],
    "answer": "It compiles JavaScript into bytecode to enable fast startup and low memory footprint.",
    "explanation": "Ignition is V8's interpreter that generates bytecode, allowing faster startup and lower memory overhead than full baseline compilation. TurboFan handles the generation of optimized machine code, and the garbage collector manages memory, not bytecode generation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 35,
    "question": "How does the JavaScript event loop prioritize the processing of Microtasks versus Macrotasks (Timer callbacks)?",
    "options": [
      "Microtasks and Macrotasks are processed in the order they were added to the queue.",
      "Macrotasks are processed before Microtasks to ensure UI responsiveness.",
      "The event loop drains the entire Microtask queue after each Macrotask execution.",
      "Microtasks are processed only when the call stack is completely empty of Macrotasks."
    ],
    "answer": "The event loop drains the entire Microtask queue after each Macrotask execution.",
    "explanation": "The event loop executes a single macrotask (e.g., a timer callback) and then immediately processes all available microtasks (e.g., Promises) before picking up the next macrotask. This ensures that Promise resolutions happen as soon as possible after the current operation completes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the primary consequence of 'starving the event loop' with recursive `Promise.then()` chains?",
    "options": [
      "The V8 garbage collector fails to reclaim memory, causing a heap crash.",
      "The call stack exceeds its maximum limit, throwing a RangeError.",
      "Macrotask processing (like I/O or rendering) is indefinitely delayed.",
      "The JavaScript engine automatically promotes the code to a separate thread."
    ],
    "answer": "Macrotask processing (like I/O or rendering) is indefinitely delayed.",
    "explanation": "Microtasks have higher priority than macrotasks. If a microtask chain recursively adds new microtasks, the event loop never drains the microtask queue, preventing it from picking up the next macrotask (I/O events, timers, or painting).",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In Node.js, which mechanism allows CPU-intensive JavaScript functions to be optimized mid-execution without restarting the function?",
    "options": [
      "On-Stack Replacement (OSR)",
      "Snippet Compilation",
      "Escape Analysis",
      "Hidden Class Transitions"
    ],
    "answer": "On-Stack Replacement (OSR)",
    "explanation": "OSR allows V8 (TurboFan) to switch from unoptimized bytecode to optimized machine code while a function is actively running, typically inside a long loop. Snippet compilation is for small regex or eval; Hidden Classes relate to object shapes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which statement accurately describes the 'Shallow Size' of a JavaScript object in a heap snapshot?",
    "options": [
      "The total size of the object including all objects it references.",
      "The memory retained by the object if no other objects exist.",
      "The size of the object's memory holder in bytes, excluding referenced objects.",
      "The size of the object after the garbage collector has run."
    ],
    "answer": "The size of the object's memory holder in bytes, excluding referenced objects.",
    "explanation": "Shallow size is the memory occupied by the object itself in memory. Retained size includes the shallow size plus the size of other objects kept alive only by this object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When comparing ES Modules (ESM) and CommonJS (CJS), how does the value of `module` differ regarding circular dependencies?",
    "options": [
      "CJS exports a live binding, while ESM exports a copy of the value.",
      "ESM exports a live binding, while CJS exports a copy of the value.",
      "Both CJS and ESM use live bindings, but ESM is asynchronous.",
      "Both systems fail immediately upon detecting a circular dependency."
    ],
    "answer": "ESM exports a live binding, while CJS exports a copy of the value.",
    "explanation": "ESM creates live bindings to the exported variables, meaning updates in the exporting module are reflected in the importing module. CJS requires the `module.exports` object, so importing a primitive creates a copy (though properties of an exported object reference remain live).",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In the context of V8 optimization, what is a 'Hidden Class' (also known as Map or Shape)?",
    "options": [
      "A class defined without a name in an anonymous function.",
      "An internal object structure tracking the layout of properties and memory offsets.",
      "A proprietary method to hide source code from the debugger.",
      "A collection of deprecated methods removed from the prototype chain."
    ],
    "answer": "An internal object structure tracking the layout of properties and memory offsets.",
    "explanation": "V8 creates Hidden Classes to track the object structure (property names and offsets). This allows the engine to optimize property access using inline caching, assuming objects with the same Hidden Class share the same memory layout.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What happens when `await` is used on a non-Promise value within an `async` function?",
    "options": [
      "It throws a TypeError immediately.",
      "It returns the value directly without suspending execution.",
      "It wraps the value in a resolved Promise and suspends execution.",
      "It blocks the main thread until the value is coerced."
    ],
    "answer": "It wraps the value in a resolved Promise and suspends execution.",
    "explanation": "The `await` keyword converts the operand into a Promise using `Promise.resolve()`. If the value is not a Promise, it is immediately resolved, but the execution is still suspended to re-enter the microtask queue, allowing other events to process.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which libuv thread pool phase handles file system operations (like `fs.readFile`) in Node.js?",
    "options": [
      "Poll Phase",
      "Check Phase",
      "Pending Callbacks Phase",
      "Thread Pool (managed outside the event loop phases)"
    ],
    "answer": "Thread Pool (managed outside the event loop phases)",
    "explanation": "File I/O and DNS lookups are offloaded to libuv's thread pool. The callback is queued in the 'Pending Callbacks' phase of the event loop only after the thread pool worker completes the task.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the specific behavior of the `queueMicrotask()` function compared to `Promise.resolve().then()`?",
    "options": [
      "`queueMicrotask` tasks run before Promise microtasks.",
      "`queueMicrotask` is a synchronous blocking call.",
      "`queueMicrotask` can throw an error if the queue is full, unlike Promises.",
      "There is no difference in scheduling priority; both add to the microtask queue."
    ],
    "answer": "There is no difference in scheduling priority; both add to the microtask queue.",
    "explanation": "Both `queueMicrotask()` and `Promise.then()` add a callback to the same microtask queue. The spec-defined difference is primarily semantic; `queueMicrotask` explicitly indicates a microtask intent without returning a Promise chain.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "How does V8's 'Generational Garbage Collection' (Orinoco) improve performance?",
    "options": [
      "By scanning the entire heap every time garbage collection runs.",
      "By separating objects into 'New' and 'Old' spaces and collecting the 'New' space more frequently.",
      "By moving all objects to the hard drive to free up RAM.",
      "By pausing the main thread indefinitely during full heap sweeps."
    ],
    "answer": "By separating objects into 'New' and 'Old' spaces and collecting the 'New' space more frequently.",
    "explanation": "The 'Generational Hypothesis' suggests most objects die young. By focusing collection efforts (Scavenger) on the New Space (Young Generation) where mortality is high, V8 minimizes expensive pauses associated with scanning the Old Space.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the output order of `console.log` statements when `process.nextTick` and `Promise.resolve().then` are called sequentially in Node.js?",
    "options": [
      "Promise callback runs first, then `nextTick` callback.",
      "`nextTick` callback runs first, then Promise callback.",
      "They run in the order they appear in the code.",
      "The order is non-deterministic due to thread racing."
    ],
    "answer": "`nextTick` callback runs first, then Promise callback.",
    "explanation": "In Node.js, `process.nextTick` has its own queue processed *after* the current operation completes but *before* the Microtask queue (Promises) and the next Event Loop phase.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which of the following best describes the 'Temporal Dead Zone' (TDZ) in relation to `let` and `const`?",
    "options": [
      "The period after a variable is deleted but before garbage collection.",
      "The scope between the start of a block and the point where the variable is declared, where accessing it throws a ReferenceError.",
      "The time delay between a `setTimeout` callback and its actual execution.",
      "A zone where variables are automatically coerced to `undefined`."
    ],
    "answer": "The scope between the start of a block and the point where the variable is declared, where accessing it throws a ReferenceError.",
    "explanation": "The TDZ starts at the beginning of the block scope and ends when the variable is declared. Accessing the variable within this zone prevents initialization before declaration, throwing a ReferenceError.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the output of `console.log(typeof null)` in JavaScript, and why is this technically the case?",
    "options": [
      "'null', because it is a primitive type.",
      "'undefined', because null represents the absence of value.",
      "'object', due to a legacy bug in V8's type tag system.",
      "'number', because null is evaluated as 0 in numeric contexts."
    ],
    "answer": "'object', due to a legacy bug in V8's type tag system.",
    "explanation": "In JavaScript, `typeof null` returns 'object'. This is a historical implementation bug where the type tag for null was all zeros, which corresponded to the type tag for objects in early ECMAScript standards.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When using `requestAnimationFrame` in a browser, when is the callback executed relative to the Event Loop?",
    "options": [
      "Immediately in the Microtask queue.",
      "Before the browser repaints, usually aligned with the display's refresh rate (60fps).",
      "After the browser repaints to capture user input.",
      "It uses a separate high-priority thread independent of the Event Loop."
    ],
    "answer": "Before the browser repaints, usually aligned with the display's refresh rate (60fps).",
    "explanation": "RAF callbacks are queued to run just before the 'Update the Rendering' step of the browser's event loop. This synchronizes logic execution with the screen refresh to ensure smooth animations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What distinguishes a `WeakMap` from a standard `Map` regarding garbage collection?",
    "options": [
      "WeakMap keys are weakly held, allowing the key object to be garbage collected if no other reference exists.",
      "WeakMap values are weakly held, allowing automatic memory cleanup.",
      "WeakMap is faster because it does not use hashing.",
      "WeakMap allows primitive values like strings as keys."
    ],
    "answer": "WeakMap keys are weakly held, allowing the key object to be garbage collected if no other reference exists.",
    "explanation": "In a `WeakMap`, references to key objects are 'weak', meaning they do not prevent garbage collection. If the key object is otherwise unreachable, it is removed from the WeakMap. Maps hold strong references.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In the V8 engine, what occurs during 'Deoptimization' (or 'Bailing Out')?",
    "options": [
      "The optimized machine code is discarded, and execution resumes in the interpreter (Ignition).",
      "The code is recompiled to use less memory at the cost of speed.",
      "The garbage collector runs immediately to free up heap space.",
      "The JavaScript engine pauses all execution to perform a 'Stop-The-World' snapshot."
    ],
    "answer": "The optimized machine code is discarded, and execution resumes in the interpreter (Ignition).",
    "explanation": "Deoptimization happens when an assumption made by the optimizing compiler (e.g., an object's shape) proves false. V8 must 'bail out' by discarding the optimized code and falling back to the slower, safer Ignition bytecode.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the primary purpose of the 'Call Stack' in the JavaScript runtime context?",
    "options": [
      "To store asynchronous callbacks waiting to be processed.",
      "To track the execution context of synchronous function calls.",
      "To manage the memory allocation for new objects.",
      "To prioritize microtasks over macrotasks."
    ],
    "answer": "To track the execution context of synchronous function calls.",
    "explanation": "The Call Stack is a LIFO (Last In, First Out) data structure that records where we are in the program. It pushes function calls when invoked and pops them when they return. Callbacks waiting for processing live in the Callback/Microtask Queues, not the stack.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does JavaScript's bitwise operator `>>` (Signed Right Shift) treat the left operand?",
    "options": [
      "It converts the operand to a 32-bit signed integer.",
      "It converts the operand to a 64-bit floating point number.",
      "It operates directly on the binary representation without conversion.",
      "It throws an error if the operand is not an integer."
    ],
    "answer": "It converts the operand to a 32-bit signed integer.",
    "explanation": "JavaScript bitwise operators convert operands to 32-bit integers (represented as two's complement) before performing operations. The result is also a standard JavaScript Number, but the operation happens within 32-bit constraints.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the result of `Promise.resolve(Promise.resolve(1)).then(console.log)`?",
    "options": [
      "Output: `Promise {<fulfilled>: 1}`",
      "Output: `1`",
      "Output: `undefined`",
      "SyntaxError"
    ],
    "answer": "Output: `1`",
    "explanation": "Promise flattening (assimilation) occurs when resolving a value that is a Promise. `Promise.resolve()` unwraps nested Promises recursively, so `then` receives the final fulfillment value, not the Promise object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Why is modifying a JavaScript object's 'shape' (adding/deleting properties) after initialization considered bad for performance in V8?",
    "options": [
      "It forces V8 to generate a new Hidden Class and triggers deoptimization of optimized code.",
      "It causes the object to be moved from the New Space to the Old Space immediately.",
      "It prevents the garbage collector from accessing the object.",
      "It increases the size of the object's shallow size beyond the 8MB limit."
    ],
    "answer": "It forces V8 to generate a new Hidden Class and triggers deoptimization of optimized code.",
    "explanation": "V8 relies on Hidden Classes for inline caching. Changing an object's property structure creates a transition to a new Hidden Class, invalidating previous optimizations and causing inline cache misses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which characteristic applies to the `delete` operator in JavaScript regarding object properties?",
    "options": [
      "It removes the property from the object but keeps the memory allocated until garbage collection.",
      "It physically reindexes the object, shifting subsequent properties.",
      "It removes the property and creates a 'Holey' Hidden Class, harming V8 optimization.",
      "It works on both object properties and variables declared with `let` or `const`."
    ],
    "answer": "It removes the property and creates a 'Holey' Hidden Class, harming V8 optimization.",
    "explanation": "While `delete` removes the property, V8 converts the object's internal Hidden Class to a 'dictionary' mode or a holey version, preventing the use of fast property access optimization. It does not shift indices (arrays are sparse).",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In a browser environment, which phase of the Event Loop does not exist in Node.js's libuv implementation?",
    "options": [
      "Timers",
      "Poll",
      "Update Rendering (Repaint)",
      "Check"
    ],
    "answer": "Update Rendering (Repaint)",
    "explanation": "Node.js is server-side and has no DOM. While libuv handles the loop phases (Timers, Pending Callbacks, Idle/Prepare, Poll, Check, Close Callbacks), the 'Update Rendering' step is specific to browser specifications (Blink/WebKit).",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the primary use of `Symbol.asyncIterator` in JavaScript?",
    "options": [
      "To define a method that allows an object to be iterated using the `for...of` loop.",
      "To enable asynchronous iteration of an object using the `for await...of` loop.",
      "To create a singleton object that is globally unique.",
      "To define a custom string tag for `Object.prototype.toString`."
    ],
    "answer": "To enable asynchronous iteration of an object using the `for await...of` loop.",
    "explanation": "The `Symbol.asyncIterator` symbol specifies the default AsyncIterator for an object. It is consumed by `for await...of`, allowing iteration over data that arrives asynchronously (like streams).",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "How does `setTimeout` with a delay of 0 milliseconds interact with the Event Loop?",
    "options": [
      "It executes the callback immediately, bypassing the queue.",
      "It places the callback in the Timers Queue, which is processed in the next iteration of the Event Loop.",
      "It places the callback in the Microtask Queue to be executed immediately.",
      "It guarantees execution within 0 milliseconds regardless of load."
    ],
    "answer": "It places the callback in the Timers Queue, which is processed in the next iteration of the Event Loop.",
    "explanation": "A delay of 0 does not mean instant execution. It means the callback is placed in the timer queue with the minimum delay possible (often 1ms clamping) and waits for the Event Loop to reach the Timers phase.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which `package.json` field takes precedence when determining if a file should be treated as an ES Module?",
    "options": [
      "`type` field at the top level.",
      "`main` field.",
      "`module` field.",
      "`exports` field."
    ],
    "answer": "`type` field at the top level.",
    "explanation": "The top-level `\"type\": \"module\"` flag tells Node.js to treat `.js` files as ES Modules. The `exports` field defines entry points, and `main` is for CJS, but `type` dictates the interpretation mode.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the output of `0.1 + 0.2 === 0.3` in JavaScript, and which IEEE 754 standard issue causes this?",
    "options": [
      "true, because JavaScript uses arbitrary precision integers.",
      "false, due to floating point precision loss (binary representation of decimals).",
      "true, because the engine rounds the result automatically.",
      "false, due to operator precedence errors."
    ],
    "answer": "false, due to floating point precision loss (binary representation of decimals).",
    "explanation": "JavaScript uses 64-bit floating-point numbers. 0.1 and 0.2 cannot be represented precisely in binary, resulting in a sum slightly different from 0.3 (approx 0.30000000000000004).",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the purpose of the V8 `Snapshot` feature (deserialization into memory)?",
    "options": [
      "To capture the heap state for debugging memory leaks.",
      "To speed up application boot time by serializing the initial heap state.",
      "To record the execution trace for performance profiling.",
      "To compile JavaScript to WebAssembly."
    ],
    "answer": "To speed up application boot time by serializing the initial heap state.",
    "explanation": "Snapshots allow V8 to serialize a pre-parsed heap (built-in objects, or even user scripts) into a binary blob. At startup, V8 deserializes this blob, drastically reducing the time needed to parse and initialize the runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "In Node.js, what happens if `nextTick` is called recursively within a `nextTick` callback?",
    "options": [
      "The application terminates to prevent stack overflow.",
      "The event loop is blocked, and I/O callbacks are never processed.",
      "The recursion is automatically detected and throttled.",
      "The callbacks are moved to the Check phase."
    ],
    "answer": "The event loop is blocked, and I/O callbacks are never processed.",
    "explanation": "The `process.nextTick` queue is drained completely before the event loop continues. Infinite recursion here prevents the loop from reaching the subsequent phases or the microtask queue, effectively blocking the application.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "How does the V8 TurboFan optimizer utilize 'Escape Analysis'?",
    "options": [
      "It identifies objects that do not escape the function scope and allocates them on the stack instead of the heap.",
      "It breaks out of long loops to compile machine code (OSR).",
      "It detects memory leaks by analyzing escaped references.",
      "It removes security vulnerabilities by sanitizing output."
    ],
    "answer": "It identifies objects that do not escape the function scope and allocates them on the stack instead of the heap.",
    "explanation": "Escape Analysis determines if an object is used only within a specific function execution. If it does not 'escape' (get referenced outside), the object can be allocated on the stack (or scalar-replaced), avoiding GC pressure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which method is used to handle the backpressure problem efficiently when reading from a stream and writing to a slow destination in Node.js?",
    "options": [
      "Increasing the `highWaterMark` buffer size.",
      "Pausing the readable stream when `write()` returns false.",
      "Using `pipe()` which handles buffering and backpressure automatically.",
      "Processing all data chunks synchronously."
    ],
    "answer": "Using `pipe()` which handles buffering and backpressure automatically.",
    "explanation": "The `pipe()` method manages the flow control automatically. It pauses the source when the destination buffer is full and resumes it when the destination is ready, preventing memory exhaustion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In JavaScript, what is the difference between `Function.length` and `arguments.length`?",
    "options": [
      "`Function.length` is the number of arguments actually passed; `arguments.length` is the number declared.",
      "`Function.length` is the number of declared parameters; `arguments.length` is the number passed.",
      "They are identical in all scenarios.",
      "`Function.length` is non-enumerable; `arguments.length` is a global constant."
    ],
    "answer": "`Function.length` is the number of declared parameters; `arguments.length` is the number passed.",
    "explanation": "The `length` property of the function object returns the count of expected arguments (arity). The `arguments.length` property reflects the actual number of arguments passed when the function was invoked.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the security implication of using `JSON.parse()` directly with untrusted input?",
    "options": [
      "It can cause a Denial of Service (DoS) via prototype pollution if the input contains `__proto__` keys.",
      "It automatically executes JavaScript code contained in the string.",
      "It is inherently safe because JSON is a data-only subset.",
      "It causes a buffer overflow if the string exceeds 256 characters."
    ],
    "answer": "It can cause a Denial of Service (DoS) via prototype pollution if the input contains `__proto__` keys.",
    "explanation": "While JSON itself is safe, if the parsed object is merged into an existing object without sanitization, an attacker can inject `__proto__` properties. While newer JSON parsers freeze the prototype, unsafe merging can pollute `Object.prototype`, leading to application logic vulnerabilities or DoS.",
    "difficulty": "Intermediate"
  }
]