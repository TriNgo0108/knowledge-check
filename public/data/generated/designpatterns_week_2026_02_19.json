[
  {
    "id": 1,
    "question": "Which design pattern ensures that a class has only one instance and provides a global point of access to it?",
    "options": [
      "Singleton Pattern",
      "Prototype Pattern",
      "Factory Method Pattern",
      "Builder Pattern"
    ],
    "answer": "Singleton Pattern",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In the Model-View-Controller (MVC) pattern, which component is responsible for handling user input and updating the Model?",
    "options": [
      "The View",
      "The Controller",
      "The Router",
      "The Template"
    ],
    "answer": "The Controller",
    "explanation": "The Controller acts as an intermediary between the Model and View, processing user input and translating it into actions on the Model. The View is responsible for display logic only.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary intent of the Strategy design pattern?",
    "options": [
      "To define a family of algorithms, encapsulate each one, and make them interchangeable",
      "To separate the construction of a complex object from its representation",
      "To attach additional responsibilities to an object dynamically",
      "To provide a unified interface to a set of interfaces in a subsystem"
    ],
    "answer": "To define a family of algorithms, encapsulate each one, and make them interchangeable",
    "explanation": "The Strategy pattern lets the algorithm vary independently from clients that use it. It defines a common interface for all supported algorithms.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which creational pattern is best suited for creating complex objects step-by-step, allowing different representations using the same construction code?",
    "options": [
      "Abstract Factory",
      "Builder",
      "Prototype",
      "Singleton"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. It allows the same construction process to create different types and representations of an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "According to the provided text, what is the key difference between Architecture Patterns and Design Patterns?",
    "options": [
      "Architecture patterns handle large-scale structures, while Design patterns address specific implementation details",
      "Architecture patterns are written in Java, while Design patterns are written in Python",
      "Architecture patterns are obsolete, while Design patterns are modern",
      "Design patterns determine the hardware structure, while Architecture patterns handle the code"
    ],
    "answer": "Architecture patterns handle large-scale structures, while Design patterns address specific implementation details",
    "explanation": "Architecture patterns (like Microservices) establish the overall system structure, whereas Design patterns (like Factory or Observer) solve specific local problems within that structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the main purpose of the Repository pattern in enterprise applications?",
    "options": [
      "To encapsulate data access logic and provide a collection-like interface for querying domain objects",
      "To manage concurrent database transactions",
      "To generate user interface layouts dynamically",
      "To compress data packets for network transmission"
    ],
    "answer": "To encapsulate data access logic and provide a collection-like interface for querying domain objects",
    "explanation": "The Repository pattern mediates between the domain and data mapping layers, acting like an in-memory domain object collection. It abstracts the underlying data store implementation details.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which design pattern allows a client to subscribe to and receive notifications about events occurring in another object?",
    "options": [
      "Observer Pattern",
      "Command Pattern",
      "Facade Pattern",
      "Adapter Pattern"
    ],
    "answer": "Observer Pattern",
    "explanation": "The Observer pattern defines a one-to-many dependency so that when one object changes state, all its dependents are notified and updated automatically. This is central to event-driven architectures.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is the role of a Data Transfer Object (DTO) in enterprise architecture?",
    "options": [
      "To transfer data between processes or layers to reduce the number of method calls",
      "To secure the database connection string",
      "To convert SQL queries to object-oriented code",
      "To format HTML responses for the browser"
    ],
    "answer": "To transfer data between processes or layers to reduce the number of method calls",
    "explanation": "A DTO is an object that carries data between processes in a performance-efficient way. It does not contain any business logic and is used to reduce communication overhead.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "The Adapter pattern is often described as a wrapper because it:",
    "options": [
      "Converts the interface of a class into another interface clients expect",
      "Hides complex subsystem functionality behind a simpler interface",
      "Creates objects without specifying the exact class of the object that will be created",
      "Dynamically adds behaviors to an object without affecting other objects"
    ],
    "answer": "Converts the interface of a class into another interface clients expect",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. It enables classes with incompatible interfaces to work together without modifying their source code.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which structural pattern provides a simplified interface to a library, a framework, or any other complex set of classes?",
    "options": [
      "Facade Pattern",
      "Proxy Pattern",
      "Decorator Pattern",
      "Composite Pattern"
    ],
    "answer": "Facade Pattern",
    "explanation": "The Facade pattern defines a higher-level interface that makes the subsystem easier to use. It does not encapsulate the subsystem but merely provides a simplified layer over it.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "In the context of domain logic patterns, what characterizes the Transaction Script approach?",
    "options": [
      "A single procedure handles all logic for a specific use case from presentation to database",
      "Logic is organized into a domain model where objects have behavior and state",
      "Data access is strictly separated into independent microservices",
      "Business rules are defined entirely in the database stored procedures"
    ],
    "answer": "A single procedure handles all logic for a specific use case from presentation to database",
    "explanation": "Transaction Script organizes business logic primarily as a single procedure (method). It is a simple way to handle logic where the domain logic is not complex.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates what?",
    "options": [
      "The writing out of changes and the resolution of concurrency problems",
      "The creation of the user interface and the input validation",
      "The compilation of code and the deployment to the server",
      "The encryption of data and the generation of API keys"
    ],
    "answer": "The writing out of changes and the resolution of concurrency problems",
    "explanation": "The Unit of Work pattern tracks changes to objects during a transaction. It ensures that all changes are committed to the database as a single atomic operation or rolled back completely.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which design pattern defines a skeleton for an algorithm in the superclass but lets subclasses override specific steps without changing the algorithm's structure?",
    "options": [
      "Template Method",
      "Strategy",
      "Builder",
      "Bridge"
    ],
    "answer": "Template Method",
    "explanation": "The Template Method pattern defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It allows subclasses to redefine certain steps of an algorithm without changing the algorithm's structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the primary consequence of violating the Separation of Concerns principle?",
    "options": [
      "The system becomes harder to maintain, test, and scale due to tightly coupled components",
      "The application runs faster because logic is centralized in one place",
      "The database schema becomes normalized automatically",
      "The user interface becomes more responsive"
    ],
    "answer": "The system becomes harder to maintain, test, and scale due to tightly coupled components",
    "explanation": "Separation of Concerns divides an application into distinct sections, where each section addresses a separate concern. Violating this leads to 'spaghetti code' where UI, business logic, and data access are intertwined.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "The Gateway pattern acts as an interface between an application and what external entity?",
    "options": [
      "An external system or resource such as a database or web service",
      "The end-user's web browser",
      "The computer's internal CPU",
      "The application's source code repository"
    ],
    "answer": "An external system or resource such as a database or web service",
    "explanation": "The Gateway pattern encapsulates access to an external system or resource. It handles the communication protocol and data transformation required to interact with that external entity.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which creational pattern allows you to create objects by cloning an existing instance rather than constructing a new one?",
    "options": [
      "Prototype Pattern",
      "Singleton Pattern",
      "Factory Method Pattern",
      "Facade Pattern"
    ],
    "answer": "Prototype Pattern",
    "explanation": "The Prototype pattern specifies the kind of objects to create using a prototypical instance. It creates new objects by copying this prototype, which can be more efficient than creating from scratch.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "In the Decorator pattern, how is additional functionality added to an object?",
    "options": [
      "By wrapping the original object with a decorator object that shares the same interface",
      "By modifying the class of the object directly at runtime",
      "By inheriting from the object's class and overriding methods",
      "By creating a global function that manipulates the object"
    ],
    "answer": "By wrapping the original object with a decorator object that shares the same interface",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which design pattern suggests composing objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Composite Pattern",
      "Flyweight Pattern",
      "Proxy Pattern",
      "Bridge Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly. It is used when clients should ignore the difference between compositions of objects and individual objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "The Command pattern encapsulates a request as an object, thereby allowing you to:",
    "options": [
      "Parameterize clients with different requests, queue or log requests, and support undoable operations",
      "Encrypt the data contained within the request automatically",
      "Convert the request object into a database table row",
      "Prevent the request from being accessed over a network"
    ],
    "answer": "Parameterize clients with different requests, queue or log requests, and support undoable operations",
    "explanation": "The Command pattern turns a request into a stand-alone object. This object contains all information about the request, enabling queuing, logging, and undo/redo capabilities.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the primary purpose of the Abstract Factory pattern?",
    "options": [
      "To provide an interface for creating families of related or dependent objects without specifying their concrete classes",
      "To create a single instance of a class and hide the constructor",
      "To separate the interface of a class from its implementation",
      "To dynamically add responsibilities to an object"
    ],
    "answer": "To provide an interface for creating families of related or dependent objects without specifying their concrete classes",
    "explanation": "Abstract Factory is a super-factory that creates other factories. It works best when a system must be independent of how its products are created, composed, and represented.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "The Proxy pattern provides a surrogate or placeholder for another object to control access to it. Which of the following is a typical use case?",
    "options": [
      "Lazy initialization of a heavy object or access control",
      "Converting a string to an integer",
      "Creating a user interface for a mobile app",
      "Parsing a JSON file into a Python dictionary"
    ],
    "answer": "Lazy initialization of a heavy object or access control",
    "explanation": "A Proxy acts as a representative or substitute for a real object. Common uses include Virtual Proxies (lazy loading) and Protection Proxies (access control).",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "How does the Bridge pattern differ from the Adapter pattern?",
    "options": [
      "Bridge separates abstraction from implementation so they can vary independently, whereas Adapter makes incompatible interfaces work together",
      "Bridge is used only for connecting databases, while Adapter is used for UI components",
      "Adapter is used during the design phase, while Bridge is used during maintenance",
      "Bridge creates objects, while Adapter destroys them"
    ],
    "answer": "Bridge separates abstraction from implementation so they can vary independently, whereas Adapter makes incompatible interfaces work together",
    "explanation": "The Bridge pattern is used to decouple an abstraction from its implementation so that the two can vary independently. The Adapter pattern is used to make existing (incompatible) interfaces compatible.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "In the context of Enterprise Architecture, what is the main characteristic of Layered Architecture?",
    "options": [
      "Components are organized into horizontal layers (e.g., Presentation, Business, Data) with specific roles",
      "All components are deployed as independent microservices",
      "Components are organized around business capabilities rather than technical layers",
      "There is no distinction between the user interface and the database"
    ],
    "answer": "Components are organized into horizontal layers (e.g., Presentation, Business, Data) with specific roles",
    "explanation": "Layered Architecture (n-tier) organizes the application into distinct horizontal layers. Each layer has a specific responsibility, typically moving from Presentation (UI) down to Data persistence.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which behavioral pattern defines an object that encapsulates how a set of objects interact?",
    "options": [
      "Mediator Pattern",
      "Observer Pattern",
      "Memento Pattern",
      "Visitor Pattern"
    ],
    "answer": "Mediator Pattern",
    "explanation": "The Mediator pattern promotes loose coupling by keeping objects from referring to each other explicitly. It lets you vary their interaction independently by centralizing the communication logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the benefit of using the Flyweight pattern?",
    "options": [
      "It reduces memory usage by sharing common state between multiple fine-grained objects",
      "It increases processing speed by duplicating objects for every thread",
      "It simplifies the user interface by merging components",
      "It ensures that a class is only loaded once into memory"
    ],
    "answer": "It reduces memory usage by sharing common state between multiple fine-grained objects",
    "explanation": "The Flyweight pattern minimizes memory use by sharing as much data as possible with other similar objects. It is useful when a large number of similar objects must be created.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In the Chain of Responsibility pattern, how is a request processed?",
    "options": [
      "The request is passed along a chain of potential handlers until one handles it",
      "The request is broadcast to all handlers simultaneously",
      "The request is handled immediately by the first object in the code",
      "The request is stored in a database for later processing"
    ],
    "answer": "The request is passed along a chain of potential handlers until one handles it",
    "explanation": "Chain of Responsibility passes a request along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "The Interpreter pattern is typically used to:",
    "options": [
      "Interpret sentences in a language given a representation of its grammar",
      "Translate binary code into assembly language",
      "Encrypt sensitive data before storage",
      "Compress large files for disk storage"
    ],
    "answer": "Interpret sentences in a language given a representation of its grammar",
    "explanation": "The Interpreter pattern defines a representation for a language's grammar and an interpreter to use the representation to interpret sentences in the language.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which pattern provides a way to traverse the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator Pattern",
      "Visitor Pattern",
      "Command Pattern",
      "State Pattern"
    ],
    "answer": "Iterator Pattern",
    "explanation": "The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. It places the iteration task in the iterator object.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "The Memento pattern is used to:",
    "options": [
      "Capture and externalize an object's internal state so it can be restored later",
      "Notify multiple objects about a state change",
      "Construct complex objects step by step",
      "Convert the interface of a class into another interface"
    ],
    "answer": "Capture and externalize an object's internal state so it can be restored later",
    "explanation": "The Memento pattern is used to implement undo mechanisms. Without violating encapsulation, it captures and externalizes an object's internal state so the object can be restored to this state later.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the core principle of the 'Separation of Concerns' in software design?",
    "options": [
      "A software component should focus on a single, distinct aspect of the program's functionality",
      "All code must be written in a single file for easier compilation",
      "Programmers should work in separate rooms to avoid distractions",
      "Concerns are separated only at the hardware level"
    ],
    "answer": "A software component should focus on a single, distinct aspect of the program's functionality",
    "explanation": "Separation of Concerns dictates that a program should be divided into distinct features, where minimal overlap exists. This improves modularity, maintainability, and testability.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "The State pattern allows an object to:",
    "options": [
      "Alter its behavior when its internal state changes, appearing as if it changes class",
      "Create a copy of itself when the application runs low on memory",
      "Add new functionality to an object at runtime without using inheritance",
      "Translate a database schema into object-oriented code"
    ],
    "answer": "Alter its behavior when its internal state changes, appearing as if it changes class",
    "explanation": "The State pattern allows an object to change its behavior when its internal state changes. The object will appear to change its class by delegating operations to a state object.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which pattern defines a new operation to a class without changing the classes of the elements on which it operates?",
    "options": [
      "Visitor Pattern",
      "Iterator Pattern",
      "Facade Pattern",
      "Proxy Pattern"
    ],
    "answer": "Visitor Pattern",
    "explanation": "The Visitor pattern represents an operation to be performed on elements of an object structure. It lets you define a new operation without changing the classes of the elements on which it operates.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which enterprise pattern is described as the simplest way to organize business logic, where procedures handle transactions from presentation to database?",
    "options": [
      "Transaction Script",
      "Domain Model",
      "Service Layer",
      "Table Module"
    ],
    "answer": "Transaction Script",
    "explanation": "Transaction Script organizes business logic as a single procedure (script). It is straightforward and effective for simple applications with little logic overlap between use cases.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In software architecture, high coupling generally leads to which of the following negative outcomes?",
    "options": [
      "Difficulty in reusing components and testing in isolation",
      "Faster execution times due to direct memory access",
      "Simplified code structure and readability",
      "Enhanced security through data hiding"
    ],
    "answer": "Difficulty in reusing components and testing in isolation",
    "explanation": "High coupling means that a component relies heavily on other components. Changes in one component force changes in others, making the system rigid, hard to test, and difficult to reuse.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which architectural style relies heavily on events to trigger decoupled components?",
    "options": [
      "Event-Driven Architecture",
      "Layered Architecture",
      "Monolithic Architecture",
      "Client-Server Architecture"
    ],
    "answer": "Event-Driven Architecture",
    "explanation": "Event-Driven Architecture is a paradigm where components respond to events (like state changes or messages) rather than direct calls. This promotes loose coupling and agile operations.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which creational pattern is best suited for constructing complex objects step-by-step, allowing different representations using the same construction process?",
    "options": [
      "Abstract Factory",
      "Builder",
      "Prototype",
      "Factory Method"
    ],
    "answer": "Builder",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. Abstract Factory creates families of related objects, while Prototype clones existing objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary distinction between the Abstract Factory and Factory Method patterns?",
    "options": [
      "Abstract Factory creates single objects; Factory Method creates families of objects",
      "Abstract Factory uses inheritance; Factory Method uses object composition",
      "Abstract Factory creates families of related objects; Factory Method defers instantiation to subclasses",
      "Abstract Factory is a creational pattern; Factory Method is a structural pattern"
    ],
    "answer": "Abstract Factory creates families of related objects; Factory Method defers instantiation to subclasses",
    "explanation": "Factory Method defines an interface for creating a single object but lets subclasses decide which class to instantiate. Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the context of the Singleton pattern, what problem does 'Double-Checked Locking' primarily solve?",
    "options": [
      "Preventing deadlocks during resource contention",
      "Reducing the overhead of acquiring a lock every time the instance is accessed",
      "Ensuring the singleton is serialized correctly across the network",
      "Guaranteeing that the singleton state is thread-safe during mutation"
    ],
    "answer": "Reducing the overhead of acquiring a lock every time the instance is accessed",
    "explanation": "Double-Checked Locking checks the instance variable first without synchronization; if null, it enters a synchronized block to initialize. This avoids the performance cost of synchronization after the instance is initialized.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which structural pattern allows you to add new functionality to an existing object dynamically without altering its structure, often acting as a wrapper to the original object?",
    "options": [
      "Proxy",
      "Decorator",
      "Adapter",
      "Facade"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. Proxies control access, Adapters change interfaces, and Facades simplify interfaces, but only Decorator focuses on recursively extending behavior.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "How does the Adapter pattern differ from the Facade pattern?",
    "options": [
      "Adapter wraps a single class to change its interface; Facade simplifies the interface of a complex subsystem",
      "Adapter simplifies a complex subsystem; Facade wraps a single class",
      "Adapter is used at compile time; Facade is used at runtime",
      "Adapter adds new behavior; Facade removes existing behavior"
    ],
    "answer": "Adapter wraps a single class to change its interface; Facade simplifies the interface of a complex subsystem",
    "explanation": "The Adapter pattern converts the interface of a class into another interface clients expect. The Facade pattern provides a unified interface to a set of interfaces in a subsystem, defining a higher-level interface that makes the subsystem easier to use.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Which pattern decouples the abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Adapter",
      "Bridge",
      "Proxy",
      "Composite"
    ],
    "answer": "Bridge",
    "explanation": "The Bridge pattern separates an objectâ€™s abstraction from its implementation. This is distinct from Adapter, which merely makes an existing interface work with another, and Proxy, which controls access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In the Composite pattern, what is the primary function of the 'Component' interface?",
    "options": [
      "To define the specific behavior for leaf nodes only",
      "To manage the tree structure of child nodes",
      "To provide an interface for all objects in the composition, both individual and composite",
      "To store the shared state of the composite objects"
    ],
    "answer": "To provide an interface for all objects in the composition, both individual and composite",
    "explanation": "The Component interface declares the interface for objects in the composition and implements default behavior for the interface common to all classes. This allows client code to treat individual objects and compositions uniformly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which behavioral pattern allows you to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Strategy",
      "Observer",
      "Command",
      "Memento"
    ],
    "answer": "Command",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undo.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What distinguishes the Strategy pattern from the State pattern?",
    "options": [
      "Strategy defines a family of algorithms; State defines a family of states",
      "Strategy allows an object to alter its behavior when its internal state changes; State does not",
      "State is a creational pattern; Strategy is a behavioral pattern",
      "Strategy patterns cannot be used with dependency injection"
    ],
    "answer": "Strategy defines a family of algorithms; State defines a family of states",
    "explanation": "While the structures are similar, the Strategy pattern is intended for interchangeable algorithms, whereas the State pattern is intended for an object to change its behavior based on its internal state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which pattern provides a surrogate or placeholder for another object to control access to it?",
    "options": [
      "Decorator",
      "Proxy",
      "Flyweight",
      "Bridge"
    ],
    "answer": "Proxy",
    "explanation": "The Proxy pattern provides a representative for another object to control access to it. This can be for reasons like lazy initialization, access control, logging, or caching.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In the Chain of Responsibility pattern, how is a request handled?",
    "options": [
      "All handlers in the chain process the request simultaneously",
      "The request is passed along the chain until a handler handles it or the chain ends",
      "The first handler in the chain always handles the request",
      "The client explicitly chooses which handler will process the request"
    ],
    "answer": "The request is passed along the chain until a handler handles it or the chain ends",
    "explanation": "The pattern decouples senders from receivers by giving more than one object a chance to handle a request. The request flows along the chain until an object handles it or it reaches the end.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the primary intent of the Observer pattern?",
    "options": [
      "To define a one-to-many dependency between objects so that when one object changes state, all dependents are notified",
      "To encapsulate a request as an object",
      "To allow traversal of aggregate objects without exposing the underlying representation",
      "To define the skeleton of an algorithm in an operation, deferring some steps to subclasses"
    ],
    "answer": "To define a one-to-many dependency between objects so that when one object changes state, all dependents are notified",
    "explanation": "The Observer pattern establishes a subscription mechanism to notify multiple objects about any events that happen to the object they are observing. It is key for event-driven systems.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which behavioral pattern allows you to define a skeleton of an algorithm in a base class but let subclasses override specific steps of the algorithm without changing its structure?",
    "options": [
      "Strategy",
      "Command",
      "Template Method",
      "Builder"
    ],
    "answer": "Template Method",
    "explanation": "The Template Method pattern defines the program skeleton of an algorithm in a method, deferring some steps to subclasses. It lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What issue does the Flyweight pattern primarily address?",
    "options": [
      "Complex object creation logic",
      "Extraneous object inheritance hierarchies",
      "High memory usage by sharing intrinsic state of objects",
      "Tight coupling between objects"
    ],
    "answer": "High memory usage by sharing intrinsic state of objects",
    "explanation": "The Flyweight pattern minimizes memory usage by sharing as much data as possible with other similar objects. It is useful when a large number of similar objects must be created.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which design pattern is most commonly used to separate data access logic from business logic in enterprise applications?",
    "options": [
      "Service Locator",
      "Repository",
      "Data Access Object",
      "Active Record"
    ],
    "answer": "Repository",
    "explanation": "The Repository pattern acts as a mediary between the domain logic and the data mapping layers, providing a collection-like interface for accessing domain objects. While DAO is similar, Repository typically enforces a domain-centric view.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In the context of Domain-Driven Design, which pattern is used to encapsulate complex business logic that does not naturally fit within a single entity?",
    "options": [
      "Value Object",
      "Aggregate",
      "Domain Service",
      "Specification"
    ],
    "answer": "Domain Service",
    "explanation": "A Domain Service is used when a concept or operation in the domain model is not naturally associated with a specific Entity or Value Object. It encapsulates business logic or processes that apply to multiple domain objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which Enterprise Pattern defines an object that carries data between processes in order to reduce the number of method calls?",
    "options": [
      "Data Transfer Object (DTO)",
      "Value Object",
      "Entity",
      "Message"
    ],
    "answer": "Data Transfer Object (DTO)",
    "explanation": "A DTO is an object that carries data between processes. The primary benefit is to reduce the number of calls, especially in remote calls, by aggregating data into a single structure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the core responsibility of the Unit of Work pattern?",
    "options": [
      "To map database tables to domain objects",
      "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes",
      "To execute queries against a data source",
      "To decouple the business logic from the database schema"
    ],
    "answer": "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes",
    "explanation": "The Unit of Work pattern tracks changes to objects during a transaction. It ensures that all changes are committed to the database together or rolled back, maintaining integrity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which design pattern describes a class that has only one instance and provides a global point of access to it, but is often criticized for hindering testability and modularity?",
    "options": [
      "Monostate",
      "Singleton",
      "Service Locator",
      "Multiton"
    ],
    "answer": "Singleton",
    "explanation": "The Singleton pattern ensures a class has only one instance. It is frequently criticized because it introduces global state, making unit testing difficult and hiding dependencies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "The 'Hollywood Principle' (Don't call us, we'll call you) is associated with which design pattern?",
    "options": [
      "Observer",
      "Inversion of Control (IoC)",
      "Template Method",
      "Mediator"
    ],
    "answer": "Template Method",
    "explanation": "The Template Method pattern is the classic implementation of the Hollywood Principle. The parent class (Hollywood) calls the methods of the subclass (the actor) at specific times, rather than the subclass calling the parent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the main purpose of the Visitor pattern?",
    "options": [
      "To separate an algorithm from the object structure it operates on",
      "To allow a group of objects to be treated as a single object",
      "To add new functionality to existing classes without inheritance",
      "To provide a way to traverse a collection of objects"
    ],
    "answer": "To separate an algorithm from the object structure it operates on",
    "explanation": "The Visitor pattern lets you define a new operation without changing the classes of the elements on which it operates. It separates the logic from the data structure by utilizing double dispatch.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the Model-View-Controller (MVC) pattern, which component is responsible for handling user input and updating the model?",
    "options": [
      "Model",
      "View",
      "Controller",
      "Service Layer"
    ],
    "answer": "Controller",
    "explanation": "The Controller handles the user input, interacts with the Model to update data, and selects the View for display. The View simply renders the data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which structural pattern is used to ensure that a class has only one instance, but does so by relying on the language's runtime environment rather than a static method?",
    "options": [
      "Singleton",
      "Monostate",
      "Object Pool",
      "Prototype"
    ],
    "answer": "Monostate",
    "explanation": "The Monostate pattern ensures all instances share the same state by making all data fields static, rather than controlling instantiation via a private constructor like the Singleton pattern.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which pattern allows you to define a new behavior for objects without changing their classes, by placing these objects inside special wrapper objects?",
    "options": [
      "Adapter",
      "Decorator",
      "Proxy",
      "Bridge"
    ],
    "answer": "Decorator",
    "explanation": "The Decorator pattern attaches additional behavior to an object dynamically at runtime. It provides a flexible alternative to subclassing for extending functionality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the 'Liskov Substitution Principle' (LSP) primarily concerned with in the context of design patterns?",
    "options": [
      "Using interfaces to decouple modules",
      "Ensuring that a derived class can substitute its base class without breaking the application",
      "Restricting classes to a single responsibility",
      "Depending on abstractions rather than concretions"
    ],
    "answer": "Ensuring that a derived class can substitute its base class without breaking the application",
    "explanation": "LSP states that if S is a subtype of T, then objects of type T should be replaceable with objects of type S without altering the correctness of the program.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which enterprise pattern acts as an entry point for all client requests to a web application, centralizing request handling logic?",
    "options": [
      "Front Controller",
      "Dispatcher",
      "Interceptor",
      "Command"
    ],
    "answer": "Front Controller",
    "explanation": "The Front Controller pattern provides a centralized controller for managing incoming requests. It handles common concerns like authentication, logging, and routing before delegating to specific handlers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which creational pattern is used when the cost of creating a new object is high, and you want to initialize a new object by copying an existing one?",
    "options": [
      "Factory Method",
      "Prototype",
      "Builder",
      "Object Pool"
    ],
    "answer": "Prototype",
    "explanation": "The Prototype pattern creates new objects by cloning an existing instance (the prototype) instead of creating them from scratch. This is efficient when object creation is resource-intensive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the primary difference between a 'Value Object' and an 'Entity' in Domain-Driven Design?",
    "options": [
      "Value Objects are mutable; Entities are immutable",
      "Value Objects are identified by their attributes; Entities are identified by their identity",
      "Entities are used for data transfer; Value Objects are used for persistence",
      "Value Objects represent database tables; Entities represent database rows"
    ],
    "answer": "Value Objects are identified by their attributes; Entities are identified by their identity",
    "explanation": "An Entity is defined by its identity (ID), which remains consistent over time. A Value Object has no conceptual identity and is defined by the values of its attributes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which design pattern minimizes memory usage by sharing parts of an object's state between similar objects?",
    "options": [
      "Object Pool",
      "Flyweight",
      "Prototype",
      "Proxy"
    ],
    "answer": "Flyweight",
    "explanation": "The Flyweight pattern reduces memory usage by sharing intrinsic state (common data) among many objects, while passing extrinsic state (unique data) as arguments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In the context of the Dependency Inversion Principle, what does 'depending on abstractions' specifically mean?",
    "options": [
      "Using concrete classes to define behavior",
      "Programming to an interface rather than an implementation",
      "Using inheritance to share code",
      "Avoiding the use of interfaces"
    ],
    "answer": "Programming to an interface rather than an implementation",
    "explanation": "Depending on abstractions means that high-level modules should depend on interfaces or abstract classes, not on concrete low-level classes, allowing for easier substitution and maintenance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which pattern acts as an intermediary between the client and a target object, typically to control access, manage resources, or log access?",
    "options": [
      "Proxy",
      "Decorator",
      "Adapter",
      "Facade"
    ],
    "answer": "Proxy",
    "explanation": "A Proxy provides a surrogate or placeholder for another object to control access to it. Unlike a Decorator, its primary intent is not adding behavior but managing access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which pattern defines a mechanism that allows an object to notify other objects about changes in its state?",
    "options": [
      "Mediator",
      "Observer",
      "Chain of Responsibility",
      "Command"
    ],
    "answer": "Observer",
    "explanation": "The Observer pattern establishes a subscription model where subscribers (observers) register with a publisher (subject) to receive notifications upon state changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the primary intent of the 'Specification' pattern in Domain-Driven Design?",
    "options": [
      "To encapsulate business rules as Boolean-valued functions that can be combined",
      "To separate the database schema from the domain model",
      "To define the lifecycle of a domain object",
      "To handle concurrency conflicts in transactions"
    ],
    "answer": "To encapsulate business rules as Boolean-valued functions that can be combined",
    "explanation": "The Specification pattern defines a predicate (Boolean function) to test if an object satisfies a specific criteria. Specifications can be combined using logic (AND, OR, NOT) to form complex queries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In the Mediator pattern, how does the Mediator object affect the communication between Colleague objects?",
    "options": [
      "The Mediator broadcasts messages to all colleagues simultaneously",
      "Colleague objects communicate directly, but the Mediator logs the interaction",
      "The Mediator encapsulates the interaction logic, so colleagues communicate via the Mediator rather than directly",
      "The Mediator restricts communication to only two specific colleague objects"
    ],
    "answer": "The Mediator encapsulates the interaction logic, so colleagues communicate via the Mediator rather than directly",
    "explanation": "The Mediator pattern promotes loose coupling by preventing objects from referring to each other explicitly. It routes communication between objects through a central mediator.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which Enterprise Pattern is primarily concerned with coordinating a transactional scope for a collection of domain objects?",
    "options": [
      "Unit of Work",
      "Repository",
      "Transaction Script",
      "Data Mapper"
    ],
    "answer": "Unit of Work",
    "explanation": "The Unit of Work pattern tracks changes made to a set of objects during a business transaction and writes out those changes as a single atomic action, ensuring consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of the Visitor pattern, what is the primary mechanism that allows the operation to vary based on the type of the element being visited without using `instanceof` checks?",
    "options": [
      "Reflection and dynamic method interception",
      "Double dispatch (dynamic binding based on both visitor and element types)",
      "A central registry mapping element types to visitor functions",
      "Iterating over a composite structure using an external iterator"
    ],
    "answer": "Double dispatch (dynamic binding based on both visitor and element types)",
    "explanation": "The Visitor pattern relies on double dispatch: the element accepts the visitor, calling the visitor's overloaded method specific to that element type. This effectively resolves the concrete type of both the visitor and the visitee at runtime.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Which Enterprise Design Pattern defines a method that tracks the business objects affected by a transaction to ensure atomic writes to the database?",
    "options": [
      "Identity Map",
      "Unit of Work",
      "Data Mapper",
      "Lazy Load"
    ],
    "answer": "Unit of Work",
    "explanation": "The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates the writing out of changes. This ensures that the persistence layer commits the transaction as a single atomic action.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What distinguishes the Proxy pattern from the Decorator pattern regarding the intent of the structural change?",
    "options": [
      "Proxy adds behavior to an object dynamically, whereas Decorator controls access to it",
      "Decorator adds behavior dynamically, whereas Proxy manages access or lifecycle of the object",
      "Proxy is used only for remote communication, while Decorator is used for graphical interfaces",
      "Decorator changes the interface of the object, while Proxy keeps it identical"
    ],
    "answer": "Decorator adds behavior dynamically, whereas Proxy manages access or lifecycle of the object",
    "explanation": "While both structures are similar, the Proxy pattern acts as a surrogate or placeholder to control access to the real subject. The Decorator pattern dynamically adds responsibilities to an object without changing its interface for the sole purpose of extension.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "In a CQRS (Command Query Responsibility Segregation) implementation, what is the primary technical advantage of separating the read model from the write model?",
    "options": [
      "It allows the read model to be optimized for queries and the write model for validation and transactions",
      "It eliminates the need for a database entirely by using in-memory storage",
      "It ensures that the read and write operations always run on the same physical server",
      "It automatically prevents all concurrency conflicts without needing locking mechanisms"
    ],
    "answer": "It allows the read model to be optimized for queries and the write model for validation and transactions",
    "explanation": "CQRS separates the responsibility: the write side handles domain logic and consistency (updates), while the read side is denormalized for high-performance querying, allowing independent scaling and optimization of both data models.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "How does the State pattern differ structurally from the Strategy pattern despite having nearly identical class diagrams?",
    "options": [
      "Strategy allows the client to switch algorithms, while State allows an object to alter its behavior when its internal state changes",
      "State uses inheritance, whereas Strategy uses composition",
      "Strategy is a creational pattern, whereas State is behavioral",
      "State requires a context object to be passed as an argument, while Strategy does not"
    ],
    "answer": "Strategy allows the client to switch algorithms, while State allows an object to alter its behavior when its internal state changes",
    "explanation": "While both use composition to delegate behavior, the Strategy pattern typically allows the client to swap the strategy object. In the State pattern, the state objects themselves usually trigger transitions to other states within the Context.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the specific role of the 'Coordinator' in the Saga pattern for distributed transactions?",
    "options": [
      "To lock all involved database rows to prevent concurrent access",
      "To orchestrate the sequence of transactions and execute compensating actions if a step fails",
      "To act as a two-phase commit coordinator ensuring atomicity across resources",
      "To replicate data across all services to ensure high availability"
    ],
    "answer": "To orchestrate the sequence of transactions and execute compensating actions if a step fails",
    "explanation": "Unlike two-phase commit, a Saga coordinates a sequence of local transactions. If a step fails, the coordinator (or choreography logic) triggers a series of compensating transactions to undo the effects of previously completed steps.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "When implementing the Repository pattern, why is it considered a best practice to return a specific abstraction of a collection (like an `IEnumerable`) rather than a concrete list (like a `List`)?",
    "options": [
      "To prevent the application from accessing the Count property of the list",
      "To allow the repository to control the fetching strategy (e.g., lazy loading or streaming) of the data",
      "To ensure that the returned data is always read-only and immutable",
      "To reduce the memory footprint by always returning null instead of objects"
    ],
    "answer": "To allow the repository to control the fetching strategy (e.g., lazy loading or streaming) of the data",
    "explanation": "Returning an abstracted iterable allows the Repository implementation to defer query execution (streaming) or apply optimization logic like pagination without forcing the immediate materialization of all data into memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In the Double-Checked Locking optimization for the Singleton pattern, what is the specific technical condition required for it to function correctly without race conditions?",
    "options": [
      "The instance variable must be declared as `transient`",
      "The instance variable must be declared `volatile` to prevent instruction reordering",
      "The locking mechanism must use a `ReadWriteLock` instead of `synchronized`",
      "The constructor must be private"
    ],
    "answer": "The instance variable must be declared `volatile` to prevent instruction reordering",
    "explanation": "Double-checked locking relies on the `volatile` keyword (in Java) or equivalent memory barriers to prevent the compiler/CPU from reordering instructions, ensuring the singleton instance is fully initialized before it is visible to other threads.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which behavioral pattern is best utilized to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Memento Pattern",
      "Command Pattern",
      "Strategy Pattern",
      "Chain of Responsibility Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This decoupling allows the request to be queued, executed later, or rolled back (undo) without the invoker knowing the receiver.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the key differentiator between the Bridge pattern and the Adapter pattern?",
    "options": [
      "Adapter is used to allow incompatible interfaces to work together, whereas Bridge is used to separate an abstraction from its implementation so both can vary independently",
      "Bridge is a structural pattern used at compile time, while Adapter is used only at runtime",
      "Adapter changes the interface of the object, while Bridge changes the implementation of the object",
      "Bridge inherits from the adaptee, whereas Adapter composes the adaptee"
    ],
    "answer": "Adapter is used to allow incompatible interfaces to work together, whereas Bridge is used to separate an abstraction from its implementation so both can vary independently",
    "explanation": "The Adapter pattern converts the interface of a class into another interface clients expect, usually to fix incompatibility. The Bridge pattern is designed upfront to decouple an abstraction from its implementation to avoid a permanent binding between the two.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In Enterprise Architecture, what is the primary purpose of the 'Front Controller' pattern compared to the 'Page Controller' pattern?",
    "options": [
      "Page Controller consolidates all request handling logic into one object, while Front Controller distributes it",
      "Front Controller provides a centralized entry point for all requests to handle common concerns like security and logging, while Page Controller associates a specific controller with a specific page/view",
      "Front Controller is strictly for backend microservices, while Page Controller is for frontend UI",
      "Front Controller handles database connections, while Page Controller handles HTML rendering"
    ],
    "answer": "Front Controller provides a centralized entry point for all requests to handle common concerns like security and logging, while Page Controller associates a specific controller with a specific page/view",
    "explanation": "The Front Controller (often a servlet or filter) centralizes request processing to handle cross-cutting concerns (auth, logging) before dispatching to specific handlers. A Page Controller typically handles logic for a single specific view or page.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does the Flyweight pattern reduce memory usage in an application?",
    "options": [
      "By compressing objects using a zip algorithm before storing them in memory",
      "By sharing common state among multiple objects instead of storing duplicate data in each object",
      "By storing objects on disk and loading them only when requested",
      "By clearing the memory cache automatically when it reaches 80% capacity"
    ],
    "answer": "By sharing common state among multiple objects instead of storing duplicate data in each object",
    "explanation": "The Flyweight pattern minimizes memory usage by sharing as much data as possible with other similar objects; it stores intrinsic (shared) state externally and passes extrinsic (unique) state into the flyweight methods when needed.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Which design pattern utilizes a 'handle-body' idiom to allow you to change the implementation of an object without changing the interface, effectively decoupling abstraction from implementation?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Facade Pattern",
      "Proxy Pattern"
    ],
    "answer": "Bridge Pattern",
    "explanation": "The Bridge pattern decouples the abstraction (interface) from the implementation (details). The 'handle' is the abstraction, and the 'body' is the implementation interface, allowing them to vary independently without compile-time binding.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In the context of Domain-Driven Design (DDD), what is the 'Anemic Domain Model' considered an anti-pattern, and which pattern corrects it?",
    "options": [
      "Anemic models separate data and behavior; the Active Record pattern corrects this by merging them",
      "Anemic models lack behavior in the domain entities; the Domain Model pattern corrects this by encapsulating business logic within entities",
      "Anemic models use too many services; the Service Layer pattern corrects this by removing services",
      "Anemic models rely on stored procedures; the Table Data Gateway pattern corrects this"
    ],
    "answer": "Anemic models lack behavior in the domain entities; the Domain Model pattern corrects this by encapsulating business logic within entities",
    "explanation": "Anemic Domain Models resemble procedural designs where domain objects are just data containers with setters/getters. The 'Rich' Domain Model pattern corrects this by moving business logic and rules back into the domain entities themselves.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the 'Liskov Substitution Principle' (LSP) implication for a design pattern using inheritance?",
    "options": [
      "Derived classes must be substitutable for their base classes without altering the correctness of the program",
      "Base classes must be abstract to prevent instantiation",
      "Derived classes must override all methods defined in the base class",
      "Base classes must never contain any implementation details"
    ],
    "answer": "Derived classes must be substitutable for their base classes without altering the correctness of the program",
    "explanation": "LSP is a critical definition of subtyping. It dictates that if a program is using a base class, it should be able to use a subclass without knowing the difference and without the program behaving incorrectly or crashing.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which pattern allows you to publish a single interface to a complex subsystem, making the subsystem easier to use and reducing dependencies on the internal subsystem details?",
    "options": [
      "Mediator Pattern",
      "Facade Pattern",
      "Adapter Pattern",
      "Decorator Pattern"
    ],
    "answer": "Facade Pattern",
    "explanation": "The Facade pattern provides a unified, high-level interface to a set of interfaces within a subsystem. It decouples the client from the complex internal components of the subsystem, promoting loose coupling.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In the context of event-driven systems, what specific role does the 'Observer' pattern play regarding state propagation?",
    "options": [
      "It guarantees that all observers receive state updates in a strict, deterministic order",
      "It defines a one-to-many dependency so that when one object changes state, all its dependents are notified and updated automatically",
      "It pushes state changes to a message queue for persistence",
      "It locks the subject object during state modification to ensure thread safety"
    ],
    "answer": "It defines a one-to-many dependency so that when one object changes state, all its dependents are notified and updated automatically",
    "explanation": "The Observer pattern establishes a subscription mechanism where multiple observers listen to subject events. When the subject's state changes, it broadcasts a notification to all subscribed observers, allowing them to react accordingly.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the specific advantage of the 'Intercepting Filter' pattern in web application architecture?",
    "options": [
      "It compresses HTTP responses before sending them to the client",
      "It centralizes pre-processing and post-processing logic for requests (like authentication, logging) in a reusable chain",
      "It routes requests to different databases based on the URL",
      "It prevents SQL injection attacks by modifying the query string"
    ],
    "answer": "It centralizes pre-processing and post-processing logic for requests (like authentication, logging) in a reusable chain",
    "explanation": "Intercepting Filter implements a pluggable architecture where filters intercept incoming requests and outgoing responses. This allows developers to add or remove cross-cutting concerns (logging, auth, encoding) without changing the core processing logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which pattern creates an inheritance chain of processing objects that passes a request along until one of them handles it?",
    "options": [
      "Observer Pattern",
      "Command Pattern",
      "Chain of Responsibility Pattern",
      "Mediator Pattern"
    ],
    "answer": "Chain of Responsibility Pattern",
    "explanation": "The Chain of Responsibility pattern couples the sender of a request to a chain of potential receivers. The request travels along the chain until an object handles it or the chain ends, decoupling the sender from the specific receiver.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does the 'Interpreter' pattern treat sentences in a language?",
    "options": [
      "By translating them into machine code directly",
      "By defining a grammar representation and an interpreter that uses this representation to interpret sentences",
      "By compiling them into a binary format for faster execution",
      "By sending them to a remote server for processing"
    ],
    "answer": "By defining a grammar representation and an interpreter that uses this representation to interpret sentences",
    "explanation": "The Interpreter pattern is useful for designing a language grammar. It defines a class hierarchy for the grammar rules, where each class represents a rule and an interpreter (evaluator) processes the sentence structure based on these rules.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In the context of MVC (Model-View-Controller), how does the 'Passive View' variant (common in MVP) differ from the classical 'Active View'?",
    "options": [
      "In Passive View, the View updates the Model directly; in Active View, the Controller updates the Model",
      "In Passive View, the View is dumb and the Presenter handles all UI logic updates; in Active View, the View observes the Model directly",
      "In Passive View, the Controller is replaced by a Service Layer",
      "In Passive View, the View contains business logic, whereas in Active View, it is purely visual"
    ],
    "answer": "In Passive View, the View is dumb and the Presenter handles all UI logic updates; in Active View, the View observes the Model directly",
    "explanation": "The Passive View pattern maximizes testability by removing logic from the View. The Presenter updates the View strictly via an interface. In classical MVC (or Active View approaches), the View often observes data changes directly from the Model.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the 'Race Condition' in the context of the Singleton pattern's initialization without proper synchronization?",
    "options": [
      "Two threads create two different instances, breaking the singleton constraint",
      "The application crashes due to stack overflow",
      "The constructor is called more than once by the same thread",
      "The garbage collector deletes the instance before it is used"
    ],
    "answer": "Two threads create two different instances, breaking the singleton constraint",
    "explanation": "If a singleton check-then-act (if instance == null) is not atomic, two threads can simultaneously pass the check and create two distinct instances, violating the single-instance principle.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "Which pattern suggests composing objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions of objects uniformly?",
    "options": [
      "Decorator Pattern",
      "Composite Pattern",
      "Flyweight Pattern",
      "Proxy Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite pattern allows you to treat individual leaf objects and groups of objects (composites) identically by implementing the same interface. This simplifies client code that needs to manage recursive or hierarchical structures.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "How does the 'Data Transfer Object' (DTO) pattern primarily affect performance in distributed systems?",
    "options": [
      "It improves performance by allowing the database to be queried directly from the view",
      "It reduces the number of remote calls by aggregating data into a single coarse-grained structure",
      "It increases performance by removing the need for serialization",
      "It eliminates network latency entirely"
    ],
    "answer": "It reduces the number of remote calls by aggregating data into a single coarse-grained structure",
    "explanation": "In distributed systems, fine-grained remote calls (chatty communication) are expensive. A DTO aggregates multiple data elements into one object, transferring data in a single remote call rather than multiple calls, thereby reducing network latency overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the specific responsibility of the 'Mediator' pattern?",
    "options": [
      "To add additional behavior to individual objects dynamically",
      "To define an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly",
      "To coordinate the life-cycle of a complex object construction",
      "To translate interfaces between incompatible classes"
    ],
    "answer": "To define an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly",
    "explanation": "The Mediator pattern centralizes communication between colleague objects. Instead of objects referencing each other directly (high coupling), they go through the mediator (low coupling), making the system easier to maintain.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Which Creational pattern uses a separate 'Builder' class to construct a complex object step-by-step, allowing the same construction process to create different representations?",
    "options": [
      "Factory Method Pattern",
      "Abstract Factory Pattern",
      "Builder Pattern",
      "Prototype Pattern"
    ],
    "answer": "Builder Pattern",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation. By using a director and concrete builders, the same step-by-step construction process can create objects with different internal structures or formats.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the 'Open/Closed Principle' (OCP) and which pattern adheres to it by allowing a class to be extended without modifying its code?",
    "options": [
      "Subclasses should be able to override parent behavior; Template Method Pattern",
      "Software entities should be open for extension but closed for modification; Decorator or Strategy Pattern",
      "Objects should depend on abstractions; Dependency Injection Pattern",
      "Classes should have only one reason to change; Singleton Pattern"
    ],
    "answer": "Software entities should be open for extension but closed for modification; Decorator or Strategy Pattern",
    "explanation": "OCP dictates that existing code should not be changed to add new features. Patterns like Decorator or Strategy allow new behaviors to be added (extension) by composing new objects rather than altering the existing class code (modification).",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of the 'Active Record' pattern, how is the domain model typically related to the database schema?",
    "options": [
      "The domain model is completely decoupled and mapped via XML files",
      "The domain object contains both data and behavior, and corresponds one-to-one with a database table",
      "The domain object is stateless and holds only SQL queries",
      "The domain object is a proxy that lazy-loads data from a web service"
    ],
    "answer": "The domain object contains both data and behavior, and corresponds one-to-one with a database table",
    "explanation": "Active Record is an architectural pattern where an object wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data. The class attributes often map directly to the table columns.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Which pattern is specifically designed to avoid the 'telescoping constructor' problem where a class has numerous optional parameters?",
    "options": [
      "Prototype Pattern",
      "Builder Pattern",
      "Adapter Pattern",
      "Facade Pattern"
    ],
    "answer": "Builder Pattern",
    "explanation": "The telescoping constructor problem occurs when you have a complex constructor with many parameters (mostly optional). The Builder pattern allows you to construct the object step-by-step using setter-like methods, improving readability and handling optional parameters gracefully.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "How does the 'Null Object' pattern improve code cleanliness compared to using `null` checks?",
    "options": [
      "It automatically converts database nulls to default string values",
      "It provides a concrete do-nothing object to replace `null` checks, eliminating the need for conditional null logic in the client",
      "It uses reflection to generate stub methods for all interfaces",
      "It throws exceptions immediately if a null value is encountered"
    ],
    "answer": "It provides a concrete do-nothing object to replace `null` checks, eliminating the need for conditional null logic in the client",
    "explanation": "The Null Object pattern implements a neutral interface (doing nothing) for classes that might otherwise return null. This allows the client to treat the null case uniformly without explicit `if (object != null)` checks scattered throughout the code.",
    "difficulty": "Advanced"
  }
]