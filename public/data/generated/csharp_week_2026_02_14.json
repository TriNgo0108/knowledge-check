[
  {
    "id": 1,
    "question": "What is the primary difference between a 'struct' and a 'class' in C#?",
    "options": [
      "A struct cannot implement interfaces",
      "A struct is a value type, while a class is a reference type",
      "A struct cannot contain methods",
      "A struct is always abstract"
    ],
    "answer": "A struct is a value type, while a class is a reference type",
    "explanation": "In C#, classes are reference types stored on the heap, whereas structs are value types typically stored on the stack. This affects how they are copied, passed to methods, and how memory is managed.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which keyword is used to define a method whose implementation can be specific to the derived class that implements it?",
    "options": [
      "abstract",
      "virtual",
      "override",
      "static"
    ],
    "answer": "abstract",
    "explanation": "The 'abstract' keyword indicates that a method lacks implementation in the base class and must be implemented by any non-abstract derived class. 'Virtual' methods provide an implementation that can be optionally overridden.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What does the 'using' statement accomplish in C# when dealing with objects that implement IDisposable?",
    "options": [
      "It imports a specific namespace into the current file",
      "It automatically compiles the code in unsafe blocks",
      "It ensures that the Dispose method is called even if an exception occurs",
      "It creates a null-conditional reference to the object"
    ],
    "answer": "It ensures that the Dispose method is called even if an exception occurs",
    "explanation": "The 'using' statement provides a convenient syntax that ensures the Dispose method is called correctly, releasing resources and preventing leaks even if exceptions happen within the block.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which access modifier allows a method to be accessed by any code in the same assembly or by derived classes in other assemblies?",
    "options": [
      "protected internal",
      "internal",
      "protected",
      "public"
    ],
    "answer": "protected internal",
    "explanation": "The 'protected internal' access modifier creates a union of 'protected' and 'internal', allowing access within the same assembly or from derived classes in other assemblies.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In C#, what is the purpose of the '??' operator (null-coalescing operator)?",
    "options": [
      "It checks if two values are equal",
      "It returns the left-hand operand if it is not null, otherwise it returns the right-hand operand",
      "It shifts bits to the right",
      "It concatenates two null strings"
    ],
    "answer": "It returns the left-hand operand if it is not null, otherwise it returns the right-hand operand",
    "explanation": "The null-coalescing operator '??' provides a shorthand way to check for null values, defaulting to the right-hand side value if the left-hand side is null.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the correct way to declare a variable as nullable in C#?",
    "options": [
      "int x = null;",
      "nullable int x = 0;",
      "int? x = null;",
      "int *x = null;"
    ],
    "answer": "int? x = null;",
    "explanation": "Appending a question mark '?' to a value type (like int) creates a nullable version of that type, allowing it to hold the value 'null' in addition to its normal range.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which keyword is used to prevent a class from being inherited in C#?",
    "options": [
      "sealed",
      "static",
      "abstract",
      "internal"
    ],
    "answer": "sealed",
    "explanation": "The 'sealed' keyword applied to a class prevents other classes from inheriting from it. It can also be applied to methods to override specific virtual inheritance chains.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is the main advantage of using Generics (e.g., List) over ArrayList?",
    "options": [
      "Generics run faster because they avoid boxing and unboxing",
      "Generics automatically sort the data",
      "Generics can store any data type simultaneously",
      "Generics do not require type casting"
    ],
    "answer": "Generics run faster because they avoid boxing and unboxing",
    "explanation": "Generics provide type safety and performance improvements by storing data in a strongly typed manner, avoiding the runtime boxing and unboxing overhead associated with non-generic collections like ArrayList.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What character is used to denote a Verbatim String Literal in C#?",
    "options": [
      "@",
      "#",
      "&",
      "~"
    ],
    "answer": "@",
    "explanation": "The '@' character defines a verbatim string, which causes escape sequences (like \\\\n) to be interpreted literally and allows multi-line string declarations without special characters.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which interface must a collection implement to be iterated over using a 'foreach' loop?",
    "options": [
      "IEnumerable",
      "ICollection",
      "IList",
      "IEnumerator"
    ],
    "answer": "IEnumerable",
    "explanation": "The 'IEnumerable' interface exposes an enumerator, which is the underlying mechanism that supports a simple iteration over a collection using the 'foreach' statement.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What happens when you use the 'await' keyword on a non-generic Task in an async method?",
    "options": [
      "It forces the application to close immediately",
      "It blocks the main thread until the task completes",
      "It suspends the execution of the method until the task completes without blocking the thread",
      "It converts the task into a generic Task<int>"
    ],
    "answer": "It suspends the execution of the method until the task completes without blocking the thread",
    "explanation": "The 'await' operator suspends the evaluation of the enclosing async method until the awaited asynchronous operation completes, while returning control to the caller to prevent blocking.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which of the following correctly describes a Delegate in C#?",
    "options": [
      "A type-safe function pointer that references a method with a specific signature",
      "A keyword used to delegate memory management to the GC",
      "A synchronization primitive for multi-threading",
      "A class that acts as a base for all exceptions"
    ],
    "answer": "A type-safe function pointer that references a method with a specific signature",
    "explanation": "A delegate is a type that represents references to methods with a particular parameter list and return type, allowing methods to be passed as parameters.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the result of attempting to modify a string variable in C#?",
    "options": [
      "The original memory location is updated",
      "A compiler error occurs because strings are read-only",
      "A new string object is created in memory",
      "The variable becomes null"
    ],
    "answer": "A new string object is created in memory",
    "explanation": "Strings in C# are immutable. Any modification results in the creation of a new string object in memory, while the original object remains unchanged until garbage collected.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which LINQ method is used to filter a sequence based on a predicate?",
    "options": [
      "Select",
      "Where",
      "Take",
      "OrderBy"
    ],
    "answer": "Where",
    "explanation": "The 'Where' method filters a collection based on a predicate function (a condition), returning only the elements that satisfy the condition.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the purpose of the 'static' keyword on a class member?",
    "options": [
      "The member belongs to the specific instance of the class",
      "The member is constant and cannot be changed",
      "The member belongs to the class itself rather than any specific object instance",
      "The member is stored in a specific memory register"
    ],
    "answer": "The member belongs to the class itself rather than any specific object instance",
    "explanation": "Static members are shared across all instances of a class and can be accessed directly using the class name without creating an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which operator is used to access a member of a namespace or a member of a class?",
    "options": [
      ":: (Scope resolution)",
      ". (Dot)",
      "-> (Arrow)",
      "/ (Slash)"
    ],
    "answer": ". (Dot)",
    "explanation": "The dot operator (.) is the standard member access operator in C#, used to access namespaces, classes, methods, and properties.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the default value of a boolean variable in C#?",
    "options": [
      "true",
      "null",
      "1",
      "false"
    ],
    "answer": "false",
    "explanation": "Boolean variables default to 'false' in C#. This applies to field initialization; local variables must be explicitly assigned before use.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which statement best describes the concept of Boxing in C#?",
    "options": [
      "Converting a value type to a reference type",
      "Converting a reference type to a value type",
      "Grouping related classes in a namespace",
      "Wrapping a method inside a class"
    ],
    "answer": "Converting a value type to a reference type",
    "explanation": "Boxing is the process of converting a value type (like int) to the type object or to any interface type implemented by this value type, storing it on the heap.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What does the 'var' keyword indicate in a variable declaration?",
    "options": [
      "The variable type is dynamically inferred at runtime",
      "The variable is a variant type that can change type",
      "The compiler determines the type from the expression on the right-hand side",
      "The variable is immutable"
    ],
    "answer": "The compiler determines the type from the expression on the right-hand side",
    "explanation": "'var' enables implicitly typed local variables; the compiler infers the type from the initialization expression, but the type is static and cannot be changed later.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How do you denote a String Interpolation in C#?",
    "options": [
      "Prefixing the string with '@'",
      "Prefixing the string with '$'",
      "Using the '{0}' placeholders inside the string",
      "Using the '+' operator between strings"
    ],
    "answer": "Prefixing the string with '$'",
    "explanation": "String interpolation is identified by the '$' sign, allowing you to embed expressions (like {variable}) directly into a string literal.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which constraint can you apply to a Generic type parameter to ensure it only accepts value types?",
    "options": [
      "where T : class",
      "where T : struct",
      "where T : new()",
      "where T : interface"
    ],
    "answer": "where T : struct",
    "explanation": "The 'struct' constraint restricts the generic type parameter to value types. The 'class' constraint restricts it to reference types.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the difference between '==' and .Equals() when comparing strings in C#?",
    "options": [
      "== compares references, .Equals() compares values",
      "There is no difference, they function identically for strings",
      "== performs a case-insensitive comparison",
      ".Equals() throws an exception if the string is null"
    ],
    "answer": "There is no difference, they function identically for strings",
    "explanation": "For the String class in C#, the '==' operator is overloaded to compare the content (values) of the strings, making it functionally equivalent to calling the .Equals() method.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which construct allows you to encapsulate a block of code that might throw an exception?",
    "options": [
      "using block",
      "checked block",
      "try-catch block",
      "unsafe block"
    ],
    "answer": "try-catch block",
    "explanation": "The 'try-catch' block is the fundamental exception handling construct; 'try' contains the code that might fail, and 'catch' handles the specific exception if it occurs.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the 'base' keyword used for?",
    "options": [
      "To call a method on the parent class from the derived class",
      "To reference the current instance of the class",
      "To define a base class for inheritance",
      "To convert a derived class to its parent type"
    ],
    "answer": "To call a method on the parent class from the derived class",
    "explanation": "The 'base' keyword is used to access members of the base class from within a derived class, commonly used to call base class constructors or overridden methods.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "In a property declaration, which keyword allows you to define logic that runs when a value is retrieved?",
    "options": [
      "set",
      "value",
      "get",
      "init"
    ],
    "answer": "get",
    "explanation": "The 'get' accessor defines the logic for returning the property value to the caller. The 'set' accessor defines logic for assigning a value.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the primary function of the 'params' keyword in a method parameter?",
    "options": [
      "It passes a reference to the variable",
      "It allows the method to accept a variable number of arguments",
      "It makes the parameter optional",
      "It ensures the parameter is passed by value"
    ],
    "answer": "It allows the method to accept a variable number of arguments",
    "explanation": "The 'params' keyword lets you specify a method parameter that takes a variable number of arguments, effectively creating an array of the specified type.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which namespace contains the fundamental classes and base types for C#?",
    "options": [
      "System",
      "Microsoft.CSharp",
      "System.Collections",
      "Global"
    ],
    "answer": "System",
    "explanation": "The 'System' namespace contains fundamental classes and base classes that define commonly-used value and reference data types, events and interfaces, and attributes.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What does the 'as' operator do if the cast fails?",
    "options": [
      "It throws an InvalidCastException",
      "It returns the default value of the type",
      "It returns null",
      "It returns 0"
    ],
    "answer": "It returns null",
    "explanation": "Unlike a standard cast which throws an exception, the 'as' operator returns null if the conversion is not possible.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which property of the Array class returns the number of dimensions of the array?",
    "options": [
      "Count",
      "Size",
      "Rank",
      "Length"
    ],
    "answer": "Rank",
    "explanation": "The 'Rank' property returns the number of dimensions in an array (e.g., 1 for a single array, 2 for a rectangular array). Length returns the total number of elements.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which of the following is true regarding a 'readonly' field?",
    "options": [
      "It can only be assigned in a static constructor",
      "It must be initialized at compile time",
      "It can only be assigned during declaration or in the constructor",
      "It prevents the object reference from being changed"
    ],
    "answer": "It can only be assigned during declaration or in the constructor",
    "explanation": "A 'readonly' field can be assigned a value only at declaration or in the constructor of the class, after which it cannot be modified.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is a Lambda Expression in C#?",
    "options": [
      "A method that has no return type",
      "An anonymous function used to create delegates or expression tree types",
      "A specific type of exception",
      "A loop structure for iterating collections"
    ],
    "answer": "An anonymous function used to create delegates or expression tree types",
    "explanation": "A lambda expression is a concise way to define an anonymous function using the '=>' syntax, often used in LINQ queries and event handlers.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which method of the String class is best suited to determine if a string ends with a specific substring?",
    "options": [
      "Substring",
      "IndexOf",
      "EndsWith",
      "Contains"
    ],
    "answer": "EndsWith",
    "explanation": "The 'EndsWith' method specifically checks if the string instance ends with the specified character or string.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the 'this' keyword used for in a class constructor?",
    "options": [
      "To refer to the static members of the class",
      "To call another constructor within the same class",
      "To inherit from a base class",
      "To reference the parent namespace"
    ],
    "answer": "To call another constructor within the same class",
    "explanation": "When used as 'this(...)', it invokes another constructor from the same class, allowing for constructor chaining to avoid code duplication.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which interface defines a method to compare two objects?",
    "options": [
      "IEnumerable",
      "IComparable",
      "IDisposable",
      "ICloneable"
    ],
    "answer": "IComparable",
    "explanation": "The 'IComparable' interface defines a generalized comparison method, 'CompareTo', which a value type or class implements to create a type-specific comparison method.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the output of Console.WriteLine(\"{0:C}\", 1234); in the en-US culture?",
    "options": [
      "1234",
      "1234.00",
      "$1,234.00",
      "1,234"
    ],
    "answer": "$1,234.00",
    "explanation": "The 'C' format specifier stands for 'Currency', formatting the number as a currency string with the appropriate symbol and separators based on the culture.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary purpose of the 'volatile' keyword in C#?",
    "options": [
      "It prevents the compiler from optimizing the variable and ensures reads/writes occur directly in memory.",
      "It makes the variable immutable after it has been assigned a value.",
      "It allows a variable to be stored in the CPU cache for faster access.",
      "It indicates that the variable can be implicitly converted to any type."
    ],
    "answer": "It prevents the compiler from optimizing the variable and ensures reads/writes occur directly in memory.",
    "explanation": "The 'volatile' keyword indicates that a field might be modified by multiple threads concurrently. It disables certain compiler optimizations to ensure the most up-to-date value is always read from and written to memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which statement accurately describes the difference between 'IEnumerable' and 'IQueryable' in LINQ?",
    "options": [
      "'IEnumerable' executes queries on the client-side, while 'IQueryable' executes queries on the server-side (e.g., database).",
      "'IEnumerable' is used for querying databases, while 'IQueryable' is used for in-memory collections.",
      "'IEnumerable' supports deferred execution, whereas 'IQueryable' executes immediately.",
      "'IEnumerable' requires a database connection, while 'IQueryable' does not."
    ],
    "answer": "'IEnumerable' executes queries on the client-side, while 'IQueryable' executes queries on the server-side (e.g., database).",
    "explanation": "'IQueryable' extends 'IEnumerable' and implements expression trees to translate LINQ queries into a native query language (like SQL) for the provider. 'IEnumerable' performs the logic in-memory after fetching all data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When using the 'async/await' pattern, what is the consequence of using 'async void' instead of 'async Task' for a method?",
    "options": [
      "Exceptions thrown inside the method cannot be caught by the caller and will crash the application.",
      "The method will run synchronously and block the calling thread.",
      "The method cannot use the 'await' keyword.",
      "The compiler will throw a syntax error because 'void' is not allowed."
    ],
    "answer": "Exceptions thrown inside the method cannot be caught by the caller and will crash the application.",
    "explanation": "'async void' methods are used primarily for event handlers; errors propagate directly to the synchronization context, making them uncatchable by external try/catch blocks. 'async Task' allows exceptions to be caught by the caller.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of Generics, what is the 'default' keyword used for?",
    "options": [
      "To return the default value of the specified generic type parameter.",
      "To specify a default constructor constraint for the generic type.",
      "To set a default value for a specific property in a generic class.",
      "To override the default implementation of an interface method."
    ],
    "answer": "To return the default value of the specified generic type parameter.",
    "explanation": "The 'default(T)' (or 'default' expression) returns null for reference types and zero for value types, regardless of what 'T' represents. This is useful when the specific type is unknown.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What characterizes a 'ValueTuple' compared to the legacy 'Tuple' class in C#?",
    "options": [
      "ValueTuples are value types (structs) and are mutable, whereas Tuples are reference types (classes) and immutable.",
      "ValueTuples are immutable and stored on the heap, whereas Tuples are mutable and stored on the stack.",
      "ValueTuples require specific type definitions at compile time, whereas Tuples are dynamic.",
      "ValueTuples cannot be used as return types for async methods."
    ],
    "answer": "ValueTuples are value types (structs) and are mutable, whereas Tuples are reference types (classes) and immutable.",
    "explanation": "System.ValueTuple is a lightweight struct, offering better performance and mutable semantics compared to the System.Tuple class, which is a heap-allocated reference type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the 'yield return' statement affect the execution flow of a method?",
    "options": [
      "It transforms the method into a state machine, returning elements one at a time as requested by the enumerator.",
      "It forces the method to execute synchronously and return a complete list immediately.",
      "It pauses the application until all elements in the collection are processed.",
      "It returns the first element and terminates the method immediately."
    ],
    "answer": "It transforms the method into a state machine, returning elements one at a time as requested by the enumerator.",
    "explanation": "'yield return' creates an iterator block. The compiler generates a state machine that preserves the method's local state between iterations, allowing lazy evaluation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the result of calling a 'Task' method with the 'ConfigureAwait(false)' flag?",
    "options": [
      "It attempts to marshal the continuation back to the original capture context or falls back to the thread pool.",
      "It forces the continuation to run on the UI thread regardless of the calling context.",
      "It disables task cancellation and ensures the task runs to completion.",
      "It creates a deadlock by preventing the synchronization context from resuming."
    ],
    "answer": "It attempts to marshal the continuation back to the original capture context or falls back to the thread pool.",
    "explanation": "'ConfigureAwait(false)' tells the runtime that it does not need to capture the current SynchronizationContext (like the UI context), allowing the code to run on a thread pool thread and potentially improving performance or avoiding deadlocks in library code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which constraint ensures that a generic type argument has a parameterless constructor?",
    "options": [
      "where T : new()",
      "where T : struct",
      "where T : class",
      "where T : base()"
    ],
    "answer": "where T : new()",
    "explanation": "The 'new()' constraint specifies that the type argument 'T' must have a public parameterless constructor. This allows 'new T()' to be instantiated within the generic class or method.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the behavior of the '??=' (null-coalescing assignment) operator introduced in C# 8.0?",
    "options": [
      "It assigns the value of the right-hand operand to the left-hand operand only if the left-hand operand evaluates to null.",
      "It assigns the value of the left-hand operand to the right-hand operand if the left-hand operand is null.",
      "It checks if both operands are null and throws an exception.",
      "It performs a bitwise assignment only if the variable is not null."
    ],
    "answer": "It assigns the value of the right-hand operand to the left-hand operand only if the left-hand operand evaluates to null.",
    "explanation": "The '??=' operator is a syntactic shorthand for 'if (left is null) { left = right; }'. It simplifies code where a variable needs initialization only if it is currently null.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Why is 'String' a reference type but behaves somewhat like a value type in C#?",
    "options": [
      "Strings are immutable; modifying a string creates a new object in memory rather than changing the existing instance.",
      "Strings are actually stored on the stack, just like value types.",
      "The CLR automatically boxes string objects during comparisons.",
      "Strings use copy-on-write semantics to simulate value behavior."
    ],
    "answer": "Strings are immutable; modifying a string creates a new object in memory rather than changing the existing instance.",
    "explanation": "Because strings cannot be changed after creation, passing them 'by value' copies the reference, but operations that seem to modify them actually create new strings, mimicking the semantic safety often associated with value types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is 'covariance' in the context of generic interfaces and delegates?",
    "options": [
      "It allows a generic type parameter to be treated as a more derived type than originally specified.",
      "It allows a generic type parameter to be treated as a less derived type than originally specified.",
      "It restricts the generic type to only value types.",
      "It enforces strict type checking at runtime only."
    ],
    "answer": "It allows a generic type parameter to be treated as a more derived type than originally specified.",
    "explanation": "Covariance (keyword 'out') enables implicit conversion from a less derived type to a more derived type, typically used for return types in interfaces like `IEnumerable<out T>`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which C# feature allows you to define a method body for a member of an interface without requiring an implementing class to provide an implementation?",
    "options": [
      "Default Interface Implementations (C# 8.0)",
      "Abstract Base Classes",
      "Extension Methods",
      "Partial Methods"
    ],
    "answer": "Default Interface Implementations (C# 8.0)",
    "explanation": "Default interface methods allow developers to add methods to an interface with a concrete implementation. This lets classes implement the interface automatically without breaking existing code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "In LINQ, what is the difference between the 'Select' and 'SelectMany' operators?",
    "options": [
      "'Select' projects a one-to-one sequence, while 'SelectMany' projects a one-to-many sequence and flattens the results.",
      "'Select' returns a scalar value, while 'SelectMany' returns an IEnumerable.",
      "'Select' performs filtering, while 'SelectMany' performs projection.",
      "'Select' can only be used on Lists, while 'SelectMany' is used on Arrays."
    ],
    "answer": "'Select' projects a one-to-one sequence, while 'SelectMany' projects a one-to-many sequence and flattens the results.",
    "explanation": "'Select' is used for simple transformation/projection. 'SelectMany' is used when each element results in a sequence, and you want to merge all those resulting sequences into a single flat list.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the primary risk associated with 'lock(this)' in a C# class?",
    "options": [
      "It exposes the lock object to external code, increasing the risk of deadlocks if external code locks on the same instance.",
      "It uses a spin-wait mechanism that consumes high CPU resources.",
      "It prevents the Garbage Collector from collecting the object.",
      "It throws an exception if the thread is already in a different lock context."
    ],
    "answer": "It exposes the lock object to external code, increasing the risk of deadlocks if external code locks on the same instance.",
    "explanation": "Using 'this' or a public object as a lock allows code outside the class to acquire the same lock, potentially causing concurrency issues or deadlocks. Best practice is to use a private, read-only object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the 'IDisposable' interface primarily used for in C#?",
    "options": [
      "To release unmanaged resources explicitly and deterministically.",
      "To implement automatic memory management for managed objects.",
      "To serialize objects to a binary format.",
      "To ensure that objects are always passed by reference."
    ],
    "answer": "To release unmanaged resources explicitly and deterministically.",
    "explanation": "The 'IDisposable' interface provides a 'Dispose' method for releasing unmanaged resources (like file handles or database connections) immediately, rather than waiting for the Garbage Collector to finalize the object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What happens when a struct is passed to a method without using the 'ref' keyword?",
    "options": [
      "A copy of the struct is created and passed to the method.",
      "A reference to the struct is passed, allowing changes to affect the original.",
      "The struct is boxed into an object before being passed.",
      "The method call will fail to compile because structs must be passed by reference."
    ],
    "answer": "A copy of the struct is created and passed to the method.",
    "explanation": "Structs are value types. By default, they are passed by value, meaning a full copy of the data is made. Modifications inside the method do not affect the original struct.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is the function of the 'nameof' operator?",
    "options": [
      "It returns the string literal name of a variable, type, or member at compile time.",
      "It returns the runtime type name of an object.",
      "It retrieves the value associated with a specific configuration key.",
      "It determines the size in bytes of a specific type."
    ],
    "answer": "It returns the string literal name of a variable, type, or member at compile time.",
    "explanation": "'nameof' is a compile-time constant that resolves to the name of the symbol, reducing magic strings and ensuring refactoring safety (e.g., raising exceptions with the correct variable name).",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the output of 'Console.WriteLine(string.Join(\",\", new List<int> { 1, 2, 3 }.Where(x => x > 1)))'?",
    "options": [
      "2,3",
      "1,2,3",
      "System.Linq.Enumerable+WhereListIterator",
      "False"
    ],
    "answer": "2,3",
    "explanation": "LINQ 'Where' filters the collection, returning 2 and 3. The generic parameters are inferred. The result is an IEnumerable that 'string.Join' enumerates and joins.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "In C#, what is a 'closure' within the context of lambda expressions?",
    "options": [
      "A function combined with its surrounding environment, allowing the lambda to access variables from the outer scope.",
      "A mechanism to restrict access to private class members.",
      "A method that terminates its own execution immediately.",
      "A keyword used to seal a class from inheritance."
    ],
    "answer": "A function combined with its surrounding environment, allowing the lambda to access variables from the outer scope.",
    "explanation": "Closures occur when a lambda captures variables defined in an outer method. The compiler generates a class to hold these captured variables so they persist beyond the original method's scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How does the 'as' operator differ from explicit casting?",
    "options": [
      "'as' returns null if the conversion fails, whereas explicit casting throws an InvalidCastException.",
      "'as' throws an exception if the conversion fails, whereas explicit casting returns null.",
      "'as' is used for value types, whereas explicit casting is used for reference types.",
      "'as' performs a data type conversion, whereas explicit casting changes the object reference."
    ],
    "answer": "'as' returns null if the conversion fails, whereas explicit casting throws an InvalidCastException.",
    "explanation": "The 'as' operator is used for safe reference type or nullable conversions. If the object is not compatible, it yields null instead of throwing an exception, making it useful for conditional checks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What does the 'ref struct' declaration enforce?",
    "options": [
      "The struct must be allocated on the stack and cannot escape to the heap.",
      "The struct is passed by reference to all methods by default.",
      "The struct can only contain reference type fields.",
      "The struct is immutable and read-only."
    ],
    "answer": "The struct must be allocated on the stack and cannot escape to the heap.",
    "explanation": "Ref structs are stack-only types introduced to support high-performance scenarios like 'Span' and 'ReadOnlySpan'. They cannot be boxed, assigned to variables of type 'object', or stored in arrays.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the purpose of 'Pattern Matching' with the 'is' operator in C#?",
    "options": [
      "It allows checking a variable's type and assigning it to a new variable in a single step.",
      "It compiles regular expressions for string matching.",
      "It verifies if two objects refer to the same memory address.",
      "It overrides the 'Equals' method for custom classes."
    ],
    "answer": "It allows checking a variable's type and assigning it to a new variable in a single step.",
    "explanation": "Pattern matching (e.g., `if (obj is MyClass mc)`) tests if 'obj' is an instance of 'MyClass' and casts it to 'mc' if true, all within a concise syntax.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What characterizes 'IAsyncEnumerable' compared to 'IEnumerable'?",
    "options": [
      "It allows for asynchronous iteration over data streams, avoiding blocking the caller.",
      "It enumerates data faster by using parallel processing.",
      "It provides thread safety for concurrent access to the collection.",
      "It automatically caches results to improve performance."
    ],
    "answer": "It allows for asynchronous iteration over data streams, avoiding blocking the caller.",
    "explanation": "Unlike 'IEnumerable', which requires synchronous fetching of elements, 'IAsyncEnumerable' enables 'await foreach', allowing code to read data as it arrives (like from a database or network) without blocking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the result of 'unchecked { int x = int.MaxValue + 1; }' in C#?",
    "options": [
      "x becomes int.MinValue due to arithmetic overflow wrapping.",
      "A System.OverflowException is thrown.",
      "The code fails to compile.",
      "x becomes null."
    ],
    "answer": "x becomes int.MinValue due to arithmetic overflow wrapping.",
    "explanation": "The 'unchecked' keyword suppresses overflow checking. By default, C# allows integer overflow to wrap around, so MaxValue + 1 results in MinValue.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which statement correctly describes 'Span' in C#?",
    "options": [
      "It is a type-safe view of a contiguous region of memory that is stack-only.",
      "It represents a resizable array on the heap.",
      "It is a wrapper around Task objects for better performance.",
      "It is used to enforce immutability on reference types."
    ],
    "answer": "It is a type-safe view of a contiguous region of memory that is stack-only.",
    "explanation": "Span provides a way to work with arrays, strings, or stack-allocated memory without copying data. It is a ref struct and cannot escape the stack to the heap.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the 'finally' block in exception handling used for?",
    "options": [
      "To execute code regardless of whether an exception occurs or not, typically for cleanup.",
      "To catch specific exceptions that were not handled in the 'catch' block.",
      "To re-throw the exception after logging it.",
      "To define the code that runs only if no exception is thrown."
    ],
    "answer": "To execute code regardless of whether an exception occurs or not, typically for cleanup.",
    "explanation": "The 'finally' block is guaranteed to run after 'try' and 'catch' execute. It is the standard place for releasing resources or closing connections.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "How does the 'init' accessor (C# 9.0) differ from 'set'?",
    "options": [
      "'init' allows the property to be set only during object construction, whereas 'set' allows modification at any time.",
      "'init' can only be used in static classes.",
      "'init' throws an exception if the value is null.",
      "'init' is faster than 'set' because it bypasses the CLR."
    ],
    "answer": "'init' allows the property to be set only during object construction, whereas 'set' allows modification at any time.",
    "explanation": "The 'init' accessor enables immutable property semantics, allowing values to be assigned during object initialization (constructor or object initializer syntax) but preventing subsequent changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the behavior of the 'Polymorphism' principle in Object-Oriented Programming?",
    "options": [
      "It allows methods to perform different actions based on the object's runtime type.",
      "It restricts a class to have only one parent class.",
      "It forces classes to implement all methods of an interface.",
      "It hides the implementation details of a class."
    ],
    "answer": "It allows methods to perform different actions based on the object's runtime type.",
    "explanation": "Polymorphism allows derived classes to provide a specific implementation of a method defined in a base class (virtual/override), enabling behavior to depend on the actual instance type at runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which C# feature allows you to implement multiple interfaces with the same method name differently?",
    "options": [
      "Explicit Interface Implementation",
      "Abstract Class Inheritance",
      "Method Overloading",
      "Partial Classes"
    ],
    "answer": "Explicit Interface Implementation",
    "explanation": "Explicit interface implementation (e.g., `void IDisposable.Dispose()`) allows a class to define a specific method for an interface without exposing it in the public class scope, resolving name collisions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the primary purpose of the 'Unsafe' class in C#?",
    "options": [
      "To perform low-level pointer operations that bypass safety checks for high-performance scenarios.",
      "To disable the Garbage Collector for specific objects.",
      "To allow code execution outside the Common Language Runtime (CLR).",
      "To allocate unmanaged memory on the stack only."
    ],
    "answer": "To perform low-level pointer operations that bypass safety checks for high-performance scenarios.",
    "explanation": "The 'Unsafe' class provides methods for pointer arithmetic and memory manipulation without runtime bounds checking, useful for optimizing hot paths in managed code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is 'Race Condition' in the context of multithreading?",
    "options": [
      "An error where the system's behavior depends on the relative timing of threads accessing shared data.",
      "A situation where two threads are blocked waiting for each other to release resources.",
      "A state where the CPU core overheats due to excessive looping.",
      "A feature that allows threads to compete for resources to improve throughput."
    ],
    "answer": "An error where the system's behavior depends on the relative timing of threads accessing shared data.",
    "explanation": "Race conditions occur when the outcome of software depends on the unpredictable order of execution of concurrent threads, leading to incorrect results or data corruption without synchronization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In Entity Framework Core, what does the 'Attach' method do?",
    "options": [
      "It begins tracking an entity in the 'Unchanged' state, effectively 'docking' it to the context without database queries.",
      "It executes a SQL INSERT command immediately.",
      "It deletes the entity from the database.",
      "It creates a duplicate copy of the entity in memory."
    ],
    "answer": "It begins tracking an entity in the 'Unchanged' state, effectively 'docking' it to the context without database queries.",
    "explanation": "Attach connects a disconnected entity graph to the context assuming it already exists in the database (Unchanged state), preventing the context from fetching it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the result of casting a double value '3.9' to an integer type 'int'?",
    "options": [
      "3",
      "4",
      "0",
      "A runtime exception is thrown."
    ],
    "answer": "3",
    "explanation": "When casting a floating-point type to an integer, C# truncates the decimal part. It does not round; it simply discards the .9.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is a 'Primary Constructor' introduced in C# 12?",
    "options": [
      "A concise syntax for declaring a class constructor and its parameters directly in the class definition.",
      "A constructor that is called before all other constructors in the inheritance chain.",
      "A static constructor that runs automatically before any static members are accessed.",
      "A parameterless constructor automatically generated by the compiler."
    ],
    "answer": "A concise syntax for declaring a class constructor and its parameters directly in the class definition.",
    "explanation": "Primary constructors (e.g., `class Person(string Name)`) eliminate the need for a separate constructor block and explicit field assignments, simplifying boilerplate code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is the 'Record' type in C# primarily designed for?",
    "options": [
      "Defining immutable data models with built-in value-based equality.",
      "Creating mutable database entities.",
      "Defining interfaces for asynchronous operations.",
      "Handling exceptions and error logging."
    ],
    "answer": "Defining immutable data models with built-in value-based equality.",
    "explanation": "Records are a reference type designed for data-centric scenarios. They offer concise syntax for immutable properties and use value-based equality (comparing content rather than object reference).",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In C#, generic interfaces and delegates support covariance and contravariance. Which constraint must a variant type parameter satisfy to be declared as 'out' (covariant)?",
    "options": [
      "The type parameter must only appear as a method return type or property getter, and never as an input argument",
      "The type parameter must be a value type or sealed reference type",
      "The type parameter must implement the IComparable interface",
      "The type parameter must be used only in method arguments and never in return types"
    ],
    "answer": "The type parameter must only appear as a method return type or property getter, and never as an input argument",
    "explanation": "Covariance (out) allows a more derived type to be used than the type parameter specified, but requires the parameter is used only as an output (return). Using it as an input (contravariant position) would break type safety.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary technical distinction between `IEnumerable` and `IQueryable` regarding LINQ query execution?",
    "options": [
      "`IEnumerable` executes queries in-memory using LINQ to Objects, while `IQueryable` builds an expression tree to be executed by an external provider (e.g., a database)",
      "`IEnumerable` supports deferred execution, while `IQueryable` executes queries immediately",
      "`IEnumerable` is strictly for querying SQL databases, while `IQueryable` is for in-memory collections",
      "`IQueryable` requires all data to be loaded into memory before filtering, unlike `IEnumerable`"
    ],
    "answer": "`IEnumerable` executes queries in-memory using LINQ to Objects, while `IQueryable` builds an expression tree to be executed by an external provider (e.g., a database)",
    "explanation": "`IQueryable` inherits from `IEnumerable` but captures the expression tree to pass to a specific query provider (like Entity Framework), allowing query translation (e.g., to SQL) and server-side execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "When using `ValueTask` in C# instead of `Task`, what is the specific performance optimization mechanism that `ValueTask` employs?",
    "options": [
      "It reduces heap allocations by wrapping a `Task` or an `IValueTaskSource` to avoid allocation for asynchronous operations that complete synchronously",
      "It eliminates the need for `await` by executing the lambda expression on the calling thread",
      "It automatically converts the method to a blocking call using `GetAwaiter().GetResult()`",
      "It stores the result on the stack exclusively, never using the managed heap"
    ],
    "answer": "It reduces heap allocations by wrapping a `Task` or an `IValueTaskSource` to avoid allocation for asynchronous operations that complete synchronously",
    "explanation": "`ValueTask` is a struct, meaning it avoids the allocation of a `Task` object on the heap if the operation completes synchronously or is re-used from a pool, improving throughput in high-throughput scenarios.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Why are C# `ref struct` types, introduced in C# 7.2, restricted from being boxed or assigned to variables of type `object`, `dynamic`, or interfaces?",
    "options": [
      "They are stack-only types that cannot escape the stack frame because they may contain references to the stack (stackalloc or by-ref fields)",
      "They are implicitly immutable and therefore cannot be cast to other types",
      "They are specific to the IL interpreter and do not support reflection",
      "They require a garbage collector finalizer to clean up memory"
    ],
    "answer": "They are stack-only types that cannot escape the stack frame because they may contain references to the stack (stackalloc or by-ref fields)",
    "explanation": "A `ref struct` can only live on the stack. Boxing would require it to move to the heap, which is unsafe if it contains references to stack memory (like a `Span`), or if the object is accessed after the stack frame unwinds.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the specific behavior of exceptions thrown within an `async void` method in C#, compared to an `async Task` method?",
    "options": [
      "They are captured directly to the `SynchronizationContext` and cannot be caught by standard `try-catch` blocks in the calling method",
      "They are automatically swallowed by the runtime to prevent application crashes",
      "They are converted into an `AggregateException`",
      "They cause a compilation error because async methods must return a `Task`"
    ],
    "answer": "They are captured directly to the `SynchronizationContext` and cannot be caught by standard `try-catch` blocks in the calling method",
    "explanation": "Unlike `async Task` where the exception is stored in the returned Task object, `async void` exceptions propagate directly to the thread's synchronization context (often crashing the process) and cannot be awaited or caught by the caller.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "In C# 5.0 and later, how does the `foreach` loop handle lambda expressions that capture the loop variable during iteration?",
    "options": [
      "The loop variable is logically treated as declared *inside* the loop, so each closure captures a unique instance per iteration",
      "All closures share the same variable instance, resulting in all lambdas capturing the final value of the loop",
      "The compiler forces the variable to be `readonly` to prevent modification",
      "Lambda expressions are not allowed within `foreach` loops"
    ],
    "answer": "The loop variable is logically treated as declared *inside* the loop, so each closure captures a unique instance per iteration",
    "explanation": "Prior to C# 5.0, the loop variable was closed over by reference, leading to the classic closure bug. Since C# 5.0, the compiler generates a new variable instance per iteration to capture the correct value.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the exact purpose of the `volatile` keyword in C#?",
    "options": [
      "It indicates that a field might be modified by multiple threads, preventing compiler optimizations that assume single-threaded access and ensuring acquire/release semantics",
      "It locks the variable, making it thread-safe for read-write operations",
      "It forces the variable to be stored in CPU registers rather than RAM",
      "It marks the variable for garbage collection as soon as possible"
    ],
    "answer": "It indicates that a field might be modified by multiple threads, preventing compiler optimizations that assume single-threaded access and ensuring acquire/release semantics",
    "explanation": "`volatile` ensures the most up-to-date value is read/written from memory (preventing caching). It provides a 'half-fence' (acquire on read, release on write) but does not replace a full lock for complex operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In the context of C# Generics, how are static members handled for different closed type instantiations of the same generic type?",
    "options": [
      "Each distinct type argument combination results in a separate static field storage for the generic type",
      "Static members are shared across all generic instantiations of the type",
      "Static members are initialized only once for the open generic type definition",
      "Static members cannot be defined within generic types"
    ],
    "answer": "Each distinct type argument combination results in a separate static field storage for the generic type",
    "explanation": "Static fields are specific to the closed type. `MyClass<int>.StaticField` and `MyClass<string>.StaticField` hold distinct values because they belong to two completely different runtime types.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the specific effect of calling `ConfigureAwait(false)` on a `Task` in an asynchronous method?",
    "options": [
      "It signals that the continuation does not need to marshal back to the original synchronization context, potentially reducing context switching overhead",
      "It forces the task to run synchronously on the calling thread",
      "It instructs the garbage collector to collect the task immediately",
      "It prevents the task from being cancelled"
    ],
    "answer": "It signals that the continuation does not need to marshal back to the original synchronization context, potentially reducing context switching overhead",
    "explanation": "`ConfigureAwait(true)` (the default) attempts to capture and resume on the captured context (like the UI thread). Passing `false` optimizes performance by allowing the continuation to run on a thread pool thread.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the purpose of the `stackalloc` keyword in C#?",
    "options": [
      "It allocates a block of memory on the stack that must be of a primitive type or a struct, without involving the garbage collector",
      "It allocates memory on the heap for value types to improve cache locality",
      "It creates a new stack frame for the current method execution",
      "It automatically converts a managed struct into an unmanaged pointer"
    ],
    "answer": "It allocates a block of memory on the stack that must be of a primitive type or a struct, without involving the garbage collector",
    "explanation": "`stackalloc` is used for high-performance scenarios to create a `Span` or pointer to a stack-allocated buffer. The memory is automatically discarded when the method returns, avoiding GC pressure.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "When implementing a custom `IEnumerable` that returns an `IEnumerator` created with `yield return`, how does the compiler handle state machine implementation?",
    "options": [
      "It generates a private nested struct or class that implements `IEnumerator` and stores the local variables and state position as fields",
      "It converts the method into a lambda expression and runs it in a separate thread",
      "It stores all generated values in a temporary list before returning the enumerator",
      "It utilizes the `IAsyncEnumerable` interface implicitly to enable streaming"
    ],
    "answer": "It generates a private nested struct or class that implements `IEnumerator` and stores the local variables and state position as fields",
    "explanation": "The iterator state machine is automatically generated. It preserves the state of local variables across `MoveNext()` calls, allowing the function to pause and resume execution without explicit manual state management.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In the C# Memory Model, what does the `Interlocked` class provide?",
    "options": [
      "Atomic operations that perform reads, writes, and increments on variables shared by multiple threads without explicit locks",
      "A mechanism to lock the entire application heap",
      "A collection of static methods for debugging multi-threaded applications",
      "The logic required to implement spin-wait loops indefinitely"
    ],
    "answer": "Atomic operations that perform reads, writes, and increments on variables shared by multiple threads without explicit locks",
    "explanation": "The `Interlocked` class (e.g., `Interlocked.Increment`, `Interlocked.CompareExchange`) uses CPU-level instructions (like `LOCK CMPXCHG`) to guarantee atomicity and memory barriers without the overhead of Monitor locks.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the primary reason to use a `struct` instead of a `class` in C#?",
    "options": [
      "To improve performance for small, short-lived objects by allocating on the stack rather than the heap, avoiding garbage collection overhead",
      "To enable inheritance from multiple base types",
      "To ensure the object is always passed by reference",
      "To allow the object to contain virtual methods by default"
    ],
    "answer": "To improve performance for small, short-lived objects by allocating on the stack rather than the heap, avoiding garbage collection overhead",
    "explanation": "Structs are value types. While not always on the stack (e.g., boxed), they avoid heap allocation when local variables, reducing GC pressure. However, they are copied by value, so large structs hurt performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "When using `Expression<Func<T>>` instead of `Func<T>` (delegate), what capability becomes available?",
    "options": [
      "The ability to inspect, modify, and translate the expression tree structure (e.g., to generate SQL queries)",
      "The ability to execute the function asynchronously",
      "The ability to enforce stricter type safety at compile time",
      "The ability to serialize the function definition to a binary format"
    ],
    "answer": "The ability to inspect, modify, and translate the expression tree structure (e.g., to generate SQL queries)",
    "explanation": "A delegate is executable code. An `Expression` is a data structure representing the code. This allows providers (like Entity Framework) to traverse the tree and convert C# logic into another language (SQL) for server-side execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the consequence of the 'Liskov Substitution Principle' violation regarding generic constraints in C#?",
    "options": [
      "It prevents a generic interface method from returning a derived type where a base type is expected without explicit variance declarations",
      "It allows a generic method to accept null values regardless of the type constraint",
      "It enables implicit conversion between different generic type arguments",
      "It forces the runtime to bypass type safety checks"
    ],
    "answer": "It prevents a generic interface method from returning a derived type where a base type is expected without explicit variance declarations",
    "explanation": "Without explicit `out`/`in` variance modifiers on generic interfaces, specific types like `List<string>` are invariant to `List<object>`. LSP dictates inheritance behavior, but C# defaults to strict invariance for type safety in generics.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "How does the `fixed` statement in C# interact with Garbage Collection (GC)?",
    "options": [
      "It pins the managed variable in memory, preventing the GC from moving it during the execution of the statement",
      "It permanently fixes the memory address of the variable for the lifetime of the application",
      "It instructs the GC to immediately collect the object after the fixed block",
      "It converts the managed variable into an unmanaged global variable"
    ],
    "answer": "It pins the managed variable in memory, preventing the GC from moving it during the execution of the statement",
    "explanation": "Pointers require a stable memory address. The GC normally compacts memory (moving objects). The `fixed` keyword 'pins' the variable to a specific address so the pointer remains valid.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the specific technical role of `SynchronizationContext` in ASP.NET Core applications regarding `async/await`?",
    "options": [
      "ASP.NET Core sets `SynchronizationContext` to null, allowing continuations to run on the thread pool thread that completed the task without context switching",
      "It ensures all continuations run on the main UI thread",
      "It serializes all incoming requests to run on a single dedicated thread",
      "It captures the current HttpContext and passes it to the background thread"
    ],
    "answer": "ASP.NET Core sets `SynchronizationContext` to null, allowing continuations to run on the thread pool thread that completed the task without context switching",
    "explanation": "Unlike UI frameworks (WinForms/WPF) or classic ASP.NET, ASP.NET Core does not use a custom `SynchronizationContext`. This optimizes throughput by avoiding unnecessary marshalling back to the request thread.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the context of string manipulation, why is `string` considered immutable in C#?",
    "options": [
      "Any operation that appears to modify a string actually returns a new string instance, leaving the original unchanged",
      "Strings are stored in a read-only segment of the assembly file",
      "The `string` class is actually a struct that cannot be modified",
      "The Garbage Collector does not allow modification of existing string objects"
    ],
    "answer": "Any operation that appears to modify a string actually returns a new string instance, leaving the original unchanged",
    "explanation": "Immutability ensures thread safety for string references and allows for string interning. Operations like `Replace` or `ToUpper` allocate new memory for the result rather than changing the existing buffer.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the `protected internal` access modifier combination in C#?",
    "options": [
      "Access is limited to the current assembly or types derived from the containing class, regardless of assembly",
      "Access is limited to the current assembly only",
      "Access is limited to derived classes within the same assembly only",
      "Access is restricted to the current namespace and its children"
    ],
    "answer": "Access is limited to the current assembly or types derived from the containing class, regardless of assembly",
    "explanation": "`protected internal` is a union of both modifiers. It can be accessed by any code in the same assembly (internal) OR by any derived class in another assembly (protected).",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What differentiates `Enumerator` (Infinite Enumeration) from `IEnumerable` regarding early termination?",
    "options": [
      "`IAsyncEnumerable` allows the consumer to request cancellation via `CancellationToken` during iteration using `WithCancellation`",
      "`IEnumerable` automatically detects `NullReferenceException` to stop iteration",
      "`IAsyncEnumerable` runs on a background thread and must be manually aborted",
      "`IEnumerable` does not support the `break` statement in `foreach`"
    ],
    "answer": "`IAsyncEnumerable` allows the consumer to request cancellation via `CancellationToken` during iteration using `WithCancellation`",
    "explanation": "Asynchronous streams support cooperative cancellation. By passing a `CancellationToken` to `GetAsyncEnumerator` (or using `WithCancellation`), the data source can be instructed to stop generating data.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In a C# `record` type (reference semantics), what happens when you use the `with` expression?",
    "options": [
      "It creates a new instance of the record that is a shallow copy of the original, with specified properties modified",
      "It modifies the original instance's properties in place and returns the same reference",
      "It performs a deep copy of the object, including all nested reference types",
      "It creates a new struct value type equivalent to the record"
    ],
    "answer": "It creates a new instance of the record that is a shallow copy of the original, with specified properties modified",
    "explanation": "Records are primarily designed for immutable data. The `with` expression utilizes a protected copy constructor to clone the existing members and applies the specific modifications defined in the expression.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the result of boxing a `Nullable` instance where `HasValue` is `false`?",
    "options": [
      "The result is a `null` reference, not a boxed Nullable struct",
      "It results in an `InvalidOperationException` being thrown",
      "It boxes the underlying value type (e.g., 0 for int)",
      "It boxes the `HasValue` boolean property"
    ],
    "answer": "The result is a `null` reference, not a boxed Nullable struct",
    "explanation": "Boxing a null Nullable produces a null reference. Boxing a non-null Nullable boxes the underlying value type. This allows checking `boxedNullable == null` to be true.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "When comparing `float.NegativeInfinity` and `float.PositiveInfinity` in C#, what is the result of `float.NegativeInfinity > float.PositiveInfinity`?",
    "options": [
      "False",
      "True",
      "It throws an `ArithmeticException`",
      "It results in `NaN`"
    ],
    "answer": "False",
    "explanation": "Negative Infinity is mathematically smaller than Positive Infinity. Therefore, the operator `>` evaluates to false.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the specific function of the `Unsafe.As` method in C#?",
    "options": [
      "To cast a reference from one type to another without verifying type safety or performing validity checks, effectively reinterpreting the memory layout",
      "To force the garbage collector to treat memory as unmanaged",
      "To convert a managed array into a pointer",
      "To bypass the JIT compiler's optimization logic"
    ],
    "answer": "To cast a reference from one type to another without verifying type safety or performing validity checks, effectively reinterpreting the memory layout",
    "explanation": "`Unsafe.As` allows bypassing C# type casting rules. It does not emit a `castclass` IL instruction and effectively treats the bits of one type as another (e.g., casting a derived class to a base struct without boxing).",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "How does the `dynamic` keyword defer binding to runtime in C#?",
    "options": [
      "The compiler generates payload objects (CallSites) and DLR expressions that inspect the object at runtime to resolve the method call",
      "It compiles the code to IL that uses Reflection (`InvokeMethod`) for every dynamic call",
      "It re-runs the compiler at runtime to generate the specific method call",
      "It converts all dynamic variables to `object` and ignores type safety"
    ],
    "answer": "The compiler generates payload objects (CallSites) and DLR expressions that inspect the object at runtime to resolve the method call",
    "explanation": "The compiler emits code that utilizes the Dynamic Language Runtime (DLR). This involves a call site that performs runtime dispatch, potentially caching the result for subsequent calls.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the behavior of `Math.Round(2.5)` versus `Math.Round(3.5)` in C#?",
    "options": [
      "Both return `2` and `4` respectively, utilizing 'Banker's Rounding' (rounding to the nearest even number)",
      "Both return `3` and `4` respectively, utilizing 'Standard Rounding' (rounding away from zero)",
      "Both return `3` and `3` respectively, utilizing 'Floor Rounding'",
      "`Math.Round(2.5)` throws an `OverflowException`"
    ],
    "answer": "Both return `2` and `4` respectively, utilizing 'Banker's Rounding' (rounding to the nearest even number)",
    "explanation": "The default `MidpointRounding` mode in .NET is `ToEven`. This minimizes the accumulation of error in sums. 2.5 rounds to 2 (nearest even), 3.5 rounds to 4.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the purpose of the `in` modifier for method parameters in C#?",
    "options": [
      "It specifies that the argument is passed by reference but is read-only, preventing the method from modifying the value",
      "It specifies that the argument is passed by value",
      "It specifies that the argument must be initialized using object initializer syntax",
      "It allows the method to change the value of the parameter for the caller"
    ],
    "answer": "It specifies that the argument is passed by reference but is read-only, preventing the method from modifying the value",
    "explanation": "`in` provides the performance benefit of avoiding copies (by passing a reference) while enforcing compile-time safety to ensure the method does not write to that reference.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Which interface must be implemented to allow a C# class instance to be iterated over using the `foreach` statement?",
    "options": [
      "The class must implement the `IEnumerable` or `IEnumerable` interface explicitly, or have a `GetEnumerator` method returning an iterator",
      "The class must implement the `IAsyncEnumerable` interface",
      "The class must be a generic `List` or `Array`",
      "The class must implement the `IEnumerator` interface"
    ],
    "answer": "The class must implement the `IEnumerable` or `IEnumerable` interface explicitly, or have a `GetEnumerator` method returning an iterator",
    "explanation": "The `foreach` statement looks for a public `GetEnumerator` method (duck typing) or the `IEnumerable` interface. It does not require the class itself to be an `IEnumerator`.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What happens when an exception is thrown inside a LINQ query using deferred execution (e.g., `Select`)?",
    "options": [
      "The exception is thrown only when the query is iterated (e.g., in a `foreach` loop) and the specific element is processed",
      "The exception is thrown immediately when the query variable is defined",
      "The exception is caught and converted into an error element in the result sequence",
      "The query skips the element causing the exception and continues processing"
    ],
    "answer": "The exception is thrown only when the query is iterated (e.g., in a `foreach` loop) and the specific element is processed",
    "explanation": "LINQ queries use lazy evaluation. The lambda or logic is not executed until the query is materialized. Therefore, runtime exceptions associated with the data elements occur during iteration.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In the `IDisposable` pattern, what is the correct mechanism for a derived class to dispose of resources in C#?",
    "options": [
      "The derived class should override the protected `Dispose(bool disposing)` method and call `base.Dispose(disposing)`",
      "The derived class should implement `IDisposable` again and hide the base method",
      "The derived class should simply set resources to `null` in the destructor",
      "The derived class should call `GC.SuppressFinalize(this)` directly"
    ],
    "answer": "The derived class should override the protected `Dispose(bool disposing)` method and call `base.Dispose(disposing)`",
    "explanation": "The standard Dispose Pattern includes a virtual `Dispose(bool)` method. The derived class overrides this to clean its own resources, then calls the base implementation to ensure the full hierarchy is disposed of correctly.",
    "difficulty": "Advanced"
  }
]