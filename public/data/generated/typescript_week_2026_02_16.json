[
  {
    "id": 1,
    "question": "Which utility type makes all properties of a Type optional?",
    "options": [
      "Required<Type>",
      "Partial<Type>",
      "Readonly<Type>",
      "Nullable<Type>"
    ],
    "answer": "Partial<Type>",
    "explanation": "Partial constructs a type with all properties of Type set to optional. It is commonly used for update operations where not all fields are provided.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the primary difference between the `any` and `unknown` types?",
    "options": [
      "`any` is strictly typed while `unknown` allows arbitrary values",
      "`unknown` forces type checking before use, while `any` disables checking",
      "`any` cannot be assigned to other types, but `unknown` can",
      "`unknown` is deprecated in favor of `any`"
    ],
    "answer": "`unknown` forces type checking before use, while `any` disables checking",
    "explanation": "`unknown` is the type-safe counterpart of `any`. You must perform a type check or assertion to operate on an `unknown` value, whereas `any` allows any operation without error.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which keyword is used to enforce that a class adheres to a specific structure defined by an interface?",
    "options": [
      "extends",
      "implements",
      "inherits",
      "mixin"
    ],
    "answer": "implements",
    "explanation": "The `implements` keyword ensures a class meets the contract defined by an interface. `extends` is used for inheritance (classes or interfaces).",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "How does TypeScript perform type checking by default?",
    "options": [
      "Nominal typing (checking by explicit type names)",
      "Structural typing (checking by the shape of the value)",
      "Duck typing (only at runtime)",
      "Explicit typing (errors if types are not written)"
    ],
    "answer": "Structural typing (checking by the shape of the value)",
    "explanation": "TypeScript uses structural typing, meaning it matches types based on their members (shape), not their names. This allows one object to be used where another matching type is expected.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the result of using the `Readonly` utility type on an interface?",
    "options": [
      "All properties are removed from the type",
      "All properties are marked as optional",
      "All properties cannot be reassigned after initialization",
      "The object becomes immutable at runtime via JavaScript"
    ],
    "answer": "All properties cannot be reassigned after initialization",
    "explanation": "The `Readonly` utility type maps all properties of a type to be `readonly`. This prevents reassignment at compile-time, but does not affect runtime JavaScript behavior (it is stripped out).",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which syntax creates a type that represents a specific array with a fixed length and known types at each index?",
    "options": [
      "Array<Type>",
      "Type[]",
      "[Type1, Type2]",
      "FixedArray<Type, Length>"
    ],
    "answer": "[Type1, Type2]",
    "explanation": "Tuples are defined using square brackets with specific types, e.g., `[string, number]`. They enforce a specific length and type for each index.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does the `as` keyword signify in TypeScript?",
    "options": [
      "Type casting (Type Assertion)",
      "Creating a new variable",
      "Defining a generic constraint",
      "Importing a module"
    ],
    "answer": "Type casting (Type Assertion)",
    "explanation": "The `as` keyword is used for Type Assertions, telling the compiler to treat a value as a specific type. It bypasses the compiler's normal inference.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which operator extracts the keys of a Type as a union of string literal types?",
    "options": [
      "keys(Type)",
      "keyof Type",
      "values(Type)",
      "props(Type)"
    ],
    "answer": "keyof Type",
    "explanation": "The `keyof` operator produces a union of known property names of a type. It is the type-level equivalent of `Object.keys()`.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "When a function has a return type annotation of `void`, what does it imply?",
    "options": [
      "The function returns null",
      "The function returns undefined",
      "The function does not return a meaningful value",
      "The function is asynchronous"
    ],
    "answer": "The function does not return a meaningful value",
    "explanation": "`void` indicates the absence of a return type. While JavaScript functions implicitly return `undefined`, `void` signifies that the return value should not be used.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which utility type constructs a type by picking a set of properties Keys from Type?",
    "options": [
      "Pick<Type, Keys>",
      "Omit<Type, Keys>",
      "Extract<Type, Keys>",
      "Select<Type, Keys>"
    ],
    "answer": "Pick<Type, Keys>",
    "explanation": "`Pick` constructs a new type by selecting the specific `Keys` (string literal union) from the source `Type`. It reduces the surface area of an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What happens when you assign a value of type `string` to a variable of type `never`?",
    "options": [
      "TypeScript converts the string to never",
      "The code compiles but crashes at runtime",
      "TypeScript throws a compile-time error",
      "The string becomes undefined"
    ],
    "answer": "TypeScript throws a compile-time error",
    "explanation": "`never` represents a value that never occurs. Assigning any actual value to `never` is a type error, as `never` is the bottom type in TypeScript's type system.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which utility type creates a new type with all properties of Type set to required (removing optional modifiers)?",
    "options": [
      "Partial<Type>",
      "Required<Type>",
      "NonNullable<Type>",
      "Assert<Type>"
    ],
    "answer": "Required<Type>",
    "explanation": "`Required<Type>` constructs a type consisting of all properties of Type set to required. It is the opposite of `Partial`.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In TypeScript, two interfaces with the same name in the same scope will:",
    "options": [
      "Throw a duplicate identifier error",
      "Merge their members into a single definition",
      "Override the first definition with the second",
      "Create a namespace conflict"
    ],
    "answer": "Merge their members into a single definition",
    "explanation": "Interfaces support 'declaration merging'. If you define an interface multiple times, TypeScript merges their properties into a single definition.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the output type of `ReturnType<() => string>`?",
    "options": [
      "string",
      "() => string",
      "any",
      "unknown"
    ],
    "answer": "string",
    "explanation": "The `ReturnType` utility type extracts the return type of a function type. Since the function returns a string, the type is `string`.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which symbol is used to define a Union Type?",
    "options": [
      "&",
      "|",
      "||",
      "|||"
    ],
    "answer": "|",
    "explanation": "The pipe symbol (`|`) creates a Union Type, allowing a value to be one of several types (e.g., `string | number`). The ampersand (`&`) creates an Intersection Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the purpose of the `non-null` assertion operator (`!`) at the end of a variable?",
    "options": [
      "To convert the variable to a boolean",
      "To assert that the variable is not null or undefined",
      "To delete the variable",
      "To check if the variable is defined"
    ],
    "answer": "To assert that the variable is not null or undefined",
    "explanation": "The `!` operator tells the compiler to assume the expression preceding it is not `null` or `undefined`, removing the need for explicit null checks.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which utility type constructs a type by excluding Keys from Type?",
    "options": [
      "Pick<Type, Keys>",
      "Omit<Type, Keys>",
      "Exclude<Type, Keys>",
      "Ignore<Type, Keys>"
    ],
    "answer": "Omit<Type, Keys>",
    "explanation": "`Omit<Type, Keys>` creates a new type by picking all properties from Type and then removing the specified Keys. It is effectively `Pick<Type, Exclude<keyof Type, Keys>>`.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What does the `tsconfig.json` strict mode (`\"strict\": true`) enable?",
    "options": [
      "Only enables strict null checks",
      "Enables all strict type checking options (like noImplicitAny, strictNullChecks)",
      "Makes the compiler slower but more accurate",
      "Allows JavaScript files to be imported"
    ],
    "answer": "Enables all strict type checking options (like noImplicitAny, strictNullChecks)",
    "explanation": "Strict mode is a preset flag that enables a wide range of rigorous type-checking options simultaneously, ensuring the highest level of type safety.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which keyword allows you to define a type alias, often used for Unions or complex types?",
    "options": [
      "interface",
      "typedef",
      "type",
      "class"
    ],
    "answer": "type",
    "explanation": "The `type` keyword declares a Type Alias. It is used to name primitive types, unions, tuples, and other types that interfaces cannot represent (like unions directly).",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "How do you make a class property read-only so it can only be assigned during initialization?",
    "options": [
      "const property",
      "static property",
      "readonly property",
      "private property"
    ],
    "answer": "readonly property",
    "explanation": "The `readonly` modifier marks a property as immutable after initialization. `private` restricts access, but does not prevent modification within the class.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the effect of the `?` token in a function parameter or interface property?",
    "options": [
      "It makes the property nullable",
      "It makes the property optional",
      "It marks the property as unknown",
      "It sets the property to strict mode"
    ],
    "answer": "It makes the property optional",
    "explanation": "The question mark (`?`) denotes an optional property or parameter. The value can be `undefined` if omitted, allowing the object to be created without that key.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which utility type removes `null` and `undefined` from a Type?",
    "options": [
      "NonNullable<Type>",
      "NotNull<Type>",
      "Required<Type>",
      "Defined<Type>"
    ],
    "answer": "NonNullable<Type>",
    "explanation": "`NonNullable<Type>` creates a new type by excluding `null` and `undefined` from the given Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What does the `typeof` operator do in a type context (type alias)?",
    "options": [
      "Returns the runtime JavaScript type",
      "Creates a type based on the value of a variable",
      "Checks if a variable is defined",
      "Imports a type from another file"
    ],
    "answer": "Creates a type based on the value of a variable",
    "explanation": "Used in a type position, `typeof` extracts the type of a value or variable. It is useful for capturing the type of an object literal or constant.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the result of `Extract<string | number, number>`?",
    "options": [
      "string",
      "number",
      "never",
      "string | number"
    ],
    "answer": "number",
    "explanation": "`Extract<Type, Union>` constructs a type by extracting from Type all union members that are assignable to Union. Since `number` is in the source union, it is returned.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which utility type allows you to create an object type whose keys are of a specific type?",
    "options": [
      "Map<Keys, Type>",
      "Record<Keys, Type>",
      "Object<Keys, Type>",
      "Dictionary<Keys, Type>"
    ],
    "answer": "Record<Keys, Type>",
    "explanation": "`Record<Keys, Type>` constructs an object type with property keys `Keys` and values `Type`. It is useful for mapping string enums to specific values.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is a Type Guard in TypeScript?",
    "options": [
      "A way to prevent a class from being extended",
      "A runtime check that ensures type safety in a specific block",
      "A comment indicating a type is private",
      "A wrapper around unknown data"
    ],
    "answer": "A runtime check that ensures type safety in a specific block",
    "explanation": "Type guards (e.g., `typeof x === \"number\"`) are expressions that perform a runtime check. TypeScript recognizes them and narrows the type within the conditional block.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which operator is used for Intersection Types (combining multiple types into one)?",
    "options": [
      "|",
      "&",
      "+",
      "and"
    ],
    "answer": "&",
    "explanation": "The ampersand (`&`) is used to combine types. `A & B` results in a type that has all members of both A and B.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What does `\"noImplicitAny\": true` in tsconfig.json enforce?",
    "options": [
      "It prevents the usage of the `any` type entirely",
      "It raises an error when the compiler cannot infer a type and would default to `any`",
      "It converts implicit `any` types to `unknown`",
      "It allows `any` only in function return types"
    ],
    "answer": "It raises an error when the compiler cannot infer a type and would default to `any`",
    "explanation": "When `noImplicitAny` is on, TypeScript issues an error if it infers `any` for a variable that lacks an explicit type annotation, preventing accidental unsafety.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "How do you define a Numeric Enum?",
    "options": [
      "enum Color { Red, Green }",
      "enum Color { Red = 0, Green = 1 }",
      "const enum Color { Red: 'red', Green: 'green' }",
      "Both 'enum Color { Red, Green }' and 'enum Color { Red = 0, Green = 1 }'"
    ],
    "answer": "Both 'enum Color { Red, Green }' and 'enum Color { Red = 0, Green = 1 }'",
    "explanation": "Numeric enums can be defined without initializers (auto-incrementing from 0) or with explicit number initializers.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the type of `arr` in `const arr = [1, \"hello\", true]`?",
    "options": [
      "number[]",
      "any[]",
      "(number | string | boolean)[]",
      "tuple"
    ],
    "answer": "(number | string | boolean)[]",
    "explanation": "When an array is initialized with mixed types, TypeScript infers an array of a Union Type containing those types. It does not infer a Tuple unless explicitly typed.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which `tsconfig` option specifies the JavaScript version the compiler should output?",
    "options": [
      "target",
      "module",
      "lib",
      "outDir"
    ],
    "answer": "target",
    "explanation": "The `target` option determines the ECMAScript version (e.g., ES3, ES5, ES2020) the emitted JavaScript will be compatible with.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What does the `satisfies` operator do compared to a type annotation?",
    "options": [
      "It casts the value to the type immediately",
      "It checks if the value matches the type but keeps the value's specific inferred type",
      "It forces the value to be `any`",
      "It prevents the value from being reassigned"
    ],
    "answer": "It checks if the value matches the type but keeps the value's specific inferred type",
    "explanation": "Unlike annotations which erase specific inference details (e.g., exact literal types), `satisfies` ensures the value fits the constraint while preserving the original specific type information.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which utility type removes types from a Type that are assignable to Union?",
    "options": [
      "Omit<Type, Union>",
      "Exclude<Type, Union>",
      "Remove<Type, Union>",
      "NonNullable<Type>"
    ],
    "answer": "Exclude<Type, Union>",
    "explanation": "`Exclude<Type, Union>` constructs a type by excluding all members of Type that are assignable to Union. It is often used to filter out specific types from a union.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the primary purpose of the `declare` keyword?",
    "options": [
      "To declare a variable that must be initialized",
      "To define ambient types (variables or modules) that exist outside the current file",
      "To export a type for use in other files",
      "To create a generic function"
    ],
    "answer": "To define ambient types (variables or modules) that exist outside the current file",
    "explanation": "The `declare` keyword tells the compiler that a value (like a global variable or a module) exists, without generating any JavaScript code for it. It is used for `.d.ts` files.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which utility type constructs a type by picking the set of properties `K` from type `T`?",
    "options": [
      "type Pick<T, K> = { [P in keyof T as K]: T[P]; }",
      "type Pick<T, K> = { [P in K]: T[P]; }",
      "type Pick<T, K> = Omit<T, Exclude<keyof T, K>>;",
      "type Pick<T, K> = Partial<T> & Record<K, any>;"
    ],
    "answer": "type Pick<T, K> = { [P in K]: T[P]; }",
    "explanation": "`Pick<T, K>` iterates over the union `K` and creates a new object type containing only those properties from `T`. It is a mapped type constrained to the keys specified in `K`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the primary distinction between the `unknown` and `any` types in TypeScript?",
    "options": [
      "`any` allows type checking and assignment; `unknown` disables all type checking",
      "`unknown` forces type narrowing before usage; `any` allows arbitrary operations without checking",
      "`unknown` is used for primitives; `any` is used for complex objects",
      "`any` is strictly typed; `unknown` is the default type for untyped variables"
    ],
    "answer": "`unknown` forces type narrowing before usage; `any` allows arbitrary operations without checking",
    "explanation": "`unknown` is the type-safe counterpart of `any`. You cannot perform operations on an `unknown` value without first asserting or narrowing it to a more specific type, whereas `any` opts out of type checking entirely.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "How does the `as const` assertion affect the inferred type of an array literal?",
    "options": [
      "It converts the array type to `any[]`",
      "It widens the type to a generic array of the common element type",
      "It infers a readonly tuple of literal types instead of a mutable array of primitive types",
      "It enforces that the array can only contain string values"
    ],
    "answer": "It infers a readonly tuple of literal types instead of a mutable array of primitive types",
    "explanation": "The `as const` assertion sets the readonly modifier on the array and infers the most specific literal type for all elements (e.g., `readonly [\"red\", 5]` instead of `(string | number)[]`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which TypeScript feature allows you to extract the return type of a function type?",
    "options": [
      "GetReturnType<T>",
      "ReturnType<T>",
      "Extract<T, Function>",
      "InferReturn<T>"
    ],
    "answer": "ReturnType<T>",
    "explanation": "`ReturnType<T>` is a built-in utility type that extracts the return type from a function type `T`. It uses conditional type inference internally to determine the output type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the result of applying `Partial<T>` to a type `T`?",
    "options": [
      "It makes all properties of `T` readonly",
      "It makes all properties of `T` optional (sets them to `?`)",
      "It makes all properties of `T` nullable",
      "It removes the `null` and `undefined` types from all properties of `T`"
    ],
    "answer": "It makes all properties of `T` optional (sets them to `?`)",
    "explanation": "`Partial<T>` is a mapped type that transforms all properties of `T` into optional variants, effectively setting their optional flag to `true`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In a mapped type, how do you filter out keys based on a condition using Key Remapping?",
    "options": [
      "Using `if` statement inside the type definition",
      "Using `as` clause with a conditional type that returns `never`",
      "Using `extends` keyword directly on the key parameter",
      "Using `Omit` utility before mapping"
    ],
    "answer": "Using `as` clause with a conditional type that returns `never`",
    "explanation": "In key remapping (`[K in keyof T as NewType]`), if the `NewType` evaluates to `never`, that property is dropped from the final mapped type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the result of the `Extract` utility type when applied to two union types?",
    "options": [
      "It returns a union of all members present in either type",
      "It returns a union of members present in the first type but not in the second",
      "It returns a union of members present in both types (the intersection)",
      "It returns the intersection of object structures"
    ],
    "answer": "It returns a union of members present in both types (the intersection)",
    "explanation": "`Extract<T, U>` constructs a type by extracting from `T` all properties that are assignable to `U`. It effectively computes the intersection of the two union types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which operator is used to define a Generic Constraint in TypeScript?",
    "options": [
      "The `implements` keyword",
      "The `constraint` keyword",
      "The `extends` keyword",
      "The `super` keyword"
    ],
    "answer": "The `extends` keyword",
    "explanation": "The `extends` keyword is used to constrain a generic type parameter (e.g., `<T extends SomeInterface>`) to ensure the type argument provided is a subtype of the specified constraint.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the purpose of the `satisfies` operator (introduced in TS 4.9)?",
    "options": [
      "To cast a variable to a specific type overriding the compiler's inference",
      "To check if a variable matches a type without changing the variable's inferred type",
      "To enforce strict null checks on a specific variable",
      "To define a generic constraint on a function argument"
    ],
    "answer": "To check if a variable matches a type without changing the variable's inferred type",
    "explanation": "Unlike type annotations, `satisfies` ensures the expression matches the type but preserves the specific, narrower inferred type of the expression for downstream usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which statement accurately describes the difference between `interface` and `type` for object definitions?",
    "options": [
      "`interface` does not support extending other types, while `type` does",
      "`type` can represent primitives and unions, while `interface` is restricted to object structures",
      "`interface` supports declaration merging, while `type` aliases do not",
      "`type` is removed during compilation, while `interface` generates JavaScript code"
    ],
    "answer": "`interface` supports declaration merging, while `type` aliases do not",
    "explanation": "Interfaces can be declared multiple times with the same name, and their definitions will be merged into a single interface. Type aliases cannot be merged; redeclaring them throws an error.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "How does TypeScript's `readonly` modifier affect object properties at runtime?",
    "options": [
      "It prevents the property from being serialized to JSON",
      "It makes the property immutable at runtime via JavaScript getters/setters",
      "It performs no runtime check; it is only a compile-time check",
      "It converts the property value to a constant primitive"
    ],
    "answer": "It performs no runtime check; it is only a compile-time check",
    "explanation": "`readonly` is a TypeScript-only annotation used for static type checking. It is stripped out during compilation to JavaScript and does not enforce immutability at runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is a Type Predicate in the context of a user-defined type guard?",
    "options": [
      "A function that returns a boolean value",
      "A return type annotation of the form `argName is Type`",
      "A generic constraint limiting the input type",
      "A class method implementing the `IPredicate` interface"
    ],
    "answer": "A return type annotation of the form `argName is Type`",
    "explanation": "A type predicate (e.g., `x is Fish`) signals to the compiler that if the function returns true, the argument passed in is of the specified type, narrowing the type in the scope where the guard is used.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What does `Parameters<T>` extract?",
    "options": [
      "The return type of a generic function T",
      "The types of a tuple type T",
      "The parameter types of a function type T as a tuple",
      "The constructor parameters of a class T"
    ],
    "answer": "The parameter types of a function type T as a tuple",
    "explanation": "`Parameters<T>` is a utility type that constructs a tuple type from the types used in the parameters of a function type `T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which utility type is the opposite of `Partial`, making all properties of `T` required?",
    "options": [
      "Required<T>",
      "Defined<T>",
      "Strict<T>",
      "Mandatory<T>"
    ],
    "answer": "Required<T>",
    "explanation": "`Required<T>` constructs a type consisting of all properties of `T` set to required, removing the optional modifier from any properties that previously had it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In Template Literal Types, how do you convert a string literal union to uppercase?",
    "options": [
      "Using the `.toUpperCase()` method",
      "Using the intrinsic `Uppercase` type",
      "Using the `as` clause with `capital`",
      "Using the `Stringify` utility"
    ],
    "answer": "Using the intrinsic `Uppercase` type",
    "explanation": "TypeScript provides intrinsic string manipulation types like `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize` for use within type definitions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the definition of a 'Discriminated Union' in TypeScript?",
    "options": [
      "A union of primitive types like string | number",
      "A union type where all members share a common singleton property field (the discriminant)",
      "A type that has been stripped of its null and undefined values",
      "A generic type that accepts multiple types separated by commas"
    ],
    "answer": "A union type where all members share a common singleton property field (the discriminant)",
    "explanation": "Discriminated unions leverage a common property with a literal type (e.g., `kind: 'circle'`) to narrow the type of the union member in control flow analysis.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What happens when you use `keyof` on a type containing an index signature?",
    "options": [
      "It returns 'number' only",
      "It returns 'string' only",
      "It returns 'string | number' or the specific literal type of the key",
      "It returns 'any' as the index signature is not a specific property"
    ],
    "answer": "It returns 'string | number' or the specific literal type of the key",
    "explanation": "`keyof` includes the types of the index signature keys. Since JavaScript object keys are always coerced to strings (or Symbols), `keyof` typically returns `string | number` for index signatures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How do you define a generic interface that enforces the type argument to have a specific property?",
    "options": [
      "interface Id { length: number }",
      "interface Id { T.length: number }",
      "interface Id<T extends { length: number }> {}",
      "interface Id implements { length: number }"
    ],
    "answer": "interface Id<T extends { length: number }> {}",
    "explanation": "Using a generic constraint (`extends`) on the type parameter `T` ensures that any type passed to `Id` must contain a `length` property of type `number`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which tsconfig flag enables 'this' type checking in methods?",
    "options": [
      "strictNullChecks",
      "strictThis",
      "noImplicitThis",
      "strictBindCallApply"
    ],
    "answer": "noImplicitThis",
    "explanation": "When `noImplicitThis` is enabled, TypeScript flags instances where `this` is inferred as `any`, forcing you to explicitly type `this` in functions or methods where the context is ambiguous.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the `NonNullable` utility type used for?",
    "options": [
      "To remove the `void` type from a union",
      "To remove `null` and `undefined` from a type",
      "To ensure a property is not set to null at runtime",
      "To filter out falsey values from an array type"
    ],
    "answer": "To remove `null` and `undefined` from a type",
    "explanation": "`NonNullable<T>` creates a new type by excluding `null` and `undefined` from `T`. It is equivalent to `T & {}` or `Exclude<T, null | undefined>`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the behavior of the `infer` keyword in conditional types?",
    "options": [
      "It asserts that a type extends another type",
      "It instructs the compiler to infer a type variable from the structure of the checked type",
      "It creates a new generic type parameter",
      "It casts a type to `any` to bypass checks"
    ],
    "answer": "It instructs the compiler to infer a type variable from the structure of the checked type",
    "explanation": "`infer` is used within the `extends` clause of a conditional type to declare a type variable that TypeScript will deduce from the type being compared.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which configuration option prevents implicit conversion of `any` types in expressions?",
    "options": [
      "noImplicitAny",
      "suppressImplicitAnyIndexErrors",
      "noUnusedLocals",
      "noImplicitReturns"
    ],
    "answer": "noImplicitAny",
    "explanation": "While `noImplicitAny` generally prevents implicit `any`, specific usage like `noImplicitAny` in tsconfig forces developers to explicitly type variables where TypeScript cannot infer the type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "How does TypeScript handle 'const assertions' on object properties?",
    "options": [
      "It makes all properties read-only and sets their values to literal types",
      "It converts the object to a JSON string",
      "It prevents the object from being deleted",
      "It marks the object as `sealed`"
    ],
    "answer": "It makes all properties read-only and sets their values to literal types",
    "explanation": "Using `as const` on an object literal infers literal types for properties (e.g., `5` instead of `number`) and sets the `readonly` modifier on all properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the output type of `Awaited<T>`?",
    "options": [
      "The promise wrapper type",
      "The unwrapped type of a Promise recursively",
      "The type T if it is not a Promise",
      "The return type of an async function"
    ],
    "answer": "The unwrapped type of a Promise recursively",
    "explanation": "`Awaited<T>` recursively unwraps Promises to get the final fulfillment type. It is useful for handling `Promise<Promise>` structures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the behavior of `declare` on a class property?",
    "options": [
      "It allocates memory for the property in the constructor",
      "It tells TypeScript the property exists at runtime, but does not emit a property definition",
      "It makes the property public",
      "It initializes the property to undefined"
    ],
    "answer": "It tells TypeScript the property exists at runtime, but does not emit a property definition",
    "explanation": "The `declare` modifier is used for ambient contexts. It tells the compiler to assume the variable or property exists elsewhere without generating any JavaScript code for its definition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which operator allows you to access the type of a variable or expression?",
    "options": [
      "typeof",
      "typeof! (type assertion)",
      "instanceof",
      "type()"
    ],
    "answer": "typeof",
    "explanation": "In a type context (type annotation), `typeof` extracts the type of a value or variable, allowing you to reference static types derived from runtime values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What does `Omit<T, K>` do?",
    "options": [
      "It constructs a type by picking all properties from T and then removing K",
      "It constructs a type by removing properties specified in K from T",
      "It sets the properties in K to optional",
      "It creates a type excluding null and undefined"
    ],
    "answer": "It constructs a type by picking all properties from T and then removing K",
    "explanation": "`Omit<T, K>` is essentially `Pick<T, Exclude<keyof T, K>>`. It creates a new type by including all properties of `T` except for those specified in the union `K`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is a 'Branded Type' in TypeScript patterns?",
    "options": [
      "A type that maps to a specific brand name",
      "A pattern using intersection with a unique object property to distinguish between identical underlying types",
      "A type exported from a brand library",
      "A type that uses the `brand` keyword"
    ],
    "answer": "A pattern using intersection with a unique object property to distinguish between identical underlying types",
    "explanation": "Nominal typing is simulated in TypeScript by 'branding', e.g., `type UserId = string & { readonly __brand: unique symbol };`. This prevents accidental assignment of a plain `string` to a `UserId`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which utility type creates a type with a set of properties `K` of type `T`?",
    "options": [
      "Map<T, K>",
      "Record<K, T>",
      "Object<K, T>",
      "Dictionary<K, T>"
    ],
    "answer": "Record<K, T>",
    "explanation": "`Record<K, T>` constructs an object type whose property keys are `K` and whose property values are `T`. It is useful for mapping enums to specific value types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How do Conditional Types distribute over union types?",
    "options": [
      "They automatically convert the union to an intersection",
      "They apply the conditional check to each constituent member of the union",
      "They check the union as a whole, not individual members",
      "They require the `extends` keyword to be wrapped in parentheses"
    ],
    "answer": "They apply the conditional check to each constituent member of the union",
    "explanation": "When a conditional type acts on a generic that is a union, the condition is distributive. It evaluates the condition for each member of the union and unions the results.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What does `--strict` flag in `tsconfig.json` enable?",
    "options": [
      "All strict type-checking options (noImplicitAny, strictNullChecks, etc.)",
      "Strict mode for JavaScript functions",
      "Strict variable naming conventions",
      "Only `strictNullChecks` and `noImplicitAny`"
    ],
    "answer": "All strict type-checking options (noImplicitAny, strictNullChecks, etc.)",
    "explanation": "The `strict` flag is a shorthand to enable all strict type checking options (`noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `noImplicitThis`, `alwaysStrict`) at once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "In TypeScript 4.1+, how do you create a Template Literal Type that capitalizes the first letter?",
    "options": [
      "`type Cap = Uppercase<string>`",
      "`type Cap = Capitalize<string>`",
      "`type Cap = string[0].toUpperCase() + string.slice(1)`",
      "`type Cap = ToUpper<string>`"
    ],
    "answer": "`type Cap = Capitalize<string>`",
    "explanation": "`Capitalize<StringType>` is an intrinsic utility type that transforms the first character of a string literal type to uppercase.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the purpose of the `import type` syntax?",
    "options": [
      "To import a module only for side effects",
      "To ensure the import is completely removed from the JavaScript output",
      "To import a module asynchronously",
      "To import a value that is not a type"
    ],
    "answer": "To ensure the import is completely removed from the JavaScript output",
    "explanation": "`import type { Type }` is used to import types, interfaces, or enums, signaling to the compiler that this import can be safely erased if it is not used in a value position.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which option correctly describes `Exclude<T, U>`?",
    "options": [
      "It removes types from T that are present in U",
      "It removes types from U that are present in T",
      "It intersects T and U",
      "It creates a union of T and U"
    ],
    "answer": "It removes types from T that are present in U",
    "explanation": "`Exclude<T, U>` constructs a type by excluding from `T` all types that are assignable to `U`. It effectively subtracts the union `U` from the union `T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "How does `esModuleInterop` affect module resolution?",
    "options": [
      "It allows importing CommonJS modules as if they were ES6 modules with a default export",
      "It forces all modules to be compiled to ES6",
      "It prohibits the use of `require`",
      "It enables namespace imports only"
    ],
    "answer": "It allows importing CommonJS modules as if they were ES6 modules with a default export",
    "explanation": "When `esModuleInterop` is true, TypeScript allows importing CommonJS modules using default ES6 syntax (e.g., `import pkg from 'fs'`) by creating a synthetic default export in the emitted code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which utility type implementation correctly removes the `readonly` modifier from all properties of a given type `T`?",
    "options": [
      "type Mutable<T> = { -readonly [P in keyof T]: T[P] }",
      "type Mutable<T> = { [P in keyof T]-?: T[P] }",
      "type Mutable<T> = { [P in keyof T]: -readonly T[P] }",
      "type Mutable<T> = Writable<T>"
    ],
    "answer": "type Mutable<T> = { -readonly [P in keyof T]: T[P] }",
    "explanation": "The minus sign prefix (-readonly) in a mapped type removes the readonly modifier. The other syntaxes are invalid or refer to removing optional modifiers (-?).",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "In TypeScript 4.9+, what is the primary distinction between the `satisfies` operator and a standard type annotation?",
    "options": [
      "The `satisfies` operator ensures the value is not null or undefined, whereas type annotations allow nulls.",
      "The `satisfies` operator validates that the expression matches the type but preserves the specific inferred type of the expression for usage.",
      "Type annotations allow for implicit any conversion, while `satisfies` enforces strict null checks.",
      "The `satisfies` operator is used for interface declarations, while type annotations are used for type aliases."
    ],
    "answer": "The `satisfies` operator validates that the expression matches the type but preserves the specific inferred type of the expression for usage.",
    "explanation": "Unlike type annotations (which widen the literal type to the annotated type), `satisfies` checks validity against the constraint but keeps the expression's specific narrow type for subsequent operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "When using conditional types, when does TypeScript distribute a conditional type over a union type `T`?",
    "options": [
      "When `T` is used in the `extends` clause of a generic type that is not wrapped in a tuple.",
      "When the conditional type is nested inside another conditional type.",
      "When the `infer` keyword is used in the true branch.",
      "Distribution only occurs if the `strict` flag is enabled in tsconfig.json."
    ],
    "answer": "When `T` is used in the `extends` clause of a generic type that is not wrapped in a tuple.",
    "explanation": "TypeScript automatically distributes conditional types over unions (e.g., `A | B extends C ? D : E`) when the checked type is a naked type parameter. Wrapping the parameter in a tuple (e.g., `[T]`) disables distribution.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the result type of the `Parameters` utility when applied to a generic function type `function f<T>(x: T): void`?",
    "options": [
      "[]",
      "[T]",
      "unknown[]",
      "never"
    ],
    "answer": "[T]",
    "explanation": "The `Parameters` utility extracts the parameter types. `f` takes one argument of type `T`, so the result is the tuple type `[T]`, preserving the generic reference.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which statement accurately describes the type relationship between function parameters in TypeScript, specifically regarding bivariance?",
    "options": [
      "Function parameter types are strictly contravariant to ensure soundness.",
      "Function parameter types are strictly invariant.",
      "Function parameter types are treated as bivariant (both covariant and contravariant) for practical reasons, though unsound.",
      "Function parameter types are strictly covariant to allow array spreading."
    ],
    "answer": "Function parameter types are treated as bivariant (both covariant and contravariant) for practical reasons, though unsound.",
    "explanation": "TypeScript treats function parameters as bivariant to accommodate common array handling patterns (e.g., comparing arrays of animals). This is technically unsound but allows for more ergonomic JavaScript compatibility.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "How does the `as const` assertion affect the type of an array literal?",
    "options": [
      "It converts the array type to `readonly` and narrows all elements to their specific literal types (e.g., '10' instead of string).",
      "It prevents the array from being garbage collected.",
      "It casts the array to `any`, allowing any mutation.",
      "It enforces that the array length is fixed but allows elements to be widened to primitives."
    ],
    "answer": "It converts the array type to `readonly` and narrows all elements to their specific literal types (e.g., '10' instead of string).",
    "explanation": "The `as const` assertion creates a readonly tuple with literal types for all elements, effectively 'freezing' the type structure to match the value exactly.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the primary function of the `infer` keyword within TypeScript conditional types?",
    "options": [
      "To cast a type to a more specific subtype.",
      "To declare a new generic type parameter that must be explicitly passed.",
      "To infer a type variable from the structure of a type within the `extends` clause for use in the true branch.",
      "To enforce strict null checking on the inferred type."
    ],
    "answer": "To infer a type variable from the structure of a type within the `extends` clause for use in the true branch.",
    "explanation": "`infer` declares a type variable that is captured by matching the structure of the type being tested in the conditional type's extends clause.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In TypeScript configuration, what does the `useDefineForClassFields` flag (defaulting to `true` in `modules: ESNext`) change regarding class property declarations?",
    "options": [
      "It forces all class properties to be defined on the class prototype rather than instances.",
      "It changes class field definitions to use the ECMAScript standard semantics (define semantics) instead of TypeScript's legacy assign semantics.",
      "It prevents the use of getters and setters in classes.",
      "It makes all class properties private by default."
    ],
    "answer": "It changes class field definitions to use the ECMAScript standard semantics (define semantics) instead of TypeScript's legacy assign semantics.",
    "explanation": "When enabled, properties are defined using `Object.defineProperty` (Define Semantics). When disabled (legacy), they are assigned via simple assignment (Assign Semantics), which affects how decorators and initializers interact.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Which utility type allows you to create a type where all properties of `T` are set to optional, including optional nested properties recursively?",
    "options": [
      "type DeepPartial<T> = { [P in keyof T]?: T[P] }",
      "type DeepPartial<T> = T | null | undefined",
      "type DeepPartial<T> = { [P in keyof T]?: DeepPartial<T[P]> }",
      "type DeepPartial<T> = Partial<T>"
    ],
    "answer": "type DeepPartial<T> = { [P in keyof T]?: DeepPartial<T[P]> }",
    "explanation": "Standard `Partial` only shallowly affects the top level. To handle nested objects, the mapped type must recursively call itself, `DeepPartial<T[P]>`.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What happens to the `never` type when it appears inside a union type (e.g., `string | never`)?",
    "options": [
      "It dominates the union, forcing the result to be `never`.",
      "It is ignored and removed from the union.",
      "It converts the union to `unknown`.",
      "It causes a compile-time error because `never` cannot be unioned."
    ],
    "answer": "It is ignored and removed from the union.",
    "explanation": "`never` is the empty union. In a union operation `A | never`, the result simplifies to `A` because adding an empty set of values to a set of values yields the original set.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the type of `value` in: `const value = 'hello' as string | number;`?",
    "options": [
      "The literal type `'hello'`",
      "The union type `string | number`",
      "The primitive type `string`",
      "`unknown`"
    ],
    "answer": "The union type `string | number`",
    "explanation": "Type assertions (using `as`) override the compiler's inferred narrow type (`'hello'`) and explicitly widen it to the specified type (`string | number`).",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which intrinsic string manipulation type converts a string literal type to Uppercase?",
    "options": [
      "ToUpperCase<T>",
      "Capitalize<T>",
      "Uppercase<T>",
      "Uncapitalize<T>"
    ],
    "answer": "Uppercase<T>",
    "explanation": "`Uppercase` converts string literal types to uppercase. `Capitalize` only uppercases the first letter. `ToUpperCase` does not exist.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does TypeScript treat optional properties in an interface when using the `keyof` operator?",
    "options": [
      "`keyof` excludes optional properties from the resulting union.",
      "`keyof` includes them, but their value types automatically include `undefined` if the `strictNullChecks` flag is on.",
      "`keyof` includes them without `undefined` unless explicitly typed as `| undefined`.",
      "Optional properties are treated as `never` in `keyof` results."
    ],
    "answer": "`keyof` includes them, but their value types automatically include `undefined` if the `strictNullChecks` flag is on.",
    "explanation": "When accessing a property via `keyof` that is optional, the resulting access type includes `undefined` to reflect the runtime reality that the property might be missing.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Which TypeScript feature allows you to map over union types using template literal strings?",
    "options": [
      "Mapped Types on Union Types",
      "Template Literal Types",
      "Conditional Types with `infer`",
      "Recursive Type Aliases"
    ],
    "answer": "Template Literal Types",
    "explanation": "Template literal types allow distributing over a union, generating a new union of string literal combinations, effectively acting as a map over unions.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What does the `ThisType<T>` utility marker do?",
    "options": [
      "It creates a new class that extends `T`.",
      "It explicitly specifies the type of `this` within object literals that contain methods, provided `noImplicitThis` is enabled.",
      "It casts the current scope to type `T`.",
      "It enforces that `this` cannot be `null`."
    ],
    "answer": "It explicitly specifies the type of `this` within object literals that contain methods, provided `noImplicitThis` is enabled.",
    "explanation": "`ThisType` is a special empty interface used in a library definition to signal to the compiler that the `this` type inside methods of a transformed object literal should be `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How do you implement a type that returns the return type of an async function `MyAsyncFunc` (which returns a Promise)?",
    "options": [
      "ReturnType<MyAsyncFunc>",
      "Awaited<ReturnType<MyAsyncFunc>>",
      "PromiseType<MyAsyncFunc>",
      "UnwrapPromise<ReturnType<MyAsyncFunc>>"
    ],
    "answer": "Awaited<ReturnType<MyAsyncFunc>>",
    "explanation": "The `ReturnType` of an async function is the `Promise` itself. To get the resolved value type, you must unwrap the Promise using the `Awaited` utility (or recursively inferring it).",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What does the `Exclude<UnionType, ExcludedMembers>` utility type do?",
    "options": [
      "It removes properties from an object type.",
      "It constructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.",
      "It filters a union to only include members present in `ExcludedMembers`.",
      "It sets all excluded members to `undefined`."
    ],
    "answer": "It constructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.",
    "explanation": "`Exclude` works on Unions. If `T` extends `U`, it is removed from the resulting union. It does not work on object properties.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In the context of template literal types, how do you enforce that a type string starts with a specific prefix, e.g., 'data-'?",
    "options": [
      "type Prefixed = string extends `data-${infer Rest}` ? string : never",
      "type Prefixed<T extends string> = `data-${T}`",
      "type Prefixed = T & 'data-'",
      "type Prefixed = `${'data-'}${string}`"
    ],
    "answer": "type Prefixed<T extends string> = `data-${T}`",
    "explanation": "Using the template literal syntax `data-${T}` where `T` is a generic parameter restricts valid inputs to strings starting with 'data-'.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the output type of the following conditional type? `type T = 1 extends 1 | 2 ? 'Yes' : 'No';`",
    "options": [
      "'No'",
      "'Yes'",
      "boolean",
      "never"
    ],
    "answer": "'Yes'",
    "explanation": "Because `1` is assignable to the union `1 | 2`, the condition is true, resulting in the first branch.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How does `NonNullable<T>` work?",
    "options": [
      "It recursively removes null and undefined from T.",
      "It checks if T is null or undefined and throws a compile error if so.",
      "It constructs a type by excluding `null` and `undefined` from `T`.",
      "It adds `null` and `undefined` to the type T."
    ],
    "answer": "It constructs a type by excluding `null` and `undefined` from `T`.",
    "explanation": "`NonNullable` is a utility type equivalent to `T extends null | undefined ? never : T`. It removes null and undefined from a union type.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When are interface declarations merged?",
    "options": [
      "When they are defined in the same file.",
      "When they have the same name in the same scope and are not merged with a `namespace` or `module`.",
      "Only when the `merge` flag is enabled.",
      "When they have different names but compatible properties."
    ],
    "answer": "When they have the same name in the same scope and are not merged with a `namespace` or `module`.",
    "explanation": "TypeScript merges interfaces with the same name in the same scope, creating a single logical interface with the union of their members.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the difference between `unknown` and `any`?",
    "options": [
      "`unknown` is the top type that allows any assignment but requires narrowing before usage; `any` allows anything without checks.",
      "`any` is the top type; `unknown` is the bottom type.",
      "`unknown` allows assignments to any type; `any` does not.",
      "There is no difference; they are aliases."
    ],
    "answer": "`unknown` is the top type that allows any assignment but requires narrowing before usage; `any` allows anything without checks.",
    "explanation": "Both accept any value, but `unknown` is type-safe: you must perform type checks or assertions to use the value as a specific type, whereas `any` opts out of all type checking.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which mapped type modifier is used to make optional properties required?",
    "options": [
      "+required",
      "-?",
      "!",
      "required"
    ],
    "answer": "-?",
    "explanation": "The `?` modifier signifies optionality. To make it required, you remove the modifier using the minus prefix: `-?`.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the result of `type T = readonly ['a', 'b'] extends { [k: string]: any } ? true : false;`?",
    "options": [
      "false",
      "true",
      "Type error: Cannot compare tuple with object.",
      "never"
    ],
    "answer": "true",
    "explanation": "In TypeScript, array and tuple types are considered assignable to object index signatures (as strings are valid indices). Therefore, a readonly tuple extends a general string index signature.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Which `tsconfig.json` option is strictly required to enable `null` and `undefined` checks in conditional branches?",
    "options": [
      "strictNullChecks",
      "strict",
      "noImplicitAny",
      "strictPropertyInitialization"
    ],
    "answer": "strictNullChecks",
    "explanation": "While `strict` enables it, the specific option governing the treatment of null/undefined and narrowing in conditional blocks is `strictNullChecks`.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the signature of a Type Guard function?",
    "options": [
      "`function isString(arg: any): boolean`",
      "`function isString(arg: unknown): arg is string`",
      "`function assertString(arg: any): asserts arg is string`",
      "`function typeGuard<T>(arg: T): T is string`"
    ],
    "answer": "`function isString(arg: unknown): arg is string`",
    "explanation": "A type guard returns a boolean whose type is `arg is SpecificType`. This syntax informs the compiler to narrow the type of `arg` in the scope where the return value is true.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How can you use key remapping in a mapped type to filter out specific keys?",
    "options": [
      "By using `as never` on keys you want to exclude.",
      "By using the `Omit` utility inside the mapped type.",
      "By using `as any` on the keys.",
      "Key remapping cannot be used for filtering."
    ],
    "answer": "By using `as never` on keys you want to exclude.",
    "explanation": "In key remapping `[K in keyof T as NewType]`, if `NewType` evaluates to `never` (e.g., via a conditional type), that property is dropped from the result.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What does `Parameters<typeof console.log>` evaluate to?",
    "options": [
      "any[]",
      "an array of arguments starting with any",
      "[...args: any[]]",
      "[]"
    ],
    "answer": "an array of arguments starting with any",
    "explanation": "TypeScript definitions for `console.log` are `(message?: any, ...optionalParams: any[]) => void`. `Parameters` extracts this as `[any, ...any[]]`.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "How does the `ReadonlyArray<T>` type differ from `readonly T[]`?",
    "options": [
      "`ReadonlyArray` prevents array methods like `push` from being called; `readonly T[]` only prevents modifying indices.",
      "`ReadonlyArray` is an interface; `readonly T[]` is a type alias.",
      "They are effectively identical in behavior and usage.",
      "`readonly T[]` is a legacy syntax removed in TS 5.0."
    ],
    "answer": "They are effectively identical in behavior and usage.",
    "explanation": "`ReadonlyArray` and `readonly T[]` are interchangeable representations of an immutable array type in TypeScript.",
    "difficulty": "Advanced"
  }
]