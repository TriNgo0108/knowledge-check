[
  {
    "id": 1,
    "question": "In React, which syntax is required to return multiple elements from a component without a wrapper DOM node?",
    "options": [
      "Array syntax",
      "React Fragments",
      "Conditional rendering",
      "Higher-Order Components"
    ],
    "answer": "React Fragments",
    "explanation": "React Fragments (denoted by <>...</> or <React.Fragment>) allow grouping of children without adding extra nodes to the DOM. Arrays are valid but less idiomatic and require keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which Hook is primarily used to manage local state within a functional component?",
    "options": [
      "useEffect",
      "useContext",
      "useState",
      "useReducer"
    ],
    "answer": "useState",
    "explanation": "useState declares a state variable and a function to update it, triggering re-renders. useEffect handles side effects, while useReducer is for complex state logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the term for the process React uses to determine which parts of the UI need to be updated?",
    "options": [
      "Reconciliation",
      "Rendering",
      "Hydration",
      "Mounting"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation (or diffing) compares the new element tree with the previous one to calculate the minimal set of changes required. Rendering is the execution of those changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "When using 'useState', why might you use the functional update form (e.g., setCount(c => c + 1))?",
    "options": [
      "To render the component faster",
      "To prevent unnecessary re-renders",
      "To ensure the update is based on the most recent state",
      "To allow passing props to the setter"
    ],
    "answer": "To ensure the update is based on the most recent state",
    "explanation": "Functional updates are used when the new state depends on the previous state, preventing issues where state might be stale due to closures.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In React's rendering lifecycle, which phase is considered interruptible?",
    "options": [
      "Commit Phase",
      "Render Phase",
      "Mount Phase",
      "Unmount Phase"
    ],
    "answer": "Render Phase",
    "explanation": "The Render (or Reconciliation) phase is interruptible, allowing React to prioritize high-priority work. The Commit phase is always synchronous and non-interruptible.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the correct syntax to embed a JavaScript expression within JSX?",
    "options": [
      "Using double quotes inside the tag",
      "Wrapping the expression in curly braces",
      "Wrapping the expression in parentheses",
      "Using the dollar sign prefix"
    ],
    "answer": "Wrapping the expression in curly braces",
    "explanation": "Curly braces {} allow embedding dynamic values, variables, or expressions directly within JSX markup. Quotes are used for string literals.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which method allows you to render a component outside the parent DOM hierarchy?",
    "options": [
      "ReactDOM.render",
      "ReactDOM.createPortal",
      "React.cloneElement",
      "React.forwardRef"
    ],
    "answer": "ReactDOM.createPortal",
    "explanation": "Portals provide a way to render children into a DOM node that exists outside the parent component's hierarchy, useful for modals and tooltips.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which of the following best describes a 'Controlled Component' in React forms?",
    "options": [
      "An input that maintains its own internal state",
      "An input whose value is controlled by React state",
      "An input that does not trigger re-renders",
      "An input wrapped in a Higher-Order Component"
    ],
    "answer": "An input whose value is controlled by React state",
    "explanation": "In a controlled component, the form element's value is driven by React state, making React the 'single source of truth'. Uncontrolled components maintain their own internal state.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What happens if you pass a different 'key' prop to a component element during a list update?",
    "options": [
      "React will ignore the component and skip rendering",
      "React will destroy the old component instance and create a new one",
      "React will merge the old and new props automatically",
      "React will throw a runtime error"
    ],
    "answer": "React will destroy the old component instance and create a new one",
    "explanation": "Keys help React identify which items have changed, been added, or removed. A change in key causes React to discard the old state and mount a fresh instance.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which Hook is designed to handle side effects that run after the browser has painted the screen?",
    "options": [
      "useLayoutEffect",
      "useEffect",
      "useInsertionEffect",
      "useTransition"
    ],
    "answer": "useEffect",
    "explanation": "useEffect runs asynchronously after the commit phase and the browser paint, making it non-blocking. useLayoutEffect runs synchronously before paint.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the purpose of 'StrictMode' in React?",
    "options": [
      "To enforce TypeScript strict checking",
      "To enforce strict linting rules",
      "To highlight potential problems in an application",
      "To prevent unauthorized API calls"
    ],
    "answer": "To highlight potential problems in an application",
    "explanation": "StrictMode activates additional checks and warnings for components, such as detecting legacy APIs or side effects during rendering, but it does not render visible UI.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "How does React determine if a component needs to be re-rendered regarding props?",
    "options": [
      "By checking if the component has class methods",
      "By comparing the previous and current props using Object.is",
      "By checking if the component function returns null",
      "By random sampling of state values"
    ],
    "answer": "By comparing the previous and current props using Object.is",
    "explanation": "React performs a shallow comparison (reference equality) on props and state. If references haven't changed, it skips the re-render for pure components or memoized components.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In the context of the Fiber architecture, what is a 'Fiber'?",
    "options": [
      "A specialized CSS fiber for layout",
      "A JavaScript object representing a unit of work",
      "A networking protocol for WebSockets",
      "A virtual DOM node replacement"
    ],
    "answer": "A JavaScript object representing a unit of work",
    "explanation": "A Fiber is a JavaScript data structure that holds information about a component's state, props, and the work it needs to do during rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which Hook is used to optimize performance by memoizing a calculated value?",
    "options": [
      "useCallback",
      "useMemo",
      "useRef",
      "useReducer"
    ],
    "answer": "useMemo",
    "explanation": "useMemo caches the result of a calculation between re-renders until dependencies change. useCallback is specifically for memoizing function references.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What prevents a child component from updating when its parent re-renders?",
    "options": [
      "Using React.forwardRef",
      "Using React.memo",
      "Using the key prop",
      "Using useEffect"
    ],
    "answer": "Using React.memo",
    "explanation": "React.memo is a higher-order component that performs a shallow comparison of props; if they haven't changed, it skips re-rendering the wrapped component.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which event handling convention is specific to React for standardizing events across browsers?",
    "options": [
      "Native DOM Events",
      "jQuery Events",
      "Synthetic Events",
      "Custom Events"
    ],
    "answer": "Synthetic Events",
    "explanation": "React wraps native browser events in SyntheticEvents to ensure consistent behavior across different browsers, while pooling them for performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the result of calling 'setState' (or the state updater function) inside 'render'?",
    "options": [
      "The state updates synchronously",
      "It triggers an infinite loop",
      "It is ignored by React",
      "It triggers a shallow re-render"
    ],
    "answer": "It triggers an infinite loop",
    "explanation": "Updating state during render causes the component to re-render immediately after the current render pass, creating an infinite recursion loop.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which Hook should be used to trigger an animation immediately after React updates the DOM?",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useState",
      "useRef"
    ],
    "answer": "useLayoutEffect",
    "explanation": "useLayoutEffect fires synchronously before the browser paints, allowing you to read layout from the DOM and mutate it without the user seeing a flicker.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "In JSX, how do you write a comment?",
    "options": [
      "<!-- This is a comment -->",
      "// This is a comment",
      "{/* This is a comment */}",
      "# This is a comment"
    ],
    "answer": "{/* This is a comment */}",
    "explanation": "JSX comments must be wrapped in curly braces and use the multi-line comment syntax /* ... */, HTML style comments are treated as text nodes.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What mechanism does React Fiber use to keep track of the component tree currently displayed on the screen?",
    "options": [
      "The Work-in-Progress Tree",
      "The Current Tree",
      "The Virtual DOM",
      "The Shadow DOM"
    ],
    "answer": "The Current Tree",
    "explanation": "React maintains a 'current' tree representing the flushed UI and a 'work-in-progress' tree for the updates. Once committed, the work-in-progress becomes current.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the behavior of the dependency array in 'useEffect' if it is omitted entirely?",
    "options": [
      "The effect runs once on mount",
      "The effect runs after every render",
      "The effect never runs",
      "The effect runs only on unmount"
    ],
    "answer": "The effect runs after every render",
    "explanation": "Without a dependency array, React assumes the effect depends on every value from the component scope, triggering it on every update.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which technique allows a parent component to access a DOM element or a child component instance directly?",
    "options": [
      "State lifting",
      "Refs",
      "Context",
      "Portals"
    ],
    "answer": "Refs",
    "explanation": "Refs provide a way to access DOM nodes or React elements created in the render method, bypassing the typical data flow.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the 'Children' prop in React?",
    "options": [
      "A built-in Hook to fetch child data",
      "A special prop that receives the content between the opening and closing tags of a component",
      "A method to sort components by ID",
      "A lifecycle method for mounting"
    ],
    "answer": "A special prop that receives the content between the opening and closing tags of a component",
    "explanation": "props.children represents whatever is passed between the component's tags, allowing for composition and flexible UI structures.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Why is the 'key' prop important when rendering lists of elements?",
    "options": [
      "It enables CSS styling of the list",
      "It helps React identify which items have changed, been added, or removed",
      "It automatically adds unique IDs to the DOM elements",
      "It prevents the list from re-rendering"
    ],
    "answer": "It helps React identify which items have changed, been added, or removed",
    "explanation": "Keys give elements a stable identity, allowing React to efficiently update the DOM by matching state to items.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which higher-order component takes a component and returns a new component that forwards refs?",
    "options": [
      "React.memo",
      "React.lazy",
      "React.forwardRef",
      "React.cloneElement"
    ],
    "answer": "React.forwardRef",
    "explanation": "forwardRef is a technique for passing a ref through a component to one of its children, essential for reusable component libraries.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What happens when a component's 'render' method (or function body) returns 'null' or 'false'?",
    "options": [
      "React throws an error",
      "React renders a blank text node",
      "React renders nothing (no DOM node)",
      "React renders an empty <div>"
    ],
    "answer": "React renders nothing (no DOM node)",
    "explanation": "Returning null, false, or undefined from render tells React to render no DOM node for that component, though lifecycle methods (or effects) will still fire.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which of the following is the correct import statement for 'useEffect'?",
    "options": [
      "import { effect } from 'react';",
      "import useEffect from 'react';",
      "import { useEffect } from 'react';",
      "import 'useEffect' from 'react';"
    ],
    "answer": "import { useEffect } from 'react';",
    "explanation": "Hooks are named exports. Therefore, they must be imported using named import syntax inside curly braces.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What does the 'useCallback' Hook optimize?",
    "options": [
      "The speed of arithmetic calculations",
      "The referential identity of functions passed to optimized child components",
      "The time it takes to fetch data",
      "The size of the DOM tree"
    ],
    "answer": "The referential identity of functions passed to optimized child components",
    "explanation": "useCallback returns a memoized function, useful when passing callbacks to child components that are optimized with React.memo to prevent unnecessary re-renders.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "In React, 'lifting state up' refers to:",
    "options": [
      "Deleting state from low-level components",
      "Moving state to the closest common ancestor of components that need it",
      "Using Redux to manage state",
      "Converting functional components to class components"
    ],
    "answer": "Moving state to the closest common ancestor of components that need it",
    "explanation": "Lifting state up involves moving the state to a parent component so that multiple children can share or synchronize data.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which Hook is best suited for managing complex state logic involving multiple sub-values or dependencies on previous state?",
    "options": [
      "useState",
      "useReducer",
      "useContext",
      "useRef"
    ],
    "answer": "useReducer",
    "explanation": "useReducer is preferable when state logic is complex or involves multiple sub-values, using a reducer function to manage state transitions based on actions.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the purpose of the 'React.lazy' function?",
    "options": [
      "To delay the execution of expensive calculations",
      "To dynamically import components to reduce initial bundle size",
      "To make a component wait for data before rendering",
      "To put a component to sleep during idle time"
    ],
    "answer": "To dynamically import components to reduce initial bundle size",
    "explanation": "React.lazy allows you to define a component that is loaded dynamically, helping to reduce the initial loading time by code-splitting.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which function is used to explicitly render a React element into a specific DOM node?",
    "options": [
      "React.render",
      "ReactDOM.mount",
      "ReactDOM.createRoot",
      "React.hydrate"
    ],
    "answer": "ReactDOM.createRoot",
    "explanation": "In React 18+, createRoot is used to create a root for a React application, replacing the legacy ReactDOM.render method to enable concurrent features.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the primary rule of Hooks?",
    "options": [
      "Hooks can only be called inside class components",
      "Hooks can be called conditionally or inside loops",
      "Hooks must be called at the top level of a React function",
      "Hooks cannot be used in functional components"
    ],
    "answer": "Hooks must be called at the top level of a React function",
    "explanation": "Hooks must be called at the top level to ensure they are called in the same order on every render, preserving React's state logic between renders.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which phase is responsible for mutating the DOM tree in React's rendering process?",
    "options": [
      "Reconciliation Phase",
      "Commit Phase",
      "Pre-render Phase",
      "Scheduling Phase"
    ],
    "answer": "Commit Phase",
    "explanation": "The Commit phase is where React applies the calculated changes to the DOM. It is synchronous and atomic to prevent inconsistent UI.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What does the 'useContext' Hook allow you to do?",
    "options": [
      "Create a new context object",
      "Read and subscribe to context values without using a Consumer component",
      "Update the value of a context provider",
      "Pass props to deeply nested components"
    ],
    "answer": "Read and subscribe to context values without using a Consumer component",
    "explanation": "useContext accepts a context object and returns the current context value, allowing functional components to consume context without nesting.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which phase of the React rendering lifecycle is considered interruptible and allows for prioritizing high-priority updates?",
    "options": [
      "The Commit phase",
      "The Reconciliation (Render) phase",
      "The Pre-commit phase",
      "The Passive effect phase"
    ],
    "answer": "The Reconciliation (Render) phase",
    "explanation": "The Reconciliation phase, also known as the Render phase, constructs a work-in-progress Fiber tree and can be interrupted by higher-priority work. The Commit phase is strictly synchronous and non-interruptible to ensure UI consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary purpose of the `key` prop when rendering lists of elements in React?",
    "options": [
      "To improve CSS styling specificity",
      "To ensure unique identification of DOM nodes for efficient reconciliation",
      "To prevent SQL injection attacks",
      "To automatically bind event handlers to list items"
    ],
    "answer": "To ensure unique identification of DOM nodes for efficient reconciliation",
    "explanation": "Keys help React identify which items have changed, been added, or removed, allowing the diffing algorithm to match elements in the old and new trees correctly and reuse DOM nodes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which Hook should be used to read layout values synchronously and apply mutations to the DOM before the browser repaints?",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useInsertionEffect",
      "useReducer"
    ],
    "answer": "useLayoutEffect",
    "explanation": "useLayoutEffect fires synchronously after all DOM mutations but before the browser paints the screen. This makes it ideal for reading layout from the DOM and synchronously re-rendering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of React Fiber, what technique does React use to prevent flickering by maintaining two versions of the tree?",
    "options": [
      "Triple buffering",
      "Double buffering",
      "Shadow DOM",
      "Virtual cloning"
    ],
    "answer": "Double buffering",
    "explanation": "React Fiber maintains two trees: the 'current' tree (what is on screen) and the 'work-in-progress' tree (what is being calculated). Once the work-in-progress tree is ready, React swaps the pointers, a technique known as double buffering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Why must React Hooks be called at the top level of a component and not inside loops, conditions, or nested functions?",
    "options": [
      "To ensure the component renders faster",
      "To reduce the memory footprint of the component",
      "To preserve the order of Hook state between multiple renders",
      "To allow the use of multiple return statements"
    ],
    "answer": "To preserve the order of Hook state between multiple renders",
    "explanation": "React relies on the order in which Hooks are called to correctly associate the state with a specific Hook instance. Calling Hooks conditionally changes this order, leading to bugs in state preservation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What mechanism allows React 18+ to batch multiple state updates, even those occurring asynchronously in promises or timeouts?",
    "options": [
      "Automatic Batching",
      "Strict Mode",
      "Concurrent Mode",
      "Suspense"
    ],
    "answer": "Automatic Batching",
    "explanation": "Automatic Batching (via createRoot) groups state updates into a single re-render for performance, regardless of where they originate, unlike legacy Root rendering which only batched updates in event handlers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the specific function of the `startTransition` API in React 18?",
    "options": [
      "To immediately abort pending network requests",
      "To mark specific state updates as non-urgent and allow interruptible rendering",
      "To force a synchronous re-render of the entire component tree",
      "To lazy load components dynamically"
    ],
    "answer": "To mark specific state updates as non-urgent and allow interruptible rendering",
    "explanation": "startTransition allows React to interrupt low-priority UI updates (like filtering a large list) to handle high-priority user interactions (like typing) first, keeping the interface responsive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which lifecycle method is considered unsafe to use in asynchronous applications because it may be called multiple times before an update commits?",
    "options": [
      "componentDidMount",
      "componentDidUpdate",
      "componentWillMount",
      "getSnapshotBeforeUpdate"
    ],
    "answer": "componentWillMount",
    "explanation": "componentWillMount (and other componentWill* methods) is unsafe for async use because React may pause or abandon the render phase, causing the method to be invoked multiple times or not at all before commit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the React Fiber reconciliation algorithm, what heuristic determines when React stops traversing a specific branch of the tree?",
    "options": [
      "When the component exceeds its memory limit",
      "When the `shouldComponentUpdate` method returns false",
      "When React detects a change in element types",
      "When the `key` prop changes"
    ],
    "answer": "When React detects a change in element types",
    "explanation": "If the element type changes (e.g., from `<div>` to `<span>` or `<ComponentA>` to `<ComponentB>`), React assumes the entire subtree has changed, destroys the old subtree, and builds a new one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the behavior of `useEffect` if the dependency array is omitted entirely?",
    "options": [
      "The effect runs once on mount",
      "The effect runs on every render",
      "The effect never runs",
      "The effect runs only on unmount"
    ],
    "answer": "The effect runs on every render",
    "explanation": "Omitting the dependency array causes the effect to run after every single render cycle, which often leads to infinite loops or performance issues if the effect triggers state updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does `React.memo` differ from `useMemo` regarding what it optimizes?",
    "options": [
      "React.memo optimizes a value, useMemo optimizes a function",
      "React.memo optimizes a component, useMemo optimizes a calculated value",
      "React.memo optimizes the render phase, useMemo optimizes the commit phase",
      "There is no functional difference"
    ],
    "answer": "React.memo optimizes a component, useMemo optimizes a calculated value",
    "explanation": "React.memo is a Higher-Order Component that prevents a functional component from re-rendering if props haven't changed. useMemo is a hook that caches the result of an expensive calculation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the primary technical reason that props are read-only in React?",
    "options": [
      "To enforce immutability and ensure Pure Function behavior for components",
      "To reduce the bundle size of the React library",
      "To prevent memory leaks in the browser",
      "To allow React to use WebAssembly for rendering"
    ],
    "answer": "To enforce immutability and ensure Pure Function behavior for components",
    "explanation": "React components must be pure functions of their props (props -> UI). Making props read-only ensures that child components cannot inadvertently mutate data owned by parents, maintaining a unidirectional data flow.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the `ref` return value used for in a custom Ref forwarding scenario?",
    "options": [
      "To store the previous state value",
      "To pass a DOM node or component instance to the parent component",
      "To trigger a re-render in the child component",
      "To access the parent component's context"
    ],
    "answer": "To pass a DOM node or component instance to the parent component",
    "explanation": "Ref forwarding allows a parent component to pass a ref down to a child component and attach it to a specific DOM element or component instance within that child.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Why might a developer use the `forwardRef` HOF instead of a standard `ref` prop?",
    "options": [
      "To access the context of a child component",
      "To pass a ref through a component to one of its children",
      "To create a reference to a class component only",
      "To automatically clean up event listeners"
    ],
    "answer": "To pass a ref through a component to one of its children",
    "explanation": "Standard components cannot pass the `ref` prop to their children. `forwardRef` is required to expose a child's DOM node to a parent component.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What happens when a component throws an error during the Render phase?",
    "options": [
      "The error is caught by window.onerror",
      "The component is unmounted and replaced by an Error Boundary fallback",
      "The error is ignored and the render continues",
      "The entire browser tab crashes"
    ],
    "answer": "The component is unmounted and replaced by an Error Boundary fallback",
    "explanation": "Errors thrown during rendering (and in lifecycle methods) can be caught by a parent Error Boundary component, which renders a fallback UI instead of crashing the whole app.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What distinguishes a Controlled Component from an Uncontrolled Component in React forms?",
    "options": [
      "Controlled components are written in TypeScript, uncontrolled in JavaScript",
      "Controlled components derive their input value from state, unhandled components manage their own internal state",
      "Controlled components do not use refs, uncontrolled components use refs",
      "Controlled components are faster to render than uncontrolled components"
    ],
    "answer": "Controlled components derive their input value from state, unhandled components manage their own internal state",
    "explanation": "In a controlled component, form data is handled by a React component via state. In an uncontrolled component, form data is handled by the DOM itself, usually accessed via refs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does React 18 handle 'hydration' differently regarding event listeners?",
    "options": [
      "It re-attaches all event listeners on every render",
      "It does not re-attach event listeners if the server-rendered HTML matches the client tree",
      "It hydration is now asynchronous and blocking",
      "It uses standard browser events instead of SyntheticEvents"
    ],
    "answer": "It does not re-attach event listeners if the server-rendered HTML matches the client tree",
    "explanation": "React 18 improves hydration performance by not re-attaching event listeners to the DOM if the server-rendered HTML structure matches the client-side Virtual DOM tree, skipping expensive work.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which utility allows you to extract state logic into a testable function without requiring a specific component hierarchy?",
    "options": [
      "useReducer",
      "Custom Hooks",
      "Context API",
      "Render Props"
    ],
    "answer": "Custom Hooks",
    "explanation": "Custom Hooks allow you to reuse stateful logic between components without changing the component hierarchy. They are functions that start with 'use' and can call other Hooks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the definition of a 'Side Effect' in the context of React components?",
    "options": [
      "Any synchronous calculation performed in the render body",
      "An interaction with the outside world (API calls, DOM mutations) during or after render",
      "A mutation of the state variable directly",
      "A bug caused by infinite re-rendering"
    ],
    "answer": "An interaction with the outside world (API calls, DOM mutations) during or after render",
    "explanation": "Side effects are operations that affect things outside the scope of the function returning the UI, such as network requests, manual DOM changes, or timers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the default behavior of `shouldComponentUpdate` in a React Class Component?",
    "options": [
      "It returns false by default",
      "It returns true by default",
      "It compares props deeply and returns the result",
      "It throws an error if not implemented"
    ],
    "answer": "It returns true by default",
    "explanation": "By default, `shouldComponentUpdate` returns `true`, meaning the component always re-renders when new props or state are received.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which API allows rendering a component into a physical DOM node that exists outside the parent component's DOM hierarchy?",
    "options": [
      "React.cloneElement",
      "ReactDOM.createPortal",
      "ReactDOM.hydrate",
      "React.StrictMode"
    ],
    "answer": "ReactDOM.createPortal",
    "explanation": "Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component, useful for modals and tooltips.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the context of `useReducer`, what is the purpose of the third argument to the `useReducer` hook (init function)?",
    "options": [
      "To handle async actions",
      "To lazy initialize the state based on the initial action",
      "To dispatch multiple actions at once",
      "To reset the reducer to its default state"
    ],
    "answer": "To lazy initialize the state based on the initial action",
    "explanation": "The init function allows you to extract logic for calculating the initial state outside the reducer, enabling the state to be reset based on the initial action later.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the behavior difference between `useCallback(fn, deps)` and `useMemo(fn, deps)`?",
    "options": [
      "useCallback caches a function, useMemo caches a value",
      "useCallback caches a value, useMemo caches a function",
      "useCallback runs during commit, useMemo runs during render",
      "There is no difference; they are aliases"
    ],
    "answer": "useCallback caches a function, useMemo caches a value",
    "explanation": "useCallback returns a memoized callback function, whereas useMemo returns a memoized value (the result of a function).",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What does the 'React.pure' method do?",
    "options": [
      "It enforces that a component only accepts primitive props",
      "It is an alias for React.memo",
      "It performs a deep equality check of props and state",
      "There is no such method in the standard React API"
    ],
    "answer": "There is no such method in the standard React API",
    "explanation": "The standard API for preventing re-renders based on shallow prop comparison is `React.memo`. While `React.PureComponent` exists for classes, `React.pure` does not exist.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which legacy method is used to initialize state in a Class Component?",
    "options": [
      "getInitialState",
      "constructor",
      "initState",
      "componentWillMount"
    ],
    "answer": "constructor",
    "explanation": "In modern React, state is initialized in the `constructor` by assigning `this.state`. `getInitialState` was used in `React.createClass`, which is obsolete.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does Strict Mode help detect side effects in React 18?",
    "options": [
      "It runs the constructor twice",
      "It double-invokes the render phase and effects (in development) to detect impure logic",
      "It prevents any component from rendering until all async operations are done",
      "It automatically converts functional components to class components"
    ],
    "answer": "It double-invokes the render phase and effects (in development) to detect impure logic",
    "explanation": "Strict Mode intentionally double-invokes functions like component body, reducer, and effects to make side effects more visible during development.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the technical term for the process where React converts JSX into JavaScript function calls?",
    "options": [
      "Transpilation",
      "Hydration",
      "Reconciliation",
      "Diffing"
    ],
    "answer": "Transpilation",
    "explanation": "Babel (or other transpilers) converts JSX syntax into `React.createElement` (or `jsx` for automatic runtime) calls during the build process.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Why is `className` used instead of `class` in React elements?",
    "options": [
      "Class is a reserved keyword in JavaScript",
      "To avoid confusion with React class components",
      "Browsers do not support the 'class' attribute",
      "To differentiate between CSS classes and Inline styles"
    ],
    "answer": "Class is a reserved keyword in JavaScript",
    "explanation": "Since JSX is syntactic sugar for JavaScript objects, 'class' is a reserved keyword. Therefore, React uses 'className' to set the CSS class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In a functional component, how do you perform a cleanup on a `useEffect` that has a dependency array?",
    "options": [
      "By returning a function from the useEffect callback",
      "By using the componentWillUnmount lifecycle hook",
      "By calling a cleanup function inside the render body",
      "By using the `cleanup` prop on the component"
    ],
    "answer": "By returning a function from the useEffect callback",
    "explanation": "The `useEffect` hook can return a cleanup function. This function runs before the component is removed from the UI and before the effect runs again (if dependencies changed).",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What does the `React.lazy` function do?",
    "options": [
      "It delays the execution of the render method by 500ms",
      "It allows you to define a component that is loaded dynamically (code-splitting)",
      "It puts the component to sleep if it is not in view",
      "It automatically caches the component's stylesheet"
    ],
    "answer": "It allows you to define a component that is loaded dynamically (code-splitting)",
    "explanation": "React.lazy lets you render a dynamic import as a regular component, allowing the code for that component to be loaded only when it is first rendered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which context consumer approach is considered legacy?",
    "options": [
      "Using the useContext hook",
      "Using the Context.Consumer render prop component",
      "Using Context.displayName",
      "Using createContext directly"
    ],
    "answer": "Using the Context.Consumer render prop component",
    "explanation": "While still functional, `Context.Consumer` (requiring a render prop function) is the legacy pattern for consuming context in functional components, largely replaced by the `useContext` hook.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the implication of passing an unstable value (like a new object literal) to a `useRef` dependency?",
    "options": [
      "It will cause the component to re-render indefinitely",
      "It will cause a lint error but not a runtime error",
      "It resets the ref's current value on every render",
      "useRef does not take a dependency array"
    ],
    "answer": "useRef does not take a dependency array",
    "explanation": "The `useRef` hook does not accept a dependency array; it simply returns a mutable ref object. `useEffect` and `useCallback` are the hooks that utilize dependency arrays.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the specific behavior of a 'Server Component' in React Server Components architecture?",
    "options": [
      "It renders on the client using a Web Worker",
      "It renders on the server and has no interactivity (no useState/useEffect)",
      "It hydrates automatically on client mount",
      "It requires JavaScript to be enabled on the client"
    ],
    "answer": "It renders on the server and has no interactivity (no useState/useEffect)",
    "explanation": "Server Components run exclusively on the server. They cannot use hooks like useState or useEffect (which are for client-side interactivity) and their code is not sent to the client.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the core limitation of Synthetic Events compared to native DOM events?",
    "options": [
      "They cannot be stopped from propagation",
      "They do not support all DOM event types",
      "They use a pooling mechanism that can lead to stale data if accessed asynchronously",
      "They are only compatible with Chrome"
    ],
    "answer": "They use a pooling mechanism that can lead to stale data if accessed asynchronously",
    "explanation": "In older React versions, SyntheticEvent objects were pooled (nullified after the event handler). Reading them asynchronously in `setTimeout` or `Promise.then` would result in null properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which method is the recommended way to handle multiple conditional classes in React without a library?",
    "options": [
      "Using the classnames library",
      "Using template literals with ternary operators",
      "Using the CSS-in-JS syntax",
      "Using the `classList.add` method"
    ],
    "answer": "Using template literals with ternary operators",
    "explanation": "While libraries like `classnames` are popular, the native way without dependencies is using template literals (e.g., `base-class ${isActive ? 'active' : ''}`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of React Fiber, what is the specific mechanism that allows the browser to interrupt the rendering process to handle high-priority user inputs?",
    "options": [
      "Time Slicing via the `Scheduler` module and `requestIdleCallback`",
      "Stack frame manipulation using JavaScript generators",
      "The Microtask Queue checking for pending interactions",
      "A Web Worker that offloads the reconciliation algorithm"
    ],
    "answer": "Time Slicing via the `Scheduler` module and `requestIdleCallback`",
    "explanation": "Fiber implements time slicing by breaking work into units, yielding control back to the main thread via the Scheduler (often using `requestIdleCallback` or `MessageChannel`). This allows high-priority events like clicks to interrupt low-priority rendering work.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the correct order of sub-phases within the non-interruptible Commit phase in React's Fiber architecture?",
    "options": [
      "Before Mutation, Mutation, Layout",
      "Mutation, Before Mutation, Layout",
      "Layout, Mutation, Before Mutation",
      "Snapshot, Mutation, Layout"
    ],
    "answer": "Before Mutation, Mutation, Layout",
    "explanation": "The Commit phase runs synchronously in three specific sub-phases: 'Before Mutation' (getSnapshotBeforeUpdate), 'Mutation' (DOM changes), and 'Layout' (updates refs and fires useLayoutEffect).",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does React's double-buffering technique manage state updates during the Render phase?",
    "options": [
      "It modifies the `current` Fiber tree directly and replicates changes to a backup tree",
      "It builds a separate `workInProgress` tree, leaving the `current` tree untouched until commit",
      "It calculates changes in a Virtual DOM diff and patches the real DOM immediately",
      "It maintains two copies of the real DOM and swaps the visible container"
    ],
    "answer": "It builds a separate `workInProgress` tree, leaving the `current` tree untouched until commit",
    "explanation": "React clones nodes from the `current` tree to create a `workInProgress` tree. Updates are applied to this new tree, ensuring the UI remains consistent (referencing `current`) until the changes are fully committed.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Why are React Hooks strictly required to be called at the top level of a component function?",
    "options": [
      "To allow the JavaScript engine to optimize function hoisting",
      "Because the `this` context is lost in nested functions",
      "To ensure the order of hook calls matches the order of the linked list on the Fiber node",
      "To prevent the creation of multiple Fiber nodes for a single component"
    ],
    "answer": "To ensure the order of hook calls matches the order of the linked list on the Fiber node",
    "explanation": "React stores hooks state in a linked list attached to the Fiber node. Calling hooks conditionally or in loops changes the invocation order, causing the internal pointer to mismatch and corrupt state.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What specific role does the `key` prop play during the Reconciliation of child lists?",
    "options": [
      "It acts as a unique identifier for the Virtual DOM to enforce global uniqueness",
      "It allows React to identify which elements have changed, been added, or been removed to minimize DOM mutations",
      "It forces React to re-render the entire component subtree when the value changes",
      "It serves as a cryptographic signature to secure the element tree"
    ],
    "answer": "It allows React to identify which elements have changed, been added, or been removed to minimize DOM mutations",
    "explanation": "Keys help React match elements in the previous tree with elements in the new tree. Without stable keys, React uses sibling index, leading to inefficient re-mounting and state loss when lists are reordered.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which effect hook runs synchronously after all DOM mutations but before the browser has painted the changes to the screen?",
    "options": [
      "useEffect",
      "useInsertionEffect",
      "useLayoutEffect",
      "useImperativeHandle"
    ],
    "answer": "useLayoutEffect",
    "explanation": "useLayoutEffect fires synchronously during the 'Layout' sub-phase of the Commit phase. This blocks the browser paint, allowing developers to read layout from the DOM and apply mutations synchronously.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In Fiber terminology, what is the specific function of the `return` pointer on a Fiber node?",
    "options": [
      "It points to the DOM node that the Fiber renders",
      "It points to the parent Fiber node, used to return to the parent once child processing is complete",
      "It holds the return value of the component function",
      "It stores the next priority level to schedule an update"
    ],
    "answer": "It points to the parent Fiber node, used to return to the parent once child processing is complete",
    "explanation": "The Fiber tree is a linked list. The `return` pointer allows the traversal algorithm to bubble back up the tree after finishing work on a node's children (handling 'completeWork').",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "How does the `startTransition` API affect the scheduling priority of a state update?",
    "options": [
      "It marks the update as 'urgent', triggering an immediate synchronous re-render",
      "It classifies the update as 'transitional' (low priority), allowing React to interrupt it for higher-priority events",
      "It debounces the state update until the main thread is idle for 500ms",
      "It moves the state update to a separate Web Worker to avoid blocking the UI"
    ],
    "answer": "It classifies the update as 'transitional' (low priority), allowing React to interrupt it for higher-priority events",
    "explanation": "Transitions mark non-urgent updates. React treats them with lower priority (Lane model), so typing or clicks can interrupt the rendering of slow transitions to keep the UI responsive.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the purpose of the `sibling` pointer in the Fiber node structure?",
    "options": [
      "To link adjacent nodes in the `workInProgress` tree for efficient traversal",
      "To point to the next component in the application source code order",
      "To reference the previous state of the component for comparison",
      "To manage the list of event listeners attached to the node"
    ],
    "answer": "To link adjacent nodes in the `workInProgress` tree for efficient traversal",
    "explanation": "If a Fiber node has processed its children but has a sibling, React uses the `sibling` pointer to move horizontally across the tree to perform work on the next branch.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which technical constraint necessitated the creation of React Fiber (as opposed to the legacy Stack Reconciler)?",
    "options": [
      "The inability to render components on the server-side",
      "The inability to interrupt execution once the call stack was entered",
      "The lack of support for ES6 class syntax in JavaScript",
      "The difficulty of managing component state without a centralized store"
    ],
    "answer": "The inability to interrupt execution once the call stack was entered",
    "explanation": "The Stack Reconciler rendered recursively in a single, continuous stack frame. Once started, it could not yield control until completion, blocking the main thread and preventing priority-based rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What does the `ShouldComponentUpdate` lifecycle method (or `React.memo`) return to prevent a specific Fiber node from reconciling its children?",
    "options": [
      "false",
      "null",
      "undefined",
      "true"
    ],
    "answer": "false",
    "explanation": "Returning false tells the reconciler to skip 'beginWork' for this subtree. React bails out of rendering, preserving the current Fiber node and its descendants without re-executing the component function.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does React's `useEffect` hook handle cleanup functions for components that unmount?",
    "options": [
      "Cleanup runs immediately when the component function returns",
      "Cleanup runs before the next effect execution or immediately prior to component removal from the DOM",
      "Cleanup runs synchronously during the render phase",
      "Cleanup functions are garbage collected automatically without explicit invocation"
    ],
    "answer": "Cleanup runs before the next effect execution or immediately prior to component removal from the DOM",
    "explanation": "React schedules the cleanup function to run after the browser paint but before the next effect's execution (or unmount), ensuring the UI updates reflect the cleanup before new side effects start.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In the context of the Lane model (used for prioritization), what is the relationship between a Lane's integer value and its update priority?",
    "options": [
      "Higher integer values represent higher priority",
      "Lower integer values represent higher priority",
      "Priority is determined by the bit position (least significant bits are highest priority)",
      "Priority is randomised to prevent starvation"
    ],
    "answer": "Priority is determined by the bit position (least significant bits are highest priority)",
    "explanation": "Lanes are 32-bit integers. The least significant bits (e.g., 1, 2, 4) represent higher priority updates (user interactions), while more significant bits represent lower priority offscreen work.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the primary data structure used by the `Scheduler` (the separate package for React Fiber) to manage task queues?",
    "options": [
      "A standard JavaScript Array sorted by timestamp",
      "A Min-Heap (priority queue)",
      "A Linked List based on insertion order",
      "A Hash Map with task IDs as keys"
    ],
    "answer": "A Min-Heap (priority queue)",
    "explanation": "The Scheduler uses a Min-Heap to efficiently find and pop the task with the earliest expiration time or highest priority, ensuring the most urgent work is performed first.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Why does React `StrictMode` double-invoke effects (like `useState` updater) in development, but not the Render phase itself?",
    "options": [
      "It doubles the render phase but suppresses the extra log to reduce confusion",
      "It only double-invokes functions passed to `useState` to ensure they are pure and idempotent",
      "It double-invokes effects to detect memory leaks in the cleanup phase",
      "StrictMode does not double-invoke any functions in development mode"
    ],
    "answer": "It only double-invokes functions passed to `useState` to ensure they are pure and idempotent",
    "explanation": "In StrictMode, React intentionally mounts-unmounts-remounts components and double-runs reducer functions/effects setup. This helps detect side-effects impurely embedded in render logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What happens during the 'Mutation' sub-phase of the Commit phase?",
    "options": [
      "React calculates the diff and prepares the `workInProgress` tree",
      "React inserts, updates, and removes DOM nodes based on the finished `workInProgress` tree",
      "React executes `getSnapshotBeforeUpdate` lifecycle methods",
      "React flushes passive effects (`useEffect`) to the screen"
    ],
    "answer": "React inserts, updates, and removes DOM nodes based on the finished `workInProgress` tree",
    "explanation": "The Mutation phase is where the actual DOM manipulations (appendChild, removeChild, textContent changes) occur based on the finalized Fiber tree.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is `useSyncExternalStore` designed to solve in the context of Concurrent Rendering?",
    "options": [
      "It synchronizes the internal Fiber state with external Web Workers",
      "It provides a mechanism to subscribe to external data sources while ensuring reads and writes are atomic (tear-free)",
      "It replaces Redux by automatically syncing state across browser tabs",
      "It allows synchronous data fetching during the render phase"
    ],
    "answer": "It provides a mechanism to subscribe to external data sources while ensuring reads and writes are atomic (tear-free)",
    "explanation": "In Concurrent Mode, a render might be interrupted. `useSyncExternalStore` ensures that external state reads are consistent and don't 'tear' (show parts of old and new state) during concurrent rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "How does `flushSync` differ from a standard state update in React 18+?",
    "options": [
      "`flushSync` forces a synchronous, blocking commit of the update immediately, ignoring priority",
      "`flushSync` batches the update with the next high-priority user interaction",
      "`flushSync` invalidates the entire Fiber cache and forces a full re-render",
      "`flushSync` only runs `useLayoutEffect` and skips `useEffect`"
    ],
    "answer": "`flushSync` forces a synchronous, blocking commit of the update immediately, ignoring priority",
    "explanation": "`flushSync` forces React to perform the work synchronously, bypassing the Scheduler's time-slicing. It blocks until the update is committed to the DOM.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the specific behavior of `React.lazy` combined with `Suspense` during the initial render?",
    "options": [
      "It throws a Promise which triggers the Suspense boundary's fallback",
      "It returns a `null` component until the Promise resolves",
      "It blocks the main thread until the chunk is downloaded",
      "It automatically hydrates the component before the initial paint"
    ],
    "answer": "It throws a Promise which triggers the Suspense boundary's fallback",
    "explanation": "When a lazy component is rendered, React throws a Promise (the chunk request). The Suspense boundary catches this Promise, suspends rendering, and shows the fallback UI until the Promise resolves.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does React handle Context updates to prevent unnecessary re-renders of consumers?",
    "options": [
      "It uses `Proxy` objects to track property access",
      "It checks if the `value` prop of the Provider has changed by reference (shallow comparison)",
      "It deep-compares the context object to verify changes",
      "It only updates consumers if they are direct children of the Provider"
    ],
    "answer": "It checks if the `value` prop of the Provider has changed by reference (shallow comparison)",
    "explanation": "React uses `Object.is` (reference equality) to check if the Provider's value changed. If the reference is the same, consumers are skipped; if the reference changes, all consuming components are re-rendered.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the function of the `alternate` property on a Fiber node?",
    "options": [
      "It stores the previous props for comparison purposes",
      "It points to the corresponding node in the other tree (current <-> workInProgress)",
      "It provides a backup node to use if the render fails",
      "It links the node to its sibling in the same tree"
    ],
    "answer": "It points to the corresponding node in the other tree (current <-> workInProgress)",
    "explanation": "The `alternate` attribute creates a circular link between the node in the `current` tree and its counterpart in the `workInProgress` tree, facilitating efficient cloning and tree swapping.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which function is responsible for creating the DOM instances but not yet appending them to the container during the Render phase?",
    "options": [
      "createInstance",
      "appendChild",
      "commitPlacement",
      "finalizeInitialChildren"
    ],
    "answer": "createInstance",
    "explanation": "During 'completeWork', React calls `createInstance` (host config) to create the DOM node. It does not append them to the container yet; that happens later in the Mutation phase.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the 'Zombie Child' effect in React reconciliation?",
    "options": [
      "When a child component remains mounted after its parent unmounts",
      "When React applies properties meant for a new element to an old element before replacing it",
      "When memory leaks occur due to unsubscribed events",
      "When a child Fiber node enters the `workInProgress` tree but has no corresponding current node"
    ],
    "answer": "When React applies properties meant for a new element to an old element before replacing it",
    "explanation": "In the Stack Reconciler, this occurred when props were applied to a stale DOM node. In Fiber, it is mitigated by the distinct phases, ensuring DOM updates apply only to the finalized tree.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In React Server Components (RSC), where is the serialized JSON output of the component tree rendered?",
    "options": [
      "On the client browser",
      "On the server, and streamed to the client",
      "In the Edge Worker only",
      "Inside the Web Worker via `useWorker`"
    ],
    "answer": "On the server, and streamed to the client",
    "explanation": "RSCs render on the server to a special format (not HTML), which is streamed to the client. The client runtime then reconstructs the UI, often merging it with client interactivity.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the primary technical reason `className` is used instead of `class` in JSX?",
    "options": [
      "To support IE8 compatibility",
      "Because `class` is a reserved keyword in JavaScript, creating parsing issues for the JSX transform",
      "To distinguish React classes from HTML classes",
      "Because Babel requires specific attribute mappings"
    ],
    "answer": "Because `class` is a reserved keyword in JavaScript, creating parsing issues for the JSX transform",
    "explanation": "JSX is syntactic sugar for function calls. Since `class` is a reserved word in JS (used for class definitions), React uses `className` to avoid syntax errors in the generated object.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does `useId` guarantee uniqueness of IDs across Server and Client in Suspense boundaries?",
    "options": [
      "It uses the component's name combined with a global counter",
      "It uses a deterministic algorithm based on the tree structure and a 'base path' logic that survives server-to-client transfer",
      "It generates random UUIDs on the server and syncs them via cookies",
      "It relies on the `key` prop of the parent component"
    ],
    "answer": "It uses a deterministic algorithm based on the tree structure and a 'base path' logic that survives server-to-client transfer",
    "explanation": "If the number of suspense boundaries differs between server and client, indexes shift. `useId` uses a logical 'path' to the component rather than a simple index to ensure ID stability.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the term for the concept where a component 'remembers' a value across renders without causing a re-render when updated?",
    "options": [
      "State",
      "Effect",
      "Ref",
      "Context"
    ],
    "answer": "Ref",
    "explanation": "A `useRef` stores a mutable value in the `.current` property. Unlike `useState`, updating a ref does not trigger a re-render, allowing it to persist values across renders without side effects.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Why is it recommended to pass a dispatcher to `setState` rather than the direct next state?",
    "options": [
      "It allows React to batch the state update and access the previous state reliably",
      "It reduces the memory footprint of the component",
      "It forces the update to happen synchronously",
      "It automatically serializes the object for storage"
    ],
    "answer": "It allows React to batch the state update and access the previous state reliably",
    "explanation": "Using a function `(prevState) => newState` ensures the update is based on the most recent state, avoiding race conditions where updates might overwrite each other due to closures.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "In the context of `act` from `react-dom/test-utils`, what does `act` enforce?",
    "options": [
      "That all state updates are synchronous and applied before `act` returns",
      "That the component is mounted and unmounted automatically",
      "That no network requests are made during the test",
      "That the test runs in a strict mode environment"
    ],
    "answer": "That all state updates are synchronous and applied before `act` returns",
    "explanation": "`act` ensures that all pending React updates (renders, effects) have been flushed to the DOM before the assertion runs, making tests deterministic and reproducible.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "How does the 'ref forwarding' technique technically interact with the Fiber tree?",
    "options": [
      "It bypasses the Fiber node of the HOC and directly attaches the ref to the child DOM node",
      "It creates a new Fiber node specifically for the ref in the middle of the tree",
      "It modifies the `current` property of the parent Fiber to point to the child",
      "It converts the DOM node into a React Element"
    ],
    "answer": "It bypasses the Fiber node of the HOC and directly attaches the ref to the child DOM node",
    "explanation": "Without forwarding, a ref attaches to the wrapper component's Fiber instance. Forwarding uses `React.forwardRef` to pass the ref prop through the intermediate Fiber nodes to the underlying host component.",
    "difficulty": "Advanced"
  }
]