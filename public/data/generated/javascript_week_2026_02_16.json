[
  {
    "id": 1,
    "question": "Which keyword declares a block-scoped variable that cannot be reassigned after initialization?",
    "options": [
      "var",
      "let",
      "const",
      "static"
    ],
    "answer": "const",
    "explanation": "The `const` keyword creates a block-scoped constant reference. While the variable cannot be reassigned, the properties of objects assigned to it remain mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What value does the `typeof` operator return for a `null` value in JavaScript?",
    "options": [
      "'null'",
      "'undefined'",
      "'object'",
      "'number'"
    ],
    "answer": "'object'",
    "explanation": "This is a legacy bug in JavaScript. `typeof null` returns 'object' instead of 'null' for backward compatibility with early implementations.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which of the following is NOT a valid JavaScript primitive data type?",
    "options": [
      "Boolean",
      "Symbol",
      "Object",
      "BigInt"
    ],
    "answer": "Object",
    "explanation": "JavaScript has 7 primitive types: String, Number, BigInt, Boolean, Undefined, Symbol, and Null. Objects are used to store collections of data and more complex entities.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the output of `console.log(1 + '1')` in JavaScript?",
    "options": [
      "2",
      "'11'",
      "NaN",
      "TypeError"
    ],
    "answer": "'11'",
    "explanation": "The `+` operator triggers type coercion. When a number is added to a string, the number is converted to a string, resulting in concatenation.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which method is used to remove the last element from an array and return that element?",
    "options": [
      "shift()",
      "pop()",
      "push()",
      "slice()"
    ],
    "answer": "pop()",
    "explanation": "`pop()` removes the last element. `shift()` removes the first element. `push()` adds an element to the end.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What distinguishes a `let` variable from a `var` variable?",
    "options": [
      "`let` is function-scoped, while `var` is block-scoped",
      "`var` allows redeclaration, while `let` does not",
      "`let` cannot be updated, while `var` can",
      "`var` is block-scoped, while `let` is global"
    ],
    "answer": "`var` allows redeclaration, while `let` does not",
    "explanation": "Both `let` and `var` can be updated, but only `var` allows you to redeclare the same variable name in the same scope. `let` is block-scoped, `var` is function-scoped.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the result of `Boolean(0)` and `Boolean('0')`?",
    "options": [
      "true, false",
      "false, true",
      "false, false",
      "true, true"
    ],
    "answer": "false, true",
    "explanation": "The number `0` is a falsy value. However, any non-empty string, including the string `'0'`, is a truthy value.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which function creates a new array by applying a function to every element in an existing array?",
    "options": [
      "Array.forEach()",
      "Array.map()",
      "Array.filter()",
      "Array.reduce()"
    ],
    "answer": "Array.map()",
    "explanation": "`map()` creates a new array populated with the results of calling a provided function on every element. `forEach()` returns undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "How do you declare a function that can be called before its definition in the code?",
    "options": [
      "Arrow function expression",
      "Function expression assigned to a variable",
      "Function declaration",
      "Callback function"
    ],
    "answer": "Function declaration",
    "explanation": "Function declarations are hoisted to the top of their scope, allowing them to be called before they are defined. Function expressions are not hoisted.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the default value of a function parameter that is not provided by the caller?",
    "options": [
      "null",
      "0",
      "undefined",
      "NaN"
    ],
    "answer": "undefined",
    "explanation": "JavaScript initializes function parameters that are not supplied with the value `undefined`.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which statement is used to exit a loop completely in JavaScript?",
    "options": [
      "continue",
      "break",
      "return",
      "exit"
    ],
    "answer": "break",
    "explanation": "`break` terminates the current loop or switch statement. `continue` skips to the next iteration of the loop.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the purpose of the `this` keyword in a JavaScript object method?",
    "options": [
      "To refer to the parent class",
      "To refer to the object that is executing the current function",
      "To refer to the global window object",
      "To refer to the function itself"
    ],
    "answer": "To refer to the object that is executing the current function",
    "explanation": "In an object method, `this` refers to the 'owner' of the method, which is the object itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which syntax correctly imports a specific function from a module named `mathUtils.js`?",
    "options": [
      "import sum from './mathUtils.js'",
      "import { sum } from './mathUtils.js'",
      "require('./mathUtils.js')",
      "include './mathUtils.js'"
    ],
    "answer": "import { sum } from './mathUtils.js'",
    "explanation": "Named imports require curly braces. `import { sum } ...` is the standard ES6 module syntax for importing specific exports.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is a closure in JavaScript?",
    "options": [
      "A function that has no access to its parent scope",
      "A function bundled together with references to its surrounding state (lexical environment)",
      "A method to close a database connection",
      "A variable that cannot be accessed"
    ],
    "answer": "A function bundled together with references to its surrounding state (lexical environment)",
    "explanation": "A closure allows a function to access variables from an outer function that has already returned, preserving the scope chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which operator allows you to access an object property using a variable key?",
    "options": [
      "Dot notation (.)",
      "Bracket notation ([])",
      "Arrow operator (=>)",
      "Hash symbol (#)"
    ],
    "answer": "Bracket notation ([])",
    "explanation": "Bracket notation, e.g., `obj[key]`, evaluates the expression inside the brackets to find the matching property name. Dot notation requires a literal identifier.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What happens when you use the `delete` operator on an object property?",
    "options": [
      "It removes the property from the object",
      "It sets the property value to null",
      "It sets the property value to undefined",
      "It throws a syntax error"
    ],
    "answer": "It removes the property from the object",
    "explanation": "The `delete` operator completely removes the property (key and value) from the object, rather than just setting the value to null or undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which method converts a JSON object into a string?",
    "options": [
      "JSON.parse()",
      "JSON.toString()",
      "JSON.stringify()",
      "JSON.convert()"
    ],
    "answer": "JSON.stringify()",
    "explanation": "`JSON.stringify()` converts a JavaScript object or value to a JSON string. `JSON.parse()` does the reverse.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the purpose of the `finally` block in a `try...catch` statement?",
    "options": [
      "To execute code only if an error occurs",
      "To execute code only if no error occurs",
      "To execute code regardless of whether an exception was thrown or caught",
      "To stop the execution of the program"
    ],
    "answer": "To execute code regardless of whether an exception was thrown or caught",
    "explanation": "The `finally` block runs after the `try` and `catch` blocks complete, ensuring cleanup code runs even if an error occurs.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which loop is best suited for iterating over the indices of an array?",
    "options": [
      "for...of loop",
      "for...in loop",
      "forEach() method",
      "while loop"
    ],
    "answer": "for...in loop",
    "explanation": "`for...in` iterates over enumerable property keys (including indices), whereas `for...of` iterates over the values. While `forEach` works, it is not a loop construct.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the output of `console.log(typeof undefined)`?",
    "options": [
      "'undefined'",
      "'null'",
      "'object'",
      "'number'"
    ],
    "answer": "'undefined'",
    "explanation": "The `typeof` operator returns the string 'undefined' for an undefined variable or value.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which global object is used to schedule a function to run after a specified delay in milliseconds?",
    "options": [
      "setInterval",
      "setTimeout",
      "requestAnimationFrame",
      "Promise.resolve"
    ],
    "answer": "setTimeout",
    "explanation": "`setTimeout` executes a function once after a specified delay. `setInterval` executes repeatedly.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the purpose of the `async` keyword before a function declaration?",
    "options": [
      "To make the function run synchronously",
      "To allow the use of the `await` keyword within the function",
      "To prevent the function from returning a value",
      "To automatically catch errors"
    ],
    "answer": "To allow the use of the `await` keyword within the function",
    "explanation": "The `async` keyword defines an asynchronous function, which implicitly returns a Promise and allows the use of `await` inside it.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which comparison operator checks if two values are not equal without performing type coercion?",
    "options": [
      "!==",
      "!=",
      "!===",
      "!"
    ],
    "answer": "!==",
    "explanation": "`!==` is the strict inequality operator. `!=` performs loose inequality with type coercion.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "In the DOM, which method is used to select the first element that matches a specific CSS selector?",
    "options": [
      "document.querySelectorAll()",
      "document.getElementsByTagName()",
      "document.querySelector()",
      "document.getElementById()"
    ],
    "answer": "document.querySelector()",
    "explanation": "`document.querySelector()` returns the first matching element. `querySelectorAll` returns a NodeList of all matches.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the result of the spread operator `[...arr]` used on an array?",
    "options": [
      "It creates a reference to the original array",
      "It creates a shallow copy of the array",
      "It concatenates two arrays",
      "It deletes the array elements"
    ],
    "answer": "It creates a shallow copy of the array",
    "explanation": "The spread syntax expands an iterable (like an array) into its individual elements, effectively creating a shallow copy when used in brackets.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which of the following values evaluates to `false` in a Boolean context?",
    "options": [
      "'false'",
      "[]",
      "0",
      "{}"
    ],
    "answer": "0",
    "explanation": "The number `0` is falsy. Non-empty strings, empty arrays, and empty objects are truthy in JavaScript.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the main difference between `slice()` and `splice()` array methods?",
    "options": [
      "`slice` modifies the original array, `splice` does not",
      "`splice` modifies the original array, `slice` does not",
      "Both methods modify the original array",
      "Both methods return a string"
    ],
    "answer": "`splice` modifies the original array, `slice` does not",
    "explanation": "`splice()` changes the contents of an array by removing or replacing elements. `slice()` returns a shallow copy of a portion of an array.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the logical AND (&&) short-circuit evaluation behavior?",
    "options": [
      "It executes both operands regardless of the first value",
      "It returns the first falsy value encountered or the last value if all are truthy",
      "It returns true only if both operands are strings",
      "It always returns a boolean true"
    ],
    "answer": "It returns the first falsy value encountered or the last value if all are truthy",
    "explanation": "If the first operand is falsy, the expression returns it immediately. Otherwise, it returns the second operand.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which variable declaration creates a variable in the global scope regardless of where it is declared?",
    "options": [
      "let",
      "const",
      "var",
      "block"
    ],
    "answer": "var",
    "explanation": "`var` declarations are function-scoped or globally scoped; they are not block-scoped. `let` and `const` are block-scoped.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "How do you create a Promise that resolves immediately with the value 'success'?",
    "options": [
      "Promise.resolve('success')",
      "new Promise('success')",
      "Promise.return('success')",
      "resolve('success')"
    ],
    "answer": "Promise.resolve('success')",
    "explanation": "`Promise.resolve(value)` returns a Promise object that is resolved with the given value.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the specific term for an arrow function that takes exactly one parameter?",
    "options": [
      "It requires parentheses around the parameter",
      "It can omit the parentheses around the parameter list",
      "It must use the `function` keyword",
      "It cannot return a value"
    ],
    "answer": "It can omit the parentheses around the parameter list",
    "explanation": "Arrow functions allow `param => expression` syntax for single parameters. Parentheses are required for zero or multiple parameters.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which feature allows importing only specific parts of a module rather than the whole file?",
    "options": [
      "Default export",
      "Named export",
      "Namespace export",
      "Wildcard export"
    ],
    "answer": "Named export",
    "explanation": "Named exports allow specific functions or variables to be imported individually using curly braces (e.g., `import { func } from '...'`).",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which string method checks if a string exists within another string and returns `true` or `false`?",
    "options": [
      "indexOf()",
      "includes()",
      "search()",
      "match()"
    ],
    "answer": "includes()",
    "explanation": "`includes()` returns a boolean indicating whether the specified string is contained within the string. `indexOf` returns an index number.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What behavior defines 'Hoisting' in JavaScript?",
    "options": [
      "Moving function declarations to the top of the file during compilation",
      "Moving variable declarations to the top of their scope before code execution",
      "Converting all code to strict mode",
      "Automatically optimizing loops for performance"
    ],
    "answer": "Moving variable declarations to the top of their scope before code execution",
    "explanation": "Hoisting is the default behavior of moving declarations (not initializations) to the top of the current scope (function or global).",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In the V8 engine, what is the specific role of the 'Ignition' interpreter?",
    "options": [
      "It compiles JavaScript directly into machine code ahead of time",
      "It executes bytecode and collects feedback for optimization",
      "It manages the asynchronous callback queue and event loop",
      "It performs garbage collection on the old generation space"
    ],
    "answer": "It executes bytecode and collects feedback for optimization",
    "explanation": "Ignition is V8's interpreter that executes bytecode. It collects type feedback and execution profiles, which are passed to optimizing compilers like TurboFan to generate efficient machine code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "Regarding the JavaScript Event Loop, when are Microtasks (such as Promise callbacks) processed relative to Macrotasks (such as setTimeout)?",
    "options": [
      "After all Macrotasks in the queue have been executed",
      "Before the next Macrotask begins, but after the current script finishes",
      "Concurrently with Macrotasks via multi-threading",
      "Only when the call stack is completely empty and the browser is idle"
    ],
    "answer": "Before the next Macrotask begins, but after the current script finishes",
    "explanation": "Microtasks are processed after the current execution context (script) completes and before the next Macrotask is taken from the queue. This ensures high-priority task resolution, such as Promise chains.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary technical consequence of modifying an object's structure (e.g., adding a property) after V8 has optimized it based on a 'Hidden Class'?",
    "options": [
      "The object is garbage collected immediately",
      "The object is moved to the Large Object Space (LOS)",
      "A deoptimization is triggered, reverting to slower execution",
      "The Hidden Class is updated in-place without penalty"
    ],
    "answer": "A deoptimization is triggered, reverting to slower execution",
    "explanation": "V8 relies on stable object shapes (Hidden Classes) for inline caching. Changing the structure forces V8 to abandon the optimized code path and generate a new Hidden Class, incurring a performance penalty.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In the context of V8's generational garbage collector, why are new objects allocated in the 'New Space' (Young Generation)?",
    "options": [
      "It uses a compressed pointer representation to save RAM",
      "It assumes most objects die young (Short-lived objects), making collection faster",
      "It prevents memory fragmentation by using a compacting algorithm",
      "It allows objects to be serialized to disk automatically"
    ],
    "answer": "It assumes most objects die young (Short-lived objects), making collection faster",
    "explanation": "The 'Generational Hypothesis' posits that most objects are short-lived. By allocating them in a small New Space, V8 can perform frequent, fast Scavenger collections, reclaiming memory with minimal overhead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the fundamental behavior difference between `Object.freeze()` and `Object.seal()` in JavaScript?",
    "options": [
      "`seal` deletes all existing properties, while `freeze` keeps them",
      "`freeze` prevents adding/removing properties and makes existing properties non-writable, while `seal` only allows modification of existing property values",
      "`seal` prevents prototype chain changes, while `freeze` allows them",
      "There is no difference; they are aliases for the same operation"
    ],
    "answer": "`freeze` prevents adding/removing properties and makes existing properties non-writable, while `seal` only allows modification of existing property values",
    "explanation": "`Object.seal()` prevents adding or removing properties but allows modifying existing values. `Object.freeze()` makes the object immutable by also preventing changes to existing property values (writable: false).",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which statement accurately describes the behavior of the `this` keyword in an arrow function compared to a standard function expression?",
    "options": [
      "Arrow functions bind `this` dynamically based on the call site",
      "Arrow functions lexically bind `this` from the enclosing parent scope at creation time",
      "Arrow functions do not have a `this` binding and throw a ReferenceError",
      "Arrow functions rebind `this` to the global object if not in strict mode"
    ],
    "answer": "Arrow functions lexically bind `this` from the enclosing parent scope at creation time",
    "explanation": "Unlike standard functions, arrow functions do not have their own `this` context. They capture the `this` value of the surrounding lexical scope, making them ideal for callbacks in object-oriented patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the output order when executing `console.log('start'); setTimeout(() => console.log('timeout'), 0); Promise.resolve().then(() => console.log('promise')); console.log('end');`?",
    "options": [
      "start, end, timeout, promise",
      "start, end, promise, timeout",
      "start, promise, timeout, end",
      "start, timeout, promise, end"
    ],
    "answer": "start, end, promise, timeout",
    "explanation": "Synchronous code ('start', 'end') runs first. Microtasks (Promise) run immediately after the stack clears. Macrotasks (setTimeout) run in the next iteration of the Event Loop.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In V8, what is 'On-Stack Replacement' (OSR)?",
    "options": [
      "Replacing the event loop stack with a worker thread stack",
      "Swapping optimized machine code mid-execution in a long-running loop",
      "Replacing the memory heap with a new generation space",
      "Swapping out the internal V8 engine version at runtime"
    ],
    "answer": "Swapping optimized machine code mid-execution in a long-running loop",
    "explanation": "OSR allows V8 to switch from unoptimized bytecode to optimized machine code while a function is actively running (e.g., inside a long loop), without waiting for the function to restart.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What distinguishes a `WeakMap` from a standard `Map` in JavaScript regarding memory management?",
    "options": [
      "`WeakMap` keys must be objects and are held weakly, allowing garbage collection if no other references exist",
      "`WeakMap` uses a hash table for faster O(1) lookup time",
      "`WeakMap` stores data in the persistent disk cache rather than RAM",
      "`WeakMap` allows primitive values like strings as keys but not objects"
    ],
    "answer": "`WeakMap` keys must be objects and are held weakly, allowing garbage collection if no other references exist",
    "explanation": "In a `WeakMap`, references to key objects are 'weak', meaning they do not prevent garbage collection. If the key object is destroyed elsewhere, the entry is automatically removed from the `WeakMap`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "How does the `async` keyword function regarding return values under the hood?",
    "options": [
      "It returns the value directly, blocking execution until resolved",
      "It automatically wraps the returned value in a resolved Promise",
      "It converts the function into a synchronous generator function",
      "It returns `undefined` unless the `await` keyword is used"
    ],
    "answer": "It automatically wraps the returned value in a resolved Promise",
    "explanation": "Declaring a function `async` ensures it always returns a Promise. If a non-Promise value is returned, JavaScript automatically wraps it in a resolved Promise; if a Promise is returned, it is returned directly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the primary technical reason `let` and `const` variables are not accessible before their declaration (Temporal Dead Zone)?",
    "options": [
      "They are stored in the heap instead of the stack",
      "They are hoisted but remain uninitialized until the code execution reaches the declaration line",
      "They are not hoisted, whereas `var` is",
      "The browser deletes the variable reference until initialization"
    ],
    "answer": "They are hoisted but remain uninitialized until the code execution reaches the declaration line",
    "explanation": "While `let` and `const` are hoisted to the top of their block scope, they remain in a 'Temporal Dead Zone' where accessing them throws a `ReferenceError` until the declaration line is executed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which method correctly creates a new object that inherits from a specific prototype without invoking the parent constructor?",
    "options": [
      "`Object.assign(child, parent)`",
      "`Object.create(proto)`",
      "`new Parent.prototype.constructor()`",
      "`child.prototype = parent`"
    ],
    "answer": "`Object.create(proto)`",
    "explanation": "`Object.create(proto)` creates a new object with the specified prototype object and properties. It does not execute a constructor function, making it ideal for establishing prototype chains.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In JavaScript, what is the result of `1 + '1'` and why?",
    "options": [
      "`2` because JavaScript performs type coercion to Number",
      "`NaN` because string addition is not supported",
      "`'11'` because the `+` operator triggers string concatenation when one operand is a string",
      "`TypeError` because implicit coercion is unsafe"
    ],
    "answer": "`'11'` because the `+` operator triggers string concatenation when one operand is a string",
    "explanation": "The `+` operator is overloaded for both arithmetic and string concatenation. If one operand is a string, JavaScript converts the other to a string and concatenates them.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the primary purpose of 'Inline Caching' (IC) in the V8 engine?",
    "options": [
      "To inline HTML and CSS directly into the JavaScript source",
      "To cache machine code on the hard disk for faster startup",
      "To optimize property access by embedding assumptions about object shapes directly into generated code",
      "To compress the JavaScript bundle size using gzip"
    ],
    "answer": "To optimize property access by embedding assumptions about object shapes directly into generated code",
    "explanation": "Inline Caching optimizes dynamic property lookups by remembering the locations (offsets) of properties on objects of the same 'Hidden Class' (shape), embedding these offsets directly into the machine code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Why does `0.1 + 0.2 !== 0.3` return `true` in JavaScript?",
    "options": [
      "A bug in the V8 comparison algorithm",
      "IEEE 754 double-precision floating-point representation cannot precisely represent 0.1 or 0.2",
      "JavaScript interprets the dot as a method chaining operator",
      "The `+` operator has higher precedence than `===`"
    ],
    "answer": "IEEE 754 double-precision floating-point representation cannot precisely represent 0.1 or 0.2",
    "explanation": "JavaScript uses binary floating-point format (IEEE 754). Fractions like 1/10 and 1/5 result in repeating binary fractions, leading to tiny precision errors (e.g., 0.30000000000000004) that prevent strict equality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What happens when a `Promise` rejection is not handled (no `.catch` handler) in a Node.js environment?",
    "options": [
      "The error is silently ignored by the event loop",
      "The application immediately crashes with a `UnhandledPromiseRejectionWarning`",
      "The rejection is stored in a global buffer until the process exits",
      "The promise retries automatically until it resolves"
    ],
    "answer": "The application immediately crashes with a `UnhandledPromiseRejectionWarning`",
    "explanation": "In modern Node.js, an unhandled rejection causes an `UnhandledPromiseRejectionWarning`. If no handler is attached before the event loop continues, it may trigger a crash/hook to prevent silent failures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the effect of using the 'spread' syntax `[...array]` on an object with holes (sparse arrays)?",
    "options": [
      "It throws an error for undefined indices",
      "It creates a dense array, replacing holes with `undefined` values",
      "It creates a sparse array with the same memory addresses",
      "It converts the array into a JSON string"
    ],
    "answer": "It creates a dense array, replacing holes with `undefined` values",
    "explanation": "When spreading a sparse array, the iterator treats empty slots as if they have the value `undefined`, resulting in a new, dense (contiguous) array where holes are replaced with actual `undefined` values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In the V8 engine, what triggers 'Deoptimization' of a previously optimized function?",
    "options": [
      "The function is executed fewer than 100 times",
      "The function runs out of allocated stack memory",
      "Assumptions made during optimization (e.g., object shape) are violated by new input",
      "The user switches to a different browser tab"
    ],
    "answer": "Assumptions made during optimization (e.g., object shape) are violated by new input",
    "explanation": "V8 optimizes code based on heuristics and type feedback. If the code encounters data types or object structures that contradict those assumptions (e.g., changing a hidden class), the optimized code is discarded (deoptimized) and execution falls back to the interpreter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which term describes the behavior where a JavaScript variable remains accessible in a closure even after the function creating it has returned?",
    "options": [
      "Hoisting",
      "Scope chaining",
      "Lexical scoping",
      "Variable resurrection"
    ],
    "answer": "Scope chaining",
    "explanation": "Closures maintain a reference to their parent's scope. When a variable is accessed, the JavaScript engine traverses the scope chain upwards until it finds the variable definition, preserving the state of variables from outer functions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the technical limitation of using `JSON.stringify()` to serialize objects with circular references?",
    "options": [
      "It converts circular references to the string `null`",
      "It throws a `TypeError` due to a circular structure",
      "It automatically removes the properties causing the cycle",
      "It serializes the circular reference as `undefined`"
    ],
    "answer": "It throws a `TypeError` due to a circular structure",
    "explanation": "The native `JSON.stringify` algorithm does not handle circular references by default; it detects a cycle in the object graph and throws a `TypeError` (Converting circular structure to JSON).",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the primary difference between `requestAnimationFrame` and `setTimeout` in the context of browser rendering?",
    "options": [
      "`setTimeout` runs immediately, while `requestAnimationFrame` waits 100ms",
      "`requestAnimationFrame` synchronizes with the browser's repaint rate (typically 60fps), `setTimeout` does not",
      "`requestAnimationFrame` runs on a separate Web Worker thread",
      "`setTimeout` is deprecated in favor of `requestAnimationFrame`"
    ],
    "answer": "`requestAnimationFrame` synchronizes with the browser's repaint rate (typically 60fps), `setTimeout` does not",
    "explanation": "`requestAnimationFrame` attempts to execute the callback right before the next repaint, optimizing visual updates. `setTimeout` schedules based on time delays independent of the display refresh cycle.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "How does V8's 'TurboFan' compiler differ from the 'Ignition' interpreter?",
    "options": [
      "Ignition is used for parsing, TurboFan is used for garbage collection",
      "Ignition executes bytecode, TurboFan produces optimized machine code",
      "Ignition runs on the server, TurboFan runs in the browser",
      "TurboFan interprets source code, Ignition compiles to bytecode"
    ],
    "answer": "Ignition executes bytecode, TurboFan produces optimized machine code",
    "explanation": "Ignition is the baseline interpreter that generates and executes bytecode. TurboFan is the optimizing compiler that takes 'hot' functions and compiles them into highly efficient machine code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In Node.js, why is `process.nextTick` not technically part of the Event Loop phases?",
    "options": [
      "It runs in a separate process thread",
      "It executes immediately after the current operation completes, before the Event Loop continues",
      "It is deprecated and replaced by `setImmediate`",
      "It is part of the Timers phase but has higher priority"
    ],
    "answer": "It executes immediately after the current operation completes, before the Event Loop continues",
    "explanation": "`process.nextTick` is handled by the C++ `nextTickQueue`. It drains *after* the current C++ API call finishes but *before* returning to the Event Loop to process the next phase, potentially causing I/O starvation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the result of `typeof null` in JavaScript?",
    "options": [
      "`'null'`",
      "`'undefined'`",
      "`'object'`",
      "`'number'`"
    ],
    "answer": "`'object'`",
    "explanation": "This is a legacy bug in JavaScript. The `typeof` operator returns `'object'` for `null` because of how machine words were tagged in early implementations, specifically to represent the null pointer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the function of the 'Symbol' primitive type in JavaScript?",
    "options": [
      "To create unique, immutable identifiers for object properties",
      "To encrypt data stored in variables",
      "To reference the prototype of an object",
      "To define global constants across frames"
    ],
    "answer": "To create unique, immutable identifiers for object properties",
    "explanation": "Symbols are guaranteed to be unique. They are often used to add properties to objects without risking property name collisions (e.g., for internal logic or iteration skipping).",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In a Proxy object, which trap method is triggered when the `in` operator is used?",
    "options": [
      "`has`",
      "`get`",
      "`in`",
      "`check`"
    ],
    "answer": "`has`",
    "explanation": "The `has` trap corresponds to the `in` operator. It allows you to intercept `prop in proxy` operations to return custom boolean values or hide properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the output of `[2, 3, 10].sort()` in JavaScript?",
    "options": [
      "`[2, 3, 10]`",
      "`[2, 10, 3]`",
      "`[10, 2, 3]`",
      "`[3, 2, 10]`"
    ],
    "answer": "`[10, 2, 3]`",
    "explanation": "JavaScript's default `.sort()` converts elements to strings and compares their UTF-16 code units values. '10' comes before '2' lexicographically because the character '1' has a lower code unit than '2'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which feature of ES Modules contributes to better static analysis and tree-shaking compared to CommonJS?",
    "options": [
      "Dynamic execution of require() paths",
      "Static import/export structure defined at parse time",
      "The ability to import JSON directly",
      "Synchronous loading of modules"
    ],
    "answer": "Static import/export structure defined at parse time",
    "explanation": "ES Modules define their import/export dependencies statically before the code runs. This allows engines to determine the module graph ahead of time, enabling dead code elimination (tree-shaking) that dynamic `require()` does not support.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the behavior of the `delete` operator on an array element (e.g., `delete arr[1]`)?",
    "options": [
      "It removes the element and re-indexes the array to close the gap",
      "It removes the element but leaves the array length unchanged, creating a sparse hole",
      "It throws a TypeError because arrays are fixed-size",
      "It sets the value at the index to `0`"
    ],
    "answer": "It removes the element but leaves the array length unchanged, creating a sparse hole",
    "explanation": "The `delete` operator removes the property (index) from the object. It does not shift the subsequent elements; the index becomes empty (empty slot), and the array's length property remains the same.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Why is the `class` syntax in JavaScript considered 'syntactic sugar' for prototypal inheritance?",
    "options": [
      "It does not support private properties by default",
      "It compiles down to function constructors and prototype manipulation under the hood",
      "It is slower to execute than traditional prototypes",
      "It prevents the use of the `new` keyword"
    ],
    "answer": "It compiles down to function constructors and prototype manipulation under the hood",
    "explanation": "Classes do not introduce a new inheritance model. They provide a clearer syntax for standard constructor functions and prototype-based inheritance, which can be verified by logging a Class constructor.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the difference between `Promise.all()` and `Promise.allSettled()`?",
    "options": [
      "`Promise.all` fails fast on the first rejection; `Promise.allSettled` waits for all promises to complete regardless of rejection",
      "`Promise.all` executes in parallel; `Promise.allSettled` executes in series",
      "`Promise.allSettled` returns only the rejected promises",
      "There is no difference; they are aliases"
    ],
    "answer": "`Promise.all` fails fast on the first rejection; `Promise.allSettled` waits for all promises to complete regardless of rejection",
    "explanation": "`Promise.all` rejects immediately if any input promise rejects. `Promise.allSettled` waits until every promise has fulfilled or rejected, returning an array of status objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the specific mechanism used by V8 to optimize property access for objects that share the same structure?",
    "options": [
      "Inline Caching (IC)",
      "On-Stack Replacement (OSR)",
      "Conservative Garbage Collection",
      "Bytecode Branch Prediction"
    ],
    "answer": "Inline Caching (IC)",
    "explanation": "Inline Caching optimizes property access by caching the lookup result (memory offset) based on the object's 'Hidden Class'. If subsequent objects have the same class, V8 reuses the cached offset, skipping the expensive lookup process.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In the context of 'Explicit Binding', what distinguishes `.call()` from `.apply()`?",
    "options": [
      "`.call()` accepts an array of arguments, while `.apply()` accepts individual arguments",
      "`.apply()` accepts an array (or array-like object) of arguments, while `.call()` accepts arguments individually",
      "`.call()` binds permanently, while `.apply()` is temporary",
      "`.apply()` can only be used on functions, while `.call()` works on objects"
    ],
    "answer": "`.apply()` accepts an array (or array-like object) of arguments, while `.call()` accepts arguments individually",
    "explanation": "Both methods invoke a function with a specific `this` value. The difference lies in argument passing: `.call(func, thisArg, arg1, arg2)` takes arguments one by one, while `.apply(func, thisArg, [argsArray])\" takes a single array of arguments.\"",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the purpose of the 'Intl' object in JavaScript?",
    "options": [
      "To handle internationalization and localization of strings, dates, and numbers",
      "To manage internalization of module dependencies",
      "To interact with the operating system's interrupt layer",
      "To provide utility functions for integer math"
    ],
    "answer": "To handle internationalization and localization of strings, dates, and numbers",
    "explanation": "The `Intl` namespace provides language-sensitive string comparison, number formatting, and date/time formatting (e.g., `Intl.DateTimeFormat`), supporting localization without external libraries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What occurs when a JavaScript function is declared in 'Strict Mode'?",
    "options": [
      "The function is hoisted to the top of the file regardless of block scope",
      "Silent errors are converted to thrown errors (e.g., assigning to non-writable properties)",
      "Variables are automatically coerced to the global scope",
      "The `this` keyword is ignored entirely"
    ],
    "answer": "Silent errors are converted to thrown errors (e.g., assigning to non-writable properties)",
    "explanation": "Strict mode fixes mistakes that make it difficult for JavaScript engines to perform optimizations. It turns silent errors (like creating global variables accidentally) into throw errors, improving code safety and optimization potential.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the V8 compilation pipeline, what is the primary role of the Maglev compiler?",
    "options": [
      "It parses the JavaScript source code into an Abstract Syntax Tree (AST)",
      "It acts as an intermediate optimizing tier between Ignition and TurboFan",
      "It performs garbage collection of unreachable objects in the heap",
      "It manages the event loop and asynchronous callbacks in Node.js"
    ],
    "answer": "It acts as an intermediate optimizing tier between Ignition and TurboFan",
    "explanation": "Maglev serves as a mid-tier optimizer in V8, providing faster optimization than TurboFan but with lower code quality. It bridges the gap between the baseline Ignition interpreter and the peak-performance TurboFan compiler.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the specific behavior of On-Stack Replacement (OSR) in V8?",
    "options": [
      "It swaps the optimized machine code back to bytecode when memory is low",
      "It pauses a running loop to switch execution from bytecode to optimized machine code",
      "It replaces the current context with a global context to resolve variable lookups",
      "It offloads stack frames to the heap to prevent stack overflow"
    ],
    "answer": "It pauses a running loop to switch execution from bytecode to optimized machine code",
    "explanation": "OSR allows V8 to switch execution to optimized code in the middle of a long-running loop without waiting for the function to be re-invoked, improving performance for compute-heavy tasks.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "How does V8 handle the transition from a 'Packed' elements kind to a 'Holey' elements kind in an array?",
    "options": [
      "The array is automatically compacted during garbage collection",
      "The elements kind is changed permanently, and the array cannot revert to 'Packed'",
      "The array is cloned, and the original is kept for snapshot rollback",
      "V8 prevents this transition by throwing a runtime exception"
    ],
    "answer": "The elements kind is changed permanently, and the array cannot revert to 'Packed'",
    "explanation": "Once an array acquires a hole (e.g., by deleting an element or assigning out of bounds), V8 changes its internal representation to 'Holey'. This transition is one-way; even if the hole is filled, the optimization remains 'Holey'.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary condition for an object in the Young Generation (New Space) to be promoted to the Old Generation in V8's generational garbage collector?",
    "options": [
      "The object size exceeds the maximum pointer size of the New Space",
      "The object survives at least two scavenge garbage collection cycles",
      "The object is accessed by a thread other than the main thread",
      "The object's hidden class transitions to a slow mode"
    ],
    "answer": "The object survives at least two scavenge garbage collection cycles",
    "explanation": "Objects that survive two consecutive Scavenge cycles in the New Space are assumed to be long-lived and are moved (promoted) to the Old Generation to make way for new short-lived objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which of the following scenarios is most likely to trigger 'deoptimization' in V8, causing code execution to fall back from TurboFan to Ignition?",
    "options": [
      "A function call with a primitive argument type that differs from previous invocations",
      "A loop that iterates fewer than 100 times",
      "Assigning a new object property that matches the existing hidden class structure",
      "Inlining a small, frequently called utility function"
    ],
    "answer": "A function call with a primitive argument type that differs from previous invocations",
    "explanation": "V8 optimizes code based on assumptions derived from 'feedback' (type profiling). If a function receives a type it hasn't seen before, the optimized assumptions become invalid, triggering a deoptimization to the safe interpreter path.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of V8's 'Hidden Classes' (also known as Maps or Shapes), why is initializing object properties in a consistent order important for performance?",
    "options": [
      "It ensures the prototype chain lookup remains linear",
      "It allows V8 to share the same Hidden Class between objects with the same structure",
      "It forces the garbage collector to use the 'Mark-and-Sweep' algorithm",
      "It prevents the 'Holey' elements kind from being applied to arrays"
    ],
    "answer": "It allows V8 to share the same Hidden Class between objects with the same structure",
    "explanation": "Consistent property initialization allows V8 to transition objects through identical Hidden Class trees. If properties are added in different orders, new classes are created, preventing Inline Caching (IC) from optimizing property access.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the specific optimization technique used by V8 to avoid memory duplication when concatenating very large strings?",
    "options": [
      "String deduplication via hash consing",
      "ConsString (Rope) representation",
      "Direct pointer swapping in the C++ heap",
      "Storing strings in the read-only code space"
    ],
    "answer": "ConsString (Rope) representation",
    "explanation": "V8 uses a ConsString (or Rope) tree structure to represent concatenated strings, holding references to the left and right parts rather than copying the entire data. The string is only materialized ('flattened') when strictly necessary.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How does the Node.js `process.nextTick()` queue differ from the Promise `microtask` queue regarding the event loop?",
    "options": [
      "`process.nextTick()` runs after the microtask queue but before the next macrotask",
      "`process.nextTick()` has higher priority and runs immediately after the current operation completes, before microtasks",
      "Microtasks have higher priority and drain completely before `process.nextTick()` is processed",
      "`process.nextTick()` is handled by the Libuv thread pool, while microtasks are handled by V8"
    ],
    "answer": "`process.nextTick()` has higher priority and runs immediately after the current operation completes, before microtasks",
    "explanation": "In Node.js, the `nextTickQueue` is processed immediately after the current C++ handler finishes but before returning to the event loop's main phases (and before the microtask queue).",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the 'Sea of Nodes' representation in the context of the TurboFan compiler?",
    "options": [
      "A graph representation of the AST where control flow and data flow are merged into a single graph",
      "A linked list of bytecode instructions generated by the Ignition interpreter",
      "A memory pool in the Old Generation used for storing object references",
      "A visualization of the DOM structure used by Chrome DevTools"
    ],
    "answer": "A graph representation of the AST where control flow and data flow are merged into a single graph",
    "explanation": "TurboFan converts code into a 'Sea of Nodes' graph, which eliminates the distinction between data and control flow. This allows for advanced optimizations like instruction scheduling and global value numbering.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which V8 API mechanism is responsible for executing a resumed JavaScript function (after an await) within the correct context?",
    "options": [
      "The Libuv E-loop handle",
      "The Inline Cache (IC) handler",
      "`v8::Function::Call`",
      "The Maglev deoptimizer"
    ],
    "answer": "`v8::Function::Call`",
    "explanation": "When an async operation completes, V8 uses internal APIs like `v8::Function::Call` (conceptually) to invoke the continuation. This ensures the function executes within the correct `v8::Isolate` and `v8::Context` scope.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the 'write barrier' in the context of V8's Generational Garbage Collector?",
    "options": [
      "A mutex lock preventing concurrent writes to the heap",
      "A mechanism to track pointers from the Old Generation to the Young Generation",
      "A validation check that prevents stack overflow on recursive writes",
      "A compiler optimization that eliminates redundant variable assignments"
    ],
    "answer": "A mechanism to track pointers from the Old Generation to the Young Generation",
    "explanation": "Since the GC primarily scans the Young Generation, it needs to know if objects in the Old Generation reference objects in the New Space. The write barrier records these pointers to prevent live Young objects from being incorrectly collected.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In V8, what is 'Escape Analysis' used for?",
    "options": [
      "Detecting memory leaks in C++ extensions",
      "Allocating objects on the stack instead of the heap if they do not escape the function scope",
      "Analyzing the 'this' binding in arrow functions",
      "Determining the lifetime of asynchronous promises"
    ],
    "answer": "Allocating objects on the stack instead of the heap if they do not escape the function scope",
    "explanation": "Escape analysis determines if an object is accessed outside the function where it was created. If it doesn't 'escape', V8 can allocate it on the stack or scalar-replace it, avoiding expensive heap allocation and garbage collection.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What distinguishes the 'Typer' phase in the TurboFan compilation pipeline?",
    "options": [
      "It converts bytecode into machine instructions",
      "It assigns types to nodes in the Sea of Nodes to enable speculative optimizations",
      "It checks for syntax errors in the JavaScript source",
      "It manages the reference counting for V8 handles"
    ],
    "answer": "It assigns types to nodes in the Sea of Nodes to enable speculative optimizations",
    "explanation": "The Typer phase narrows down the types of variables (e.g., from Number to SignedSmall32). This precise type information allows TurboFan to perform aggressive optimizations like specialized lowering.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Which operation in Node.js is guaranteed to use the Libuv thread pool by default?",
    "options": [
      "Asynchronous file system operations (e.g., `fs.readFile`) in most environments",
      "Network socket operations (e.g., `net.createServer`)",
      "DNS resolution on some platforms",
      "All asynchronous cryptographic operations"
    ],
    "answer": "Asynchronous file system operations (e.g., `fs.readFile`) in most environments",
    "explanation": "While network I/O uses the OS kernel's non-blocking interfaces, file system APIs generally use the Libuv thread pool to perform blocking I/O operations without halting the main event loop.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What happens to an Inline Cache (IC) when it transitions from 'Monomorphic' to 'Megamorphic' state?",
    "options": [
      "The property access is optimized using a fast inline assembly stub",
      "The cache lookup is disabled, and a full hash table lookup is performed on the object",
      "The object is deoptimized and recompiled by Ignition",
      "The hidden class of the object is forcibly merged with others"
    ],
    "answer": "The cache lookup is disabled, and a full hash table lookup is performed on the object",
    "explanation": "A Megamorphic state implies too many different object shapes (hidden classes) have been seen. V8 gives up on caching, resulting in significantly slower lookups that require traversing the prototype chain or a hash table.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is 'Snapshot deserialization' in the context of V8 startup?",
    "options": [
      "Restoring the heap from a memory-mapped file to skip initial parsing and compilation",
      "Loading the source code from a `.js` file into memory",
      "Replaying the JIT compilation logs from a previous session",
      "Parsing the AST to generate bytecode for the first time"
    ],
    "answer": "Restoring the heap from a memory-mapped file to skip initial parsing and compilation",
    "explanation": "V8 can serialize a pre-initialized heap (including built-in objects and compiled code) into a snapshot. At startup, this snapshot is deserialized, drastically reducing the time needed to parse and initialize the runtime environment.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "How does the V8 garbage collector handle 'weak references' (e.g., `WeakRef` in JavaScript)?",
    "options": [
      "It keeps the referenced object in the Young Generation indefinitely",
      "It does not prevent the object from being collected if it is otherwise unreachable",
      "It invokes a finalizer callback on the main thread before collection",
      "It automatically promotes weak references to strong references if memory is available"
    ],
    "answer": "It does not prevent the object from being collected if it is otherwise unreachable",
    "explanation": "Weak references allow holding a reference to an object without preventing the garbage collector from reclaiming that object's memory if no strong references exist.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the consequence of a 'Long Microtask Queue' stall on browser interactivity?",
    "options": [
      "It blocks the UI thread, delaying rendering and user input processing",
      "It triggers an immediate garbage collection cycle",
      "It causes the browser to crash due to stack overflow",
      "It forces the browser to switch to a multi-threaded rendering mode"
    ],
    "answer": "It blocks the UI thread, delaying rendering and user input processing",
    "explanation": "Microtasks (like Promise callbacks) run to completion before the browser yields control to render or handle user events. Excessive microtasks starve the main thread, causing UI freezing.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In V8's optimization pipeline, what is 'Simplified Lowering'?",
    "options": [
      "The process of removing unused variables from the Sea of Nodes",
      "Converting high-level, typed graph nodes into low-level machine-specific instructions",
      "The initial parsing of JavaScript into bytecode",
      "The garbage collection phase specific to pointer compression"
    ],
    "answer": "Converting high-level, typed graph nodes into low-level machine-specific instructions",
    "explanation": "Simplified Lowering is a TurboFan pass that takes the optimized, typed Sea of Nodes and translates it into machine-level operations (e.g., load, store, add) specific to the target architecture.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the functional difference between `setImmediate` (Node.js) and `setTimeout(fn, 0)`?",
    "options": [
      "`setImmediate` executes in the 'Check' phase, while `setTimeout` executes in the 'Timers' phase",
      "`setImmediate` uses the thread pool, while `setTimeout` is non-blocking",
      "`setTimeout` is guaranteed to run before `setImmediate`",
      "There is no functional difference; they are aliases"
    ],
    "answer": "`setImmediate` executes in the 'Check' phase, while `setTimeout` executes in the 'Timers' phase",
    "explanation": "The execution order depends on where the call originates from in the event loop cycle, but fundamentally they target different phases: Timers (setTimeout) versus Check (setImmediate).",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does V8's 'Pointer Compression' (now often called 'Pointer Tagging' or 'Heap Compression') improve performance?",
    "options": [
      "It compresses the JavaScript source code using Gzip before parsing",
      "It stores pointers as 32-bit offsets within a heap, reducing memory footprint and cache pressure",
      "It replaces numeric pointers with string identifiers to save RAM",
      "It moves all objects to the hard disk when physical memory is full"
    ],
    "answer": "It stores pointers as 32-bit offsets within a heap, reducing memory footprint and cache pressure",
    "explanation": "By using a 32-bit offset relative to a base pointer rather than a full 64-bit absolute address, V8 significantly reduces memory usage and improves CPU cache utilization, which speeds up execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the 'Construct Stub' built-in in V8?",
    "options": [
      "A specialized stub used to optimize the creation of objects using the `new` operator",
      "A debugging utility for inspecting the V8 stack trace",
      "A function that constructs the Hidden Class tree",
      "The C++ function responsible for creating the `globalThis` object"
    ],
    "answer": "A specialized stub used to optimize the creation of objects using the `new` operator",
    "explanation": "The Construct stub optimizes the instantiation of objects. It handles the memory allocation and prototype setup for constructors that are frequently called with `new`.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which of the following best describes 'Smi' (Small Integer) in V8?",
    "options": [
      "A specialized floating-point format for high-precision decimals",
      "A way to represent 31-bit (or 32-bit) signed integers directly as pointers to avoid heap allocation",
      "A string representation for integers used in JSON parsing",
      "The default type for all variables declared with `let`"
    ],
    "answer": "A way to represent 31-bit (or 32-bit) signed integers directly as pointers to avoid heap allocation",
    "explanation": "V8 uses 'Smis' (Small Integers) to store small integers as tagged pointers (where the least significant bit is 1). This avoids allocating a heap object for the number, making math operations extremely fast.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is 'Embedded Builtins' optimization in V8?",
    "options": [
      "Writing JavaScript built-ins (like `Array.prototype.push`) in JavaScript instead of C++",
      "Embedding V8 directly into the browser HTML renderer",
      "Pre-compiling C++ built-ins into machine code embedded in the V8 binary",
      "Including the V8 source code inside Node.js modules"
    ],
    "answer": "Pre-compiling C++ built-ins into machine code embedded in the V8 binary",
    "explanation": "V8 includes a snapshot of the executable code for runtime built-ins. This avoids the overhead of parsing and compiling these heavily used functions at startup.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In V8, what distinguishes 'minor' GC from 'major' GC?",
    "options": [
      "Minor GC runs only when the tab is inactive; Major GC runs when active",
      "Minor GC collects the Young Generation (Scavenge); Major GC collects the entire heap (Mark-Sweep-Compact)",
      "Minor GC is triggered by `window.gc()`; Major GC is automatic",
      "Minor GC handles DOM nodes; Major GC handles JavaScript objects"
    ],
    "answer": "Minor GC collects the Young Generation (Scavenge); Major GC collects the entire heap (Mark-Sweep-Compact)",
    "explanation": "Minor GC (Scavenge) is frequent and fast, cleaning the New Space. Major GC (Mark-Sweep-Compact) is slower and handles the entire heap, including the Old Generation, to handle fragmentation and reclaim memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the purpose of the 'Feedback Vector' attached to every function in V8?",
    "options": [
      "It stores the source code of the function for debugging",
      "It holds the execution counts and type information (Inline Cache state) gathered during runtime",
      "It contains the error stack trace if the function throws",
      "It lists the closures that have access to this function's scope"
    ],
    "answer": "It holds the execution counts and type information (Inline Cache state) gathered during runtime",
    "explanation": "The Feedback Vector is a data structure that stores 'speculation' data, such as which types of objects were passed to a function. This data drives decisions about when to optimize to machine code.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does 'Code flushing' work in V8?",
    "options": [
      "It clears the instruction cache of the CPU",
      "It deletes optimized machine code for functions that haven't been executed recently to save memory",
      "It flushes the JIT compiler pipeline upon low memory events",
      "It rewrites bytecode to assembly language"
    ],
    "answer": "It deletes optimized machine code for functions that haven't been executed recently to save memory",
    "explanation": "To reduce memory footprint, V8 can garbage-collect the compiled machine code of functions that are no longer 'hot' (frequently used), retaining only the bytecode which is much smaller.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the 'Stack Register' in the context of the V8 interpreter (Ignition)?",
    "options": [
      "A hardware CPU register reserved exclusively for V8",
      "A register (usually in the accumulator) pointing to the current execution frame in the bytecode array",
      "A global variable in Node.js that tracks stack usage",
      "A memory buffer used to generate the source map"
    ],
    "answer": "A register (usually in the accumulator) pointing to the current execution frame in the bytecode array",
    "explanation": "The Ignition interpreter uses a register-based architecture (using the accumulator) to execute bytecode. The 'register' refers to specific locations in the virtual machine state used to store intermediate values.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Why are object properties stored 'in-object' (fast) versus 'out-of-object' (slow) in V8?",
    "options": [
      "Out-of-object properties are serialized to disk",
      "In-object properties are stored directly within the object's memory allocation, reducing indirection",
      "Out-of-object properties are accessible from Web Workers only",
      "In-object properties are always constant values"
    ],
    "answer": "In-object properties are stored directly within the object's memory allocation, reducing indirection",
    "explanation": "V8 reserves space for a fixed number of properties within the object's memory structure. Accessing these requires one fewer memory dereference than accessing properties stored in a separate backing store (out-of-object), making it faster.",
    "difficulty": "Advanced"
  }
]