[
  {
    "id": 1,
    "question": "What is the primary responsibility of the Repository pattern in enterprise applications?",
    "options": [
      "To encapsulate the logic required to retrieve and store domain objects from a data source",
      "To manage the lifecycle of business transactions across multiple services",
      "To define the user interface layout for administrative dashboards",
      "To handle asynchronous communication between distributed nodes"
    ],
    "answer": "To encapsulate the logic required to retrieve and store domain objects from a data source",
    "explanation": "The Repository pattern abstracts the data access layer, mediating between the domain and data mapping layers. It provides a collection-like interface for accessing domain objects, unlike Transaction Scripts which handle logic directly.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which architectural pattern separates an application into three interconnected components: the Model, the View, and the Controller?",
    "options": [
      "Model-View-Controller (MVC)",
      "Data Transfer Object (DTO)",
      "Service-Oriented Architecture (SOA)",
      "Front Controller"
    ],
    "answer": "Model-View-Controller (MVC)",
    "explanation": "MVC separates the application logic (Model) from the UI (View) and the user input handling (Controller). DTO is a data container, SOA is a structural style, and Front Controller is a specific pattern for handling requests.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In the context of Domain Logic patterns, what is the primary characteristic of the Transaction Script pattern?",
    "options": [
      "It organizes business logic as a single procedure for each specific user interaction",
      "It creates a layer of objects that models the business domain entirely",
      "It uses metadata to map database rows directly to object properties",
      "It delegates business rules to the database server via stored procedures"
    ],
    "answer": "It organizes business logic as a single procedure for each specific user interaction",
    "explanation": "Transaction Script is a procedural approach where a single script (method) handles all logic for a specific transaction, typically in a single class or file. This contrasts with Domain Models which use object-oriented logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which design pattern is primarily used to reduce the number of remote calls by transferring multiple data elements in a single structure?",
    "options": [
      "Data Transfer Object (DTO)",
      "Unit of Work",
      "Repository",
      "Gateway"
    ],
    "answer": "Data Transfer Object (DTO)",
    "explanation": "A DTO is an object that carries data between processes to reduce the cost of remote communication. The Unit of Work tracks changes, the Repository abstracts data access, and a Gateway encapsulates external access.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the core function of the Unit of Work pattern?",
    "options": [
      "To maintain a list of objects affected by a business transaction and coordinate writing out changes",
      "To divide a large monolithic application into smaller independent services",
      "To separate the user interface from the business logic processing",
      "To convert database schemas into object-oriented class diagrams"
    ],
    "answer": "To maintain a list of objects affected by a business transaction and coordinate writing out changes",
    "explanation": "Unit of Work tracks changes to objects during a transaction and ensures consistency by writing all changes to the database as a single atomic operation, preventing partial updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which enterprise architecture pattern organizes code into distinct layers such as Presentation, Business, and Data Access, where upper layers can only interact with the immediate layer below them?",
    "options": [
      "Layered Architecture",
      "Microservices Architecture",
      "Event-Driven Architecture",
      "Space-Based Architecture"
    ],
    "answer": "Layered Architecture",
    "explanation": "Layered Architecture (or N-Tier) enforces a strict separation of concerns where presentation depends on business, and business depends on data. Microservices decouple services, and Event-Driven relies on messages.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which architectural pattern structures the application as a set of loosely coupled, fine-grained services, each owning its own data store?",
    "options": [
      "Microservices Architecture",
      "Client-Server Architecture",
      "Master-Slave Architecture",
      "Monolithic Architecture"
    ],
    "answer": "Microservices Architecture",
    "explanation": "Microservices decompose the application into small autonomous services that communicate via APIs. Monolithic architectures bundle functionality into a single unit, and Master-Slave focuses on command replication.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "In the Event-Driven Architecture pattern, what triggers the processing of a business action?",
    "options": [
      "The emission or detection of a significant state change or event",
      "A direct synchronous call from a client controller",
      "A scheduled cron job polling the database",
      "A central configuration server update"
    ],
    "answer": "The emission or detection of a significant state change or event",
    "explanation": "Event-Driven Architecture relies on asynchronous events to propagate state changes. Components react to events rather than polling or being directly invoked by a synchronous controller.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the primary purpose of the Separation of Concerns principle in software design?",
    "options": [
      "To divide a software system into distinct sections that address unrelated or overlapping aspects of functionality",
      "To ensure all code is written in a single programming language",
      "To maximize the coupling between different modules for faster performance",
      "To combine user interface code with database logic for easier access"
    ],
    "answer": "To divide a software system into distinct sections that address unrelated or overlapping aspects of functionality",
    "explanation": "Separation of Concerns involves breaking a program into distinct features that overlap in functionality as little as possible, improving manageability and modularity.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which pattern is best described as a structural solution to standardize communication and integration between different applications by exposing reusable services?",
    "options": [
      "Service-Oriented Architecture (SOA)",
      "Blackboard Pattern",
      "Broker Pattern",
      "Peer-to-Peer Pattern"
    ],
    "answer": "Service-Oriented Architecture (SOA)",
    "explanation": "SOA focuses on service reuse and standardization of contracts to integrate disparate systems. The Blackboard pattern involves independent specialized components working on a shared data structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which of the following best describes the 'Microkernel' architecture pattern?",
    "options": [
      "It separates a minimal system core from extended functionality and custom features",
      "It uses a central message broker to route data between all microservices",
      "It organizes the system into a rigid hierarchy of parent and child processes",
      "It duplicates data across multiple nodes to ensure high availability"
    ],
    "answer": "It separates a minimal system core from extended functionality and custom features",
    "explanation": "The Microkernel pattern partitions the system into a core component (kernel) providing generic capabilities and plug-in modules providing specific features, allowing for high extensibility.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the primary role of the Gateway pattern in enterprise software?",
    "options": [
      "To encapsulate access to an external system or resource",
      "To generate the HTML view for the client browser",
      "To route database queries to the read replica",
      "To compile Java bytecode into machine code"
    ],
    "answer": "To encapsulate access to an external system or resource",
    "explanation": "The Gateway pattern acts as a facade or wrapper to decouple the application from external interfaces, APIs, or protocols, simplifying integration and handling communication logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which pattern is commonly used to implement a centralized request handling mechanism that receives all requests and delegates them to specific controllers?",
    "options": [
      "Front Controller",
      "Intercepting Filter",
      "Model View Controller",
      "Service Locator"
    ],
    "answer": "Front Controller",
    "explanation": "The Front Controller pattern provides a centralized entry point for handling all requests, managing common logic like authentication and logging before dispatching to specific handlers.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which of the following is a characteristic of the Space-Based Architecture pattern?",
    "options": [
      "It utilizes a tuple space (shared memory) to facilitate high scalability and reduce database load",
      "It organizes software into distinct logical layers like UI and Data",
      "It relies on a central server to process all business logic sequentially",
      "It structures the UI as a hierarchy of composite graphical widgets"
    ],
    "answer": "It utilizes a tuple space (shared memory) to facilitate high scalability and reduce database load",
    "explanation": "Space-Based Architecture is designed for high scalability by using in-memory data grids (tuple spaces) to store state temporarily, minimizing the bottleneck of traditional database access.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the main disadvantage of the Monolithic architecture pattern compared to Microservices?",
    "options": [
      "The entire application must be redeployed as a single unit for any change",
      "It requires complex inter-service communication protocols",
      "It handles network latency poorly due to distributed nature",
      "It is difficult to scale the database independently"
    ],
    "answer": "The entire application must be redeployed as a single unit for any change",
    "explanation": "In a Monolith, all functionality is packaged together, so a small update requires redeploying the whole application, slowing down release cycles compared to independent microservice deployments.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable?",
    "options": [
      "Strategy Pattern",
      "Observer Pattern",
      "Singleton Pattern",
      "Adapter Pattern"
    ],
    "answer": "Strategy Pattern",
    "explanation": "The Strategy pattern allows the algorithm to vary independently from clients that use it by defining a common interface. Observer is for notifications, Singleton restricts instantiation, and Adapter converts interfaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the primary function of the Adapter pattern?",
    "options": [
      "To allow incompatible interfaces to work together by wrapping an object",
      "To create a single instance of a class globally",
      "To separate abstraction from implementation so both can vary independently",
      "To provide a unified interface to a set of interfaces in a subsystem"
    ],
    "answer": "To allow incompatible interfaces to work together by wrapping an object",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces. Facade simplifies a complex subsystem, Bridge decouples abstraction from implementation, and Singleton ensures one instance.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which pattern is utilized to notify multiple subscriber objects about any events that happen to the publisher object they are observing?",
    "options": [
      "Observer Pattern",
      "Mediator Pattern",
      "Memento Pattern",
      "Command Pattern"
    ],
    "answer": "Observer Pattern",
    "explanation": "The Observer pattern defines a one-to-many dependency so that when one object changes state, all its dependents are notified automatically. Mediator reduces chaotic communication, Memento captures state.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which creational design pattern separates the construction of a complex object from its representation?",
    "options": [
      "Builder Pattern",
      "Factory Method Pattern",
      "Prototype Pattern",
      "Singleton Pattern"
    ],
    "answer": "Builder Pattern",
    "explanation": "The Builder pattern allows you to construct complex objects step by step. Factory Method creates objects via subclasses, Prototype clones objects, and Singleton restricts instantiation.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which pattern ensures a class has only one instance and provides a global point of access to it?",
    "options": [
      "Singleton Pattern",
      "Flyweight Pattern",
      "Proxy Pattern",
      "Decorator Pattern"
    ],
    "answer": "Singleton Pattern",
    "explanation": "The Singleton pattern restricts instantiation of a class to one object. Flyweight shares common state, Proxy controls access to another object, and Decorator adds behavior dynamically.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "In the context of the Master-Slave pattern, what happens if the Master node fails?",
    "options": [
      "A Slave node is promoted to the role of Master to maintain availability",
      "The entire system halts immediately until the Master is restarted",
      "The Slave nodes automatically execute their own independent transactions",
      "The load balancer redirects all traffic directly to the database"
    ],
    "answer": "A Slave node is promoted to the role of Master to maintain availability",
    "explanation": "The Master-Slave pattern supports fault tolerance by allowing a Slave to take over the Master's responsibilities if the Master fails, ensuring system continuity.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which component in the Layered Architecture is primarily responsible for presenting data to the user and interpreting user commands?",
    "options": [
      "Presentation Layer",
      "Business Logic Layer",
      "Data Access Layer",
      "Database Layer"
    ],
    "answer": "Presentation Layer",
    "explanation": "The Presentation Layer handles the UI and user interaction. Business Logic handles rules, Data Access handles persistence, and Database handles storage.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the primary benefit of using the Service Layer pattern in an enterprise application?",
    "options": [
      "It defines application boundaries and encapsulates business logic separate from the presentation and data access",
      "It compresses data to reduce network traffic between the client and server",
      "It allows the database to manage user authentication directly",
      "It automatically generates the user interface code"
    ],
    "answer": "It defines application boundaries and encapsulates business logic separate from the presentation and data access",
    "explanation": "The Service Layer acts as a transaction boundary, defining application operations and orchestrating business logic, keeping it independent of the UI and data layers.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which pattern would you use to add responsibilities to individual objects dynamically without affecting other objects of the same class?",
    "options": [
      "Decorator Pattern",
      "Composite Pattern",
      "Facade Pattern",
      "Bridge Pattern"
    ],
    "answer": "Decorator Pattern",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically. Composite treats objects uniformly (tree structure), Facade simplifies an interface, and Bridge separates abstraction from implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which pattern is best suited for complex object graph persistence where the system must track which objects have been modified to ensure transactional consistency?",
    "options": [
      "Unit of Work",
      "Identity Map",
      "Lazy Load",
      "Active Record"
    ],
    "answer": "Unit of Work",
    "explanation": "Unit of Work maintains a list of changes and commits them atomically. Identity Map ensures each object is loaded once, Lazy Load delays loading, and Active Record mixes domain logic and data access.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which architectural style relies heavily on asynchronous message passing between services to achieve loose coupling?",
    "options": [
      "Event-Driven Architecture",
      "Layered Architecture",
      "N-Tier Architecture",
      "Client-Server Architecture"
    ],
    "answer": "Event-Driven Architecture",
    "explanation": "Event-Driven Architecture relies on events/messages to trigger behavior, ensuring loose coupling as producers do not know who is consuming the events. The others are typically synchronous or strictly layered.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which Enterprise Integration Pattern involves a component that receives messages from a channel and transforms them before sending them to another channel?",
    "options": [
      "Message Translator",
      "Message Endpoint",
      "Message Channel",
      "Pipes and Filters"
    ],
    "answer": "Message Translator",
    "explanation": "A Message Translator converts data from one format to another to enable communication between different systems. An Endpoint is the interface, Channel is the conduit, and Pipes and Filters is the processing chain.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which structural pattern allows you to compose objects into tree structures to represent part-whole hierarchies?",
    "options": [
      "Composite Pattern",
      "Decorator Pattern",
      "Flyweight Pattern",
      "Proxy Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly. Decorator adds behavior, Flyweight minimizes memory, and Proxy controls access.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the primary intent of the Facade pattern?",
    "options": [
      "To provide a simplified interface to a complex subsystem",
      "To separate an abstraction from its implementation",
      "To allow incompatible interfaces to work together",
      "To create a tree structure of objects"
    ],
    "answer": "To provide a simplified interface to a complex subsystem",
    "explanation": "The Facade pattern provides a high-level interface that makes a subsystem easier to use. Bridge decouples abstraction and implementation, Adapter matches interfaces, Composite handles hierarchies.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "In the context of Domain-Driven Design, what is the purpose of an Aggregate Root?",
    "options": [
      "To act as the entry point for accessing and modifying a cluster of related domain objects",
      "To serve as the primary database connection pool",
      "To encrypt sensitive data within the domain model",
      "To generate unique primary keys for all entities"
    ],
    "answer": "To act as the entry point for accessing and modifying a cluster of related domain objects",
    "explanation": "An Aggregate Root is the only member of an aggregate that outside objects are allowed to hold references to, ensuring consistency of the data within the aggregate.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which design pattern is useful when you need to parameterize objects with an operation, queue or log operations, and support undoable operations?",
    "options": [
      "Command Pattern",
      "State Pattern",
      "Visitor Pattern",
      "Iterator Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern encapsulates a request as an object, thereby allowing parameterization, queuing, and undo functionality. State alters behavior when internal state changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator Pattern",
      "Strategy Pattern",
      "Template Method Pattern",
      "Observer Pattern"
    ],
    "answer": "Iterator Pattern",
    "explanation": "The Iterator pattern provides a standard way to traverse a collection. Strategy encapsulates algorithms, Template Method defines skeleton steps, and Observer notifies changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which of the following best describes the 'Circuit Breaker' pattern in distributed systems?",
    "options": [
      "It detects failures and stops cascading failures by redirecting traffic away from failing services",
      "It aggregates logs from multiple services into a central dashboard",
      "It compresses data packets to improve network throughput",
      "It encrypts all communication between microservices"
    ],
    "answer": "It detects failures and stops cascading failures by redirecting traffic away from failing services",
    "explanation": "The Circuit Breaker pattern prevents a system from trying to perform an operation likely to fail (like calling a downed service), allowing the system to recover or fail gracefully.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which design pattern defines the skeleton of an algorithm in an operation, deferring some steps to subclasses?",
    "options": [
      "Template Method Pattern",
      "Factory Method Pattern",
      "Builder Pattern",
      "Prototype Pattern"
    ],
    "answer": "Template Method Pattern",
    "explanation": "The Template Method pattern lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. Factory Method is for creation, Builder is for complex construction.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the primary distinction between the Repository pattern and the Data Access Object (DAO) pattern?",
    "options": [
      "Repository operates on domain entities while DAO typically operates on data structures",
      "DAO is used for frontend logic while Repository is for backend",
      "Repository is only for NoSQL databases while DAO is only for SQL databases",
      "Repository creates objects while DAO only reads them"
    ],
    "answer": "Repository operates on domain entities while DAO typically operates on data structures",
    "explanation": "Repository represents a collection of domain objects, abstracting the persistence layer. DAO is more low-level, handling CRUD operations on data structures/tables without necessarily enforcing domain semantics.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In the context of enterprise data access, what is the primary responsibility of the Repository pattern?",
    "options": [
      "To abstract the data mapping layer and mimic a collection of domain objects",
      "To generate SQL queries dynamically based on user input",
      "To manage database connection pooling and transaction isolation levels",
      "To cache frequently accessed data in the application memory layer"
    ],
    "answer": "To abstract the data mapping layer and mimic a collection of domain objects",
    "explanation": "The Repository pattern mediates between the domain and data mapping layers, acting like an in-memory collection of domain objects. It provides a more object-oriented view of the persistence layer, separating concerns. Options B and C are infrastructure concerns, and D is a caching concern.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which architectural pattern is characterized by a central component that coordinates the lifecycle of plug-in applications, ensuring core system stability while allowing feature extensions?",
    "options": [
      "Microkernel Architecture",
      "Layered Architecture",
      "Space-Based Architecture",
      "Event-Driven Architecture"
    ],
    "answer": "Microkernel Architecture",
    "explanation": "Microkernel architecture separates a minimal core system from extensible plug-in features. The core handles the startup and lifecycle of plug-ins. Layered architecture organizes code into horizontal tiers, while Space-based focuses on distributed in-memory data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the specific benefit of using the Unit of Work pattern in conjunction with the Repository pattern?",
    "options": [
      "It reduces the number of database round-trips by tracking changes and committing them in a single transaction",
      "It dynamically generates SQL schemas based on the object model",
      "It enables sharding of data across multiple database instances",
      "It creates a read-only view of the database to prevent dirty writes"
    ],
    "answer": "It reduces the number of database round-trips by tracking changes and committing them in a single transaction",
    "explanation": "The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates the writing out of changes. This ensures consistency and optimizes performance by batching operations. It does not generate schemas or handle sharding directly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which design pattern allows a family of related algorithms to be defined and encapsulated in separate classes, making them interchangeable at runtime?",
    "options": [
      "Strategy Pattern",
      "Template Method Pattern",
      "Factory Pattern",
      "Observer Pattern"
    ],
    "answer": "Strategy Pattern",
    "explanation": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it. Template Method defines the skeleton of an algorithm but defers steps to subclasses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In an Event-Driven Architecture, what is the primary role of the 'Channel' component?",
    "options": [
      "To act as a conduit that passes events from the producer to the consumer",
      "To filter events based on user permissions",
      "To persist events to a durable database storage",
      "To transform event data formats between producers"
    ],
    "answer": "To act as a conduit that passes events from the producer to the consumer",
    "explanation": "In Event-Driven architectures, a Channel is the logical pathway through which an event is delivered from a producer to a consumer. It decouples the sender from the receiver. Transformation is typically the role of an adapter, and persistence is a separate concern.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Which GoF design pattern is best utilized to attach additional responsibilities to an object dynamically without altering the object's structure?",
    "options": [
      "Decorator Pattern",
      "Proxy Pattern",
      "Adapter Pattern",
      "Facade Pattern"
    ],
    "answer": "Decorator Pattern",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically by wrapping it. It provides a flexible alternative to subclassing for extending functionality. Proxy controls access, Adapter changes interfaces, and Facade simplifies interfaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the defining characteristic of the CQRS (Command Query Responsibility Segregation) pattern?",
    "options": [
      "Separating the models used for reading data from the models used for updating data",
      "Using a single database for both read and write operations",
      "Segregating command execution from query execution within the same method",
      "Ensuring all queries are eventually consistent"
    ],
    "answer": "Separating the models used for reading data from the models used for updating data",
    "explanation": "CQRS splits the application into two parts: the command side (update) and the query side (read), often using different models. This maximizes performance, scalability, and security. While eventual consistency is often a result, the separation of models is the definition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which pattern solves the problem of incompatible interfaces by converting the interface of a class into another interface clients expect?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Facade Pattern",
      "Decorator Pattern"
    ],
    "answer": "Adapter Pattern",
    "explanation": "The Adapter pattern allows classes with incompatible interfaces to work together by wrapping an object in an adapter to make it compatible with another class. The Bridge pattern separates abstraction from implementation, and Facade provides a simplified interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the context of scalable distributed systems, what is the primary function of the Circuit Breaker pattern?",
    "options": [
      "To detect failures and prevent cascading failures by stopping requests to a failing service",
      "To encrypt data packets sent over the network",
      "To load balance traffic across multiple healthy server instances",
      "To break large database transactions into smaller chunks"
    ],
    "answer": "To detect failures and prevent cascading failures by stopping requests to a failing service",
    "explanation": "The Circuit Breaker pattern prevents a network or service failure from cascading to other services by failing fast. It wraps a function call and stops routing calls to the failing service after a threshold is reached. Load balancing is handled by different patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which architectural pattern specifically addresses high scalability issues in distributed systems by utilizing a shared in-memory data grid?",
    "options": [
      "Space-Based Architecture",
      "Microservices Architecture",
      "Layered Architecture",
      "Client-Server Architecture"
    ],
    "answer": "Space-Based Architecture",
    "explanation": "Space-Based architecture is designed for high scalability and linear scalability, utilizing a tuple space (in-memory data grid) to handle high concurrency. Microservices focus on service granularity, while Layered focuses on separation of concerns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the main advantage of using the Data Transfer Object (DTO) pattern when communicating across process boundaries?",
    "options": [
      "It reduces the number of remote calls by chunking data together and minimizes serialization overhead",
      "It ensures that business logic is executed on the client side",
      "It automatically encrypts sensitive data during transport",
      "It creates a direct real-time connection to the database"
    ],
    "answer": "It reduces the number of remote calls by chunking data together and minimizes serialization overhead",
    "explanation": "DTOs are used to transfer data with multiple attributes in a single shot to reduce network chattiness. They are simple POJOs without behavior, optimized for serialization. They do not execute business logic or handle encryption inherently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which pattern promotes loose coupling between components by defining a dependency abstraction that is injected into the class rather than created inside it?",
    "options": [
      "Dependency Injection",
      "Service Locator",
      "Factory Method",
      "Singleton"
    ],
    "answer": "Dependency Injection",
    "explanation": "Dependency Injection (DI) removes the dependency on the concrete implementation by injecting it (usually via constructor or setter). Service Locator is an active anti-pattern where the class asks for the dependency. Factory creates objects but doesn't manage injection scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "In the Model-View-Controller (MVC) pattern, which component is responsible for handling user input and updating the Model?",
    "options": [
      "Controller",
      "View",
      "Model",
      "Router"
    ],
    "answer": "Controller",
    "explanation": "The Controller acts as the intermediary that accepts user inputs, interacts with the Model to update data, and selects the View for display. The View displays data, and the Model maintains the state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What distinguishes the Façade pattern from the Adapter pattern?",
    "options": [
      "Façade provides a simplified interface to a complex subsystem, while Adapter matches an existing interface to another",
      "Façade converts interfaces, while Adapter simplifies interfaces",
      "Façade adds new behaviors to an interface, while Adapter hides complexity",
      "Façade is used for runtime changes, while Adapter is used for compile-time changes"
    ],
    "answer": "Façade provides a simplified interface to a complex subsystem, while Adapter matches an existing interface to another",
    "explanation": "The Façade pattern defines a higher-level interface that makes a subsystem easier to use without changing the interfaces of the underlying objects. The Adapter pattern changes the interface of an existing object to match a specific target interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which design pattern suggests that a class should have only one reason to change, thereby promoting separation of concerns?",
    "options": [
      "Single Responsibility Principle (SRP)",
      "Open/Closed Principle",
      "Liskov Substitution Principle",
      "Interface Segregation Principle"
    ],
    "answer": "Single Responsibility Principle (SRP)",
    "explanation": "SRP states that a class should have one, and only one, reason to change. It aims to separate functionality so that any specific change requirement impacts only one class. Open/Closed refers to being open for extension but closed for modification.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "How does the Proxy pattern differ from the Decorator pattern regarding structural intent?",
    "options": [
      "Proxy controls access to an object, while Decorator adds behavior/responsibility to an object",
      "Proxy changes the interface of an object, while Decorator keeps it the same",
      "Proxy is used at compile time, while Decorator is used at runtime",
      "Proxy removes behavior, while Decorator adds behavior"
    ],
    "answer": "Proxy controls access to an object, while Decorator adds behavior/responsibility to an object",
    "explanation": "The Proxy pattern provides a surrogate or placeholder to control access to an object (lazy loading, access control). The Decorator pattern adds responsibilities dynamically without changing the interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In a microservices architecture, which pattern helps maintain consistency across services by ensuring that a transaction across multiple services eventually results in a consistent state?",
    "options": [
      "Saga Pattern",
      "Two-Phase Commit (2PC)",
      "Shared Database Pattern",
      "Bulkhead Pattern"
    ],
    "answer": "Saga Pattern",
    "explanation": "The Saga pattern coordinates distributed transactions by executing a sequence of local transactions; if one fails, compensating transactions undo the previous steps. 2PC locks resources (blocking), and Shared Database contradicts microservices autonomy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which design pattern allows you to publish changes to an object's state to other objects without explicitly specifying the recipient objects?",
    "options": [
      "Observer Pattern",
      "Mediator Pattern",
      "Command Pattern",
      "Memento Pattern"
    ],
    "answer": "Observer Pattern",
    "explanation": "The Observer pattern defines a one-to-many dependency so that when one object changes state, all its dependents are notified and updated automatically. Mediator encapsulates how a set of objects interact.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the primary function of the Builder pattern?",
    "options": [
      "To construct complex objects step by step, allowing different representations",
      "To create a family of related objects",
      "To clone an object based on a prototype",
      "To restrict a class to a single instance"
    ],
    "answer": "To construct complex objects step by step, allowing different representations",
    "explanation": "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Factory is better for families of objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which pattern is intended to encapsulate a request as an object, thereby allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations?",
    "options": [
      "Command Pattern",
      "Strategy Pattern",
      "State Pattern",
      "Chain of Responsibility"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue execution, and support undo.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the main intent of the Chain of Responsibility pattern?",
    "options": [
      "To pass a request along a chain of handlers until one handles it",
      "To intercept and modify method calls to an object",
      "To define a skeleton of an algorithm in an operation",
      "To compose objects into tree structures to represent part-whole hierarchies"
    ],
    "answer": "To pass a request along a chain of handlers until one handles it",
    "explanation": "Chain of Responsibility passes a request along a chain of potential handlers until an object handles it. The intent is to decouple the sender from the receiver. Composite deals with tree structures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which architectural pattern advocates structuring the application into distinct horizontal layers (e.g., Presentation, Business, Data Access) where upper layers can use lower layers but not vice versa?",
    "options": [
      "Layered Architecture",
      "Hexagonal Architecture",
      "Microservices Architecture",
      "Serverless Architecture"
    ],
    "answer": "Layered Architecture",
    "explanation": "Layered (or N-Tier) Architecture organizes code into layers, with the most common being Presentation, Business Logic, and Data Access. It enforces the separation of concerns and strict dependency rules (upper depends on lower).",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which pattern allows an object to alter its behavior when its internal state changes, appearing as if the object changed its class?",
    "options": [
      "State Pattern",
      "Strategy Pattern",
      "Visitor Pattern",
      "Iterator Pattern"
    ],
    "answer": "State Pattern",
    "explanation": "The State pattern allows an object to change its behavior when its internal state changes. The object will appear to change its class. Strategy is about interchangeable algorithms, not state-dependent behavior.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the intent of the Template Method pattern defined in the Gang of Four?",
    "options": [
      "To define the skeleton of an algorithm in an operation, deferring some steps to subclasses",
      "To convert the interface of a class into another interface clients expect",
      "To attach additional responsibilities to an object dynamically",
      "To provide a unified interface to a set of interfaces in a subsystem"
    ],
    "answer": "To define the skeleton of an algorithm in an operation, deferring some steps to subclasses",
    "explanation": "Template Method defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps. It promotes code reuse and invariant behavior in the superclass.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In the context of object persistence, which pattern strictly separates the in-memory representation of an object from the database representation?",
    "options": [
      "Data Mapper",
      "Active Record",
      "Repository",
      "Unit of Work"
    ],
    "answer": "Data Mapper",
    "explanation": "The Data Mapper pattern is responsible for transferring data between memory objects and a database while keeping them independent of each other. Active Record couples the data and behavior in a single class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What distinguishes the Bridge pattern from the Adapter pattern?",
    "options": [
      "Bridge separates an abstraction from its implementation so both can vary independently, used before design is complete",
      "Bridge makes incompatible interfaces work together, used after the code is written",
      "Bridge is a structural pattern, whereas Adapter is a creational pattern",
      "Bridge adds functionality to an interface dynamically"
    ],
    "answer": "Bridge separates an abstraction from its implementation so both can vary independently, used before design is complete",
    "explanation": "Bridge is used up-front in design to decouple an abstraction from its implementation, allowing both to evolve independently. Adapter is typically used retroactively to make existing classes work together.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which design pattern composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions of objects uniformly?",
    "options": [
      "Composite Pattern",
      "Decorator Pattern",
      "Flyweight Pattern",
      "Proxy Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite pattern lets clients treat individual objects and compositions of objects uniformly by composing them into tree structures. It is essential for hierarchical structures like file systems or UI widgets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which pattern uses sharing to support large numbers of fine-grained objects efficiently, reducing the memory footprint by sharing intrinsic state?",
    "options": [
      "Flyweight Pattern",
      "Singleton Pattern",
      "Object Pool Pattern",
      "Prototype Pattern"
    ],
    "answer": "Flyweight Pattern",
    "explanation": "The Flyweight pattern minimizes memory usage by sharing as much data as possible with other similar objects; it stores intrinsic state externally and passes it in. Object Pool manages reusable objects, but doesn't necessarily share state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the key limitation of the Active Record pattern compared to the Data Mapper pattern?",
    "options": [
      "It couples the domain logic tightly with the database schema",
      "It prevents the use of lazy loading",
      "It requires a complex configuration setup",
      "It does not support inheritance"
    ],
    "answer": "It couples the domain logic tightly with the database schema",
    "explanation": "Active Record couples the object class to the database structure (1 class = 1 table), making refactoring difficult if the schema changes. Data Mapper decouples them, allowing independent evolution of the domain model and schema.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly?",
    "options": [
      "Mediator Pattern",
      "Observer Pattern",
      "Facade Pattern",
      "Bridge Pattern"
    ],
    "answer": "Mediator Pattern",
    "explanation": "The Mediator pattern defines an object that centralizes communication between colleagues. Colleagues do not interact directly, reducing dependencies. Observer is a one-to-many broadcast, while Facade simplifies a subsystem's interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which behavioral pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    "options": [
      "Iterator Pattern",
      "Visitor Pattern",
      "Command Pattern",
      "Memento Pattern"
    ],
    "answer": "Iterator Pattern",
    "explanation": "The Iterator pattern provides a uniform way to traverse various aggregate structures (lists, trees) without exposing the internal details of the aggregate. Visitor allows you to add new operations without changing the classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the primary purpose of the Visitor pattern?",
    "options": [
      "To define new operations without changing the classes of the elements on which it operates",
      "To traverse a collection of objects sequentially",
      "To separate the construction of an object from its representation",
      "To dynamically add behavior to an object"
    ],
    "answer": "To define new operations without changing the classes of the elements on which it operates",
    "explanation": "The Visitor pattern lets you define a new operation without changing the classes of the elements on which it operates by separating the algorithm from the object structure. Iterator traverses, and Decorator adds behavior dynamically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "Which pattern captures and externalizes an object's internal state so that the object can be restored to this state later?",
    "options": [
      "Memento Pattern",
      "Command Pattern",
      "Prototype Pattern",
      "State Pattern"
    ],
    "answer": "Memento Pattern",
    "explanation": "The Memento pattern provides the ability to restore an object to its previous state (undo) by saving snapshots of internal state. Command encapsulates a request, and Prototype creates clones.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In a Layered Architecture, which anti-pattern occurs when a layer makes a request to a layer immediately below it, but that lower layer calls back up to the requester?",
    "options": [
      "Circular Dependency",
      "Cascade Layering",
      "Tight Coupling",
      "Race Condition"
    ],
    "answer": "Circular Dependency",
    "explanation": "Circular dependencies occur when a lower layer references an upper layer (e.g., Business Layer calling Presentation Layer), breaking the strict dependency rule of layered architecture and causing tight coupling.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which architectural pattern is most suitable for a system where strict transactional integrity and data consistency are prioritized over scalability and deployment speed?",
    "options": [
      "Monolithic Architecture",
      "Microservices Architecture",
      "Serverless Architecture",
      "Event-Driven Architecture"
    ],
    "answer": "Monolithic Architecture",
    "explanation": "Monolithic architectures are often easier to secure and maintain strict transactional integrity (via ACID) because everything shares the same memory and database. Microservices sacrifice strict consistency for eventual consistency and higher scalability.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "Which design pattern best describes a mechanism where a component acts as a surrogate or placeholder for another object to control access to it, specifically to delay the creation or initialization of expensive resources until they are actually needed?",
    "options": [
      "Decorator Pattern",
      "Proxy Pattern",
      "Adapter Pattern",
      "Facade Pattern"
    ],
    "answer": "Proxy Pattern",
    "explanation": "The Proxy pattern provides a surrogate object to control access to a real subject, often used for lazy initialization (Virtual Proxy) or access control. A Decorator adds behavior dynamically, an Adapter changes interfaces, and a Facade simplifies an interface.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In the context of the Command Pattern, how does the pattern typically support 'undo' operations?",
    "options": [
      "The Invoker stores a stack of previous states of the Receiver.",
      "The Command object encapsulates an `unexecute()` method that reverses the effects of `execute()`.",
      "The Receiver maintains a history log of all executed operations.",
      "The Client serializes the entire object graph after each command."
    ],
    "answer": "The Command object encapsulates an `unexecute()` method that reverses the effects of `execute()`.",
    "explanation": "The Command pattern encapsulates a request as an object; to support undo, the command implements an inverse operation (`unexecute`) that reverts the state changes made by the original execution. Storing state in the Invoker or Receiver violates the single responsibility principle of the command encapsulation.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary distinction between the 'Thread-per-Request' and 'Thread-per-Connection' concurrency models in the context of Enterprise Architecture?",
    "options": [
      "Thread-per-Request assigns a dedicated thread for the life of the client connection, while Thread-per-Connection reuses threads for multiple requests.",
      "Thread-per-Request dynamically allocates a thread for the duration of a single logical task, whereas Thread-per-Connection blocks the thread for the duration of the socket's life.",
      "Thread-per-Request uses non-blocking I/O exclusively, while Thread-per-Connection relies solely on synchronous blocking I/O.",
      "Thread-per-Request creates a thread for every database query, while Thread-per-Connection creates a thread for every transaction."
    ],
    "answer": "Thread-per-Request dynamically allocates a thread for the duration of a single logical task, whereas Thread-per-Connection blocks the thread for the duration of the socket's life.",
    "explanation": "Thread-per-Request (often used in thread pools) ties a thread to a specific business logic task or HTTP request, allowing the thread to return to the pool once the request is processed. Thread-per-Connection ties the thread to the TCP connection, often leading to resource starvation during idle waits.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which of the following statements accurately describes the difference between the State Pattern and the Strategy Pattern?",
    "options": [
      "State Pattern allows an object to alter its behavior when its internal state changes, whereas Strategy Pattern defines a family of algorithms and makes them interchangeable.",
      "Strategy Pattern manages state transitions automatically, while State Pattern requires the client to manage the context.",
      "State Pattern is used for algorithms, while Strategy Pattern is used for object lifecycle management.",
      "There is no structural difference; they are identical patterns with different names."
    ],
    "answer": "State Pattern allows an object to alter its behavior when its internal state changes, whereas Strategy Pattern defines a family of algorithms and makes them interchangeable.",
    "explanation": "The State pattern typically delegates state-specific behavior to state objects that know about each other and handle transitions. The Strategy pattern is about selecting a specific algorithm at runtime without the strategies knowing about each other or managing transitions.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In a Microservices architecture using the Saga pattern, how is consistency maintained across distributed services without using distributed transactions (2PC)?",
    "options": [
      "A central coordinator locks all resources involved in the transaction until completion.",
      "Each local transaction publishes an event triggering the next local transaction, with compensating transactions rolling back previous steps if a failure occurs.",
      "The database uses optimistic locking to retry failed transactions automatically until they succeed.",
      "All services share a single database instance to ensure ACID properties."
    ],
    "answer": "Each local transaction publishes an event triggering the next local transaction, with compensating transactions rolling back previous steps if a failure occurs.",
    "explanation": "The Saga pattern sequences local transactions; if one step fails, a series of compensating transactions (reverse operations) are executed to undo the effects of preceding transactions. This avoids the locking overhead and fragility of Two-Phase Commit (2PC) in distributed systems.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Why is the Visitor Pattern typically considered more difficult to add new concrete element types to compared to adding new operations?",
    "options": [
      "Because the Visitor interface requires a specific `visit` method for every concrete element type, forcing changes to all existing Visitors.",
      "Because the Visitor pattern relies on run-time type identification (RTTI) which breaks when new types are introduced.",
      "Because element classes store a reference to the Visitor, preventing them from being extended.",
      "Because the Visitor pattern violates the Liskov Substitution Principle."
    ],
    "answer": "Because the Visitor interface requires a specific `visit` method for every concrete element type, forcing changes to all existing Visitors.",
    "explanation": "The Visitor pattern utilizes double dispatch; adding a new concrete element requires updating the Visitor interface (adding a `visitConcreteElement` method) and implementing that method in every concrete Visitor. Adding new operations is easy because it only requires creating a new Visitor class.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of Fowler's Enterprise Patterns, what is the primary function of the Unit of Work pattern?",
    "options": [
      "To abstract the database connection logic from the business layer.",
      "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes as a single batch.",
      "To map database rows to domain objects automatically.",
      "To ensure that only one instance of an entity with a specific ID exists in memory."
    ],
    "answer": "To maintain a list of objects affected by a business transaction and coordinate the writing out of changes as a single batch.",
    "explanation": "The Unit of Work tracks changes to objects during a transaction and commits these changes to the database in a single go, ensuring consistency. It is often used in conjunction with Identity Map and Data Mapper.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Which Enterprise Architecture pattern relies on a 'Token' or 'Leader' node to coordinate state changes across distributed replicas to resolve update conflicts?",
    "options": [
      "Multi-Leader Replication",
      "Leaderless Replication with Quorum",
      "Single-Leader (Active-Passive) Replication",
      "Event Sourcing"
    ],
    "answer": "Single-Leader (Active-Passive) Replication",
    "explanation": "In Single-Leader replication, all writes must go through the leader node, which serializes them to avoid update conflicts, before replicating to followers. Multi-leader and leaderless strategies inherently require conflict resolution mechanisms because they allow concurrent writes.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the specific behavior of the 'Circuit Breaker' pattern when the system enters the 'Open' state?",
    "options": [
      "Requests are passed through to the service, but execution time is monitored.",
      "All incoming requests are immediately failed without attempting to execute the protected logic.",
      "The system retries the connection periodically to check if the service has recovered.",
      "Requests are queued and processed asynchronously when the service becomes available."
    ],
    "answer": "All incoming requests are immediately failed without attempting to execute the protected logic.",
    "explanation": "When the Circuit Breaker is Open, it prevents requests from reaching the failing service to avoid overload and latency. It transitions to 'Half-Open' after a timeout to test if the service has recovered.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "In the Data Mapper pattern, how does the mapping logic differ from the Active Record pattern?",
    "options": [
      "Data Mapper uses inheritance to persist objects, while Active Record uses composition.",
      "Data Mapper moves the database persistence logic into a separate class layer, whereas Active Record couples the data access logic directly to the domain object.",
      "Active Record is only applicable to NoSQL databases, while Data Mapper is for SQL.",
      "Data Mapper requires a Service Layer to function, while Active Record interacts directly with the View."
    ],
    "answer": "Data Mapper moves the database persistence logic into a separate class layer, whereas Active Record couples the data access logic directly to the domain object.",
    "explanation": "Data Mapper enforces 'Separation of Concerns' by keeping the domain model ignorant of persistence. Active Record typically has 1:1 correspondence between classes and tables, with persistence methods (save, delete) residing in the domain object.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "When applying the Front Controller pattern, what is the primary benefit over the traditional 'Page Controller' (e.g., one servlet per JSP/Action)?",
    "options": [
      "It improves database performance by utilizing connection pooling.",
      "It centralizes request processing logic and security, allowing for shared behavior (authentication, logging) to be applied to all requests in one place.",
      "It eliminates the need for a View layer because the controller renders the HTML directly.",
      "It reduces the number of HTTP connections required for the client."
    ],
    "answer": "It centralizes request processing logic and security, allowing for shared behavior (authentication, logging) to be applied to all requests in one place.",
    "explanation": "The Front Controller funnels all requests through a single handler (or a small set), promoting code reuse for cross-cutting concerns like navigation, dispatching, and security, which would be duplicated across individual Page Controllers.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which pattern describes a situation where a 'Read Model' is optimized for queries and potentially denormalized, while a 'Write Model' handles transactions and validation?",
    "options": [
      "Service Layer Pattern",
      "CQRS (Command Query Responsibility Segregation)",
      "Table Data Gateway",
      "Remote Facade"
    ],
    "answer": "CQRS (Command Query Responsibility Segregation)",
    "explanation": "CQRS splits the model into separate stacks for updates (Commands) and reads (Queries), allowing them to be scaled, optimized, and secured independently. The Read model is often denormalized for performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "How does the 'Double-Checked Locking' idiom function correctly in a Singleton implementation?",
    "options": [
      "It locks the method for the entire duration of object creation.",
      "It checks the instance variable without synchronization first, and only synchronizes if it is null, checking again inside the synchronized block.",
      "It relies on the garbage collector to destroy and recreate the instance if a race condition is detected.",
      "It uses a static constructor to ensure thread-safety without explicit locking."
    ],
    "answer": "It checks the instance variable without synchronization first, and only synchronizes if it is null, checking again inside the synchronized block.",
    "explanation": "This optimization avoids the expensive synchronization cost after the instance is initialized. The second check inside the synchronized block prevents two threads from creating two instances if they race on the first check.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In the context of Enterprise Integration, what is the core difference between an Enterprise Service Bus (ESB) and a lightweight Message Broker?",
    "options": [
      "An ESB uses binary protocols, while a Message Broker uses text protocols.",
      "An ESB typically provides intelligent transformation, routing, and orchestration of services, while a lightweight broker focuses on simple channel-based message passing.",
      "A Message Broker guarantees delivery, but an ESB does not.",
      "There is no difference; they are synonymous terms."
    ],
    "answer": "An ESB typically provides intelligent transformation, routing, and orchestration of services, while a lightweight broker focuses on simple channel-based message passing.",
    "explanation": "ESBs are heavy, centralized integration hubs often with smart adapters and protocol conversion. Modern brokers (like Kafka or RabbitMQ) often act as 'dumb pipes' with 'smart endpoints' (microservices), reducing central complexity.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the primary disadvantage of using the 'Monolithic Architecture' pattern regarding scalability?",
    "options": [
      "It requires complex distributed transactions to maintain data consistency.",
      "The entire application must be scaled as a unit, even if only a specific module experiences high load, leading to inefficient resource utilization.",
      "It is impossible to implement a Monolith using modern languages like Java or Python.",
      "It prevents the use of load balancers."
    ],
    "answer": "The entire application must be scaled as a unit, even if only a specific module experiences high load, leading to inefficient resource utilization.",
    "explanation": "In a Monolith, modules share memory and the deployment process. You cannot scale the 'Billing' module independently of the 'Catalog' module; you must replicate the whole application binary.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which pattern allows you to 'rollback' the state of an object to a previous state without violating encapsulation?",
    "options": [
      "Memento Pattern",
      "Command Pattern",
      "Iterator Pattern",
      "Observer Pattern"
    ],
    "answer": "Memento Pattern",
    "explanation": "The Memento pattern captures and externalizes an object's internal state without exposing its internal structure (violating encapsulation), allowing the object to restore itself to this state later.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What structural change is required when introducing the 'Specification' pattern into a Domain Model?",
    "options": [
      "The domain entity must inherit from a 'Specification' base class.",
      "Business rules are encapsulated in separate classes (Specifications) that can be combined using boolean logic (AND, OR, NOT).",
      "The database schema must be normalized to store specifications as rows.",
      "All methods in the service layer must be refactored to return void."
    ],
    "answer": "Business rules are encapsulated in separate classes (Specifications) that can be combined using boolean logic (AND, OR, NOT).",
    "explanation": "The Specification pattern encapsulates domain rules into reusable predicates (`isSatisfiedBy`), allowing complex business logic (e.g., 'overdue invoices for premium customers') to be chained and passed to repositories or domain services.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the context of the 'Intercepting Filter' pattern, how is the processing of a request typically managed?",
    "options": [
      "By a single large conditional statement in the Controller.",
      "By a chain of independent filters that process the request before it reaches the final resource, with each filter potentially deciding to terminate the chain.",
      "By the database trigger calling the application logic.",
      "By modifying the request header at the client-side only."
    ],
    "answer": "By a chain of independent filters that process the request before it reaches the final resource, with each filter potentially deciding to terminate the chain.",
    "explanation": "The Intercepting Filter pattern implements pre-processing and post-processing logic (like authentication, logging, compression) in a reusable chain of responsibility, allowing the request to pass through or be stopped by any filter.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How does the 'Flyweight' pattern aim to reduce memory footprint?",
    "options": [
      "By compressing the object bytecode at compile time.",
      "By sharing the common state (intrinsic) of multiple objects and storing the varying state (extrinsic) externally.",
      "By disposing of objects immediately after use.",
      "By moving the object storage to a database."
    ],
    "answer": "By sharing the common state (intrinsic) of multiple objects and storing the varying state (extrinsic) externally.",
    "explanation": "Flyweight minimizes memory use by sharing intrinsic data (context-independent) among many objects. Extrinsic data (context-dependent) is passed in during method execution rather than stored in the flyweight object.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the 'Inversion of Control' (IoC) principle primarily concerned with?",
    "options": [
      "Reversing the order of execution in a multi-threaded application.",
      "Delegating the task of creating and managing dependencies to a container or framework, rather than the class itself.",
      "Swapping the database and application server roles.",
      "Allowing the database to trigger events in the application."
    ],
    "answer": "Delegating the task of creating and managing dependencies to a container or framework, rather than the class itself.",
    "explanation": "IoC inverts the flow of control: instead of the class creating its dependencies, the class receives them (e.g., via Dependency Injection). This decouples the class from concrete implementations.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In the context of database sharding, what is 'Horizontal Sharding'?",
    "options": [
      "Splitting a table with many columns into separate tables to reduce row width.",
      "Distributing rows of a single table across multiple database instances based on a shard key.",
      "Replicating the entire database to multiple nodes for high availability.",
      "Combining multiple tables into a single wide table."
    ],
    "answer": "Distributing rows of a single table across multiple database instances based on a shard key.",
    "explanation": "Horizontal sharding (often called 'sharding' by default) distributes the dataset (rows) across nodes to spread the load. Vertical sharding splits tables by columns; replication copies data.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which of the following best describes 'Temporal Decoupling' in asynchronous messaging architectures?",
    "options": [
      "The sender and receiver must be online at the exact same time to exchange messages.",
      "The sender and receiver can operate independently; the sender can send a message when the receiver is offline, and the receiver processes it when available.",
      "The system uses a synchronized clock to order messages.",
      "The message is automatically deleted after a specific timestamp."
    ],
    "answer": "The sender and receiver can operate independently; the sender can send a message when the receiver is offline, and the receiver processes it when available.",
    "explanation": "Temporal decoupling means the timing of the sender's message production and the receiver's consumption are not linked. A message queue or broker buffers messages until the consumer is ready.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the main purpose of the 'Service Locator' pattern?",
    "options": [
      "To provide a centralized registry where services can be looked up by consumers, abstracting the actual creation or location of the dependency.",
      "To locate the geographical location of a server instance.",
      "To compress the service code into a smaller footprint.",
      "To load balance traffic between service instances."
    ],
    "answer": "To provide a centralized registry where services can be looked up by consumers, abstracting the actual creation or location of the dependency.",
    "explanation": "The Service Locator acts as a registry (a 'broker') that returns the requested service instance. While similar to Dependency Injection, it requires the consumer to explicitly request the dependency (pull) rather than receiving it (push).",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the Event Sourcing pattern, what constitutes the 'Source of Truth' for the system state?",
    "options": [
      "The current state stored in the relational database tables.",
      "The log of immutable events representing all state changes that have occurred.",
      "The cache layer in front of the application.",
      "The snapshots taken during nightly backups."
    ],
    "answer": "The log of immutable events representing all state changes that have occurred.",
    "explanation": "In Event Sourcing, the current state is derived by replaying the event log. Therefore, the event log is the definitive source of truth; the database state (if present) is merely a projection or cache of that log.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the primary risk of the 'Anemic Domain Model' anti-pattern?",
    "options": [
      "It causes memory leaks due to circular references.",
      "It reduces the object model to a set of data holders (properties) without behavior, moving business logic into service classes, which violates Object-Oriented Design principles.",
      "It makes the database schema incompatible with the object model.",
      "It prevents the application from being scalable."
    ],
    "answer": "It reduces the object model to a set of data holders (properties) without behavior, moving business logic into service classes, which violates Object-Oriented Design principles.",
    "explanation": "Anemic Domain Models essentially use domain objects as DTOs, losing the benefits of encapsulation and polymorphism. It often leads to 'procedural' code in service layers rather than rich domain logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the 'Database-per-Service' pattern in Microservices architecture address data coupling?",
    "options": [
      "It forces all services to share a single database schema to ensure data integrity.",
      "It allows each service to own its private data store, ensuring that other services must access the data only through that service's API.",
      "It replicates the entire database for every service deployed.",
      "It uses a distributed locking mechanism to synchronize access to shared tables."
    ],
    "answer": "It allows each service to own its private data store, ensuring that other services must access the data only through that service's API.",
    "explanation": "This pattern ensures loose coupling; services cannot directly query tables of other services (preventing implicit schema coupling). If data is needed, it must be requested via API (e.g., REST, gRPC) or events.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which pattern is utilized to decouple the 'presentation' logic from the 'business logic' in web applications by strictly separating the View and Controller responsibilities?",
    "options": [
      "Data Access Object (DAO)",
      "Model-View-Controller (MVC)",
      "Singleton Pattern",
      "Bridge Pattern"
    ],
    "answer": "Model-View-Controller (MVC)",
    "explanation": "MVC separates the application into three interconnected components: the Model (data), the View (presentation), and the Controller (input handling). This decoupling allows for independent development and testing of UI and business logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of API Gateway pattern, what is 'Backend for Frontend' (BFF)?",
    "options": [
      "A single backend API that serves all types of clients (Web, Mobile).",
      "A specific layer where separate API Gateways are created for specific client interfaces (e.g., one for iOS, one for Web) to optimize payload and reduce coupling.",
      "A database backup strategy.",
      "A legacy mainframe interface wrapper."
    ],
    "answer": "A specific layer where separate API Gateways are created for specific client interfaces (e.g., one for iOS, one for Web) to optimize payload and reduce coupling.",
    "explanation": "BFF acknowledges that different clients have different data requirements; instead of a generic gateway, a tailored backend (gateway) serves each specific client type, avoiding over-fetching or complex client-side logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What distinguishes a 'Collocated' decomposition (Modular Monolith) from a 'Distributed' one (Microservices)?",
    "options": [
      "Collocated decomposition deploys all modules to a single runtime process, while distributed deploys modules to separate processes.",
      "Collocated decomposition cannot use Domain-Driven Design, while distributed requires it.",
      "Distributed decomposition does not require a network, while collocated does.",
      "There is no difference; the terms are synonymous."
    ],
    "answer": "Collocated decomposition deploys all modules to a single runtime process, while distributed deploys modules to separate processes.",
    "explanation": "A Modular Monolith (Collocated) maintains strict module boundaries but runs as one application, simplifying deployment and networking. Microservices (Distributed) run these modules as independent services.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "Which of the following best describes 'Read-Through' caching?",
    "options": [
      "The application checks the cache; if data is missing, it loads from the database and puts it in the cache before returning.",
      "The cache sits in front of the database and automatically populates itself when the requested data is not present.",
      "The database pushes data to the cache whenever a change occurs.",
      "The cache is warmed up during application startup and never checked for consistency afterwards."
    ],
    "answer": "The cache sits in front of the database and automatically populates itself when the requested data is not present.",
    "explanation": "In Read-Through caching, the application talks to the cache provider. If data is missing, the cache provider fetches it from the persistent store. This differs from 'Cache-Aside' (Lazy Loading) where the application code manages the fetch.",
    "difficulty": "Advanced"
  }
]