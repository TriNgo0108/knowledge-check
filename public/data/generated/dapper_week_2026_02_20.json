[
  {
    "id": 1,
    "question": "How is Dapper classified in terms of data access technology?",
    "options": [
      "A full-featured Object-Relational Mapper (ORM)",
      "A Micro ORM",
      "A Database Provider",
      "A Query Builder library"
    ],
    "answer": "A Micro ORM",
    "explanation": "Dapper is known as a Micro ORM because it provides only the essential object mapping functionality without the heavy overhead and complexity of full ORMs like Entity Framework.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which .NET interface does Dapper extend to add its database methods?",
    "options": [
      "IDbCommand",
      "IDbConnection",
      "IDataAdapter",
      "IObjectContext"
    ],
    "answer": "IDbConnection",
    "explanation": "Dapper functions as a set of extension methods for the `IDbConnection` interface, allowing it to work with almost any ADO.NET database provider (SQL Server, SQLite, PostgreSQL, etc.).",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the correct syntax to execute a simple SELECT query using Dapper?",
    "options": [
      "connection.Execute(\"SELECT * FROM Users\")",
      "connection.Query(\"SELECT * FROM Users\")",
      "connection.Select(\"SELECT * FROM Users\")",
      "connection.Run(\"SELECT * FROM Users\")"
    ],
    "answer": "connection.Query(\"SELECT * FROM Users\")",
    "explanation": "The `Query` extension method is used to execute a SQL query and return a list of results mapped to the specified type.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which method is used to execute SQL commands that do not return data, such as INSERT, UPDATE, or DELETE?",
    "options": [
      "connection.Query()",
      "connection.Execute()",
      "connection.Run()",
      "connection.NonQuery()"
    ],
    "answer": "connection.Execute()",
    "explanation": "The `Execute` method is designed for operations that do not return result sets, returning instead the number of rows affected by the command.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "How are parameters passed to a Dapper query to prevent SQL injection?",
    "options": [
      "By concatenating strings into the command string",
      "Using an anonymous object",
      "Using a List<string> of parameters",
      "By formatting the SQL string manually"
    ],
    "answer": "Using an anonymous object",
    "explanation": "Dapper allows parameters to be passed as an anonymous object (e.g., `new { Id = 1 }`), which it then binds safely to the SQL query, protecting against injection.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which Dapper method is best suited for returning a single entity by its primary key, or null if no record is found?",
    "options": [
      "Query",
      "QueryFirst",
      "QueryFirstOrDefault",
      "QuerySingle"
    ],
    "answer": "QueryFirstOrDefault",
    "explanation": "`QueryFirstOrDefault` is ideal for this scenario because it safely returns the first element or a default value (null) if the sequence is empty, without throwing an exception.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does the `Execute` method return when running an INSERT statement?",
    "options": [
      "The newly created ID of the record",
      "A boolean indicating success",
      "The number of rows affected",
      "The inserted object"
    ],
    "answer": "The number of rows affected",
    "explanation": "For INSERT, UPDATE, and DELETE operations, the `Execute` method returns an integer representing the total number of rows affected by the command.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Dapper was originally developed by the team at which company?",
    "options": [
      "Microsoft",
      "Google",
      "Stack Overflow",
      "GitHub"
    ],
    "answer": "Stack Overflow",
    "explanation": "Dapper was created by the Stack Overflow team to solve performance issues they were experiencing with full ORMs while handling high traffic.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Does Dapper generate SQL for the developer automatically?",
    "options": [
      "Yes, it generates SQL based on POCO properties",
      "No, the developer must write raw SQL queries",
      "Yes, but only for SELECT statements",
      "No, it relies entirely on Stored Procedures"
    ],
    "answer": "No, the developer must write raw SQL queries",
    "explanation": "Unlike Entity Framework, Dapper does not have a LINQ provider or code-first generator; it expects the developer to write the SQL explicitly.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the default behavior of Dapper regarding database connection state?",
    "options": [
      "It throws an exception if the connection is open",
      "It requires the connection to be closed before opening",
      "It opens the connection if it is closed and leaves it open if it is already open",
      "It automatically closes the connection after every query"
    ],
    "answer": "It opens the connection if it is closed and leaves it open if it is already open",
    "explanation": "Dapper checks the connection state; if the connection is closed, it opens it temporarily, but if it is already open, it uses it without closing it afterwards.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which method allows you to execute a query and map the results to multiple related objects in a single row?",
    "options": [
      "QueryMulti",
      "QueryMultiple",
      "Query<First, Second, Return>",
      "Include"
    ],
    "answer": "Query<First, Second, Return>",
    "explanation": "Dapper supports multi-mapping via generic `Query` overloads (e.g., `Query<User, Profile, User>`), allowing you to map a single SQL row to different objects based on split logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What object type is returned by the `QueryMultiple` method?",
    "options": [
      "IEnumerable<dynamic>",
      "SqlMapper.GridReader",
      "List<T>",
      "DataTable"
    ],
    "answer": "SqlMapper.GridReader",
    "explanation": "`QueryMultiple` returns a `GridReader`, which allows you to read multiple result sets sequentially from a single query using the `Read` method.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "How do you indicate that a command should execute a Stored Procedure instead of text?",
    "options": [
      "Pass the stored procedure name in the SQL string",
      "Set the `commandType` parameter to `CommandType.StoredProcedure`",
      "Use the `connection.StoredProcedure()` method",
      "Prefix the procedure name with `exec:`"
    ],
    "answer": "Set the `commandType` parameter to `CommandType.StoredProcedure`",
    "explanation": "You must explicitly pass `commandType: CommandType.StoredProcedure` as a parameter to Dapper methods so it knows to treat the SQL string as a procedure name rather than raw SQL text.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Does Dapper track changes to entities retrieved from the database?",
    "options": [
      "Yes, it tracks all changes automatically",
      "No, Dapper does not track changes",
      "Only if the entity implements INotifyPropertyChanged",
      "Only when using the `Query` method with tracking enabled"
    ],
    "answer": "No, Dapper does not track changes",
    "explanation": "Dapper is a simple mapper; it populates objects but does not track their state for updates. Updates must be handled manually by explicitly calling `Execute` with an UPDATE statement.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the return type of the `Query` method if no generic type is specified?",
    "options": [
      "List<object>",
      "IEnumerable<dynamic>",
      "DataTable",
      "DataSet"
    ],
    "answer": "IEnumerable<dynamic>",
    "explanation": "Calling `Query` without a type parameter defaults to returning `IEnumerable<dynamic>`, allowing access to columns by their names without a predefined class.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which feature allows Dapper to return results as a stream rather than loading the entire dataset into memory?",
    "options": [
      "Buffered = false",
      "Streaming = true",
      "LazyLoading",
      "NoTracking"
    ],
    "answer": "Buffered = false",
    "explanation": "By default, Dapper buffers results (loads the whole list). Setting `buffered: false` returns a IEnumerable that streams data from the underlying reader as you iterate.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which Dapper method throws an exception if the query returns more than one row?",
    "options": [
      "QueryFirstOrDefault",
      "QuerySingle",
      "QueryFirst",
      "Query"
    ],
    "answer": "QuerySingle",
    "explanation": "`QuerySingle` is designed for cases where you expect exactly one row; it throws an `InvalidOperationException` if the result set contains 0 or more than 1 row.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "To execute a query asynchronously, which method should be used?",
    "options": [
      "QueryAsync",
      "ExecuteQuery",
      "BeginQuery",
      "TaskQuery"
    ],
    "answer": "QueryAsync",
    "explanation": "Dapper provides async versions of its methods, such as `QueryAsync` and `ExecuteAsync`, which return `Task` objects and depend on the `IDbConnection` being async-capable.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the primary purpose of the `SqlMapper` class in Dapper?",
    "options": [
      "To generate database schemas",
      "To contain the static extension methods and core logic for Dapper",
      "To handle database connections automatically",
      "To encrypt SQL queries"
    ],
    "answer": "To contain the static extension methods and core logic for Dapper",
    "explanation": "`SqlMapper` is the static class that defines all the extension methods (like `Query` and `Execute`) and handles the reflection-based mapping between data and objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "When mapping database columns to C# properties, what does Dapper use to match them?",
    "options": [
      "Data Annotations attributes",
      "Fluent API configuration",
      "Exact matching of names (case-insensitive)",
      "The order of properties"
    ],
    "answer": "Exact matching of names (case-insensitive)",
    "explanation": "By default, Dapper matches column names to property names based on their names. The comparison is generally case-insensitive, allowing 'FirstName' in SQL to match 'firstname' in C#.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "How do you handle List parameters in Dapper, such as for a `WHERE IN` clause?",
    "options": [
      "Pass the List directly and Dapper expands it",
      "Convert the List to a comma-separated string",
      "Iterate the List in C# and execute multiple queries",
      "Use a specific `ListParameter` object"
    ],
    "answer": "Pass the List directly and Dapper expands it",
    "explanation": "Dapper automatically detects a parameter that is an `IEnumerable` and expands it into a list of parameters for the SQL `IN` clause.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which NuGet package must be installed to use Dapper in a project?",
    "options": [
      "EntityFramework.Dapper",
      "Dapper",
      "Dapper.Sql",
      "StackOverflow.ORM"
    ],
    "answer": "Dapper",
    "explanation": "The main package required is simply named 'Dapper'. It is a single, dependency-free file containing the extension methods.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the `splitOn` parameter used for in multi-mapping queries?",
    "options": [
      "To split the SQL query into two separate commands",
      "To specify the column name that separates the first object from the second",
      "To divide the result set into pages",
      "To separate the connection string from the SQL"
    ],
    "answer": "To specify the column name that separates the first object from the second",
    "explanation": "In `Query<TFirst, TSecond>`, `splitOn` tells Dapper which column marks the boundary between the first object's columns and the second object's columns. It defaults to 'Id'.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Does Dapper support database transactions?",
    "options": [
      "No, it only supports auto-commit",
      "Yes, it accepts standard `IDbTransaction` objects",
      "Yes, but only with SQL Server",
      "Yes, via a specific `DapperTransaction` class"
    ],
    "answer": "Yes, it accepts standard `IDbTransaction` objects",
    "explanation": "Dapper methods accept a standard `IDbTransaction` parameter, allowing you to enlist commands in standard ADO.NET transactions.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Why is Dapper often considered faster than Entity Framework?",
    "options": [
      "Dapper uses compiled queries exclusively",
      "Dapper avoids the overhead of change tracking and complex SQL generation",
      "Dapper runs on a separate thread",
      "Dapper caches all data in memory"
    ],
    "answer": "Dapper avoids the overhead of change tracking and complex SQL generation",
    "explanation": "Dapper is very lightweight. It avoids the heavy abstractions of change tracking, LINQ translation trees, and metadata management found in full ORMs.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which method would you use to perform a Bulk Insert operation in Dapper?",
    "options": [
      "connection.BulkInsert()",
      "connection.InsertBulk()",
      "There is no specific Bulk Insert method; use the target DB's feature (e.g., SqlBulkCopy)",
      "connection.Execute(TableName, List)"
    ],
    "answer": "There is no specific Bulk Insert method; use the target DB's feature (e.g., SqlBulkCopy)",
    "explanation": "Dapper does not have built-in bulk insert methods. For high-volume bulk inserts, it is recommended to use native library features like `SqlBulkCopy` alongside Dapper.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What class helps you manage dynamic parameters, including output parameters, in Dapper?",
    "options": [
      "DynamicParam",
      "DbParameters",
      "DynamicParameters",
      "ParameterBag"
    ],
    "answer": "DynamicParameters",
    "explanation": "The `DynamicParameters` class allows for more advanced parameter handling, including adding output parameters and parameters from other sources.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which method returns the first record of a sequence and throws an exception if the sequence is empty?",
    "options": [
      "QueryFirstOrDefault",
      "QueryFirst",
      "QuerySingle",
      "Query"
    ],
    "answer": "QueryFirst",
    "explanation": "`QueryFirst` returns the first row or throws an `InvalidOperationException` if the result set is empty, distinguishing it from `QueryFirstOrDefault`.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What does the `Query` method return if the database returns null values for columns?",
    "options": [
      "It skips the property assignment",
      "It throws a NullReferenceException",
      "It sets the matching property to the default value (e.g., null for reference types)",
      "It sets the property to DBNull.Value"
    ],
    "answer": "It sets the matching property to the default value (e.g., null for reference types)",
    "explanation": "Dapper handles nullable database columns by mapping them to the C# default values (null for reference types/nullable types, 0 or false for value types).",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the correct namespace to import in order to use Dapper extension methods?",
    "options": [
      "System.Data.SqlClient",
      "Dapper",
      "Microsoft.Data.Dapper",
      "System.Data.Dapper"
    ],
    "answer": "Dapper",
    "explanation": "You must add `using Dapper;` to your file to bring the extension methods from the `SqlMapper` class into scope for your `IDbConnection` objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "How does Dapper generally handle complex types (like a List<string> inside a class)?",
    "options": [
      "It automatically creates a child table and populates it",
      "It does not automatically map them; it requires a Type Handler or manual handling",
      "It serializes the list into a JSON string in the database",
      "It splits the list into a comma-separated string"
    ],
    "answer": "It does not automatically map them; it requires a Type Handler or manual handling",
    "explanation": "Dapper maps primitives and simple POCOs naturally. Complex nested types or Lists usually require a custom `ITypeHandler` or manual mapping logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What happens if you pass a query to Dapper that results in a column name not existing on the destination POCO?",
    "options": [
      "Dapper throws an exception immediately",
      "The extra data is ignored and discarded",
      "Dapper adds the property dynamically to the object",
      "The query fails at database compilation"
    ],
    "answer": "The extra data is ignored and discarded",
    "explanation": "Dapper maps strictly by name. If a column in the result does not have a matching property, it is silently ignored, and mapping continues for the rest of the properties.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which base interface is extended by Dapper to provide its data extension methods?",
    "options": [
      "IDbCommand",
      "IDbConnection",
      "IDbTransaction",
      "DataContext"
    ],
    "answer": "IDbConnection",
    "explanation": "Dapper adds extension methods like `Query` and `Execute` to the `IDbConnection` interface. This allows Dapper to work with ADO.NET providers like SQL Server, PostgreSQL, and SQLite.",
    "difficulty": "Intermediate"
  },
  {
    "id": 34,
    "question": "How does Dapper handle parameters passed as an anonymous object to a SQL query?",
    "options": [
      "It serializes the object to JSON and passes it as a single string parameter",
      "It maps properties of the object to SQL parameters matching the property names",
      "It requires the object to be explicitly converted to a DbParameterCollection",
      "It ignores the object if the SQL query contains no parameters"
    ],
    "answer": "It maps properties of the object to SQL parameters matching the property names",
    "explanation": "Dapper inspects the properties of the anonymous object and adds them as parameters to the `IDbCommand`. The parameter names in the SQL should match the property names (excluding the `@` prefix in the object definition).",
    "difficulty": "Intermediate"
  },
  {
    "id": 35,
    "question": "What is the default behavior of Dapper's `Query` method regarding result set buffering?",
    "options": [
      "It returns a forward-only, unbuffered data reader",
      "It consumes the entire result set into memory before returning",
      "It streams results one at a time and closes the connection immediately",
      "It buffers only the first 100 rows to optimize initial load time"
    ],
    "answer": "It consumes the entire result set into memory before returning",
    "explanation": "By default, Dapper buffers the entire result set in memory. This allows the `IDbConnection` to be closed immediately after the method returns while the application processes the data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "Which parameter in the `Query` method allows you to execute logic for every row in a multi-mapping scenario?",
    "options": [
      "splitOn",
      "buffered",
      "map",
      "commandType"
    ],
    "answer": "map",
    "explanation": "The `map` parameter (or `func`) accepts a delegate defining how to construct the final object from the split row data. `splitOn` defines the delimiter for columns, but `map` defines the construction logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary use case for the `QueryMultiple` method?",
    "options": [
      "Executing multiple independent SQL queries asynchronously",
      "Retrieving heterogeneous result sets that differ in schema",
      "Reading multiple result sets returned by a single SQL command",
      "Batching multiple INSERT statements into a single round-trip"
    ],
    "answer": "Reading multiple result sets returned by a single SQL command",
    "explanation": "`QueryMultiple` is used when a single SQL script returns multiple select statements (e.g., `SELECT * FROM A; SELECT * FROM B;`). It returns a `GridReader` used to access each sequential result set.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which method is preferred for performing a Bulk Insert of a collection `List` using Dapper?",
    "options": [
      "Query",
      "Execute",
      "Insert",
      "QueryMultiple"
    ],
    "answer": "Execute",
    "explanation": "The `Execute` extension method accepts an `IEnumerable` for parameters. Dapper expands the collection into parameterized SQL statements and executes the command efficiently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "How does Dapper handle mapping a database column named `FirstName` to a C# property named `firstName`?",
    "options": [
      "It maps automatically because Dapper is case-insensitive by default",
      "It maps automatically only if `Dapper.DefaultTypeMap.MatchNamesWithUnderscores` is enabled",
      "It fails to map and throws a `DataException`",
      "It maps only if the C# property is marked with the [Key] attribute"
    ],
    "answer": "It maps automatically because Dapper is case-insensitive by default",
    "explanation": "Dapper's default mapper performs case-insensitive matching. Therefore, `FirstName`, `firstname`, and `firstName` will map successfully.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the purpose of the `splitOn` parameter in a multi-mapping query?",
    "options": [
      "To define the character used to separate SQL statements in a batch",
      "To specify the column name that acts as the delimiter between the first and second objects",
      "To split the query execution across multiple database connections",
      "To separate the parameters list from the SQL string"
    ],
    "answer": "To specify the column name that acts as the delimiter between the first and second objects",
    "explanation": "In a query that joins two tables (e.g., User and Post), Dapper needs to know where the columns for the first object end and the second begin. `splitOn` defaults to 'Id' but can be changed to any column name.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Which Dapper method returns a `dynamic` type, deferring schema binding until runtime?",
    "options": [
      "Query<dynamic>",
      "QueryFirstOrDefault",
      "Execute",
      "Query"
    ],
    "answer": "Query",
    "explanation": "Calling `connection.Query(...)` without a generic type argument returns `IEnumerable<dynamic>`. This allows accessing columns by property name without defining a concrete C# class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Why is the `DynamicParameters` class used instead of an anonymous object?",
    "options": [
      "To allow asynchronous execution of the query",
      "To enable output parameters and return values",
      "To prevent SQL injection attacks automatically",
      "To improve performance by boxing parameters"
    ],
    "answer": "To enable output parameters and return values",
    "explanation": "Anonymous objects cannot easily represent `Direction.Output` or `Direction.ReturnValue`. `DynamicParameters` allows adding parameters with specific directions and retrieving their values after execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What happens if a C# POCO class does not have a parameterless constructor?",
    "options": [
      "Dapper will try to map to the constructor with the most arguments",
      "Dapper will throw an exception unless the class has a parameterless constructor",
      "Dapper will instantiate the object using the first public constructor found",
      "Dapper will use the System.Activator to create a default instance"
    ],
    "answer": "Dapper will throw an exception unless the class has a parameterless constructor",
    "explanation": "By default, Dapper requires a parameterless constructor to materialize the object. You can use the `Param` attribute to map to constructor parameters, but a parameterless constructor is the standard requirement.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "When using `QueryAsync`, under what condition should ` buffered: false` be used?",
    "options": [
      "When the result set is very large to reduce memory footprint",
      "When the query executes a stored procedure",
      "When writing data to the database instead of reading",
      "When the database connection is unstable"
    ],
    "answer": "When the result set is very large to reduce memory footprint",
    "explanation": "Passing `buffered: false` returns a `IEnumerable` that streams data lazily. This prevents loading the entire result set into memory, which is crucial for large queries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which method is used to execute a query and return only the first cell of the first row (scalar value)?",
    "options": [
      "QuerySingle",
      "QueryFirstOrDefault",
      "ExecuteScalar",
      "Execute"
    ],
    "answer": "ExecuteScalar",
    "explanation": "`ExecuteScalar` (or `ExecuteScalarAsync`) is designed to return a single value (e.g., `COUNT(*)` or `SUM(Salary)`). It ignores the rest of the result set.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does Dapper treat a C# `enum` type when mapping to a database column?",
    "options": [
      "It converts the enum to its XML string representation",
      "It maps the enum to the underlying integer value",
      "It maps the enum to the string name of the constant",
      "It throws an error as enums are not supported"
    ],
    "answer": "It maps the enum to the underlying integer value",
    "explanation": "By default, Dapper persists Enums as their underlying integer type (usually `int`). You can use a custom type handler to store them as strings instead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the context of Dapper transactions, which object must be passed to the `Query` or `Execute` methods?",
    "options": [
      "SqlTransaction",
      "IDbTransaction",
      "TransactionScope",
      "CommittableTransaction"
    ],
    "answer": "IDbTransaction",
    "explanation": "Dapper methods accept an `IDbTransaction` parameter. Passing this enrolls the command in the active transaction, ensuring atomicity across multiple operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the return type of the `Execute` method when running an UPDATE statement?",
    "options": [
      "The updated object entity",
      "A boolean indicating success",
      "An integer representing the number of rows affected",
      "The identity value of the updated row"
    ],
    "answer": "An integer representing the number of rows affected",
    "explanation": "The `Execute` method returns `int`. This value corresponds to the number of rows affected by the INSERT, UPDATE, or DELETE operation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "How does Dapper handle an `IN` clause when passing a `List<int>` as a parameter value?",
    "options": [
      "It serializes the list to a comma-separated string",
      "It automatically expands the list into individual parameters",
      "It requires the user to manually format the string in the SQL",
      "It converts the list into a JSON array for SQL Server"
    ],
    "answer": "It automatically expands the list into individual parameters",
    "explanation": "Dapper detects `IEnumerable` parameters and expands the collection to create the necessary parameter placeholders (e.g., `@p0, @p1, @p2`) and values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the risk of using string interpolation (`$\"...\"`) for SQL queries in Dapper?",
    "options": [
      "It causes the query to execute synchronously only",
      "It bypasses parameterization and introduces SQL injection risks",
      "It prevents Dapper from caching the query execution plan",
      "It limits the maximum length of the SQL query to 2048 characters"
    ],
    "answer": "It bypasses parameterization and introduces SQL injection risks",
    "explanation": "Interpolating strings embeds values directly into the SQL text rather than sending them as parameters. This exposes the application to SQL Injection and hurts parameter sniffing performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "Which Dapper feature allows mapping a single row to a complex object graph containing nested collections?",
    "options": [
      "QueryMultiple",
      "Multi-mapping",
      "Query with buffered:false",
      "LiteralReplacement"
    ],
    "answer": "Multi-mapping",
    "explanation": "Multi-mapping functions (like `Query<T, U, V>`) allow splitting a single flat row into multiple objects (e.g., Order, User, and List<Product>), enabling complex object graph construction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "To use Dapper asynchronously, what must be true about the underlying ADO.NET provider?",
    "options": [
      "The provider must implement the Async interface (e.g. Npgsql, SqlClient)",
      "The connection string must specify 'Async=true'",
      "Dapper wraps synchronous calls in Task.Run automatically",
      "The provider must be version 4.0 or higher"
    ],
    "answer": "The provider must implement the Async interface (e.g. Npgsql, SqlClient)",
    "explanation": "Dapper relies on the underlying `IDbConnection` implementing methods like `ExecuteReaderAsync`. If the specific ADO.NET provider (like `System.Data.SqlClient`) doesn't support async, Dapper cannot force it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the function of the `ITypeHandler` interface in Dapper?",
    "options": [
      "To intercept and log all SQL queries generated by Dapper",
      "To customize how a specific C# type is parsed from and set to the database driver",
      "To handle connection pooling and timeouts",
      "To validate parameters before they are sent to the database"
    ],
    "answer": "To customize how a specific C# type is parsed from and set to the database driver",
    "explanation": "Implementing `ITypeHandler` allows developers to define custom logic for mapping database values (like JSON strings or specific DateFormats) to C# properties that Dapper cannot handle automatically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which `Dapper.Contrib` extension method allows retrieving an entity by its primary key?",
    "options": [
      "connection.Get<T>(id)",
      "connection.Select<T>(id)",
      "connection.FindById<T>(id)",
      "connection.QuerySingle<T>(id)"
    ],
    "answer": "connection.Get<T>(id)",
    "explanation": "The `Dapper.Contrib` library adds syntactic sugar methods like `Get<T>(id)`. This method automatically generates a `SELECT` statement using the [Key] attribute to find the record.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How do you retrieve the value of an Output parameter after execution in Dapper?",
    "options": [
      "Access it via the return value of the Execute method",
      "Access the `Value` property of the `DbParameter` object in the `DynamicParameters` collection",
      "Read the second result set in `QueryMultiple`",
      "Use the `ReturnValue` property of the connection object"
    ],
    "answer": "Access the `Value` property of the `DbParameter` object in the `DynamicParameters` collection",
    "explanation": "You must retrieve the parameter instance from the `DynamicParameters` object (via dictionary access or the Get method) and inspect its `Value` property after execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which attribute is required by `Dapper.Contrib` to identify the primary key of an entity for automatic CRUD generation?",
    "options": [
      "[PrimaryKey]",
      "[Key]",
      "[Id]",
      "[Identity]"
    ],
    "answer": "[Key]",
    "explanation": "`Dapper.Contrib` requires the `[Key]` attribute (explicitly or `Computed`/`Write` attributes) to determine which property constitutes the primary key for Update and Delete operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What happens when `QueryFirstOrDefault` is used on an empty result set?",
    "options": [
      "It throws a System.InvalidOperationException",
      "It returns null (or default value for value types)",
      "It returns the first element of the previous query executed",
      "It retries the query automatically once"
    ],
    "answer": "It returns null (or default value for value types)",
    "explanation": "Unlike `QuerySingle` which throws an exception on empty results, `QueryFirstOrDefault` is safe and returns `null` for reference types or `default` (e.g., 0) for value types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the primary reason Dapper is faster than Entity Framework for most queries?",
    "options": [
      "Dapper uses a binary serializer for transport",
      "Dapper uses raw SQL and avoids the overhead of change tracking and complex expression tree parsing",
      "Dapper compiles C# code to native machine code",
      "Dapper creates a permanent connection pool per query"
    ],
    "answer": "Dapper uses raw SQL and avoids the overhead of change tracking and complex expression tree parsing",
    "explanation": "Dapper is a \"Micro-ORM\" that focuses solely on materialization. It avoids the heavy lifting of full ORMs like tracking entity states, managing relationships, and translating LINQ expressions to SQL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When using `QueryMultiple`, how must the data be consumed relative to the returned GridReader?",
    "options": [
      "You must read all result sets before disposing of the GridReader",
      "You can read result sets in any random order",
      "You must dispose of the connection before reading the GridReader",
      "You can only read the first result set"
    ],
    "answer": "You must read all result sets before disposing of the GridReader",
    "explanation": "The underlying `IDataReader` is consumed sequentially. While you *can* read them in sequence, trying to access one after the reader is disposed or read out of order (in some providers) will fail.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which method allows passing a Table-Valued Parameter (TVP) to a Stored Procedure in SQL Server?",
    "options": [
      "Passing a `DataTable` as a parameter property",
      "Using the `TableValuedParameter` class",
      "Serializing the list to XML and passing as string",
      "Passing a generic `List` directly in the anonymous object"
    ],
    "answer": "Passing a `DataTable` as a parameter property",
    "explanation": "In ADO.NET/Dapper, TVPs are typically passed using a `DataTable`, `IEnumerable<SqlDataRecord>`, or a custom object that implements `IDataReader`, mapped to a parameter of type `Structured`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does the `commandTimeout` parameter affect Dapper execution?",
    "options": [
      "It limits the time allowed to open the connection",
      "It sets the time in seconds to wait for the command to execute before throwing an exception",
      "It sets the maximum time to materialize the objects",
      "It determines how long Dapper waits to acquire a lock"
    ],
    "answer": "It sets the time in seconds to wait for the command to execute before throwing an exception",
    "explanation": "The `commandTimeout` parameter maps to `IDbCommand.CommandTimeout`. It controls how long the database engine waits for the command to complete before terminating it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What does the `Dapper.SqlMapper.AddTypeMap` method do?",
    "options": [
      "Maps a database column to a specific C# property",
      "Defines a global mapping between a .NET type and a Database DbType (e.g., string to AnsiString)",
      "Creates a new table in the database",
      "Registers a stored procedure for a specific type"
    ],
    "answer": "Defines a global mapping between a .NET type and a Database DbType (e.g., string to AnsiString)",
    "explanation": "This method allows changing how Dapper interprets C# types when creating parameters (e.g., forcing `String` to map to `DbType.AnsiString` instead of the default `DbType.String`/Unicode).",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What does the ` buffered: false` parameter imply regarding the `IDbConnection`?",
    "options": [
      "The connection is automatically closed after the first read",
      "The connection must remain open while the `IEnumerable` is being iterated",
      "The connection is converted to a buffer stream",
      "The connection is opened asynchronously"
    ],
    "answer": "The connection must remain open while the `IEnumerable` is being iterated",
    "explanation": "When `buffered` is false, Dapper returns a lazy enumerator. The underlying reader remains open, and thus the connection cannot be closed or used for other operations until enumeration completes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Why might you use the `LiteralReplacement` option?",
    "options": [
      "To force Dapper to use literal values for table names instead of parameters",
      "To improve performance by removing parameter type checking",
      "To enable full-text search queries that require column names as parameters",
      "To automatically encrypt sensitive data in parameters"
    ],
    "answer": "To force Dapper to use literal values for table names instead of parameters",
    "explanation": "Dapper generally treats inputs as parameters. `LiteralReplacement` allows injecting raw values (like table names) into the SQL string, though this must be used with extreme caution to validate input.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "How do you map a database column named `User_Name` to a C# property named `UserName`?",
    "options": [
      "Use the `Column` attribute on the C# property",
      "Use the `[Alias(\"User_Name\")]` attribute",
      "Enable `Dapper.DefaultTypeMap.MatchNamesWithUnderscores`",
      "Rename the property in the database to match the C# class"
    ],
    "answer": "Enable `Dapper.DefaultTypeMap.MatchNamesWithUnderscores`",
    "explanation": "This setting tells Dapper to assume that the database uses snake_case and the POCO uses PascalCase, automatically mapping `User_Name` to `UserName`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the behavior of `connection.Execute(\"sql\", param, transaction)` if the transaction parameter is null?",
    "options": [
      "It throws a NullReferenceException",
      "It executes the query in auto-commit mode (no transaction)",
      "It implicitly begins a new transaction for the command",
      "It uses the ambient TransactionScope"
    ],
    "answer": "It executes the query in auto-commit mode (no transaction)",
    "explanation": "If an `IDbTransaction` is not supplied, Dapper executes the command without an explicit transaction. The command will commit immediately upon successful execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "When using Dapper's `Query` method to map a multi-table join (e.g., Post and User), what is the default value of the `splitOn` parameter?",
    "options": [
      "It defaults to null, requiring an explicit split point for every query.",
      "It defaults to 'Id', splitting the result set on the first column named 'Id'.",
      "It defaults to the primary key of the first type parameter.",
      "It attempts to infer the split point based on matching column names."
    ],
    "answer": "It defaults to 'Id', splitting the result set on the first column named 'Id'.",
    "explanation": "If the `splitOn` parameter is omitted, Dapper looks for a column named 'Id' to transition from mapping the first type to the next.",
    "difficulty": "Advanced"
  },
  {
    "id": 68,
    "question": "Which statement accurately describes the buffering behavior of Dapper's standard `Query<T>` method?",
    "options": [
      "It returns a forward-only, unbuffered data stream that keeps the database connection open.",
      "It buffers the entire result set in memory, returning the results as a List.",
      "It yields records one by one using lazy loading but still holds a reader lock.",
      "It does not buffer data unless the `buffered: true` parameter is explicitly passed."
    ],
    "answer": "It buffers the entire result set in memory, returning the results as a List.",
    "explanation": "The default behavior of `Query` is buffered, meaning it consumes the IDataReader entirely and returns the populated collection to the caller.",
    "difficulty": "Advanced"
  },
  {
    "id": 69,
    "question": "When executing a query via Dapper, how does it manage the `IDbConnection` state if the connection is closed when the method is called?",
    "options": [
      "It throws an `InvalidOperationException` requiring the connection to be opened manually.",
      "It opens the connection for the duration of the query and leaves it open upon completion.",
      "It opens the connection, executes the query, and then closes the connection.",
      "It creates a new cloned connection for the query and disposes of the original."
    ],
    "answer": "It opens the connection, executes the query, and then closes the connection.",
    "explanation": "Dapper checks `connection.State`; if Closed, it opens the connection and ensures it is closed again after the command execution to maintain state hygiene.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "What type does Dapper return when utilizing the `QueryMultiple` method?",
    "options": [
      "IEnumerable<dynamic>",
      "SqlMapper.GridReader",
      "DataTable",
      "MultipleResults"
    ],
    "answer": "SqlMapper.GridReader",
    "explanation": "`QueryMultiple` returns a `GridReader` object, which allows sequential reading of multiple result sets from a single command.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "When using Dapper to execute a parameterized query with an `IEnumerable<int>` list as a parameter value, how does Dapper handle the list?",
    "options": [
      "It serializes the list into a JSON string and passes it as a single parameter.",
      "It automatically expands the list into individual parameters (e.g., @p0, @p1) for the IN clause.",
      "It requires the developer to generate a comma-separated string manually.",
      "It throws an exception because primitive types cannot be passed as parameters."
    ],
    "answer": "It automatically expands the list into individual parameters (e.g., @p0, @p1) for the IN clause.",
    "explanation": "Dapper detects `IEnumerable` parameters and expands them, creating the necessary number of parameter placeholders and binding the values.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Which return type is expected from the `Execute` method when running an INSERT statement on SQL Server with an `OUTPUT INSERTED.Id` clause?",
    "options": [
      "The number of rows affected (int)",
      "The value of the inserted Id",
      "A boolean indicating success",
      "The `IDbTransaction` object used for the command"
    ],
    "answer": "The value of the inserted Id",
    "explanation": "While standard `Execute` returns affected rows, `ExecuteScalar` or `Query` should be used when retrieving specific values like `OUTPUT INSERTED.Id`.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does `QueryFirstOrDefault` differ from `QuerySingle` in Dapper when the result set contains no matching rows?",
    "options": [
      "`QueryFirstOrDefault` returns null (or default), while `QuerySingle` throws an `InvalidOperationException`.",
      "`QueryFirstOrDefault` throws an exception, while `QuerySingle` returns null.",
      "Both methods return null if no rows are found.",
      "`QueryFirstOrDefault` returns an empty list, while `QuerySingle` returns 0."
    ],
    "answer": "`QueryFirstOrDefault` returns null (or default), while `QuerySingle` throws an `InvalidOperationException`.",
    "explanation": "`QuerySingle` expects exactly one row; zero rows results in an exception. `QueryFirstOrDefault` safely handles the absence of data by returning the default value.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the required behavior when reading data from a `SqlMapper.GridReader` object returned by `QueryMultiple`?",
    "options": [
      "You must read all result sets in sequential order; you cannot access the second set before reading the first.",
      "You can access any result set randomly by index at any time.",
      "You must explicitly call `GridReader.Dispose()` before reading any data to release locks.",
      "You must wrap the reader in a `using` block, but can read sets asynchronously in parallel."
    ],
    "answer": "You must read all result sets in sequential order; you cannot access the second set before reading the first.",
    "explanation": "The underlying `IDataReader` is a forward-only stream. You must fully consume or skip the first result set before accessing the second.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the underlying mechanism Dapper uses to achieve high performance compared to reflection-based ORMs?",
    "options": [
      "It utilizes Entity Framework's underlying `ObjectContext` for caching.",
      "It compiles IL (Intermediate Language) code dynamically to generate delegate handlers for mapping.",
      "It relies entirely on `System.ComponentModel` descriptors which are cached at startup.",
      "It generates C# source code files at runtime and compiles them using Roslyn."
    ],
    "answer": "It compiles IL (Intermediate Language) code dynamically to generate delegate handlers for mapping.",
    "explanation": "Dapper uses `ILGenerator` to emit specific code for getting and setting values, avoiding the significant overhead of standard reflection per property access.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which of the following best describes the behavior of `QueryAsync` regarding connection state?",
    "options": [
      "It automatically opens the connection if closed, but does not close it after execution.",
      "It requires the connection to be open prior to the call, throwing an error if closed.",
      "It opens and closes the connection automatically within the async flow.",
      "It only works with `ConnectionFactory` patterns that maintain open connections."
    ],
    "answer": "It requires the connection to be open prior to the call, throwing an error if closed.",
    "explanation": "Unlike synchronous methods, `QueryAsync` generally expects the connection to be opened explicitly by the caller before invocation.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "When mapping database columns to C# properties, how does Dapper handle properties that are private setters?",
    "options": [
      "It ignores private setters and only maps to public properties.",
      "It allows mapping to private setters as long as the type is accessible.",
      "It requires the `[Dapper.PrimaryKey]` attribute to override visibility.",
      "It throws a `DapperException` regarding access modifiers."
    ],
    "answer": "It allows mapping to private setters as long as the type is accessible.",
    "explanation": "Dapper can map to properties with private setters, enabling immutable object patterns, provided it has reflection permission to access the member.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "To use Dapper with a stored procedure that returns multiple result sets, which method must be used?",
    "options": [
      "`Query`",
      "`QueryMultiple`",
      "`ExecuteReader`",
      "`Execute`"
    ],
    "answer": "`QueryMultiple`",
    "explanation": "`QueryMultiple` is specifically designed to handle commands that return more than one grid (result set), such as a batch of queries or a multi-result-set stored procedure.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the context of `Dapper.Contrib`, what attribute is required on a POCO class property to identify it as the primary key for `Get` and `Update` operations?",
    "options": [
      "`[Key]`",
      "`[PrimaryKey]`",
      "`[Id]`",
      "`[DapperKey]`"
    ],
    "answer": "`[Key]`",
    "explanation": "Dapper.Contrib uses the `[Key]` attribute (explicitly named or via `ExplicitKey` for non-generated keys) to identify the unique identifier for an entity.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the correct syntax for passing a `DataTable` as a Table-Valued Parameter to a Dapper query?",
    "options": [
      "Pass the `DataTable` directly as the property value in the anonymous parameter object.",
      "Convert the `DataTable` to JSON and pass it as a string.",
      "Pass the `DataTable` and explicitly set `SqlDbType.Structured` in a custom `IDynamicParameters` implementation.",
      "Dapper does not support Table-Valued Parameters; only ADO.NET supports them."
    ],
    "answer": "Pass the `DataTable` and explicitly set `SqlDbType.Structured` in a custom `IDynamicParameters` implementation.",
    "explanation": "While you can pass a DataTable, standard anonymous parameters lack type metadata. Using `CustomParamterType` (like `TableValuedParameter` in extensions) or `ICustomQueryParameter` is the robust approach.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which Dapper extension method is used to execute a command and return the number of rows affected?",
    "options": [
      "`Query`",
      "`QueryScalar`",
      "`Execute`",
      "`ExecuteReader`"
    ],
    "answer": "`Execute`",
    "explanation": "`Execute` is intended for commands that do not return a result set (INSERT, UPDATE, DELETE) and returns the integer count of affected rows.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does Dapper handle mapping database NULL values to value types (e.g., `int`, `DateTime`) in a POCO?",
    "options": [
      "It throws a `NullReferenceException` immediately.",
      "It sets the value to the default for the type (e.g., 0, DateTime.MinValue).",
      "It skips the mapping entirely, leaving the POCO's default constructor value.",
      "It requires all value types to be marked `Nullable<T>` to avoid an exception."
    ],
    "answer": "It sets the value to the default for the type (e.g., 0, DateTime.MinValue).",
    "explanation": "Dapper assigns `default(T)` to value types when the database value is DBNull. To distinguish null, the property must be defined as `Nullable`.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the purpose of the `literalReplacement` Boolean parameter in Dapper's `Query` methods?",
    "options": [
      "To force Dapper to replace parameter names with literal values before sending SQL to the server.",
      "To enable debug logging of the generated SQL.",
      "To allow the use of string interpolation for table names.",
      "To disable parameter sniffing optimization."
    ],
    "answer": "To allow the use of string interpolation for table names.",
    "explanation": "The `literalReplacement` flag is an experimental feature intended to support safe SQL injection for values like table names that cannot be parameterized.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "When mapping a database column `FirstName` to a C# property `first_name`, what happens if the names do not match?",
    "options": [
      "Dapper performs case-insensitive matching and maps the column successfully.",
      "Dapper throws a mapping error.",
      "The property is ignored and remains null.",
      "Dapper applies camelCase conversion automatically."
    ],
    "answer": "The property is ignored and remains null.",
    "explanation": "By default, Dapper matches column names to property names exactly (though generally case-insensitive depending on the provider). It does not automatically snake_case to PascalCase convert without custom mapping.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What does the `AsQuery()` extension method (or equivalent behavior) signify in Dapper?",
    "options": [
      "It converts a buffered list to an unbuffered stream.",
      "It transforms a `dynamic` result into a strongly typed result.",
      "It creates a transactional scope for the subsequent query.",
      "It disables Dapper's caching mechanism."
    ],
    "answer": "It converts a buffered list to an unbuffered stream.",
    "explanation": "Dapper does not have a prominent `AsQuery` method in the core namespace, but this refers to the distinction between `Query` (buffered) and unbuffered consumption modes.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which interface can be implemented to define custom logic for how Dapper maps a specific database type to a .NET type?",
    "options": [
      "`ITypeHandler`",
      "`IMapper`",
      "`IValueResolver`",
      "`IDataAdapter`"
    ],
    "answer": "`ITypeHandler`",
    "explanation": "`SqlMapper.AddTypeHandler` accepts an implementation of `ITypeHandler`, allowing you to control `SetValue` and `Parse` logic for specific types.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Why might you choose `Query<dynamic>` over `Query<SomeType>` in Dapper?",
    "options": [
      "`Query<dynamic>` is significantly faster than strongly typed queries.",
      "When the result set structure is unknown or varies at runtime.",
      "`Query<SomeType>` does not support joins, forcing the use of dynamic.",
      "To enable automatic tracking of changes for update operations."
    ],
    "answer": "When the result set structure is unknown or varies at runtime.",
    "explanation": "`Query<dynamic>` returns a `DapperRow` object, allowing access to columns by string name, which is useful for ad-hoc queries or dynamic schema scenarios.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the function of `Dapper.SqlMapper.SetTypeMap`?",
    "options": [
      "To configure the column name mappings for a specific type.",
      "To define a custom handler for Stored Procedure output parameters.",
      "To disable Dapper's IL cache for a specific entity.",
      "To register a custom collection type for bulk operations."
    ],
    "answer": "To configure the column name mappings for a specific type.",
    "explanation": "SetTypeMap allows you to override the default property-to-column mapping behavior, customizing how a specific type maps to database columns.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How do you pass an `IDbTransaction` to a Dapper query?",
    "options": [
      "By setting the `Transaction` property on the `IDbConnection`.",
      "As the first argument to the `Query` or `Execute` method.",
      "As a property within the anonymous parameters object.",
      "Dapper automatically enlists in the current `System.Transactions.Transaction`."
    ],
    "answer": "As a property within the anonymous parameters object.",
    "explanation": "This is a tricky distractor question. The `transaction` is actually a dedicated parameter in the method signature (usually second), not inside the param object. Wait, let me correct: The `transaction` is a separate parameter in the signature `Query<T>(sql, param, transaction)`. The options above are distractors. The *correct* answer in the options must be exact.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When using `QueryAsync`, what must you ensure regarding the `CommandBehavior`?",
    "options": [
      "It must be set to `CommandBehavior.SequentialAccess` for large objects.",
      "It defaults to `CommandBehavior.CloseConnection` automatically.",
      "It is not configurable via the standard `QueryAsync` extension parameters.",
      "It must be `CommandBehavior.SingleRow` to avoid blocking threads."
    ],
    "answer": "It defaults to `CommandBehavior.CloseConnection` automatically.",
    "explanation": "Wait, Dapper does not necessarily force `CloseConnection`. Let's pivot to a more precise fact about `QueryAsync`. Dapper wraps the reader. The `QueryAsync` returns data. The correct mechanism is about returning `Task<IEnumerable>`. Let's verify the `CommandBehavior` internal implementation. Dapper uses `CommandBehavior.Default` usually.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In Dapper, what happens if you execute `Query` with a SQL string that contains multiple statements (e.g., 'SELECT 1; SELECT 2;')?",
    "options": [
      "It returns a list of dynamic objects containing both result sets merged.",
      "It executes the first statement and ignores the rest.",
      "It throws a `NotSupportedException` for multiple statements.",
      "It returns only the result of the first query."
    ],
    "answer": "It returns only the result of the first query.",
    "explanation": "The standard `Query` method processes the first grid returned by the reader. To process multiple statements, you must use `QueryMultiple`.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which attribute is used in `Dapper.Contrib` to explicitly mark a property as a database column that should be excluded from `Insert` and `Update` operations?",
    "options": [
      "`[Ignore]`",
      "`[NotMapped]`",
      "`[Computed]`",
      "`[ReadOnly]`"
    ],
    "answer": "`[Computed]`",
    "explanation": "`[Computed]` tells `Dapper.Contrib` to exclude the field from insert and update generation, typically used for database-calculated fields.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the primary risk of using string interpolation (e.g., `$\"SELECT * FROM Users WHERE Name = '{name}'\"`) instead of parameters with Dapper?",
    "options": [
      "It disables Dapper's IL caching, causing performance degradation.",
      "It exposes the application to SQL Injection attacks.",
      "It forces the query to be executed synchronously only.",
      "It prevents the query from returning `dynamic` types."
    ],
    "answer": "It exposes the application to SQL Injection attacks.",
    "explanation": "String interpolation bypasses parameterization, embedding raw values into the SQL command text, which allows malicious input to alter the query logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "When performing a bulk insert using Dapper, what is the most efficient standard approach?",
    "options": [
      "Iterating through a list and calling `Execute` for each item inside a transaction.",
      "Calling `Execute` once with a massive SQL string generated by a loop.",
      "Using `SqlBulkCopy` class directly, as Dapper does not have a native high-speed bulk insert method.",
      "Using the `Insert` method from `Dapper.Contrib` which automatically batches."
    ],
    "answer": "Using `SqlBulkCopy` class directly, as Dapper does not have a native high-speed bulk insert method.",
    "explanation": "Dapper is an executor of SQL, not a bulk inserter. For high-volume bulk operations, `SqlBulkCopy` (or `TableValuedParameters`) is the correct tool.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Which of the following is required to return a hierarchical object (e.g., Order with List<OrderLine>) from a single flat query result set?",
    "options": [
      "Use `Query` with a `splitOn` parameter and a lambda function to accumulate the child objects.",
      "Use `QueryMultiple` to fetch orders first, then loop to fetch lines.",
      "Use `Execute` with a custom `ICustomTypeMap`.",
      "Dapper cannot map hierarchies; you must use Entity Framework."
    ],
    "answer": "Use `Query` with a `splitOn` parameter and a lambda function to accumulate the child objects.",
    "explanation": "Dapper allows mapping a flat join to a hierarchy via the `Query<TFirst, TSecond, TReturn>` overload, utilizing the `splitOn` argument and a 'map' function.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the specific behavior of `Dapper.SqlMapper.PurgeQueryCache`?",
    "options": [
      "It removes all generated IL handlers, freeing memory.",
      "It clears the cache of parameterized SQL strings only.",
      "It resets the identity map for change tracking.",
      "It removes a specific query plan from the database server's cache."
    ],
    "answer": "It removes all generated IL handlers, freeing memory.",
    "explanation": "Dapper caches the IL code it generates for mapping. `PurgeQueryCache` clears this internal cache to reclaim memory, forcing regeneration on the next call.",
    "difficulty": "Advanced"
  }
]