[
  {
    "id": 1,
    "question": "Which command-line interface (CLI) command is used to create a new ASP.NET Core Minimal API project?",
    "options": [
      "dotnet new mvc",
      "dotnet new web",
      "dotnet new webapi",
      "dotnet new console"
    ],
    "answer": "dotnet new web",
    "explanation": "The 'dotnet new web' command creates an empty ASP.NET Core template, which is the standard starting point for building Minimal APIs without controllers.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In the ASP.NET Core middleware pipeline, how is the execution order of middleware components determined?",
    "options": [
      "Alphabetically by middleware name",
      "In the order they are registered in the code",
      "Randomized at runtime for load balancing",
      "Based on the HTTP verb of the request"
    ],
    "answer": "In the order they are registered in the code",
    "explanation": "Middleware components are executed in the exact order they are added to the pipeline using methods like Use(), Run(), or Map().",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary purpose of the 'dotnet run' command?",
    "options": [
      "To compile the project only",
      "To publish the application for deployment",
      "To build and run the application source code",
      "To clean the bin and obj folders"
    ],
    "answer": "To build and run the application source code",
    "explanation": "'dotnet run' compiles the source code if it has changed and then executes the application, providing immediate feedback during development.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In a Minimal API, which extension method is used to configure an endpoint that responds to HTTP GET requests?",
    "options": [
      "app.MapGet()",
      "app.UseGet()",
      "app.Get()",
      "app.RunGet()"
    ],
    "answer": "app.MapGet()",
    "explanation": "The MapGet() method specifically maps a handler delegate to an HTTP GET route and the specified path pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which Dependency Injection lifetime ensures that only one instance of a service is created throughout the application's lifecycle?",
    "options": [
      "Transient",
      "Scoped",
      "Singleton",
      "Request"
    ],
    "answer": "Singleton",
    "explanation": "Singleton services are created the first time they are requested and live until the application shuts down.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the default name of the entry point file in modern .NET applications using top-level statements?",
    "options": [
      "Startup.cs",
      "Main.cs",
      "Program.cs",
      "App.cs"
    ],
    "answer": "Program.cs",
    "explanation": "Program.cs acts as the entry point where the WebApplicationBuilder is created, services are configured, and the middleware pipeline is defined.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which method is used to terminate the middleware pipeline and return a response immediately?",
    "options": [
      "app.Use()",
      "app.Map()",
      "app.Run()",
      "app.Next()"
    ],
    "answer": "app.Run()",
    "explanation": "The Run() method adds a terminal middleware delegate that executes and prevents subsequent middleware from processing the request.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which built-in class is used to build the application and configure services in ASP.NET Core?",
    "options": [
      "WebApplication",
      "WebApplicationBuilder",
      "HttpServer",
      "ServiceCollection"
    ],
    "answer": "WebApplicationBuilder",
    "explanation": "WebApplicationBuilder provides a streamlined way to configure services (Services), logging (Logging), and build the app (Build()).",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "When a C# object is returned from a Minimal API endpoint, how is it serialized by default?",
    "options": [
      "As XML",
      "As Binary",
      "As JSON",
      "As Plain Text"
    ],
    "answer": "As JSON",
    "explanation": "ASP.NET Core Minimal APIs use JSON as the default content negotiation format for returning complex C# objects.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which Dependency Injection lifetime creates a new instance of the service every time it is requested from the container?",
    "options": [
      "Singleton",
      "Scoped",
      "Transient",
      "PerRequest"
    ],
    "answer": "Transient",
    "explanation": "Transient services are lightweight and created each time they are injected, ensuring the consumer always gets a new instance.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the function of the 'UseMiddleware' extension method in the ASP.NET Core pipeline?",
    "options": [
      "To register a new service in DI",
      "To inject a custom middleware class into the pipeline",
      "To handle HTTP errors globally",
      "To map a specific route pattern"
    ],
    "answer": "To inject a custom middleware class into the pipeline",
    "explanation": "UseMiddleware allows a developer to add a custom class or inline delegate to the request processing pipeline.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "In .NET, which keyword defines a value type?",
    "options": [
      "class",
      "interface",
      "struct",
      "enum"
    ],
    "answer": "struct",
    "explanation": "A struct is a value type that is stored on the stack (if local) or inline, whereas a class is a reference type stored on the heap.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which configuration file is typically used to store application settings like connection strings in .NET?",
    "options": [
      "web.config",
      "appsettings.json",
      "settings.json",
      "config.json"
    ],
    "answer": "appsettings.json",
    "explanation": "Modern .NET applications use appsettings.json (and environment-specific overrides like appsettings.Development.json) for configuration.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the main benefit of using Dependency Injection (DI)?",
    "options": [
      "Faster execution time",
      "Smaller application size",
      "Loose coupling and improved testability",
      "Automatic memory management"
    ],
    "answer": "Loose coupling and improved testability",
    "explanation": "DI promotes Inversion of Control (IoC), allowing classes to depend on abstractions (interfaces) rather than concrete implementations, making unit testing easier.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which HTTP verb is conventionally used to update an existing resource in a RESTful API?",
    "options": [
      "GET",
      "POST",
      "PUT",
      "DELETE"
    ],
    "answer": "PUT",
    "explanation": "PUT is used to update a resource at a specific URI, while POST is typically used to create a new resource.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which method in Minimal APIs is used to branch the pipeline based on the requested path?",
    "options": [
      "app.Use()",
      "app.Map()",
      "app.Run()",
      "app.Branch()"
    ],
    "answer": "app.Map()",
    "explanation": "Map() creates a branch in the middleware pipeline that executes only if the request path matches the given pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What does the acronym CORS stand for in the context of web APIs?",
    "options": [
      "Cross-Origin Resource Sharing",
      "Central Object Request State",
      "Client-Origin Routing Service",
      "Cross-Open Reference Standard"
    ],
    "answer": "Cross-Origin Resource Sharing",
    "explanation": "CORS is a browser security mechanism that allows or restricts resources requested from a different domain than the one that served the web page.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which interface is used to register services in the ASP.NET Core DI container?",
    "options": [
      "IServiceProvider",
      "IServiceCollection",
      "IDependency",
      "IServiceLocator"
    ],
    "answer": "IServiceCollection",
    "explanation": "Services are added to the IServiceCollection (accessed via builder.Services) during application startup.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which middleware is specifically designed to catch unhandled exceptions globally in development?",
    "options": [
      "UseExceptionHandler",
      "UseDeveloperExceptionPage",
      "UseHsts",
      "UseHttpsRedirection"
    ],
    "answer": "UseDeveloperExceptionPage",
    "explanation": "UseDeveloperExceptionPage displays a detailed stack trace and error information, which is useful in development but insecure in production.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the default port for the Kestrel web server when running 'dotnet run' in a new project?",
    "options": [
      "80",
      "443",
      "5000 or 5001",
      "8080"
    ],
    "answer": "5000 or 5001",
    "explanation": "While configurable, Kestrel typically listens on HTTP port 5000 and HTTPS port 5001 by default in development environments.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "In C#, which keywords are used to define an asynchronous method?",
    "options": [
      "sync and wait",
      "parallel and wait",
      "async and await",
      "future and result"
    ],
    "answer": "async and await",
    "explanation": "The 'async' modifier enables the 'await' keyword, which suspends execution until the awaited task completes, without blocking the thread.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which command restores the dependencies listed in a .csproj file?",
    "options": [
      "dotnet build",
      "dotnet restore",
      "dotnet install",
      "dotnet update"
    ],
    "answer": "dotnet restore",
    "explanation": "'dotnet restore' downloads the NuGet packages specified in the project file, ensuring the build can resolve dependencies.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the role of the 'builder' object in 'var builder = WebApplication.CreateBuilder(args);'?",
    "options": [
      "To handle HTTP requests",
      "To configure services and the host",
      "To manage the database connection",
      "To write logs to the console"
    ],
    "answer": "To configure services and the host",
    "explanation": "The builder provides access to Configuration, Services (DI), and Logging to set up the application before it runs.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which HTTP status code represents a 'Not Found' error?",
    "options": [
      "200",
      "400",
      "401",
      "404"
    ],
    "answer": "404",
    "explanation": "404 Not Found is returned when the server cannot locate the specific resource requested by the client.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What does the 'params' keyword allow you to do in a C# method argument?",
    "options": [
      "Pass arguments by reference",
      "Pass a variable number of arguments",
      "Make an argument optional",
      "Enforce type safety"
    ],
    "answer": "Pass a variable number of arguments",
    "explanation": "The 'params' keyword allows a method to accept zero, one, or more arguments of a specific type, typically processed as an array.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In Minimal APIs, how do you return a 201 Created status code with a location header?",
    "options": [
      "Return the object directly",
      "Use Results.Created()",
      "Use Results.Ok()",
      "Throw an exception"
    ],
    "answer": "Use Results.Created()",
    "explanation": "The Results helper types, such as Results.Created(), provide a structured way to return specific HTTP status codes and headers.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which CLI command is used to publish an application for deployment?",
    "options": [
      "dotnet build",
      "dotnet run",
      "dotnet publish",
      "dotnet pack"
    ],
    "answer": "dotnet publish",
    "explanation": "'dotnet publish' compiles the application and its dependencies into a folder ready for deployment to a hosting server.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the primary characteristic of a 'Reference Type' in C#?",
    "options": [
      "It stores data directly on the stack",
      "It holds a reference to data on the heap",
      "It cannot be inherited from",
      "It is always immutable"
    ],
    "answer": "It holds a reference to data on the heap",
    "explanation": "Reference types (like classes) store a reference to the object's memory address on the heap, unlike value types which store direct values.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which interface must a class implement to be automatically disposed of by the DI container?",
    "options": [
      "IDisposable",
      "IAsyncDisposable",
      "IServiceProvider",
      "IComponent"
    ],
    "answer": "IDisposable",
    "explanation": "If a service implements IDisposable or IAsyncDisposable, the container will automatically call Dispose/DisposeAsync when the scope ends.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which keyword is used to define a contract for methods without implementation?",
    "options": [
      "class",
      "struct",
      "interface",
      "abstract class"
    ],
    "answer": "interface",
    "explanation": "An interface defines a signature for members (methods, properties) that a class must implement.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the result of calling 'app.MapPost(\"/\", () => \"Hello\")' when the client sends a GET request to \"/\"?",
    "options": [
      "It returns \"Hello\"",
      "It returns a 404 Not Found",
      "It returns a 405 Method Not Allowed",
      "It throws a compile error"
    ],
    "answer": "It returns a 404 Not Found",
    "explanation": "Route matching in Minimal APIs is strict; a POST route will not match a GET request, typically resulting in a 404 from the router unless a fallback exists.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which HTTP status code indicates a server-side error (500)?",
    "options": [
      "Bad Request",
      "Unauthorized",
      "Forbidden",
      "Internal Server Error"
    ],
    "answer": "Internal Server Error",
    "explanation": "HTTP 500 is the generic status code for an unexpected condition preventing the server from fulfilling the request.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which file extension is used for C# source code files?",
    "options": [
      ".cs",
      ".net",
      ".csharp",
      ".code"
    ],
    "answer": ".cs",
    "explanation": "C# source code files use the .cs extension.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In the context of Minimal APIs, what does 'Results.Ok(value)' return?",
    "options": [
      "A 200 OK response with the value",
      "A 201 Created response",
      "A 204 No Content response",
      "A 400 Bad Request response"
    ],
    "answer": "A 200 OK response with the value",
    "explanation": "The Results.Ok() helper returns a standard HTTP 200 status code, often used to signify successful data retrieval.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In the ASP.NET Core middleware pipeline, how does the order of middleware components affect the request processing flow?",
    "options": [
      "Middleware runs concurrently in any order to maximize throughput",
      "The order is irrelevant as the framework optimizes execution paths automatically",
      "Components are executed in the order they are added, and responses travel in reverse order",
      "Middleware is executed alphabetically by component name regardless of registration order"
    ],
    "answer": "Components are executed in the order they are added, and responses travel in reverse order",
    "explanation": "The middleware pipeline is a sequence where the request passes through components in the order they are registered. Once a component completes logic, the response travels back up the stack through the previous components.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the specific risk of injecting a Scoped service into a Singleton service in ASP.NET Core?",
    "options": [
      "The application will fail to compile due to a lifetime mismatch error",
      "The Singleton service will be recreated every time the Scoped service is accessed",
      "The Scoped service may become a captive dependency, leading to memory leaks or stale data",
      "The Scoped service will automatically promote to a Singleton lifetime without error"
    ],
    "answer": "The Scoped service may become a captive dependency, leading to memory leaks or stale data",
    "explanation": "A Singleton service is created once. If it captures a Scoped service (intended to live only during a request), that Scoped instance effectively lives forever, potentially holding onto resources or state longer than intended.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "When using Minimal APIs, how does `app.MapGet` differ from a traditional Controller Action in terms of dependency injection?",
    "options": [
      "Dependency Injection is not supported in Minimal API endpoints",
      "You must use the `[FromServices]` attribute to resolve services in Minimal APIs",
      "Minimal APIs support constructor injection only",
      "Services can be resolved directly as parameters in the route handler delegate"
    ],
    "answer": "Services can be resolved directly as parameters in the route handler delegate",
    "explanation": "In Minimal APIs, the dependency injection container resolves parameters passed to the lambda expression. If a type is registered in the container, it is automatically injected without needing attributes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which middleware component should be registered first in the ASP.NET Core pipeline to catch unhandled exceptions globally?",
    "options": [
      "Authentication Middleware",
      "Authorization Middleware",
      "Exception Handling Middleware",
      "HTTPS Redirection Middleware"
    ],
    "answer": "Exception Handling Middleware",
    "explanation": "The Exception Handling Middleware (like `UseExceptionHandler`) must be registered at the start of the pipeline to ensure it can catch exceptions thrown by any subsequent middleware components.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the primary purpose of the `UseWhen` extension method in the ASP.NET Core middleware pipeline?",
    "options": [
      "To permanently branch the pipeline based on a predicate for the remainder of the application",
      "To conditionally execute middleware for a specific request path and then rejoin the main pipeline",
      "To terminate the pipeline execution immediately if a condition is met",
      "To register middleware that runs only during application shutdown"
    ],
    "answer": "To conditionally execute middleware for a specific request path and then rejoin the main pipeline",
    "explanation": "`UseWhen` allows branching the pipeline based on a boolean predicate. Unlike `Map`, it rejoins the main pipeline after the branched middleware finishes execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In the context of C# and .NET, what is a 'Captive Dependency' within Dependency Injection?",
    "options": [
      "A Singleton service depending on a Transient service",
      "A Transient service depending on a Singleton service",
      "A service with a longer lifetime (e.g., Singleton) injecting a service with a shorter lifetime (e.g., Scoped)",
      "A circular reference between two Scoped services"
    ],
    "answer": "A service with a longer lifetime (e.g., Singleton) injecting a service with a shorter lifetime (e.g., Scoped)",
    "explanation": "A Captive Dependency occurs when a service intended to be short-lived is injected into a long-lived service, causing the short-lived service to live longer than designed, often leading to bugs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the specific role of the `WebApplicationBuilder` in Minimal APIs?",
    "options": [
      "It directly handles HTTP requests and responses",
      "It configures services, logging, and the host environment before building the app",
      "It replaces the need for the Kestrel web server",
      "It acts as a wrapper for legacy WebForms applications"
    ],
    "answer": "It configures services, logging, and the host environment before building the app",
    "explanation": "`WebApplicationBuilder` is the central entry point for configuring services, configuration providers, and the host (`HostBuilder`) before creating the `WebApplication` instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "How does the behavior of `IResult` in Minimal APIs improve API design compared to returning raw objects?",
    "options": [
      "It forces the client to download the response as a file",
      "It allows explicit control over the HTTP status code and response type",
      "It automatically enables gzip compression",
      "It prevents the use of JSON serialization"
    ],
    "answer": "It allows explicit control over the HTTP status code and response type",
    "explanation": "Implementations of `IResult` (like `Results.Ok` or `Results.NotFound`) encapsulate both the status code and the data, allowing for precise HTTP responses rather than relying on implicit conventions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the impact of setting the `SuppressModelStateInvalidFilter` property in `MvcOptions` or `MinimalApiOptions`?",
    "options": [
      "It disables automatic HTTP 400 responses when model validation fails",
      "It prevents the application from starting if validation attributes are missing",
      "It enables automatic database transaction rollbacks on validation errors",
      "It forces all validation to be done manually in JavaScript clients"
    ],
    "answer": "It disables automatic HTTP 400 responses when model validation fails",
    "explanation": "By default, ASP.NET Core returns a 400 Bad Request automatically when `ModelState` is invalid. Setting this option to `true` suppresses that behavior, requiring manual handling of validation errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which interface allows you to access the current `HttpContext` within a service class that is not a Controller or Minimal API delegate?",
    "options": [
      "IHttpContextFactory",
      "IHttpAccessor",
      "IHttpContextAccessor",
      "IHttpRequestFeature"
    ],
    "answer": "IHttpContextAccessor",
    "explanation": "`IHttpContextAccessor` is a service wrapper that provides access to the current `HttpContext` from components (like services) that are not directly part of the request pipeline.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In .NET Dependency Injection, what is the default behavior of the container regarding 'Keyed Services' (introduced/update in .NET 8)?",
    "options": [
      "Services are resolved solely by their interface type",
      "Services can be registered and resolved using a specific key to distinguish different implementations of the same interface",
      "Services are automatically encrypted using a key stored in configuration",
      "Keyed services replace the need for 'Scoped' lifetime management"
    ],
    "answer": "Services can be registered and resolved using a specific key to distinguish different implementations of the same interface",
    "explanation": "Keyed DI allows multiple implementations of the same interface to be registered and resolved by a specific identifier (key), resolving ambiguity when multiple services exist.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the function of the `MapControllers` method in the Program.cs file of a Minimal API project?",
    "options": [
      "It creates a new routing table for all HTTP verbs",
      "It enables attribute routing for traditional Controller-based endpoints",
      "It converts all Minimal API endpoints to Controllers",
      "It configures MVC views to be rendered as JSON"
    ],
    "answer": "It enables attribute routing for traditional Controller-based endpoints",
    "explanation": "When mixing Controllers with Minimal APIs, `MapControllers` scans assemblies for classes marked with the `[ApiController]` or `[Controller]` attributes and registers their attribute routes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the primary difference between `app.Run` and `app.Map` middleware extension methods?",
    "options": [
      "`app.Run` is terminal; `app.Map` provides branch capability",
      "`app.Run` handles GET requests; `app.Map` handles POST requests",
      "`app.Run` is async-only; `app.Map` is synchronous-only",
      "`app.Run` supports routing; `app.Map` does not support routing"
    ],
    "answer": "`app.Run` is terminal; `app.Map` provides branch capability",
    "explanation": "`Run` adds terminal middleware that executes and ends the pipeline. `Map` branches the pipeline based on a predicate (like path matching), allowing a subset of the pipeline to execute.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "How does the 'OpenAPI' (Swagger) generation differ between Minimal APIs and Controller-based APIs?",
    "options": [
      "Minimal APIs do not support Swagger generation",
      "Minimal APIs rely heavily on XML documentation comments or specific Result types for schema inference",
      "Controllers do not support XML documentation for Swagger",
      "Swagger generation is identical for both patterns"
    ],
    "answer": "Minimal APIs rely heavily on XML documentation comments or specific Result types for schema inference",
    "explanation": "Without the explicit parameter binding information found in Controller actions, Minimal APIs often utilize XML comments (`///`) and `WithOpenApi` extensions to generate accurate Swagger schemas.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which service lifetime in .NET ensures that a new instance is created for every single request, regardless of scope depth?",
    "options": [
      "Singleton",
      "Scoped",
      "Transient",
      "PerRequest"
    ],
    "answer": "Transient",
    "explanation": "Transient services are created every time they are requested from the service container, even within the same HTTP request scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the main technical advantage of using the `Microsoft.Extensions.DependencyInjection` container over manual 'newing' up objects?",
    "options": [
      "The compiler optimizes the 'new' keyword faster than DI containers",
      "It automatically manages object lifecycles and disposes resources based on defined scopes",
      "It eliminates the need for interfaces in your application",
      "It converts C# code to assembly language at runtime"
    ],
    "answer": "It automatically manages object lifecycles and disposes resources based on defined scopes",
    "explanation": "The DI container handles the creation and disposal (if `IDisposable` is implemented) of objects based on their configured scope (Transient, Scoped, Singleton), preventing memory leaks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In Minimal APIs, how do you implement a simple 'short-circuiting' middleware that prevents further processing for specific paths?",
    "options": [
      "By throwing an exception in the middleware",
      "By calling `context.Response.WriteAsync` and not calling `next()`",
      "By using the `[AllowAnonymous]` attribute",
      "By returning a 404 status from the Controller"
    ],
    "answer": "By calling `context.Response.WriteAsync` and not calling `next()`",
    "explanation": "Short-circuiting is achieved by generating a response and *not* invoking the `next()` delegate, effectively stopping the pipeline from continuing to subsequent middleware.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "When using `Host.CreateDefaultBuilder` vs `WebApplication.CreateBuilder`, what is a key architectural distinction?",
    "options": [
      "`Host` creates a Console app; `WebApplication` creates a Web API",
      "`Host` is generic for any worker process; `WebApplication` is tuned specifically for HTTP workloads",
      "`Host` is obsolete in .NET 6+",
      "`WebApplication` does not support dependency injection"
    ],
    "answer": "`Host` is generic for any worker process; `WebApplication` is tuned specifically for HTTP workloads",
    "explanation": "The Generic Host is used for background services (non-HTTP). `WebApplication.CreateBuilder` wraps the Generic Host but pre-configures it for HTTP/HTTPS and Kestrel.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the behavior of 'Forwarded Headers Middleware' (`app.UseForwardedHeaders`) in a production deployment?",
    "options": [
      "It forwards requests to a different domain automatically",
      "It updates the HTTP context scheme and IP using headers like X-Forwarded-For and X-Forwarded-Proto",
      "It acts as a load balancer",
      "It converts HTTP/2 to HTTP/1.1"
    ],
    "answer": "It updates the HTTP context scheme and IP using headers like X-Forwarded-For and X-Forwarded-Proto",
    "explanation": "When behind a proxy (Nginx",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "How does `IOptions` differ from `IOptionsSnapshot` for reading configuration in ASP.NET Core?",
    "options": [
      "`IOptions` updates automatically when configuration changes; `IOptionsSnapshot` does not",
      "`IOptionsSnapshot` captures options at the time of request; `IOptions` is a singleton registered at startup",
      "`IOptions` is asynchronous; `IOptionsSnapshot` is synchronous",
      "`IOptions` is for Controllers only; `IOptionsSnapshot` is for Middleware"
    ],
    "answer": "`IOptionsSnapshot` captures options at the time of request; `IOptions` is a singleton registered at startup",
    "explanation": "`IOptions` registers a singleton and cannot detect configuration changes after startup. `IOptionsSnapshot` is scoped and computes options once per request, allowing it to pick up dynamic changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the specific utility of the 'source generators' feature in the context of .NET Minimal APIs and DI?",
    "options": [
      "They generate SQL scripts for database migration",
      "They compile C# code into JavaScript for the frontend",
      "They generate code to reduce reflection overhead and improve startup performance",
      "They automatically create Swagger documentation files"
    ],
    "answer": "They generate code to reduce reflection overhead and improve startup performance",
    "explanation": "In modern .NET, source generators can compile code ahead of time (AOT) to reduce the runtime cost of reflection, particularly used in DI resolution and JSON serialization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which of the following accurately describes the relationship between `WebApplication` and `IEndpointRouteBuilder` in Minimal APIs?",
    "options": [
      "WebApplication implements IEndpointRouteBuilder to allow direct endpoint mapping",
      "WebApplication inherits from IEndpointRouteBuilder via a base class",
      "IEndpointRouteBuilder is used only for MVC Controllers",
      "There is no relationship; endpoints are mapped using a static helper class"
    ],
    "answer": "WebApplication implements IEndpointRouteBuilder to allow direct endpoint mapping",
    "explanation": "The `WebApplication` class implements `IEndpointRouteBuilder`, giving it methods like `MapGet`, `MapPost`, and `MapControllers` to define the routing table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the context of middleware, why is the order `app.UseHttpsRedirection` usually placed before `app.UseStaticFiles`?",
    "options": [
      "Static files cannot be served over HTTPS",
      "To ensure that requests for static files are also redirected to HTTPS before being served",
      "`UseStaticFiles` requires an encrypted connection to function",
      "To reduce the CPU load of the server"
    ],
    "answer": "To ensure that requests for static files are also redirected to HTTPS before being served",
    "explanation": "Ordering `HttpsRedirection` before `StaticFiles` ensures that if a user requests a static asset via HTTP, they are redirected to HTTPS before the static file middleware attempts to serve the content.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "How does `app.UseRouting` differ from `app.UseEndpoints` in the ASP.NET Core middleware pipeline?",
    "options": [
      "`UseRouting` matches a request to an endpoint; `UseEndpoints` executes the matched endpoint",
      "`UseRouting` executes the endpoint; `UseEndpoints` matches the request",
      "`UseRouting` is for MVC only; `UseEndpoints` is for Web API",
      "There is no functional difference; they are aliases"
    ],
    "answer": "`UseRouting` matches a request to an endpoint; `UseEndpoints` executes the matched endpoint",
    "explanation": "`UseRouting` adds route matching middleware that determines which endpoint should handle the request. `UseEndpoints` adds the execution middleware that actually runs the delegate associated with the selected endpoint.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the primary technical reason for preferring `IHttpClientFactory` over creating a new `HttpClient` instance manually?",
    "options": [
      "`HttpClient` is abstract and cannot be instantiated directly",
      "Manual creation leads to socket exhaustion due to not reusing TCP connections",
      "`IHttpClientFactory` increases the speed of HTTP requests",
      "Manual creation is deprecated in C# 10"
    ],
    "answer": "Manual creation leads to socket exhaustion due to not reusing TCP connections",
    "explanation": "Creating `HttpClient` as disposable `using` statements can exhaust sockets because the socket stays open (TIME_WAIT) after disposal. `IHttpClientFactory` manages handlers and pools connections efficiently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In .NET 8+, what is the 'IAsyncEnumerable' feature primarily used for in Minimal API responses?",
    "options": [
      "To cache the entire response in memory before sending",
      "To stream data asynchronously to the client without blocking or buffering the full dataset",
      "To serialize complex objects faster than standard JSON",
      "To convert XML results into JSON automatically"
    ],
    "answer": "To stream data asynchronously to the client without blocking or buffering the full dataset",
    "explanation": "Returning `IAsyncEnumerable` from an endpoint allows the server to send data in chunks as it becomes available, significantly reducing memory pressure for large datasets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the role of the `ConfigureAwait(false)` method when calling asynchronous code in a library?",
    "options": [
      "It forces the code to run on a background thread",
      "It prevents the capturing of the current synchronization context, improving performance and avoiding deadlocks",
      "It increases the timeout of the async operation",
      "It converts the Task to a synchronous blocking call"
    ],
    "answer": "It prevents the capturing of the current synchronization context, improving performance and avoiding deadlocks",
    "explanation": "In library code, using `ConfigureAwait(false)` tells the runtime that the continuation does not need to return to the original context (like the UI thread), reducing overhead and preventing potential deadlocks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What does the 'Developer Exception Page' middleware (`UseDeveloperExceptionPage`) do that standard error handling does not?",
    "options": [
      "Sends an email to the administrator",
      "Returns a generic 500 Internal Server Error",
      "Provides detailed stack traces, request headers, and query strings in the browser response",
      "Restarts the application automatically"
    ],
    "answer": "Provides detailed stack traces, request headers, and query strings in the browser response",
    "explanation": "This middleware provides a detailed, developer-friendly diagnostic view of the exception, which is extremely useful during development but should be disabled in production.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which feature in .NET allows you to define multiple classes implementing the same interface and resolving them using a specific key?",
    "options": [
      "Constructor Injection",
      "Named Services",
      "Keyed Services",
      "Factory Pattern"
    ],
    "answer": "Keyed Services",
    "explanation": "Keyed Services (available via `IServiceCollection`) allow registering and resolving services by a specific key, solving the issue of having multiple implementations of a single interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the behavior of a Controller action decorated with the `[ApiController]` attribute regarding model validation?",
    "options": [
      "It automatically filters out null values from JSON requests",
      "It automatically returns an HTTP 400 Bad Request if model validation fails",
      "It suppresses model validation to improve performance",
      "It requires the manual `if (!ModelState.IsValid)` check"
    ],
    "answer": "It automatically returns an HTTP 400 Bad Request if model validation fails",
    "explanation": "The `[ApiController]` attribute triggers automatic validation, preventing the action from executing if the model state is invalid and returning a standardized 400 error response.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "When using Entity Framework Core with ASP.NET Core, what is the implication of the `AddDbContext` extension method regarding the service lifetime?",
    "options": [
      "It registers the DbContext as a Transient service",
      "It registers the DbContext as a Singleton service",
      "It registers the DbContext as a Scoped service by default",
      "It registers the DbContext as a Per-Thread service"
    ],
    "answer": "It registers the DbContext as a Scoped service by default",
    "explanation": "`AddDbContext` registers the `DbContext` as Scoped. This ensures that the context is created once per HTTP request and disposed of at the end of the request, aligning with the unit-of-work pattern.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "How does the `EnableRequestRewind` or `RequestRewindMiddleware` affect the request body stream?",
    "options": [
      "It compresses the request body to save bandwidth",
      "It allows the request body stream to be read multiple times by buffering it",
      "It encrypts the request body for security",
      "It converts the request body to a Base64 string"
    ],
    "answer": "It allows the request body stream to be read multiple times by buffering it",
    "explanation": "The request body is a forward-only stream by default. This middleware buffers the body in memory, allowing it to be read multiple times (e.g., for logging or authentication validation).",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the specific function of the `IHostedService` interface in .NET?",
    "options": [
      "To handle HTTP requests to the web server",
      "To execute long-running background tasks independently of the HTTP request pipeline",
      "To manage user session state in memory",
      "To provide configuration settings to the middleware"
    ],
    "answer": "To execute long-running background tasks independently of the HTTP request pipeline",
    "explanation": "`IHostedService` allows the execution of code (e.g., message queue consumers, scheduled tasks) in the background while the application is running, separate from HTTP requests.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "In .NET Minimal APIs, how do you return a custom status code with a JSON object without using the `Results` class?",
    "options": [
      "By returning a Tuple with the integer code and the object",
      "By returning `Results.StatusCode`",
      "By returning `Results.Text`",
      "It is not possible; you must use `Results`"
    ],
    "answer": "By returning a Tuple with the integer code and the object",
    "explanation": "Minimal APIs support returning a `Tuple<int, object>` (or `(int, object)`) where the integer is interpreted as the status code and the object is serialized as the response body.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the effect of setting `ValidateScopes` to `true` in the `ServiceProviderOptions` during development?",
    "options": [
      "It ensures that no Singleton service is ever created",
      "It throws an exception if a Scoped service is resolved from a Singleton scope (Captive Dependency)",
      "It slows down the application by forcing double initialization",
      "It automatically promotes Scoped services to Singletons"
    ],
    "answer": "It throws an exception if a Scoped service is resolved from a Singleton scope (Captive Dependency)",
    "explanation": "Scope validation helps catch misconfigured dependency lifetimes (specifically captive dependencies) during development by throwing an `InvalidOperationException` when they occur.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of ASP.NET Core middleware, what is the specific behavior of the `Run` extension method compared to `Use`?",
    "options": [
      "It executes middleware asynchronously in the background without blocking the request.",
      "It defines a terminal middleware delegate that short-circuits the pipeline.",
      "It automatically enables HTTPS redirection for the current request.",
      "It bypasses the dependency injection container to improve performance."
    ],
    "answer": "It defines a terminal middleware delegate that short-circuits the pipeline.",
    "explanation": "The `Run` method registers a terminal middleware that executes logic and then terminates the pipeline by not calling the `_next` delegate, whereas `Use` chains subsequent middleware.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the primary purpose of the `IOptionsSnapshot` interface in the .NET Options pattern?",
    "options": [
      "To provide singleton access to configuration data that never changes after startup.",
      "To retrieve scoped options that are recomputed whenever the configuration file changes.",
      "To validate configuration settings using Data Annotations before the application starts.",
      "To encrypt sensitive configuration values stored in JSON files."
    ],
    "answer": "To retrieve scoped options that are recomputed whenever the configuration file changes.",
    "explanation": "`IOptionsSnapshot` is a scoped service that captures options at the time of the request, enabling the ability to reload configuration data while the application is running.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "When implementing a `long-running task` hosted service in ASP.NET Core, which method override should contain the heavy lifting logic to prevent blocking the `StartAsync` execution?",
    "options": [
      "ExecuteAsync",
      "StartAsync",
      "StopAsync",
      "RunAsync"
    ],
    "answer": "ExecuteAsync",
    "explanation": "The `ExecuteAsync` method is designed to run the long-running logic. `StartAsync` should return quickly, allowing the host to start other services, whereas blocking `StartAsync` delays application startup.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In Entity Framework Core, what specific problem does the `.AsNoTracking()` extension method solve?",
    "options": [
      "It disables lazy loading to prevent the N+1 query problem.",
      "It prevents the query from being cached in the memory database.",
      "It bypasses the change tracker to improve read-only query performance.",
      "It stops the database context from disposing of the connection."
    ],
    "answer": "It bypasses the change tracker to improve read-only query performance.",
    "explanation": "When entities are not required to be updated, `AsNoTracking` tells EF Core not to store them in the `ChangeTracker`, significantly reducing memory usage and processing overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the behavior of a `CancellationToken` passed to an ASP.NET Core Controller action method?",
    "options": [
      "It triggers automatically when the action method throws an unhandled exception.",
      "It signals cancellation only when the application is shutting down.",
      "It propagates the client disconnect signal if the HTTP request is aborted.",
      "It defaults to a timeout of 30 seconds unless configured in `Program.cs`."
    ],
    "answer": "It propagates the client disconnect signal if the HTTP request is aborted.",
    "explanation": "ASP.NET Core binds `HttpContext.RequestAborted` to the `CancellationToken` parameter, signaling the token if the client disconnects or the request times out.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the implication of using `IAsyncEnumerable` as a return type from an ASP.NET Core Minimal API endpoint?",
    "options": [
      "The entire result set is buffered into memory before sending the response.",
      "The response is serialized and returned only when the enumeration is fully completed.",
      "Data is streamed to the client as it becomes available without full buffering.",
      "It requires the use of the `System.Web.Extensions` namespace for compatibility."
    ],
    "answer": "Data is streamed to the client as it becomes available without full buffering.",
    "explanation": "`IAsyncEnumerable` allows the server to write response data incrementally, reducing memory pressure and improving Time to First Byte (TTFB) for large datasets.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which middleware must be configured at the beginning of the ASP.NET Core pipeline to ensure that `app.UseExceptionHandler()` or `app.UseDeveloperExceptionPage()` can handle exceptions thrown in subsequent middleware?",
    "options": [
      "app.UseHttpsRedirection()",
      "app.UseStaticFiles()",
      "app.UseRouting()",
      "app.UseMiddleware<ExceptionMiddleware>()"
    ],
    "answer": "app.UseMiddleware<ExceptionMiddleware>()",
    "explanation": "While built-in exception handlers are standard, custom middleware handling exceptions must be registered early in the pipeline. Critically, `UseExceptionHandler` is typically placed first, but middleware order matters: if an exception occurs in middleware A, middleware defined *after* A cannot catch it. Only middleware defined *before* A (in the reverse execution chain) or wrapping A can handle it.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In .NET Dependency Injection, what occurs if a Scoped service is injected into a Singleton service?",
    "options": [
      "The Scoped service is automatically promoted to a Singleton lifetime.",
      "The application throws an `InvalidOperationException` at runtime if `ValidateScopes` is enabled in the Host builder.",
      "A new instance of the Scoped service is created every time the Singleton is accessed.",
      "The Scoped service behaves like a Transient service for that specific injection point."
    ],
    "answer": "The application throws an `InvalidOperationException` at runtime if `ValidateScopes` is enabled in the Host builder.",
    "explanation": "Injecting a shorter-lived service (Scoped) into a longer-lived service (Singleton) creates a captive dependency, warning that the Scoped service may not release resources correctly. This triggers a validation error in development.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the technical distinction between `Task.Run` and `Task.Factory.StartNew` regarding async state machines?",
    "options": [
      "`Task.Run` automatically unwraps the inner task created by an async delegate, while `StartNew` returns a wrapper `Task<Task>`.",
      "`Task.Run` creates a new thread, whereas `StartNew` uses the ThreadPool exclusively.",
      "`Task.Run` supports cancellation tokens implicitly, while `StartNew` does not.",
      "`Task.Run` is unsafe for UI updates, while `StartNew` marshall calls back to the UI thread."
    ],
    "answer": "`Task.Run` automatically unwraps the inner task created by an async delegate, while `StartNew` returns a wrapper `Task<Task>`.",
    "explanation": "`Task.Run` is optimized for common scenarios and handles the `Unwrap()` logic for async lambdas automatically. `StartNew` is lower-level and requires explicit handling of nested tasks.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "How does the `System.IO.Pipelines` library improve performance for high-throughput stream processing compared to traditional `Stream` APIs?",
    "options": [
      "It compresses data automatically using GZip before writing to the network.",
      "It eliminates the need for manual buffer management by separating parsing from reading/writing.",
      "It runs all I/O operations on the I/O completion ports without ThreadPool interference.",
      "It converts all stream operations into synchronous calls to reduce context switching."
    ],
    "answer": "It eliminates the need for manual buffer management by separating parsing from reading/writing.",
    "explanation": "Pipelines uses a `PipeReader` and `PipeWriter` to manage an internal buffer pool. This solves complex issues like 'back pressure' and partial reads, removing the need for developers to manually manage byte arrays and offsets.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "When using `HttpClient` in ASP.NET Core via `IHttpClientFactory`, how does the `HandlerLifetime` setting affect the underlying `HttpMessageHandler` instances?",
    "options": [
      "It determines how long the `HttpClient` object remains alive before being garbage collected.",
      "It specifies the duration that DNS changes are respected by recycling the underlying handler.",
      "It sets the timeout for the actual HTTP request made by the client.",
      "It defines the interval at which the connection pool is flushed of idle connections."
    ],
    "answer": "It specifies the duration that DNS changes are respected by recycling the underlying handler.",
    "explanation": "`HttpMessageHandler` instances are pooled to avoid socket exhaustion. The `HandlerLifetime` prevents handlers from living indefinitely, ensuring they eventually close and allow DNS updates (e.g., in container orchestration scenarios).",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In the context of .NET memory management, what differentiates the Large Object Heap (LOH) from the Generation 0/1/2 heaps?",
    "options": [
      "Objects on the LOH are always collected in Generation 0 to optimize speed.",
      "LOH objects are compressed during collection to reduce memory fragmentation.",
      "Objects larger than 85,000 bytes are allocated on the LOH and are only collected during Generation 2 garbage collection.",
      "LOH uses a reference counting mechanism instead of a tracing garbage collector."
    ],
    "answer": "Objects larger than 85,000 bytes are allocated on the LOH and are only collected during Generation 2 garbage collection.",
    "explanation": "The threshold for the LOH is approximately 85KB. These objects are treated as Generation 2 to avoid the cost of copying large memory blocks during compaction, though .NET 5+ optionally supports LOH compaction.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the specific benefit of using `Span` or `Memory` over standard arrays for high-performance parsing?",
    "options": [
      "They automatically pin the memory to the heap to prevent garbage collection.",
      "They provide type-safe access to unmanaged memory blocks without copying.",
      "They allow synchronous and asynchronous operations on the same thread.",
      "They serialize data faster than binary serialization."
    ],
    "answer": "They provide type-safe access to unmanaged memory blocks without copying.",
    "explanation": "`Span` allows slicing into memory (arrays, stack memory, pointers) with zero allocation. It avoids the performance penalty of copying data segments to new arrays for manipulation.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In the context of C# structs and memory, what is a 'ref struct'?",
    "options": [
      "A struct that is always passed by reference regardless of the method signature.",
      "A struct that can only be allocated on the stack and cannot be boxed to the heap.",
      "A struct that inherits from the `System.ValueType` reference class.",
      "A struct that serves as a pointer to a class instance."
    ],
    "answer": "A struct that can only be allocated on the stack and cannot be boxed to the heap.",
    "explanation": "`ref struct` enforces that the type cannot escape to the managed heap, preventing boxing and ensuring it cannot be used in async methods, iterators, or stored as fields in classes.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the primary role of `ConfigureAwait(false)` in a .NET library code?",
    "options": [
      "It ensures that the continuation runs on a thread pool thread rather than capturing the original SynchronizationContext.",
      "It forces the asynchronous operation to run synchronously to improve performance.",
      "It automatically handles exceptions by retrying the operation if it fails.",
      "It increases the timeout for the awaited task by 50%."
    ],
    "answer": "It ensures that the continuation runs on a thread pool thread rather than capturing the original SynchronizationContext.",
    "explanation": "In generic libraries, there is usually no need to resume on the UI thread or request context. Using `ConfigureAwait(false)` reduces overhead and prevents potential deadlocks in legacy ASP.NET (less relevant in Core but good practice).",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How does the Kestrel web server handle HTTPS `SNI` (Server Name Indication) in .NET 6+?",
    "options": [
      "It requires a reverse proxy like Nginx to terminate SSL.",
      "It allows binding multiple certificates to the same IP address based on the host header via `HttpsConnectionAdapterOptions`.",
      "It automatically generates self-signed certificates for all incoming hostnames.",
      "It routes all HTTPS traffic to the default certificate regardless of the domain."
    ],
    "answer": "It allows binding multiple certificates to the same IP address based on the host header via `HttpsConnectionAdapterOptions`.",
    "explanation": "Kestrel supports SNI, enabling a single server endpoint to host multiple HTTPS domains with distinct certificates by inspecting the `SslServerAuthenticationOptions` during the handshake.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In Minimal APIs, what is the functional purpose of `Results.Ok()` versus `TypedResults.Ok()`?",
    "options": [
      "`Results.Ok()` returns a string, while `TypedResults.Ok()` returns a JSON object.",
      "`TypedResults.Ok()` provides strongly typed metadata for OpenAPI/Swagger generation.",
      "`Results.Ok()` is synchronous, while `TypedResults.Ok()` is asynchronous.",
      "`TypedResults.Ok()` automatically validates the response model using Data Annotations."
    ],
    "answer": "`TypedResults.Ok()` provides strongly typed metadata for OpenAPI/Swagger generation.",
    "explanation": "`Results` wrappers use `IResult` which obscures the type. `TypedResults` return specific types that preserve the response type information, allowing Swashbuckle to accurately document the API schema.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the function of `UseWhen` in the ASP.NET Core middleware pipeline?",
    "options": [
      "It executes the middleware branch only when the request is an HTTP GET or POST.",
      "It conditionally branches the middleware pipeline based on a boolean predicate for the HttpContext.",
      "It creates a separate pipeline that runs in parallel to the main pipeline.",
      "It retries the middleware execution if the predicate returns false."
    ],
    "answer": "It conditionally branches the middleware pipeline based on a boolean predicate for the HttpContext.",
    "explanation": "`UseWhen` creates a branch in the pipeline; if the predicate returns true, the branch middleware executes, then rejoins the main pipeline, unlike `MapWhen` which does not rejoin.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the mechanism used by `System.Threading.Channels` to communicate data between producers and consumers?",
    "options": [
      "Named pipes using Inter-Process Communication (IPC).",
      "Thread-safe bounded or unbounded queues optimized for async/await.",
      "UDP broadcasting across localhost.",
      "Shared memory segments with manual mutex locking."
    ],
    "answer": "Thread-safe bounded or unbounded queues optimized for async/await.",
    "explanation": "Channels provide a producer/consumer model where the writer writes to the channel, and the reader awaits data. It handles backpressure and thread safety internally without explicit locks.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which Garbage Collection (GC) mode is best suited for server-side ASP.NET Core applications running on multi-core processors?",
    "options": [
      "Workstation GC with Concurrent GC disabled.",
      "Workstation GC with Concurrent GC enabled.",
      "Server GC with Concurrent GC enabled.",
      "Background Server GC."
    ],
    "answer": "Server GC with Concurrent GC enabled.",
    "explanation": "Server GC creates a dedicated heap and GC thread for each logical CPU, maximizing throughput. Background (Concurrent) GC minimizes pause time by running collection in parallel with managed threads.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the behavior of `ValueTask` compared to `Task` in the context of high-frequency asynchronous operations?",
    "options": [
      "`ValueTask` is always faster because it runs synchronously.",
      "`ValueTask` is a struct that avoids heap allocation when the result is already available or synchronous completion is possible.",
      "`Task` uses less memory than `ValueTask` because it is a reference type.",
      "`ValueTask` allows multiple awaits on the same instance, unlike `Task`."
    ],
    "answer": "`ValueTask` is a struct that avoids heap allocation when the result is already available or synchronous completion is possible.",
    "explanation": "For high-performance scenarios (e.g., parsing sockets), `ValueTask` reduces GC pressure by allocating on the stack when the operation completes synchronously, whereas `Task` always requires a heap allocation.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In Entity Framework Core, how does the 'Split Query' feature (`AsSplitQuery`) solve the 'Cartesian Explosion' problem?",
    "options": [
      "It executes a separate SQL query for each related collection included in the LINQ query.",
      "It splits the result set into temporary tables before joining them.",
      "It applies a `ROW_NUMBER()` window function to deduplicate rows.",
      "It disables lazy loading for all navigation properties."
    ],
    "answer": "It executes a separate SQL query for each related collection included in the LINQ query.",
    "explanation": "When querying multiple related collections (e.g., Blog -> Posts -> Comments), a single SQL JOIN produces duplicate rows (Cartesian product). `AsSplitQuery` generates one SQL query per collection, avoiding this data duplication.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which interface must be implemented to create a custom Keyed Service registration in .NET Dependency Injection (introduced in .NET 8)?",
    "options": [
      "IKeyedService",
      "IKeyedServiceProvider",
      "IServiceScopedFactory",
      "IResolverPolicy"
    ],
    "answer": "IKeyedServiceProvider",
    "explanation": "While services are registered using `AddKeyedScoped`, the mechanism to retrieve them involves the `IServiceProvider` abstraction, specifically the `IKeyedServiceProvider` interface extension methods like `GetRequiredKeyedService`.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the primary technical limitation of compiling C# code to Native AOT (Ahead-of-Time)?",
    "options": [
      "It requires the application to be rewritten in C++.",
      "It does not support all reflection features and dynamic loading.",
      "It increases the cold startup time significantly compared to JIT.",
      "It prevents the application from running on Linux environments."
    ],
    "answer": "It does not support all reflection features and dynamic loading.",
    "explanation": "Native AOT trims unused code and eliminates the JIT compiler. Consequently, features relying on runtime metadata generation or dynamic type loading (like some `MakeGenericMethod` calls or library plugins) are incompatible.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the context of `System.Text.Json`, what is the main difference between `JsonSerializer.Deserialize` and `JsonSerializer.DeserializeAsync`?",
    "options": [
      "`Deserialize` synchronously buffers the entire JSON into a string before parsing.",
      "`DeserializeAsync` uses `Stream` parsing to avoid buffering the entire payload in memory.",
      "`Deserialize` is deprecated in .NET 6 and higher.",
      "`DeserializeAsync` supports polymorphic deserialization, while `Deserialize` does not."
    ],
    "answer": "`DeserializeAsync` uses `Stream` parsing to avoid buffering the entire payload in memory.",
    "explanation": "Async deserialization reads from the stream incrementally using `Utf8JsonReader`, making it more memory-efficient for large payloads compared to synchronous methods which often require a completed buffer.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the function of `dynamic` buffers in `System.IO.Pipelines`?",
    "options": [
      "To compress the data using the DEFLATE algorithm.",
      "To automatically resize the buffer array as data is written to it.",
      "To allocate buffers on the Large Object Heap.",
      "To switch between Little Endian and Big Endian byte orders."
    ],
    "answer": "To automatically resize the buffer array as data is written to it.",
    "explanation": "The `Pipe` manages a pool of memory. If data written exceeds the current buffer size, the driver automatically advances to a new memory segment, abstracting the complexity of manual buffer growth management.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Which Middleware configuration causes a discrepancy between `User.Identity.Name` being populated versus `null`?",
    "options": [
      "Ordering `app.UseAuthentication()` after `app.UseAuthorization()`.",
      "Ordering `app.UseAuthorization()` before `app.UseAuthentication()`.",
      "Using `app.MapControllers()` before `app.UseRouting()`.",
      "Not calling `app.UseEndpoints()` in the pipeline."
    ],
    "answer": "Ordering `app.UseAuthorization()` before `app.UseAuthentication()`.",
    "explanation": "Middleware order is critical. If `UseAuthorization` runs before `UseAuthentication`, the authorization context runs before the authentication handler has set the `HttpContext.User`, resulting in a `null` identity.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What does the `SuppressFinalize` method do in the .NET Garbage Collection lifecycle?",
    "options": [
      "It permanently stops the Garbage Collector from running.",
      "It tells the GC that the object has already been cleaned up and does not need to be finalized.",
      "It moves the object from Generation 2 to Generation 0.",
      "It forces the finalizer thread to run immediately."
    ],
    "answer": "It tells the GC that the object has already been cleaned up and does not need to be finalized.",
    "explanation": "Calling `SuppressFinalize` prevents the GC from placing the object on the finalizer queue. This is typically done in `Dispose()` to save performance and allow the object to be reclaimed sooner.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "When using `yield return` in an iterator method, what specific event causes the enumerator's `Dispose` method to be called?",
    "options": [
      "Only when the GC collects the enumerator object.",
      "When the foreach loop completes normally or breaks early, or if the enumerator is manually disposed.",
      "Only if the method throwing an exception is caught by the caller.",
      "It is never called automatically; the developer must wrap the loop in a `using` statement."
    ],
    "answer": "When the foreach loop completes normally or breaks early, or if the enumerator is manually disposed.",
    "explanation": "The compiler-generated state machine implements `IDisposable`. The `foreach` construct automatically ensures `Dispose` is called to clean up resources (like closing database connections) when iteration ends.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the purpose of the `IHostedLifecycleService` interface in .NET?",
    "options": [
      "To manage the startup and shutdown of the application host itself.",
      "To provide hooks (`StartingAsync`, `StartedAsync`, `StoppingAsync`, `StoppedAsync`) that run before and after the application's main lifecycle events.",
      "To implement a watchdog process that restarts the host if it crashes.",
      "To allow the service to run in a separate Docker container."
    ],
    "answer": "To provide hooks (`StartingAsync`, `StartedAsync`, `StoppingAsync`, `StoppedAsync`) that run before and after the application's main lifecycle events.",
    "explanation": "Standard `IHostedService` only offers `StartAsync` and `StopAsync`. `IHostedLifecycleService` offers granular control to execute logic *before* other services start and *after* other services stop.",
    "difficulty": "Advanced"
  }
]