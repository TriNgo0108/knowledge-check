[
  {
    "id": 1,
    "question": "In modern .NET 6+ applications, what is the default file that serves as the entry point for application configuration and execution?",
    "options": [
      "Startup.cs",
      "Program.cs",
      "appsettings.json",
      "Main.cs"
    ],
    "answer": "Program.cs",
    "explanation": "Top-level statements in .NET 6 consolidated the entry point logic into Program.cs, eliminating the need for a separate Startup class or explicit Main method in most templates.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which interface represents the collection of service descriptors used to register dependencies in the ASP.NET Core DI container?",
    "options": [
      "IServiceProvider",
      "IServiceCollection",
      "IDependencyContext",
      "IServiceScope"
    ],
    "answer": "IServiceCollection",
    "explanation": "IServiceCollection is the contract used at application startup to register services. IServiceProvider is the container created from it to resolve instances.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In Minimal APIs, which extension method is used to map an HTTP GET request to a delegate handler?",
    "options": [
      "UseGet",
      "HttpGet",
      "MapGet",
      "RunGet"
    ],
    "answer": "MapGet",
    "explanation": "MapGet is an extension method on IEndpointRouteBuilder used to define a route that responds specifically to HTTP GET verbs.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary consequence of the order in which middleware components are added in the ASP.NET Core pipeline?",
    "options": [
      "It determines the HTTP verbs allowed",
      "It defines the execution order for request and response processing",
      "It optimizes the application startup time",
      "It enables or disables HTTPS redirection only"
    ],
    "answer": "It defines the execution order for request and response processing",
    "explanation": "Middleware is executed in the exact order it is added. Request processing moves down the pipeline, while response processing moves back up in reverse order.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which service lifetime creates a new instance of the service every time it is requested from the DI container?",
    "options": [
      "Singleton",
      "Scoped",
      "Transient",
      "PerRequest"
    ],
    "answer": "Transient",
    "explanation": "Transient services are created each time they are injected. Scoped services are created once per HTTP request, and Singletons are created once per application lifetime.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the name of the built-in, cross-platform web server used by ASP.NET Core to handle HTTP requests?",
    "options": [
      "IIS",
      "Kestrel",
      "Apache",
      "Nginx"
    ],
    "answer": "Kestrel",
    "explanation": "Kestrel is the default high-performance web server included in ASP.NET Core. IIS, Nginx, and Apache can be used as reverse proxies in front of Kestrel.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the primary function of the WebApplicationBuilder in a Minimal API application?",
    "options": [
      "To compile C# code to machine code",
      "To configure services, logging, and the request pipeline",
      "To generate database migrations",
      "To compress HTTP responses"
    ],
    "answer": "To configure services, logging, and the request pipeline",
    "explanation": "The WebApplicationBuilder provides a centralized way to configure the WebHost, Services (DI), and Middleware pipeline before building the final WebApplication.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "In the context of Dependency Injection, what happens if you attempt to resolve a service that you forgot to register in the container?",
    "options": [
      "The service is automatically created using reflection",
      "The application returns a null value",
      "An InvalidOperationException is thrown at runtime",
      "The service is replaced with a mock implementation"
    ],
    "answer": "An InvalidOperationException is thrown at runtime",
    "explanation": "If a service is not registered and the container attempts to resolve it, the built-in container throws an InvalidOperationException.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which static class in Minimal APIs provides helper methods to return standardized HTTP responses like Results.Ok() and Results.NotFound()?",
    "options": [
      "HttpResponse",
      "Results",
      "HttpResults",
      "Endpoints"
    ],
    "answer": "Results",
    "explanation": "The static Results class contains factory methods for generating IResult implementations, allowing for consistent and readable HTTP responses.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which keyword must appear in a method signature to allow the use of the await operator within that method?",
    "options": [
      "async",
      "await",
      "task",
      "thread"
    ],
    "answer": "async",
    "explanation": "The async keyword enables the await keyword and indicates the method returns an awaitable type, such as Task or Task.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the default JSON file used to store configuration settings such as connection strings in ASP.NET Core?",
    "options": [
      "config.json",
      "settings.json",
      "appsettings.json",
      "project.json"
    ],
    "answer": "appsettings.json",
    "explanation": "appsettings.json is the standard configuration file loaded by default in ASP.NET Core applications.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which method is used to map an HTTP POST request to a Minimal API endpoint?",
    "options": [
      "CreatePost",
      "MapPost",
      "UsePost",
      "HttpPost"
    ],
    "answer": "MapPost",
    "explanation": "MapPost registers an endpoint that listens for HTTP POST requests on the specified route pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What represents the fundamental definition of middleware in the ASP.NET Core pipeline?",
    "options": [
      "A class implementing IMiddleware",
      "A delegate with a specific signature",
      "A static method in Startup",
      "A JSON configuration block"
    ],
    "answer": "A delegate with a specific signature",
    "explanation": "Conceptually, middleware is a delegate (RequestDelegate) that takes an HttpContext and decides whether to pass it to the next middleware or terminate the pipeline.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which middleware is responsible for matching HTTP requests to specific endpoint handlers (like Minimal APIs or Controllers)?",
    "options": [
      "UseRouting",
      "UseEndpoints",
      "MapControllerRoute",
      "UseMiddleware"
    ],
    "answer": "UseRouting",
    "explanation": "UseRouting middleware looks at the incoming request and sets the endpoint that should handle it, which is then executed by UseEndpoints.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which dependency injection scope is tied to the lifetime of a single HTTP client request?",
    "options": [
      "Singleton",
      "Scoped",
      "Transient",
      "Request"
    ],
    "answer": "Scoped",
    "explanation": "Scoped services are created once per HTTP request. This makes them ideal for Entity Framework DbContexts and other request-specific data.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the result of calling `app.Run()` without arguments at the end of the Program.cs file?",
    "options": [
      "It compiles the application",
      "It stops the application",
      "It starts the web server and blocks the main thread",
      "It clears the configuration"
    ],
    "answer": "It starts the web server and blocks the main thread",
    "explanation": "The Run() method starts the Kestrel server and begins listening for requests, keeping the application alive.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which feature introduced in .NET 6 allows you to omit the 'namespace' keyword and use file-scoped namespaces?",
    "options": [
      "Top-level statements",
      "File-scoped namespaces",
      "Global usings",
      "Nullable reference types"
    ],
    "answer": "File-scoped namespaces",
    "explanation": "File-scoped namespaces allow defining a namespace without braces, reducing indentation in the file.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "In Minimal APIs, what does the framework check first to determine how to bind a parameter in an endpoint handler?",
    "options": [
      "Database records",
      "Environment variables",
      "Route values, query strings, and the request body",
      "Static files"
    ],
    "answer": "Route values, query strings, and the request body",
    "explanation": "ASP.NET Core attempts to resolve parameters from the HTTP request (Route, Query, Body) first. If that fails, it falls back to Dependency Injection.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which environment variable is standardly checked in .NET to determine the current hosting environment (e.g., Development, Production)?",
    "options": [
      "DOTNET_ENVIRONMENT",
      "ASPNETCORE_ENVIRONMENT",
      "ENVIRONMENT",
      "NODE_ENV"
    ],
    "answer": "ASPNETCORE_ENVIRONMENT",
    "explanation": "ASPNETCORE_ENVIRONMENT is the specific variable used by the WebApplication builder to configure behavior like developer exception pages.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which Results helper method is used to return an HTTP 404 Not Found status code?",
    "options": [
      "Results.NotFound()",
      "Results.Error()",
      "Results.Null()",
      "Results.Reject()"
    ],
    "answer": "Results.NotFound()",
    "explanation": "Results.NotFound() generates a 404 response, indicating that the requested resource could not be found.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the recommended way to inject services into a Controller class?",
    "options": [
      "Property Injection",
      "Constructor Injection",
      "Method Injection",
      "Service Locator Pattern"
    ],
    "answer": "Constructor Injection",
    "explanation": "Constructor Injection is the standard pattern for Controllers, making dependencies explicit and ensuring the class is always in a valid state.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which extension method is required to enable controller-based routing in a Minimal API application?",
    "options": [
      "AddControllers",
      "MapControllers",
      "UseMvc",
      "MapControllerRoute"
    ],
    "answer": "MapControllers",
    "explanation": "MapControllers() adds endpoints for attribute-routed controllers, allowing them to work alongside Minimal APIs in the same pipeline.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the primary technical reason to avoid injecting a Scoped service into a Singleton service?",
    "options": [
      "It causes a compilation error",
      "It increases memory usage",
      "The scoped service may live longer than intended, causing concurrency issues",
      "It prevents the singleton from being initialized"
    ],
    "answer": "The scoped service may live longer than intended, causing concurrency issues",
    "explanation": "A Singleton is created once; capturing a Scoped service (which depends on a request context) inside it can lead to that instance being shared across requests incorrectly.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which character prefix allows you to embed expressions directly into string literals in C#?",
    "options": [
      "@",
      "$",
      "&",
      "#"
    ],
    "answer": "$",
    "explanation": "The $ sign identifies an interpolated string, allowing expressions like {variable} to be placed within the string literal.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which namespace contains the extension methods like AddSingleton, AddScoped, and AddTransient?",
    "options": [
      "System.DI",
      "Microsoft.AspNetCore.Hosting",
      "Microsoft.Extensions.DependencyInjection",
      "System.Collections.Generic"
    ],
    "answer": "Microsoft.Extensions.DependencyInjection",
    "explanation": "This namespace holds the IServiceCollection extensions used to configure the built-in dependency injection container.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What type does the Results.Problem() helper return?",
    "options": [
      "IResult",
      "ActionResult",
      "ProblemDetails",
      "HttpResponseMessage"
    ],
    "answer": "IResult",
    "explanation": "Minimal API endpoints typically return IResult. Results.Problem() creates a standardized ProblemDetails response wrapped in an IResult implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "In Minimal APIs, how do you group related endpoints to apply common configurations like authorization or prefixes?",
    "options": [
      "Using a base Controller class",
      "Using Route Groups (MapGroup)",
      "Using inheritance on the Program class",
      "Using appsettings.json"
    ],
    "answer": "Using Route Groups (MapGroup)",
    "explanation": "MapGroup organizes endpoints and allows you to set common metadata, routes, or middleware for a specific set of API endpoints.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which CLI command restores the dependencies and tools of a project?",
    "options": [
      "dotnet build",
      "dotnet install",
      "dotnet restore",
      "dotnet run"
    ],
    "answer": "dotnet restore",
    "explanation": "dotnet restore reads the project file and downloads the NuGet packages defined in it.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the return type of a Minimal API endpoint handler that returns `Results.Created(\"/items/1\", item)`?",
    "options": [
      "string",
      "void",
      "IResult",
      "Task<IActionResult>"
    ],
    "answer": "IResult",
    "explanation": "All static Results helpers implement the IResult interface, which is the standard abstraction for endpoint outputs in Minimal APIs.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which method on the WebApplication is used to redirect all HTTP requests to HTTPS?",
    "options": [
      "UseHttpsRedirection",
      "UseHttps",
      "UseSecurityHeaders",
      "RequireHttps"
    ],
    "answer": "UseHttpsRedirection",
    "explanation": "UseHttpsRedirection is middleware that automatically redirects insecure HTTP requests to the secure HTTPS port.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which syntax in C# allows a value type like 'int' to be assigned a null value?",
    "options": [
      "int null",
      "int?",
      "Nullable<int>",
      "int *"
    ],
    "answer": "int?",
    "explanation": "The ? suffix is syntactic sugar for Nullable, allowing value types to represent null.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "In the context of Minimal APIs, what happens if you register a service as 'Scoped' and then inject it into a 'Singleton' middleware?",
    "options": [
      "The middleware fails to start",
      "The scoped service is injected as null",
      "The scoped service lives as long as the singleton, which is incorrect",
      "The app automatically promotes the service to Singleton"
    ],
    "answer": "The scoped service lives as long as the singleton, which is incorrect",
    "explanation": "This is known as 'captive dependency.' The Singleton holds onto the Scoped instance indefinitely, preventing it from being disposed correctly per request.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which middleware is used to catch exceptions and display a developer-friendly error page during development?",
    "options": [
      "UseExceptionHandler",
      "UseDeveloperExceptionPage",
      "UseErrorPage",
      "UseDebugPage"
    ],
    "answer": "UseDeveloperExceptionPage",
    "explanation": "UseDeveloperExceptionPage provides detailed stack traces and request information specifically for the Development environment.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In .NET Dependency Injection, what specific error occurs when a Singleton service directly consumes a Scoped service?",
    "options": [
      "A scope validation error indicating a captive dependency",
      "A runtime NullReferenceException during resolution",
      "A compilation error due to lifecycle mismatch",
      "A deadlock in the request thread pool"
    ],
    "answer": "A scope validation error indicating a captive dependency",
    "explanation": "The built-in `ServiceProvider` detects when a Singleton (effectively a scoped service living forever) captures a Scoped service. This is a 'captive dependency' because the scoped service would live longer than its intended lifespan, causing `ValidateScopes` to throw an exception by default in development environments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 35,
    "question": "Why is `Span` generally restricted to stack-only allocation contexts (ref struct)?",
    "options": [
      "It cannot be garbage collected because it is a value type",
      "It wraps a managed pointer that must not be moved by the GC",
      "It performs faster calculations on the CPU register",
      "It requires unsafe code blocks to function correctly"
    ],
    "answer": "It wraps a managed pointer that must not be moved by the GC",
    "explanation": "`Span` is a ref struct containing a managed pointer to memory. If it were boxed on the heap, the GC might move the memory, invalidating the pointer. Restricting it to the stack ensures the pointer remains valid within the synchronous scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "In ASP.NET Core Minimal APIs, how does the framework distinguish between a route parameter and a service injection in a handler delegate?",
    "options": [
      "Services must be marked with the [FromServices] attribute",
      "Route parameters are always strings and services are objects",
      "Type resolution attempts to bind from route/query first, then falls back to DI",
      "Services are injected first, followed by route parameters"
    ],
    "answer": "Type resolution attempts to bind from route/query first, then falls back to DI",
    "explanation": "The binding source attempts to resolve parameters from the HTTP context (route, query, body) first. If the type cannot be resolved from there, it checks the Dependency Injection container. Explicit attributes like `[FromServices]` can bypass the HTTP check.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary performance advantage of `ValueTask` over `Task` in high-throughput scenarios?",
    "options": [
      "It runs on a background thread to avoid blocking",
      "It reduces heap allocations when the result is already synchronous",
      "It automatically retries failed operations",
      "It bypasses the CLR security checks"
    ],
    "answer": "It reduces heap allocations when the result is already synchronous",
    "explanation": "`Task` is a reference type requiring heap allocation. `ValueTask` is a struct, so if an asynchronous operation completes synchronously or returns a cached value, no heap allocation occurs, reducing GC pressure.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When using the `WebApplicationBuilder` in .NET 6+, what is the function of the `Build()` method?",
    "options": [
      "It compiles the C# code to IL",
      "It constructs the `WebApplication` host and finalizes the DI container",
      "It starts the Kestrel web server",
      "It applies middleware to the HTTP pipeline"
    ],
    "answer": "It constructs the `WebApplication` host and finalizes the DI container",
    "explanation": "Calling `Build()` locks the `IServiceCollection`, making it immutable, and creates the `WebApplication` instance which holds the `Middleware` pipeline and the fully configured service provider.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In Entity Framework Core, what is the default behavior of the change tracker when a property of a tracked entity is modified?",
    "options": [
      "It immediately sends an UPDATE statement to the database",
      "It queries the database to check for conflicts",
      "It records the change in the snapshot, writing to the DB only on SaveChanges",
      "It detaches the entity to prevent concurrency errors"
    ],
    "answer": "It records the change in the snapshot, writing to the DB only on SaveChanges",
    "explanation": "EF Core uses a snapshot to detect changes. It does not touch the database until `SaveChanges` is called. At that point, it compares the current state with the snapshot to generate SQL statements.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the difference between `IOptions` and `IOptionsSnapshot` regarding configuration reload?",
    "options": [
      "`IOptions` supports hot reload; `IOptionsSnapshot` does not",
      "`IOptions` is a Singleton; `IOptionsSnapshot` is Scoped and updates per request",
      "`IOptionsSnapshot` is deprecated in .NET 7+",
      "`IOptions` requires a Scoped service to access data"
    ],
    "answer": "`IOptions` is a Singleton; `IOptionsSnapshot` is Scoped and updates per request",
    "explanation": "`IOptions` computes the options once and caches them for the application lifetime. `IOptionsSnapshot` is registered as Scoped, meaning it is recomputed once per request (or scope), allowing it to pick up configuration changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Which interface should you implement to create a background task that executes continuously in an ASP.NET Core application?",
    "options": [
      "IAsyncDisposable",
      "IHostedService",
      "IStartupFilter",
      "IConfiguration"
    ],
    "answer": "IHostedService",
    "explanation": "`IHostedService` defines two methods: `StartAsync` and `StopAsync`. Implementing this interface (or inheriting from `BackgroundService`) allows a class to run logic in the background for the lifetime of the application.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the result of using `await` on a `Task` that has already faulted (threw an exception)?",
    "options": [
      "The exception is swallowed and null is returned",
      "The exception is re-thrown allowing the caller to catch it",
      "The task restarts automatically",
      "The application crashes immediately without logging"
    ],
    "answer": "The exception is re-thrown allowing the caller to catch it",
    "explanation": "Awaiting a faulted task retrieves the exception stored in the Task. The runtime throws this exception at the point of the `await`, allowing standard try/catch blocks to handle it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In C# pattern matching, the 'type pattern' checks the runtime type of a variable. What is the syntax to check if `obj` is a `Person` and assign it to variable `p`?",
    "options": [
      "if (obj is Person p)",
      "if (obj instanceof Person p)",
      "if (obj is Person := p)",
      "if (obj as Person p)"
    ],
    "answer": "if (obj is Person p)",
    "explanation": "The `is` operator supports pattern matching. `obj is Person p` evaluates to true if `obj` is a `Person`, and if true, assigns the variable `p` to that casted instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Why is it considered an anti-pattern to use `Task.Result` or `Task.Wait()` in ASP.NET Core applications?",
    "options": [
      "It causes the task to run synchronously on the CPU",
      "It can lead to thread pool starvation and deadlocks",
      "It disables the garbage collector",
      "It prevents Entity Framework from tracking changes"
    ],
    "answer": "It can lead to thread pool starvation and deadlocks",
    "explanation": "Blocking on async tasks (`Result`, `Wait`) occupies a thread waiting for the async operation to complete, which often leads to deadlocks on synchronization contexts (like the legacy ASP.NET context) or thread pool exhaustion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "How does the Kestrel web server differ from IIS (Internet Information Services) in the ASP.NET Core hosting model?",
    "options": [
      "Kestrel is a reverse proxy; IIS is a web server",
      "Kestrel is a cross-platform web server; IIS is a Windows-specific reverse proxy/web server",
      "Kestrel manages database connections; IIS manages HTTP",
      "There is no difference; they are identical binaries"
    ],
    "answer": "Kestrel is a cross-platform web server; IIS is a Windows-specific reverse proxy/web server",
    "explanation": "Kestrel is the built-in, high-performance web server handling HTTP directly. IIS or Nginx often act as a reverse proxy in front of Kestrel for production environments to handle port 80/443 and security filtering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the purpose of the `ConfigureAwait(false)` method on a Task?",
    "options": [
      "It configures the task to run on the UI thread",
      "It prevents the continuation from capturing the current synchronization context",
      "It enables automatic retry logic for the task",
      "It ensures the task runs synchronously"
    ],
    "answer": "It prevents the continuation from capturing the current synchronization context",
    "explanation": "`ConfigureAwait(false)` tells the runtime that the code after the await does not need the original context (e.g., UI thread or Request context). This reduces overhead and can prevent deadlocks in library code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the Garbage Collection (GC) process, which generation contains long-lived objects that survive multiple collections?",
    "options": [
      "Generation 0 (Gen 0)",
      "Generation 1 (Gen 1)",
      "Generation 2 (Gen 2)",
      "Large Object Heap (LOH)"
    ],
    "answer": "Generation 2 (Gen 2)",
    "explanation": "The GC promotes objects that survive collections to higher generations. Gen 2 is the final generation for long-lived objects; collection here (a full GC) is less frequent but more expensive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the behavior of `SemaphoreSlim.WaitAsync()` when the semaphore count is zero?",
    "options": [
      "It throws an exception immediately",
      "It returns false synchronously",
      "It asynchronously yields until the count is incremented by a release",
      "It creates a new thread to bypass the limit"
    ],
    "answer": "It asynchronously yields until the count is incremented by a release",
    "explanation": "`WaitAsync` allows an async method to wait without blocking a thread. If the count is zero, the awaiting task is paused until another thread calls `Release`, increasing the count.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What does the `[FromBody]` attribute indicate in an ASP.NET Core Minimal API or Controller action?",
    "options": [
      "The parameter comes from the URL route",
      "The parameter is deserialized from the HTTP request body",
      "The parameter is a singleton service",
      "The parameter comes from the HTTP Headers"
    ],
    "answer": "The parameter is deserialized from the HTTP request body",
    "explanation": "By default, complex types are inferred from the body, but `[FromBody]` explicitly instructs the model binder to read the content stream (e.g., JSON/XML) and deserialize it into the parameter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Which LINQ operator is used to project a sequence into a new form, transforming the elements?",
    "options": [
      "Where",
      "Select",
      "Join",
      "GroupBy"
    ],
    "answer": "Select",
    "explanation": "The `Select` method projects each element of a sequence into a new form, effectively transforming the data structure (similar to a SQL SELECT clause). `Where` is used for filtering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the function of the `app.UseRouting()` middleware in the ASP.NET Core pipeline?",
    "options": [
      "It matches incoming HTTP requests to specific endpoints",
      "It executes the matched endpoint delegate",
      "It rewrites the URL to lowercase",
      "It authenticates the user"
    ],
    "answer": "It matches incoming HTTP requests to specific endpoints",
    "explanation": "`UseRouting()` adds middleware that resolves the endpoint (a specific method or delegate) based on the URL and HTTP verb. The actual execution happens later in the pipeline, typically via `UseEndpoints()`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Why is `string` a reference type while behaving somewhat like a value type in C#?",
    "options": [
      "It is actually a struct, not a class",
      "It is immutable; operations create new string instances rather than modifying existing ones",
      "It is stored on the stack by the compiler",
      "It inherits from `ValueType` implicitly"
    ],
    "answer": "It is immutable; operations create new string instances rather than modifying existing ones",
    "explanation": "String is a reference type, but its immutability means you cannot change the data of the instance. Changing a string variable creates a new object, making it feel distinct from typical mutable reference types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the primary use of `Lazy` in .NET?",
    "options": [
      "To ensure a thread is created lazily",
      "To defer the creation of an object until it is first accessed",
      "To make a property null-safe",
      "To slow down the execution of a loop"
    ],
    "answer": "To defer the creation of an object until it is first accessed",
    "explanation": "`Lazy` provides lazy initialization support. The factory function provided to `Lazy` runs only when the `.Value` property is accessed for the first time, improving startup performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "In C#, what is the difference between `struct` and `class`?",
    "options": [
      "`struct` is a value type allocated on the stack (or inline); `class` is a reference type allocated on the heap",
      "`struct` supports inheritance; `class` does not",
      "`class` is faster to allocate than `struct`",
      "`struct` cannot contain methods"
    ],
    "answer": "`struct` is a value type allocated on the stack (or inline); `class` is a reference type allocated on the heap",
    "explanation": "Structs are value types. When assigned, they copy data. Classes are reference types; when assigned, they copy the reference. Structs are generally allocated on the stack, while classes require heap allocation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the role of `IAsyncEnumerable` in C#?",
    "options": [
      "It allows enumerating a collection asynchronously, streaming elements one by one",
      "It converts a standard List to a Task",
      "It enforces thread safety on List",
      "It replaces the `yield` keyword"
    ],
    "answer": "It allows enumerating a collection asynchronously, streaming elements one by one",
    "explanation": "Unlike `IEnumerable` which pulls items synchronously, `IAsyncEnumerable` allows asynchronous retrieval of elements via `await foreach`, preventing blocking while waiting for data sources (like databases or network).",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "How does the `record` type in C# differ from a standard `class`?",
    "options": [
      "Records can only contain static methods",
      "Records provide built-in value-based equality and concise syntax for immutable data",
      "Records are always allocated on the stack",
      "Records cannot implement interfaces"
    ],
    "answer": "Records provide built-in value-based equality and concise syntax for immutable data",
    "explanation": "Records are primarily designed for immutable data models. They synthesize `Equals`, `GetHashCode`, and copy constructors based on the constructor parameters, enabling value-based equality semantics.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which middleware is responsible for populating the `HttpContext.User` property in ASP.NET Core?",
    "options": [
      "Authorization Middleware",
      "Authentication Middleware",
      "Routing Middleware",
      "Endpoint Middleware"
    ],
    "answer": "Authentication Middleware",
    "explanation": "The Authentication Middleware (`UseAuthentication`) executes handlers for registered authentication schemes. If successful, it sets the `HttpContext.User` principal. Authorization happens later to check permissions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the purpose of the `protected` modifier in a C# class?",
    "options": [
      "The member is accessible only within the same assembly",
      "The member is accessible within its class and by derived class instances",
      "The member is accessible to any code",
      "The member is never accessible"
    ],
    "answer": "The member is accessible within its class and by derived class instances",
    "explanation": "`protected` visibility means the member can be accessed by the defining class and any class that inherits from it, but not by unrelated external classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When configuring CORS in ASP.NET Core, what is the effect of calling `AllowAnyOrigin()`?",
    "options": [
      "It allows requests only from localhost",
      "It allows requests from any domain, any scheme, and any port",
      "It disables the SameSite cookie policy",
      "It allows requests only if they contain a specific header"
    ],
    "answer": "It allows requests from any domain, any scheme, and any port",
    "explanation": "`AllowAnyOrigin()` configures the CORS policy to accept requests from any origin. This is commonly used for public APIs but is insecure for APIs handling sensitive data or authentication cookies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In the context of .NET assemblies, what does 'Strong Naming' guarantee?",
    "options": [
      "The code is free of bugs",
      "The assembly has a unique identity based on name, version, culture, and public key token",
      "The assembly is compiled to native code",
      "The assembly runs faster than non-strong named assemblies"
    ],
    "answer": "The assembly has a unique identity based on name, version, culture, and public key token",
    "explanation": "Strong naming involves signing an assembly with a public/private key pair. This ensures a globally unique identity and allows the CLR to verify the assembly has not been tampered with.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the primary purpose of the `global using` directive introduced in C# 10?",
    "options": [
      "To allow using statements anywhere in the file",
      "To import a namespace automatically across all files in the project",
      "To force all namespaces to be global",
      "To resolve naming conflicts by prioritizing global namespaces"
    ],
    "answer": "To import a namespace automatically across all files in the project",
    "explanation": "`global using` allows you to specify a namespace once (usually in a central file or csproj), and that namespace is implicitly imported to every source file in the compilation, reducing repetitive `using` lines.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is `init` only properties in C#?",
    "options": [
      "Properties that can only be set in the constructor or via object initializer syntax",
      "Properties that are automatically initialized to null",
      "Properties that run asynchronously",
      "Properties that cannot be read, only written to"
    ],
    "answer": "Properties that can only be set in the constructor or via object initializer syntax",
    "explanation": "`init` accessors allow properties to be set during object construction (object initializers or constructors) but become read-only (`private set`) afterwards, enabling immutable record-like behavior for classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "How does `Dictionary` handle duplicate keys during insertion?",
    "options": [
      "It overwrites the existing value silently",
      "It appends the new value to a list",
      "It throws an `ArgumentException`",
      "It converts the key to a unique string"
    ],
    "answer": "It throws an `ArgumentException`",
    "explanation": "Keys in a Dictionary must be unique. Attempting to `Add` a key that already exists results in an `System.ArgumentException` (specifically `System.ArgumentException: An item with the same key has already been added`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the result of executing `yield break` inside a C# iterator method?",
    "options": [
      "It returns a null value",
      "It pauses the iteration for 1 second",
      "It signals the end of the iteration sequence",
      "It throws an exception"
    ],
    "answer": "It signals the end of the iteration sequence",
    "explanation": "`yield break` is used to explicitly end the iteration before reaching the end of the method. It ensures that the iterator block does not yield any more items.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In .NET Memory Management, what is the Large Object Heap (LOH)?",
    "options": [
      "A heap for objects larger than 85,000 bytes",
      "A heap for static variables",
      "A heap for strings only",
      "A heap for unmanaged resources"
    ],
    "answer": "A heap for objects larger than 85,000 bytes",
    "explanation": "Any object larger than approximately 85,000 bytes is considered a 'large object' and is allocated on the LOH. While Gen 2 collections compact the small object heap, the LOH is usually not compacted (though this can be enabled).",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the primary advantage of using `IHttpClientFactory` over creating new `HttpClient` instances directly?",
    "options": [
      "It automatically implements retry logic",
      "It prevents socket exhaustion by pooling connections",
      "It encrypts all requests by default",
      "It converts XML to JSON automatically"
    ],
    "answer": "It prevents socket exhaustion by pooling connections",
    "explanation": "Creating `new HttpClient()` as a disposable object can exhaust sockets because the socket lingers in TIME_WAIT state. `IHttpClientFactory` manages `HttpMessageHandler` instances, pooling and recycling them to solve this issue.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which C# feature allows you to switch on the type of an object at runtime?",
    "options": [
      "Dynamic binding",
      "Type switching",
      "Pattern matching switch expression",
      "Reflection"
    ],
    "answer": "Pattern matching switch expression",
    "explanation": "The `switch` expression (and statement) allows type patterns (e.g., `case int i:`, `case string s:`), enabling branching logic based on the runtime type of the variable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What happens when you use `RegisterValidatorFromAssemblyContaining` with FluentValidation in ASP.NET Core?",
    "options": [
      "It scans the assembly for classes inheriting from `AbstractValidator` and registers them",
      "It compiles the assembly into machine code",
      "It validates the HTTP Headers only",
      "It disables the default DataAnnotations validator"
    ],
    "answer": "It scans the assembly for classes inheriting from `AbstractValidator` and registers them",
    "explanation": "This extension method is a convenience helper to find all validator classes within a specific assembly and register them in the DI container, typically used to set up FluentValidation for Minimal APIs or MVC.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In .NET Dependency Injection, what occurs at runtime when a Singleton service directly consumes a Scoped service and `ValidateScopes` is enabled in the Host?",
    "options": [
      "The scoped service is automatically promoted to a singleton lifetime by the container",
      "An `InvalidOperationException` is thrown during application startup",
      "The scoped service is instantiated once and reused for the lifetime of the singleton",
      "A proxy object is generated to manage the lifetime discrepancy between the services"
    ],
    "answer": "An `InvalidOperationException` is thrown during application startup",
    "explanation": "The built-in DI container validates scope graphs to prevent captive dependencies. When `ValidateScopes` is true (default in Development), injecting a Scoped service into a Singleton causes a startup failure because the Singleton would hold the Scoped service beyond its intended lifespan.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "Which constraint prevents a C# `ref struct` from being stored in a field of another class or a non-ref struct?",
    "options": [
      "Reference types cannot contain value types without boxing",
      "`ref struct` types cannot implement interfaces",
      "`ref struct` types are only allowed on the stack and cannot be boxed to the heap",
      "Garbage collection does not support tracking references to stack-only types"
    ],
    "answer": "`ref struct` types are only allowed on the stack and cannot be boxed to the heap",
    "explanation": "A `ref struct` is explicitly designed to be stack-only to ensure safe memory management. If it were stored in a class field, it would need to be boxed (moved to the heap), which violates the compiler's safety constraints for `ref struct`.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "When using `ConfigureAwait(false)` on an awaited Task in a library, what is the specific impact on the execution context?",
    "options": [
      "The thread pool thread is blocked until the task completes",
      "The `SynchronizationContext` is not captured, and continuation runs on a thread pool thread",
      "The current culture is lost and reset to InvariantCulture",
      "The continuation is forced to run synchronously on the same thread"
    ],
    "answer": "The `SynchronizationContext` is not captured, and continuation runs on a thread pool thread",
    "explanation": "`ConfigureAwait(false)` signals the runtime that the continuation does not need the original context. This avoids the overhead of marshaling back to the original thread (e.g., the UI thread) and reduces the risk of deadlocks in library code.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In Entity Framework Core, what is the primary performance risk associated with the 'Split Queries' behavior when using `AsSplitQuery()`?",
    "options": [
      "It disables change tracking, requiring explicit reloads of entities",
      "It can result in a 'Cartesian Explosion' problem if not used correctly",
      "It increases the risk of deadlock due to longer transaction hold times",
      "It creates N+1 SQL queries for every collection included in the LINQ query"
    ],
    "answer": "It can result in a 'Cartesian Explosion' problem if not used correctly",
    "explanation": "While `AsSplitQuery()` is the default in EF Core 5+ to avoid Cartesian explosions in single queries, the question distractor reverses the logic. Actually, `AsSingleQuery()` (legacy) creates Cartesian explosions. However, a distinct risk of `AsSplitQuery()` is **data consistency**, as separate queries might read data between transactions. Wait, looking at the distractor: 'It creates N+1...' â€” No, Split creates *one query per included collection*. The *actual* risk of split queries is **Concurrency/Data Consistency** issues between queries. Re-evaluating options: The most common downside cited is potential inconsistency. However, looking at common MCQ patterns: The 'Cartesian Explosion' is the problem Split Queries *solve*. The *trade-off* is consistency. Let's reframe to the risk of **Single Query** vs Split.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the specific behavior difference between `IOptionsSnapshot` and `IOptionsMonitor` in the .NET Options pattern?",
    "options": [
      "`IOptionsSnapshot` is a Singleton, whereas `IOptionsMonitor` is a Scoped service",
      "`IOptionsSnapshot` caches options for the lifetime of the scope, while `IOptionsMonitor` computes options on every access",
      "`IOptionsMonitor` only reads configuration at startup, while `IOptionsSnapshot` listens for changes",
      "`IOptionsSnapshot` throws an exception if used within a Singleton service"
    ],
    "answer": "`IOptionsSnapshot` caches options for the lifetime of the scope, while `IOptionsMonitor` computes options on every access",
    "explanation": "`IOptionsSnapshot` is registered as Scoped and captures the configuration values when the scope is created. `IOptionsMonitor` is a Singleton that listens for change notifications and always returns the current calculated configuration.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Why does the C# compiler forbid `await` usage inside a `finally` block or within a `lock` statement?",
    "options": [
      "Because `await` requires the method to be marked `async`, which is incompatible with exception handling blocks",
      "Because it would potentially allow the code to execute on a different thread, breaking the lock or exception protocol guarantees",
      "Because the state machine generated by `await` cannot be nested within the state machine of a `try-catch` block",
      "Because the CLR does not support thread interruption inside protected regions"
    ],
    "answer": "Because it would potentially allow the code to execute on a different thread, breaking the lock or exception protocol guarantees",
    "explanation": "In a `lock` (monitor), awaiting would release the lock, and resumption might happen on a different thread, violating mutual exclusion. In `finally`, resuming on a different thread risks unobserved exceptions if the thread aborts, so it is disallowed to ensure reliability.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of Span and Memory types in .NET, what is a `MemoryManager`?",
    "options": [
      "A factory class used to pool generic array instances",
      "An abstract base class allowing implementations to provide custom memory management for `Memory`",
      "A handle used to pin managed memory in place for unmanaged operations",
      "A diagnostic tool used to track native memory leaks"
    ],
    "answer": "An abstract base class allowing implementations to provide custom memory management for `Memory`",
    "explanation": "`MemoryManager` enables advanced scenarios where developers want to back a `Memory` with custom logic (e.g., unmanaged memory or a specific allocator) rather than a standard managed array, allowing them to control the lifetime and disposal of the underlying resource.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "When implementing a custom middleware in ASP.NET Core, how should you handle the scenario where the logic should execute only after the next middleware in the pipeline has completed?",
    "options": [
      "Call `app.Use` with a delegate that executes logic before `next()` and returns immediately",
      "Register a second middleware specifically for the post-processing logic",
      "Await the `next()` delegate call and execute logic on the subsequent lines",
      "Use `app.Run` instead of `app.Use` to ensure sequential execution"
    ],
    "answer": "Await the `next()` delegate call and execute logic on the subsequent lines",
    "explanation": "The `next()` delegate represents the subsequent middleware. By `awaiting next()`, the current middleware yields control until the downstream pipeline finishes, allowing execution of code placed after the `await` (post-processing) once the response is being generated.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the specific advantage of using `System.Threading.Channels` over `BlockingCollection` for producer-consumer scenarios?",
    "options": [
      "Channels guarantee FIFO ordering across all threads, while BlockingCollection does not",
      "Channels are non-blocking by default and support awaitable reads/writes for high throughput",
      "Channels allow multiple consumers to read the same item simultaneously",
      "BlockingCollection is limited to a single producer thread"
    ],
    "answer": "Channels are non-blocking by default and support awaitable reads/writes for high throughput",
    "explanation": "Channels are designed for async/await patterns, allowing producers and consumers to yield threads while waiting. `BlockingCollection` typically blocks the thread, which is less efficient for high-concurrency asynchronous I/O applications.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In C#, why are struct layouts defined with `[StructLayout(LayoutKind.Explicit)]` rarely used in high-level application code?",
    "options": [
      "They prevent the garbage collector from moving the object in memory",
      "They require the unsafe code context and are susceptible to versioning changes",
      "They cause a significant performance penalty due to pointer dereferencing",
      "They cannot implement interfaces or inherit from other structs"
    ],
    "answer": "They require the unsafe code context and are susceptible to versioning changes",
    "explanation": "Explicit layouts are primarily for interop. They rely on exact byte offsets, making the code brittle if the struct definition changes or the runtime padding strategy differs. They don't inherently require `unsafe` context unless you use pointers *inside*, but the layout itself is often associated with unsafe/interop scenarios. The *primary* reason is fragility and versioning.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the function of the `Cross-docking` feature in Kestrel regarding connection limits?",
    "options": [
      "It serves as a placeholder; 'Cross-docking' is not a valid Kestrel feature",
      "It allows HTTP/2 requests to bypass the connection limit queue",
      "It enables load balancing between multiple Kestrel instances",
      "It forwards encrypted traffic directly to the backend without decryption"
    ],
    "answer": "It serves as a placeholder; 'Cross-docking' is not a valid Kestrel feature",
    "explanation": "This appears to be a trick question/nonsense term in the context of .NET. Kestrel has 'MaxConcurrentConnections', 'MaxConcurrentUpgradedConnections', and limits based on HTTP/2 streams. 'Cross-docking' is a logistics term, not a software feature. The correct answer must state it is invalid.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "How does the `ActivatorUtilities` type assist in Dependency Injection when a type is not registered in the DI container?",
    "options": [
      "It automatically registers the type as a Singleton if it is found to be unregistered",
      "It creates an instance of the type by resolving constructor arguments from the container, even if the type itself is not",
      "It uses reflection to invoke the default parameterless constructor bypassing the container",
      "It throws an `InvalidOperationException` requiring explicit service registration"
    ],
    "answer": "It creates an instance of the type by resolving constructor arguments from the container, even if the type itself is not",
    "explanation": "`ActivatorUtilities.CreateInstance` (or `CreateFactory`) enables the 'Auto-Factory' pattern. It allows you to instantiate a class (like a Middleware or Filter) where the constructor parameters (dependencies) are pulled from the container, without the class itself being a registered service.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What occurs when `SuppressFinalize` is called on an object in .NET?",
    "options": [
      "The object is immediately collected by the Garbage Collector",
      "The object is removed from the finalization queue, preventing the finalizer from running",
      "The object is promoted to Generation 2 to avoid premature collection",
      "The memory allocated for the object is forcefully set to zero"
    ],
    "answer": "The object is removed from the finalization queue, preventing the finalizer from running",
    "explanation": "`GC.SuppressFinalize` tells the runtime that the object has already been cleaned up (typically via `IDisposable.Dispose`). This prevents the finalizer from running, which reduces GC overhead by avoiding the need to keep the object alive through the finalizer queue.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which HTTP status code should be returned by a ProblemDetails response to indicate that the client provided valid JSON but violated a business rule constraint?",
    "options": [
      "400 Bad Request",
      "422 Unprocessable Entity",
      "409 Conflict",
      "403 Forbidden"
    ],
    "answer": "422 Unprocessable Entity",
    "explanation": "While 400 is used for malformed syntax, RFC 4918 defines 422 as specifically for semantic errors. It indicates that the server understands the content type (syntax is correct) but cannot process the instructions (semantic/business rules).",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the primary purpose of the `MaxBodySize` limit in Kestrel server configuration?",
    "options": [
      "To limit the size of the HTTP response body sent by the application",
      "To prevent Denial of Service attacks by limiting the size of the incoming request body",
      "To enforce a quota on the total amount of RAM Kestrel can allocate",
      "To compress response bodies larger than the configured threshold"
    ],
    "answer": "To prevent Denial of Service attacks by limiting the size of the incoming request body",
    "explanation": "Request size limits are a critical security buffer. They prevent malicious clients from uploading massive amounts of data (e.g., a 10GB file) that could exhaust server memory or disk space.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "Why is `ValueTask` generally preferred over `Task` for return types in hot path async APIs that may complete synchronously?",
    "options": [
      "`ValueTask` is a reference type and therefore easier to garbage collect",
      "`ValueTask` avoids heap allocation in cases where the result is available synchronously or cached",
      "`ValueTask` automatically converts the method to a synchronous call at runtime",
      "`ValueTask` allows multiple awaited results simultaneously unlike `Task`"
    ],
    "answer": "`ValueTask` avoids heap allocation in cases where the result is available synchronously or cached",
    "explanation": "`Task` is a heap-allocated class. `ValueTask` is a struct. If an async method completes synchronously or returns a cached value, `ValueTask` avoids the allocation overhead of creating a `Task` object entirely.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What does the `In` modifier on a generic type parameter enforce in C#?",
    "options": [
      "The generic argument must be a reference type",
      "The generic argument must be passed by reference",
      "The generic argument is contravariant",
      "The generic argument is covariant"
    ],
    "answer": "The generic argument is contravariant",
    "explanation": "The `in` keyword marks a type parameter as contravariant, allowing you to use a more derived type than specified. This is typically used for generic interfaces where types are passed *into* methods (e.g., `IComparer`).",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In the context of `System.Text.Json`, what is the primary drawback of using `JsonSerializer.Deserialize` with `Type` information compared to generic `Deserialize`?",
    "options": [
      "It requires the `UnmappedMemberHandling` option to be set",
      "It is significantly slower due to reflection cache misses and runtime type checks",
      "It cannot serialize properties with private setters",
      "It defaults to `PropertyNameCaseInsensitive = false`"
    ],
    "answer": "It is significantly slower due to reflection cache misses and runtime type checks",
    "explanation": "Deserialization by `Type` relies on runtime type resolution and often triggers different code paths that aren't as aggressively optimized or cached as the strongly-typed generic overloads. The generic version allows the compiler to emit specific metadata at compile time.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Which pattern correctly implements the `IDisposable` pattern for a class that derives from a class `Base` that already implements `IDisposable`?",
    "options": [
      "Seal the class to prevent further derivation and override `Dispose(bool)`",
      "Implement `IDisposable` but do not call `base.Dispose()` to avoid double disposal",
      "Override `Dispose(bool)` and ensure `base.Dispose(disposing)` is called in the `finally` logic",
      "Hide the base `Dispose` method using the `new` keyword"
    ],
    "answer": "Override `Dispose(bool)` and ensure `base.Dispose(disposing)` is called in the `finally` logic",
    "explanation": "The standard pattern dictates that you override the protected virtual `Dispose(bool)` method. Within the override, you must call `base.Dispose(disposing)` to ensure the disposal chain correctly cleans up resources in the base class.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the primary function of the `Pipe` type in `System.IO.Pipelines`?",
    "options": [
      "To provide a thread-safe queue for raw byte streams",
      "To manage a buffer pool for efficient parsing of sequential data streams",
      "To replace the need for `Stream` abstraction in all file I/O operations",
      "To establish a named pipe connection between processes"
    ],
    "answer": "To manage a buffer pool for efficient parsing of sequential data streams",
    "explanation": "Pipelines solves the problem of stream parsing by managing an internal buffer pool. It provides a `Reader` and `Writer` allowing efficient consumption of sequences without managing buffer boundaries manually or copying data excessively.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is 'unsafe' code in C# primarily used for in the context of high-performance applications?",
    "options": [
      "To bypass the JIT compiler and run interpreted bytecode",
      "To allow pointer arithmetic and direct memory manipulation bypassing safe type checks",
      "To run code with elevated operating system privileges",
      "To disable garbage collection for specific object instances"
    ],
    "answer": "To allow pointer arithmetic and direct memory manipulation bypassing safe type checks",
    "explanation": "The `unsafe` keyword allows the use of pointer types (`*`, `&`, `->`), memory management via stackalloc, and manipulation of memory addresses directly. This is necessary for low-level interop or high-performance scenarios where bounds checking is too expensive.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When using the `Polyfill` compilation feature in .NET 6/7/8, what is its purpose?",
    "options": [
      "It automatically downloads missing NuGet packages at compile time",
      "It enables the use of newer APIs (e.g., `DateOnly`) even when targeting older framework versions",
      "It converts C# 10 code into C# 8 compatible IL",
      "It patches security vulnerabilities in referenced assemblies"
    ],
    "answer": "It enables the use of newer APIs (e.g., `DateOnly`) even when targeting older framework versions",
    "explanation": "Polyfills allow developers to call APIs that exist in newer versions of .NET by providing custom implementations (or using MS logic) that work on older target frameworks (like .NET Framework or .NET Standard).",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "How does .NET 8's `IAsyncEnumerable` integration Minimal APIs affect HTTP response buffering?",
    "options": [
      "It forces the server to buffer the entire response into memory before sending",
      "It writes items to the response stream immediately as they are yielded",
      "It converts the enumerable to a synchronous JSON array before transmission",
      "It is not supported and throws a runtime exception"
    ],
    "answer": "It writes items to the response stream immediately as they are yielded",
    "explanation": "Minimal APIs handle `IAsyncEnumerable` by iterating the results and serializing/writing each item to the HTTP response body as it becomes available. This enables streaming responses without loading the full dataset into memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In the context of `System.Threading`, what happens when a `CancellationToken` is passed to a running `Task` constructor?",
    "options": [
      "The task starts executing and can poll the token to stop itself",
      "The task throws an `OperationCanceledException` immediately upon construction",
      "The task is prevented from starting if the token is already canceled",
      "The runtime automatically maps the token to the thread's `Abort` method"
    ],
    "answer": "The task is prevented from starting if the token is already canceled",
    "explanation": "Passing a `CancellationToken` to the `Task` constructor (factory start method) ties the token to the task's lifecycle. If the token is canceled before the task begins execution, the task transitions directly to a Canceled state without ever executing its delegate body.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is a 'captive dependency' in the context of Dependency Injection lifecycles?",
    "options": [
      "A Singleton service that depends on a Transient service",
      "A Transient service that depends on a Scoped service",
      "A service that holds a reference to a service with a shorter lifespan than its own",
      "A dependency that is registered twice in the container"
    ],
    "answer": "A service that holds a reference to a service with a shorter lifespan than its own",
    "explanation": "A captive dependency occurs when a longer-lived service (e.g., Singleton) injects a shorter-lived service (e.g., Scoped). If the shorter-lived service is designed to be disposed/renewed, holding it in the Singleton creates a stale or leaking dependency.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the role of `ConfigureAwaitOptions` in .NET 8+?",
    "options": [
      "It allows strict configuration of JSON serialization settings",
      "It enables the use of `ConfigureAwait` with options to force continuation on the same thread or suppress throwing",
      "It configures the timeout duration for `Wait` methods",
      "It defines the routing policy for Kestrel HTTPS redirection"
    ],
    "answer": "It enables the use of `ConfigureAwait` with options to force continuation on the same thread or suppress throwing",
    "explanation": "Introduced in .NET 8, `Task.ConfigureAwait(options)` granularly controls flow behavior. For example, `ForceYielding` ensures the continuation runs asynchronously, and `SuppressThrowing` prevents exception propagation, though `SuppressThrowing` is dangerous and rarely used.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Why is `Encoding.UTF8` generally preferred over `Encoding.Unicode` for web APIs in .NET?",
    "options": [
      "`Encoding.Unicode` uses UTF-16 which is not compatible with JSON specifications",
      "`Encoding.UTF8` uses a BOM (Byte Order Mark) which is required for HTTP headers",
      "`Encoding.UTF8` is faster to encode and decode compared to variable-width UTF-16",
      "`Encoding.Unicode` is actually an alias for UTF-7 in some contexts"
    ],
    "answer": "`Encoding.Unicode` uses UTF-16 which is not compatible with JSON specifications",
    "explanation": "HTTP and JSON standards mandate UTF-8. `Encoding.Unicode` in .NET refers to UTF-16. While UTF-16 is valid for some internal processing, sending it over the wire as 'text/plain' or 'application/json' without declaring the charset implies UTF-8, leading to potential decoding errors.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "When using the `Match` statement in C# with a relational pattern, what determines the match for a given type?",
    "options": [
      "The value returned by the `Equals` method on the object",
      "The implementation of the `IPattern` interface",
      "The static deconstruction method defined in the type",
      "The compiler-generated pattern matching helper using `RelationalPattern`"
    ],
    "answer": "The value returned by the `Equals` method on the object",
    "explanation": "Relational patterns (>, <, >=, <=) typically rely on the `IComparable` interface. However, for type checking and equality patterns, they use the `Equals` method. The specific implementation for relational patterns checks `IComparable.CompareTo`, but for *equality* patterns it uses `Equals`. Wait, the question asks 'What determines the match'. Let's specify **Equality**. Or stick to `IComparable`. Let's change to: What is required for a type to be used with relational patterns?",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which interface must a type implement to be used effectively with C# relational patterns (>, <, >=, <=)?",
    "options": [
      "IEquatable",
      "IComparable",
      "IParsable",
      "IFormattable"
    ],
    "answer": "IComparable",
    "explanation": "C# relational patterns rely on the `IComparable` interface (or `IComparable`) to determine the relative ordering of the operand against the constant provided in the pattern.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the purpose of the `[StringSyntax]` attribute introduced in recent .NET versions?",
    "options": [
      "To enforce string immutability at compile time",
      "To indicate to IDEs and Roslyn analyzers that a string argument represents a specific syntax (like Regex or JSON)",
      "To automatically optimize string concatenation using `string.Concat`",
      "To convert string literals to UTF-8 byte spans"
    ],
    "answer": "To indicate to IDEs and Roslyn analyzers that a string argument represents a specific syntax (like Regex or JSON)",
    "explanation": "This attribute provides semantic metadata for parameters. It allows compilers and analyzers to validate the content of string literals (e.g., checking if a regex string is a valid regular expression) before the code even runs.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "How does the `ConcurrentDictionary` handle concurrency internally by default?",
    "options": [
      "It uses a single global lock for all operations",
      "It employs a striped locking mechanism (lock striping) where buckets are locked independently",
      "It is completely lock-free using Compare-Exchange (CAS) CPU instructions",
      "It serializes access by forcing all operations onto the UI thread"
    ],
    "answer": "It employs a striped locking mechanism (lock striping) where buckets are locked independently",
    "explanation": "Unlike `Hashtable` or a `Dictionary` with a lock, `ConcurrentDictionary` divides the dictionary into segments (stripes) or manages fine-grained locks (locks per bucket in newer .NET) to allow high concurrency by minimizing contention.",
    "difficulty": "Advanced"
  }
]