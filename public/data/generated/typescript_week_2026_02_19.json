[
  {
    "id": 1,
    "question": "What is the primary benefit of using TypeScript over JavaScript?",
    "options": [
      "TypeScript enables direct access to the computer's GPU for rendering",
      "TypeScript allows code to run outside the browser without Node.js",
      "TypeScript adds static typing to enable error checking at compile time",
      "TypeScript automatically optimizes the runtime speed of JavaScript code"
    ],
    "answer": "TypeScript adds static typing to enable error checking at compile time",
    "explanation": "TypeScript's main feature is static typing, which allows developers to catch errors during development (compile time) rather than at runtime.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which file extension is used for TypeScript source files?",
    "options": [
      ".txt",
      ".js",
      ".ts",
      ".json"
    ],
    "answer": ".ts",
    "explanation": "TypeScript compilers look for the .ts extension to distinguish TypeScript files from standard JavaScript (.js) files.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "How do you define a variable in TypeScript that cannot be reassigned?",
    "options": [
      "let x = 10;",
      "var x = 10;",
      "const x = 10;",
      "static x = 10;"
    ],
    "answer": "const x = 10;",
    "explanation": "The `const` keyword declares a block-scoped constant that cannot be reassigned or redeclared, similar to JavaScript.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the result of compiling a TypeScript file?",
    "options": [
      "A binary executable file",
      "A JavaScript file with the same name but .js extension",
      "A CSS file for styling",
      "A Type Definition file (.d.ts)"
    ],
    "answer": "A JavaScript file with the same name but .js extension",
    "explanation": "The TypeScript compiler (tsc) transpiles TypeScript code into standard JavaScript that browsers or Node.js can execute.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which keyword is used to define an alias for a custom type in TypeScript?",
    "options": [
      "interface",
      "type",
      "enum",
      "typedef"
    ],
    "answer": "type",
    "explanation": "The `type` keyword allows you to create a name for a type alias, which can represent primitives, unions, or complex object shapes.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What does the 'any' type signify in TypeScript?",
    "options": [
      "The variable can only hold numeric values",
      "The variable is strictly typed and immutable",
      "The variable bypasses type checking and can hold any value",
      "The variable is nullable"
    ],
    "answer": "The variable bypasses type checking and can hold any value",
    "explanation": "The `any` type effectively turns off type checking for that variable, allowing it to hold any value and access any property, similar to standard JavaScript.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which operator is used to combine two types such that the resulting type has properties of both?",
    "options": [
      "Pipe (|)",
      "Ampersand (&)",
      "Plus (+)",
      "Asterisk (*)"
    ],
    "answer": "Ampersand (&)",
    "explanation": "The Intersection Types operator (&) combines multiple types into one, requiring the resulting object to satisfy all constituent types.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "How do you specify that a function parameter is optional?",
    "options": [
      "Using the 'optional' keyword",
      "Appending a question mark (?) to the parameter name",
      "Wrapping the parameter in square brackets []",
      "Setting the parameter type to 'undefined'"
    ],
    "answer": "Appending a question mark (?) to the parameter name",
    "explanation": "In TypeScript function signatures, placing a `?` after the parameter name (e.g., `name?: string`) marks it as optional.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which of the following correctly defines an array of numbers?",
    "options": [
      "let nums: [number];",
      "let nums: number;",
      "let nums: number[];",
      "let nums: array<number>;"
    ],
    "answer": "let nums: number[];",
    "explanation": "The syntax `number[]` or `Array<number>` defines an array where all elements are of type number.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is a Tuple in TypeScript?",
    "options": [
      "A key-value pair data structure",
      "An array with a fixed number of elements where each element has a specific type",
      "A function that returns multiple values",
      "A type of class constructor"
    ],
    "answer": "An array with a fixed number of elements where each element has a specific type",
    "explanation": "Tuples allow you to express an array where the type of a fixed number of elements is known, but need not be the same (e.g., `[string, number]`).",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which utility type makes all properties of a Type optional?",
    "options": [
      "Required",
      "Partial",
      "Readonly",
      "Pick"
    ],
    "answer": "Partial",
    "explanation": "The `Partial` utility type constructs a type with all properties of the provided Type set to optional.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the purpose of the 'void' type?",
    "options": [
      "To indicate a variable holds no value",
      "To indicate a function returns no value",
      "To indicate a value is null",
      "To indicate a function is asynchronous"
    ],
    "answer": "To indicate a function returns no value",
    "explanation": "The `void` type is commonly used as the return type for functions that do not return a value.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "How do you define an Enum in TypeScript?",
    "options": [
      "enum Color { Red, Green, Blue }",
      "enum Color = { Red: 1, Green: 2, Blue: 3 }",
      "define Enum Color { Red, Green, Blue }",
      "var Enum Color = ['Red', 'Green', 'Blue']"
    ],
    "answer": "enum Color { Red, Green, Blue }",
    "explanation": "The `enum` keyword allows you to define a set of named constants, organizing related values under a specific data structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which construct uses the 'extends' keyword to inherit properties?",
    "options": [
      "Interfaces",
      "Type Aliases",
      "Enums",
      "Tuples"
    ],
    "answer": "Interfaces",
    "explanation": "Interfaces support extension using the `extends` keyword, allowing one interface to inherit members from another.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What happens if you assign a 'string' value to a variable declared as 'number'?",
    "options": [
      "The value is automatically converted to a number",
      "The compiler raises a type error",
      "The variable dynamically changes its type to string",
      "The value is stored as 'any'"
    ],
    "answer": "The compiler raises a type error",
    "explanation": "TypeScript's static analysis prevents assigning a value of one type to a variable of a mismatched type, catching bugs early.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What does the 'readonly' modifier do to a class property?",
    "options": [
      "It makes the property private to the class",
      "It prevents the property from being reassigned after initialization",
      "It allows the property to be deleted",
      "It makes the property accessible only via getters"
    ],
    "answer": "It prevents the property from being reassigned after initialization",
    "explanation": "The `readonly` keyword marks a property as immutable, meaning it can only be assigned during declaration or in the constructor.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which of the following represents a Union Type?",
    "options": [
      "string & number",
      "string | number",
      "string + number",
      "string, number"
    ],
    "answer": "string | number",
    "explanation": "The pipe operator (|) defines a Union Type, meaning a value can be either a string OR a number.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "How do you explicitly assert that a value is of a specific type, overriding the compiler's inference?",
    "options": [
      "cast(value)",
      "convert(value)",
      "value as Type",
      "Type(value)"
    ],
    "answer": "value as Type",
    "explanation": "The `as` keyword is used for Type Assertions, allowing you to tell the compiler to treat a value as a specific type.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which built-in utility type constructs a type by picking a set of properties Keys from Type?",
    "options": [
      "Omit",
      "Partial",
      "Pick",
      "Exclude"
    ],
    "answer": "Pick",
    "explanation": "The `Pick` utility type allows you to create a new type by selecting specific properties from an existing type.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the syntax for defining a generic interface?",
    "options": [
      "interface Identity { value: any }",
      "interface Identity { value: T }",
      "generic interface Identity { value: T }",
      "interface Identity(T) { value }"
    ],
    "answer": "interface Identity { value: T }",
    "explanation": "Generics are defined using angle brackets ``, usually placed after the interface name, allowing types to be passed as arguments.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which utility type is the opposite of 'Pick', constructing a type by omitting specific keys?",
    "options": [
      "Exclude",
      "Omit",
      "Extract",
      "NonNullable"
    ],
    "answer": "Omit",
    "explanation": "The `Omit` utility type creates a new type by copying all properties of a type and then removing the specified keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What does 'unknown' represent in TypeScript?",
    "options": [
      "A type that represents any value without methods",
      "A type-safe counterpart of 'any' that requires type narrowing",
      "A type that ensures a value is null",
      "A type that has not been defined yet"
    ],
    "answer": "A type-safe counterpart of 'any' that requires type narrowing",
    "explanation": "The `unknown` type is like `any` but enforces type checking; you must perform a type check or assertion before using the value.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which symbol is used for the Nullish Coalescing operator?",
    "options": [
      "||",
      "&&",
      "??",
      "?:"
    ],
    "answer": "??",
    "explanation": "The `??` operator returns the right-hand operand only when the left-hand operand is null or undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "How do you type-check a variable to ensure it is a specific type at runtime?",
    "options": [
      "Using the 'typeof' keyword in a conditional",
      "Using the 'type' keyword in a conditional",
      "Using the 'cast' keyword",
      "Using the 'is' keyword"
    ],
    "answer": "Using the 'typeof' keyword in a conditional",
    "explanation": "Type guards often use `typeof` (e.g., `typeof x === 'string'`) to narrow the type of a variable within a conditional block.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the default access modifier for class members in TypeScript?",
    "options": [
      "private",
      "protected",
      "public",
      "internal"
    ],
    "answer": "public",
    "explanation": "If no access modifier is specified, class members are implicitly `public`, meaning they can be accessed from anywhere.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the name of the configuration file used to configure TypeScript compiler options?",
    "options": [
      ".tsconfig",
      "tsconfig.json",
      "typescript.json",
      "config.ts"
    ],
    "answer": "tsconfig.json",
    "explanation": "The `tsconfig.json` file in a project root specifies the root files and the compiler options required to compile the project.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which of the following is NOT a valid primitive type in TypeScript?",
    "options": [
      "boolean",
      "string",
      "array",
      "undefined"
    ],
    "answer": "array",
    "explanation": "Arrays are not primitives; they are object types. The primitives in TypeScript are: number, string, boolean, bigint, symbol, null, and undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What does the 'Record' utility type do?",
    "options": [
      "Creates a function type",
      "Constructs an object type with keys of type Keys and values of type Type",
      "Records a sequence of events",
      "Defines a constant value"
    ],
    "answer": "Constructs an object type with keys of type Keys and values of type Type",
    "explanation": "The `Record<Keys, Type>` utility type creates an object type where property keys are Keys and property values are Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which modifier prevents a class member from being accessed outside the class that defines it?",
    "options": [
      "public",
      "private",
      "protected",
      "static"
    ],
    "answer": "private",
    "explanation": "The `private` modifier restricts access to the member only within the class that defines it.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What does the 'keyof' operator return?",
    "options": [
      "The values of an object",
      "The type of the object keys",
      "The number of keys in an object",
      "A union of string literal types representing the keys"
    ],
    "answer": "A union of string literal types representing the keys",
    "explanation": "The `keyof` operator takes an object type and produces a string or numeric literal union of its keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the 'never' type used for?",
    "options": [
      "To indicate a variable that has not been assigned",
      "To represent the return type of a function that never completes (e.g., throws an error)",
      "To represent a value that is null",
      "To indicate a function is asynchronous"
    ],
    "answer": "To represent the return type of a function that never completes (e.g., throws an error)",
    "explanation": "The `never` type represents the type of values that never occur, such as functions that throw exceptions or contain infinite loops.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "How do you enable strict null checks in tsconfig.json?",
    "options": [
      "Set 'strictMode' to true",
      "Set 'strictNullChecks' to true",
      "Set 'noImplicitAny' to true",
      "Set 'strict' to true"
    ],
    "answer": "Set 'strictNullChecks' to true",
    "explanation": "The `strictNullChecks` compiler option specifically treats `null` and `undefined` as distinct values, preventing them from being assigned to other types implicitly.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which operator is used for Optional Chaining?",
    "options": [
      "?.",
      "??",
      "&&",
      "::"
    ],
    "answer": "?.",
    "explanation": "The Optional Chaining operator `?.` allows you to safely access nested object properties that may be null or undefined without throwing an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is a Declaration Merging in TypeScript?",
    "options": [
      "Combining two strings into one",
      "The compiler merging two separate declarations with the same name into a single definition",
      "Merging two JavaScript files",
      "Resolving merge conflicts in Git"
    ],
    "answer": "The compiler merging two separate declarations with the same name into a single definition",
    "explanation": "Declaration merging allows the compiler to treat two or more declarations (e.g., interfaces) with the same name as one.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which utility type removes 'null' and 'undefined' from a type?",
    "options": [
      "Exclude",
      "Omit",
      "NonNullable",
      "Required"
    ],
    "answer": "NonNullable",
    "explanation": "The `NonNullable` utility type creates a new type by removing `null` and `undefined` from the given type.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which utility type constructs a type by picking the set of keys `K` from type `T`?",
    "options": [
      "Pick<T, K>",
      "Omit<T, K>",
      "Partial<T>",
      "Record<K, T>"
    ],
    "answer": "Pick<T, K>",
    "explanation": "`Pick<T, K>` constructs a type by extracting the specified set of properties `K` from `T`. `Omit` does the inverse by removing keys, while `Partial` makes all properties optional.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary difference between the `unknown` and `any` types in TypeScript?",
    "options": [
      "`any` allows arbitrary assignments, while `unknown` requires type narrowing before use",
      "`unknown` is strictly for objects, while `any` is for primitives",
      "`any` throws a compile-time error, while `unknown` does not",
      "There is no difference; they are interchangeable aliases"
    ],
    "answer": "`any` allows arbitrary assignments, while `unknown` requires type narrowing before use",
    "explanation": "`unknown` is type-safe, requiring a type guard or assertion to operate on the value. `any` opts out of type checking entirely, allowing operations without validation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In a discriminated union, what property must be shared across all union members to enable type narrowing?",
    "options": [
      "A literal property with a distinct value for each member",
      "A generic type parameter",
      "An optional index signature",
      "A private class field"
    ],
    "answer": "A literal property with a distinct value for each member",
    "explanation": "Discriminated unions rely on a single property (usually a string or number literal) having distinct values across members. TypeScript uses this discriminant to narrow the specific type within the union.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the result of using the `keyof` operator on a type `T` that has properties `id: number` and `name: string`?",
    "options": [
      "A union type of literal property names: 'id' | 'name'",
      "An array of strings: ['id', 'name']",
      "An object type with keys 'id' and 'name'",
      "A tuple type: [number, string]"
    ],
    "answer": "A union type of literal property names: 'id' | 'name'",
    "explanation": "`keyof T` produces a union of string literal types representing the names of all public properties of `T`. It is used for polymorphic property access and mapped types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What does the `NonNullable` utility type do?",
    "options": [
      "It removes `null` and `undefined` from type `T`",
      "It ensures `T` is not `void`",
      "It converts `T` to a primitive type",
      "It adds a `null` check to every property of `T`"
    ],
    "answer": "It removes `null` and `undefined` from type `T`",
    "explanation": "`NonNullable<T>` creates a new type by excluding `null` and `undefined` from `T`. It is equivalent to `T & {}` (strict null checking context) or `T extends null | undefined ? never : T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the `as const` assertion affect the type of a literal array?",
    "options": [
      "It infers a readonly tuple of literal types instead of a mutable array of primitives",
      "It converts the array into a constant variable at runtime",
      "It allows the array to hold only string values",
      "It removes all type information from the array"
    ],
    "answer": "It infers a readonly tuple of literal types instead of a mutable array of primitives",
    "explanation": "`as const` sets the inference mode to 'readonly' and treats literals as their specific literal types (e.g., `\"red\"`) rather than their primitives (e.g., `string`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What does the `Extract<Type, Union>` utility type return?",
    "options": [
      "A union of all types in `Union` that are assignable to `Type`",
      "The difference between `Type` and `Union`",
      "The first matching type found in `Type`",
      "A tuple representation of `Type`"
    ],
    "answer": "A union of all types in `Union` that are assignable to `Type`",
    "explanation": "`Extract<T, U>` constructs a type by extracting from `T` all types that are assignable to `U`. It is the opposite of `Exclude`, which removes types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In a mapped type, what prefix removes the `readonly` modifier from a property?",
    "options": [
      "-readonly",
      "-? ",
      "mutable",
      "!readonly"
    ],
    "answer": "-readonly",
    "explanation": "In mapped types, `+readonly` adds `readonly` and `-readonly` removes it. Similarly, `+?` adds optionality and `-?` removes it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which keyword is used in a conditional type to infer a type variable from the extends clause?",
    "options": [
      "infer",
      "declare",
      "typeof",
      "keyof"
    ],
    "answer": "infer",
    "explanation": "The `infer` keyword introduces a type variable within the `extends` clause of a conditional type to capture a part of the matched type, commonly used in utility types like `ReturnType`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the behavior of TypeScript's `never` type?",
    "options": [
      "It represents a value that never occurs and has no subtypes",
      "It represents a value that can be any type except null",
      "It indicates a variable that has not been assigned yet",
      "It allows any function to be assigned to it"
    ],
    "answer": "It represents a value that never occurs and has no subtypes",
    "explanation": "`never` is the empty type (bottom type). It is used for functions that throw exceptions or never return, and in type logic to filter out unions (e.g., `Exclude<'a' | 'b', 'a'>` results in `'b'` because `'a'` becomes `never`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the output type of the `Parameters<T>` utility type?",
    "options": [
      "A tuple type of the function type `T`'s parameters",
      "A union type of the function type `T`'s parameters",
      "An object type matching `T`'s arguments",
      "The return type of `T`"
    ],
    "answer": "A tuple type of the function type `T`'s parameters",
    "explanation": "`Parameters<T>` extracts the parameter types from a function type `T` and constructs them as a tuple. This is distinct from `ReturnType<T>`, which extracts the return type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "How does TypeScript treat interface declaration merging compared to type aliases?",
    "options": [
      "Interfaces can be merged by repeated declarations; type aliases cannot",
      "Type aliases can be merged; interfaces cannot",
      "Both interfaces and type aliases support declaration merging",
      "Neither interfaces nor type aliases support declaration merging"
    ],
    "answer": "Interfaces can be merged by repeated declarations; type aliases cannot",
    "explanation": "Interfaces are open-ended and allow subsequent declarations to extend the existing interface. Type aliases represent a specific shape and cannot be re-declared or merged.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the effect of enabling the `noImplicitThis` compiler option?",
    "options": [
      "It raises an error when `this` is used in a context where its type is implicitly `any`",
      "It prevents using `this` in any function",
      "It forces `this` to refer to the global object",
      "It automatically binds `this` to class instances"
    ],
    "answer": "It raises an error when `this` is used in a context where its type is implicitly `any`",
    "explanation": "`noImplicitThis` ensures that whenever `this` is used, its type must be explicitly known or inferrable, preventing common errors in callbacks and object methods.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which utility type creates a type with all properties of `T` set to optional?",
    "options": [
      "Partial",
      "Required",
      "Readonly",
      "Mutable"
    ],
    "answer": "Partial",
    "explanation": "`Partial<T>` maps over all properties of `T` and makes them optional (`?`). This is useful for update operations (PATCH) where not all fields need to be provided.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In Template Literal Types, how do you create a union of all string literal combinations?",
    "options": [
      "Using `in` or conditional distribution within the template literal",
      "Using the `+` operator",
      "Using the `split()` method",
      "Using the `any` type as a placeholder"
    ],
    "answer": "Using `in` or conditional distribution within the template literal",
    "explanation": "When a union is used in the interpolation position of a template literal (e.g., `` `${T | U}` ``), TypeScript distributes the union to create a union of all possible string combinations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the purpose of the `satisfies` operator introduced in TypeScript 4.9?",
    "options": [
      "To validate that an expression matches a type without changing the expression's inferred type",
      "To cast an expression to a specific type",
      "To assert that a value is not null",
      "To implement an interface on a class"
    ],
    "answer": "To validate that an expression matches a type without changing the expression's inferred type",
    "explanation": "Unlike type annotation (`:`) which widens the type to the specific type, `satisfies` ensures the value conforms to the type but retains the specific, narrower inferred type for subsequent usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is a Type Guard in TypeScript?",
    "options": [
      "A runtime check that returns a boolean and narrows the type within a conditional block",
      "A comment that tells the compiler to ignore type errors",
      "A wrapper class that protects private properties",
      "A compiler flag that prevents type widening"
    ],
    "answer": "A runtime check that returns a boolean and narrows the type within a conditional block",
    "explanation": "Type guards (e.g., `typeof val === 'string'` or `val instanceof HTMLElement`) perform runtime checks. If they return `true`, TypeScript narrows the type of the variable in the corresponding scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which utility type constructs an object type by setting all properties of `T` to type `U`?",
    "options": [
      "Record<Keys, Type>",
      "Omit<T, K>",
      "Map<T, U>",
      "Pick<T, K>"
    ],
    "answer": "Record<Keys, Type>",
    "explanation": "`Record<K, T>` constructs an object type where all property keys are of type `K` and all values are of type `T`. `Map` is a JavaScript object, not a TypeScript utility type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What does the `ThisParameterType` utility type extract?",
    "options": [
      "The type of the `this` parameter for a function type",
      "The type of the first argument",
      "The return type of the function",
      "The type of the class constructor"
    ],
    "answer": "The type of the `this` parameter for a function type",
    "explanation": "`ThisParameterType<T>` extracts the explicitly declared type of the `this` parameter in a function type. If no `this` parameter is declared, it returns `unknown`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the behavior of the `Omit<Type, Keys>` utility type?",
    "options": [
      "It constructs a type by picking all properties from `Type` and then removing `Keys`",
      "It constructs a type by selecting only `Keys` from `Type`",
      "It creates a type that excludes all properties of `Type` except `Keys`",
      "It makes the specified keys optional"
    ],
    "answer": "It constructs a type by picking all properties from `Type` and then removing `Keys`",
    "explanation": "`Omit<T, K>` is implemented as `Pick<T, Exclude<keyof T, K>>`. It creates a new type containing all properties of `T` except those specified in the union `K`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the distinction between `interface X { ( ): T }` and `type Y = ( ) => T`?",
    "options": [
      "The interface declaration can be merged with other interfaces; the type alias cannot",
      "The type alias is faster at runtime",
      "The interface declaration only allows methods, not callable signatures",
      "There is no functional or type-system difference"
    ],
    "answer": "The interface declaration can be merged with other interfaces; the type alias cannot",
    "explanation": "While both define a callable signature, the interface supports declaration merging (extending the definition later), whereas the type alias is a fixed definition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "When using generics, what is the purpose of the `extends` constraint (e.g., `<T extends Length>`)?",
    "options": [
      "To restrict `T` to types that are compatible with a specific shape or primitive",
      "To allow `T` to be absolutely any type including `any`",
      "To make the generic parameter optional",
      "To convert `T` into a class"
    ],
    "answer": "To restrict `T` to types that are compatible with a specific shape or primitive",
    "explanation": "Constraints (`extends`) limit the types accepted by the generic parameter, ensuring that the type supports required properties (like `.length`) or implements a specific interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the result of the `Required` utility type applied to a type with optional properties?",
    "options": [
      "A new type where all optional properties are set to required",
      "A type that requires at least one property to be present",
      "A type that removes all properties",
      "A type that throws an error if properties are missing"
    ],
    "answer": "A new type where all optional properties are set to required",
    "explanation": "`Required<T>` constructs a type consisting of all properties of `T` set to required. It is the opposite of `Partial`, removing the `?` modifier from keys.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the function of the `infer` keyword within a conditional type like `T extends (infer U)[] ? U : never`?",
    "options": [
      "It captures the array element type as `U` for use in the true branch",
      "It casts `T` to an array type",
      "It checks if `U` is an array",
      "It creates a new generic parameter for the function"
    ],
    "answer": "It captures the array element type as `U` for use in the true branch",
    "explanation": "`infer U` declares a type variable to be inferred by TypeScript based on the structure of `T`. In this pattern, it extracts the type of the elements inside the array.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which TypeScript feature allows defining a type that can be one of several specific string values?",
    "options": [
      "Union type of string literals",
      "Enum",
      "String type",
      "Any type"
    ],
    "answer": "Union type of string literals",
    "explanation": "While `enum` is often used, a union of string literals (e.g., `type Direction = 'North' | 'South'`) is a distinct feature that does not generate runtime code (unless used in const contexts) and provides the same type safety.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does the `Awaited` utility type work?",
    "options": [
      "It recursively unwraps Promise types to get the underlying type",
      "It makes a type asynchronous",
      "It creates a Promise from a non-Promise type",
      "It checks if a type is valid for async/await usage"
    ],
    "answer": "It recursively unwraps Promise types to get the underlying type",
    "explanation": "`Awaited<T>` is similar to the `await` keyword. It peels back layers of Promise-like types (e.g., `Promise<Promise<string>>` becomes `string`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is a Branded Type in TypeScript?",
    "options": [
      "A pattern using intersection types to distinguish nominal types that are structurally identical",
      "A type that is exported to other modules",
      "A type created by the `brand` keyword",
      "A built-in primitive type like `symbol`"
    ],
    "answer": "A pattern using intersection types to distinguish nominal types that are structurally identical",
    "explanation": "Since TypeScript is structurally typed, `type UserId = string & { readonly __brand: unique symbol }` prevents assigning a generic `string` to a `UserId`, mimicking nominal typing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What does the `noUncheckedIndexedAccess` compiler flag do?",
    "options": [
      "It adds `undefined` to the type when accessing an index or array element",
      "It prevents the use of index signatures entirely",
      "It forces all arrays to be readonly",
      "It changes `null` to `undefined`"
    ],
    "answer": "It adds `undefined` to the type when accessing an index or array element",
    "explanation": "By default, accessing `arr[10]` returns `T` even if out of bounds. This flag makes the return type `T | undefined` to reflect that the access might fail, improving safety.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In a generic function, how can you specify a default type for the generic parameter?",
    "options": [
      "Using the assignment operator `<T = Default>`",
      "Using the keyword `default`",
      "Using a ternary operator inside the type",
      "Defaults are not supported for generic parameters"
    ],
    "answer": "Using the assignment operator `<T = Default>`",
    "explanation": "TypeScript allows default types in generics",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the difference between `ReadonlyArray` and a standard `Array` in TypeScript?",
    "options": [
      "`ReadonlyArray` removes all methods that mutate the array (like push, pop)",
      "`ReadonlyArray` runs faster than `Array`",
      "`ReadonlyArray` can only hold strings",
      "`ReadonlyArray` cannot be iterated over with for-of"
    ],
    "answer": "`ReadonlyArray` removes all methods that mutate the array (like push, pop)",
    "explanation": "`ReadonlyArray` ensures that the array reference cannot be modified. It excludes mutation methods and prevents assignment to indices, treating the array as immutable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What does the `ReturnType` utility type extract?",
    "options": [
      "The type returned by a function",
      "The first parameter of a function",
      "The `this` type of a function",
      "The instance type of a class constructor"
    ],
    "answer": "The type returned by a function",
    "explanation": "`ReturnType<T>` takes a function type `T` and extracts the type of the value returned by that function. It fails if `T` is not a function type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which `tsconfig.json` option enables strict type checking rules across the board?",
    "options": [
      "strict",
      "noImplicitAny",
      "strictNullChecks",
      "alwaysStrict"
    ],
    "answer": "strict",
    "explanation": "The `strict` flag enables `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, and `noImplicitThis`. It is the recommended setting for new projects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the definition of a Variance in TypeScript generics regarding functions?",
    "options": [
      "Function parameters are contravariant and return types are covariant",
      "Function parameters are covariant and return types are contravariant",
      "All generic types are invariant",
      "Generics are always bivariant"
    ],
    "answer": "Function parameters are contravariant and return types are covariant",
    "explanation": "TypeScript enforces that for a function to be assignable to another, the parameters must be compatible in reverse (contravariant) and the return value must be compatible in the forward (covariant) direction. (Note: TS treats parameters as bivariant for backward compatibility unless `strictFunctionTypes` is on).",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "How do you enforce that a class property is initialized in the constructor?",
    "options": [
      "Enable `strictPropertyInitialization` in `tsconfig`",
      "Mark the property as public",
      "Assign the property to undefined",
      "Use the `abstract` keyword"
    ],
    "answer": "Enable `strictPropertyInitialization` in `tsconfig`",
    "explanation": "When `strictPropertyInitialization` is enabled (under `strict` mode), the compiler checks that every non-optional property is initialized in the constructor or via a property initializer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is the purpose of `Uppercase<StringType>`?",
    "options": [
      "It converts a string literal type to its uppercase representation",
      "It creates a union of all uppercase strings",
      "It enforces that a variable is uppercase at runtime",
      "It removes lowercase letters from a string type"
    ],
    "answer": "It converts a string literal type to its uppercase representation",
    "explanation": "Intrinsic string manipulation types like `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize` allow transformation of string literal types at compile-time.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What is the result of applying the `keyof` operator to a type that has a string index signature?",
    "options": [
      "An array of all property names",
      "A union of specific property keys plus 'string' | 'number'",
      "The specific literal keys only, ignoring index signatures",
      "A single type 'string' representing any possible key"
    ],
    "answer": "A union of specific property keys plus 'string' | 'number'",
    "explanation": "The `keyof` operator returns specific known keys, but for types with index signatures, it also includes the types of the index signature (usually `string` and `number`), representing all possible keys.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In TypeScript 5.0+, how does the `const` modifier on a type parameter differ from standard generic constraints?",
    "options": [
      "It allows the type parameter to be assigned any value",
      "It infers the most specific literal type for the generic argument instead of a primitive",
      "It makes the generic parameter immutable within the function scope",
      "It prevents the generic type from being used in a union type"
    ],
    "answer": "It infers the most specific literal type for the generic argument instead of a primitive",
    "explanation": "The `const` type parameter modifier (e.g., `<const T>`) acts like the `as const` assertion for inference, causing `T` to be inferred as a literal type (e.g., `'red'`) rather than its primitive (e.g., `string`).",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "When using mapped types with `keyof`, how do you create a new type where all properties become optional modifiers are removed?",
    "options": [
      "type Mandatory = { -? [P in keyof T]: T[P] }",
      "type Mandatory = { [P in keyof T]: T[P] }",
      "type Mandatory = { [P+? in keyof T]: T[P] }",
      "type Mandatory = Required"
    ],
    "answer": "type Mandatory = { -? [P in keyof T]: T[P] }",
    "explanation": "The `-?` modifier in a mapped type removes the optional flag from properties. `Required` does this internally but the explicit syntax is `-?`.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the primary type-level difference between `interface` and `type` regarding declaration merging?",
    "options": [
      "Both support merging for function and class types",
      "Interfaces can be merged, while type aliases for object types cannot be reopened or merged",
      "Type aliases support merging if using the `declare` keyword",
      "Interfaces do not support merging if they have generic parameters"
    ],
    "answer": "Interfaces can be merged, while type aliases for object types cannot be reopened or merged",
    "explanation": "Interfaces are open-ended and can be redeclared to merge members. Type aliases cannot be merged; attempting to redeclare a type alias results in a duplicate identifier error.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "How does the `infer` keyword behave within conditional types?",
    "options": [
      "It forces a type assertion without runtime checks",
      "It introduces a new type variable to be inferred by the compiler from the extends clause",
      "It creates a recursive type loop",
      "It imports a type from a global module scope"
    ],
    "answer": "It introduces a new type variable to be inferred by the compiler from the extends clause",
    "explanation": "`infer` is used exclusively in the `extends` clause of a conditional type to capture a type from the structure being checked (e.g., extracting the return type of a function).",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the output type of a conditional type `T extends U ? X : Y` when `T` is a union type (e.g., `A | B`)?",
    "options": [
      "The conditional type distributes automatically over the union, resulting in (A extends U ? X : Y) | (B extends U ? X : Y)",
      "The type `X` is always returned if any member of the union extends `U`",
      "The type `Y` is returned because unions cannot be checked against a single condition",
      "The intersection of `X` and `Y`"
    ],
    "answer": "The conditional type distributes automatically over the union, resulting in (A extends U ? X : Y) | (B extends U ? X : Y)",
    "explanation": "Distributive conditional types automatically apply the condition to each member of the union. This can be disabled by wrapping the check in square brackets `[T extends U ? X : Y]`.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which utility type correctly implements 'Omit' by combining 'Pick' and 'Exclude'?",
    "options": [
      "type Omit = Pick<T, Exclude<keyof T, K>>",
      "type Omit = Exclude<Pick<T, K>>",
      "type Omit = Pick<Exclude<T, K>>",
      "type Omit = Record<Exclude<keyof T, K>, T[keyof T]>"
    ],
    "answer": "type Omit = Pick<T, Exclude<keyof T, K>>",
    "explanation": "`Omit` works by taking all keys of `T` (`keyof T`), excluding the keys `K`, and then picking the remaining properties from `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In the context of TypeScript decorators, what is the significance of the execution order for multiple decorators on a single declaration?",
    "options": [
      "They execute sequentially from top to bottom at runtime",
      "They execute from bottom to top (Higher-order functions composed), but evaluation is top to bottom",
      "Decorators execute asynchronously in parallel",
      "Only the first decorator is executed unless `@chain()` is used"
    ],
    "answer": "They execute from bottom to top (Higher-order functions composed), but evaluation is top to bottom",
    "explanation": "Decorator expressions are evaluated top-to-bottom, but the resulting functions are called bottom-to-top (inside-out), similar to function composition `f(g(x))`.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the purpose of the `satisfies` operator introduced in TypeScript 4.9?",
    "options": [
      "To cast a value to a specific type regardless of compatibility",
      "To validate that a value matches a type without widening the expression's inferred type",
      "To create a new type alias that enforces strict null checks",
      "To check if a generic constraint is met at runtime"
    ],
    "answer": "To validate that a value matches a type without widening the expression's inferred type",
    "explanation": "`satisfies` ensures a value conforms to a specific type but retains the specific, narrower inferred type of the value itself, whereas type annotations widen the type to the explicit type.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "When using Template Literal Types, how can you transform a union of string literals into uppercase?",
    "options": [
      "Using the `Uppercase` intrinsic type: `type Uppercased = Uppercase<T>`",
      "Using a mapped type with `keyof`",
      "Using the `.toUpperCase()` method in the generic constraint",
      "Using the `Capital` utility type"
    ],
    "answer": "Using the `Uppercase` intrinsic type: `type Uppercased = Uppercase<T>`",
    "explanation": "TypeScript provides intrinsic string manipulation types such as `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize` to operate on string literal types and unions.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the type-safe way to assert that a value is of a specific type when TypeScript cannot infer it, while ensuring the value passes a runtime check?",
    "options": [
      "Using a type assertion `as Type`",
      "Using a type guard function `value is Type`",
      "Using the `any` type temporarily",
      "Using `Object.prototype.toString.call()`"
    ],
    "answer": "Using a type guard function `value is Type`",
    "explanation": "Type guards are special functions that return a boolean and use a `value is Type` predicate to narrow the type of a variable in conditional blocks based on runtime logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What does the `NonNullable` utility type do?",
    "options": [
      "It removes `null` and `undefined` from the type `T`",
      "It ensures `T` is not the `any` type",
      "It creates a type that cannot be assigned `void`",
      "It enforces strict initialization for class properties"
    ],
    "answer": "It removes `null` and `undefined` from the type `T`",
    "explanation": "`NonNullable` constructs a type by excluding `null` and `undefined` from `Type`. It is equivalent to `T extends null | undefined ? never : T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "How do you enforce that a class property is initialized exactly once and remains immutable after construction?",
    "options": [
      "Use the `static` keyword",
      "Use the `readonly` modifier",
      "Use a private setter",
      "Use the `const` keyword on the property"
    ],
    "answer": "Use the `readonly` modifier",
    "explanation": "The `readonly` keyword marks a property as immutable; it can only be assigned during initialization or in the constructor. `const` is not used on class properties.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the definition of a 'Branded Type' in TypeScript, often used to simulate nominal typing?",
    "options": [
      "Using an interface with a specific `brand` property to distinct two structurally identical types",
      "Using a generic class with a private constructor",
      "Applying the `unique` symbol to a primitive type",
      "Extending the `Error` class"
    ],
    "answer": "Using an interface with a specific `brand` property to distinct two structurally identical types",
    "explanation": "Branding adds a unique, usually undeclared, property (e.g., `__brand: 'User'`) to a type via intersection to make it incompatible with other types that have the same structure but a different brand.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What does the `Extract` utility type return?",
    "options": [
      "The type `T` if it extends `U`, otherwise `never`",
      "All members of a union `T` that are assignable to `U`",
      "The instance type of a class constructor `T`",
      "The return type of a function `T`"
    ],
    "answer": "All members of a union `T` that are assignable to `U`",
    "explanation": "`Extract<T, U>` constructs a type by extracting from `T` all union members that are assignable to `U`. It is the opposite of `Exclude`.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "How does the `ThisParameterType` utility function?",
    "options": [
      "It extracts the type of the `this` parameter of a function type, or `unknown` if none exists",
      "It forces a function to bind `this` to a specific object",
      "It creates a new function that ignores the `this` context",
      "It infers the return type based on `this`"
    ],
    "answer": "It extracts the type of the `this` parameter of a function type, or `unknown` if none exists",
    "explanation": "`ThisParameterType` extracts the type of the explicit `this` parameter for a function type. It is useful for manipulating wrappers that need to preserve context.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "When defining a generic function, how do you constrain a type parameter to be a subclass of a specific class?",
    "options": [
      "function fn<T implements MyClass>()",
      "function fn<T extends MyClass>()",
      "function fn<T: MyClass>()",
      "function fn<T super MyClass>()"
    ],
    "answer": "function fn<T extends MyClass>()",
    "explanation": "The `extends` keyword in a generic declaration (e.g., `<T extends Base>`) constrains `T` to be a subtype of `Base`.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the result of `keyof any`?",
    "options": [
      "any",
      "string | number | symbol",
      "never",
      "object"
    ],
    "answer": "string | number | symbol",
    "explanation": "Because any object key can be a `string`, `number`, or `symbol`, `keyof any` returns the union of these three primitive types.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How does Variance affect function parameter types in TypeScript?",
    "options": [
      "Function parameters are covariant (allows stricter type)",
      "Function parameters are contravariant (allows wider type)",
      "Function parameters are invariant (must be exact match)",
      "Function parameters are bivariant (allows both stricter and wider)"
    ],
    "answer": "Function parameters are bivariant (allows both stricter and wider)",
    "explanation": "TypeScript treats function parameters as bivariant for compatibility reasons, though `strictFunctionTypes` enables stricter checking where parameters are contravariant (or invariant for methods).",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What does the `as const` assertion do to object literals?",
    "options": [
      "It casts the object to be immutable at runtime",
      "It infers literal types for all properties and makes them readonly",
      "It converts the object into a const variable declaration",
      "It enables object freezing for deep nested objects"
    ],
    "answer": "It infers literal types for all properties and makes them readonly",
    "explanation": "`as const` sets the inference mode to 'literal' instead of 'primitive' (e.g., `\"hello\"` instead of `string`) and adds `readonly` modifiers to all properties.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the behavior of the `unknown` type compared to `any`?",
    "options": [
      "`unknown` is the top type (like `any`) but forces type checking before usage",
      "`unknown` allows any operation without error",
      "`unknown` is strictly for objects that cannot be typed",
      "`unknown` is the bottom type equivalent to `never`"
    ],
    "answer": "`unknown` is the top type (like `any`) but forces type checking before usage",
    "explanation": "While `any` allows arbitrary actions (opting out of type safety), `unknown` requires you to narrow the type (via guards or assertions) before performing operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In TypeScript 5.0+, what feature allows variance annotations on type parameters?",
    "options": [
      "Using `in` and `out` keywords before generic parameters",
      "Using `covariant` and `contravariant` decorators",
      "Using `@ts-check` comments",
      "Setting `strictVariance` in tsconfig"
    ],
    "answer": "Using `in` and `out` keywords before generic parameters",
    "explanation": "TS 5.0+ allows explicit variance annotations using `out` for covariant (produces T) and `in` for contravariant (consumes T) on generic type parameters.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How do recursive types handle cycles in TypeScript?",
    "options": [
      "They throw a compile-time error immediately",
      "They are indistinguishable from infinite types",
      "They allow type aliases to reference themselves indirectly or directly with proper normalization",
      "They require the `--recursion` flag"
    ],
    "answer": "They allow type aliases to reference themselves indirectly or directly with proper normalization",
    "explanation": "TypeScript supports recursive type definitions (e.g., `type Json = string | number | boolean | Json[] | { [key: string]: Json }`) by normalizing the type alias.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What does the `Partial` utility type construct?",
    "options": [
      "A type with all properties of `T` set to `null`",
      "A type with all properties of `T` set to optional",
      "A type that extracts a subset of properties from `T`",
      "A type that makes all properties of `T` immutable"
    ],
    "answer": "A type with all properties of `T` set to optional",
    "explanation": "`Partial` maps over all keys of `T` and adds the `?` modifier to them, making every property optional.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "How do 'Assertion Functions' differ from Type Guards?",
    "options": [
      "Assertion functions return a boolean, whereas type guards return void",
      "Assertion functions throw an error if the condition is not met, used to signal failures to the compiler",
      "Assertion functions are only for classes, not primitives",
      "Assertion functions use `as` syntax instead of `is`"
    ],
    "answer": "Assertion functions throw an error if the condition is not met, used to signal failures to the compiler",
    "explanation": "Assertion functions (return type `asserts condition`) do not return a boolean but rather signal to the compiler that if the function completes, the condition must be true (often by throwing otherwise).",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What does `Parameters` extract?",
    "options": [
      "The parameter names as a string array",
      "The types of the parameters of a function type `T` as a tuple",
      "The return type of the function",
      "The `this` parameter type"
    ],
    "answer": "The types of the parameters of a function type `T` as a tuple",
    "explanation": "`Parameters` takes a function type and produces a tuple type of the types of the function's arguments in order.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "How do `enum` declarations with `const` modifier differ from regular `enum` declarations?",
    "options": [
      "`const enum` members are inlined at use sites and may not have a generated runtime object",
      "`const enum` prevents the use of string values",
      "`const enum` changes values to `readonly`",
      "`const enum` is scoped to the block"
    ],
    "answer": "`const enum` members are inlined at use sites and may not have a generated runtime object",
    "explanation": "During compilation, `const enum` members are replaced by their literal values where they are used, potentially removing the runtime object definition entirely.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the `NoInfer` utility type used for?",
    "options": [
      "To prevent TypeScript from inferring a specific type parameter from arguments",
      "To block inference for all generic parameters",
      "To cast a value to `never`",
      "To disable strict null checks locally"
    ],
    "answer": "To prevent TypeScript from inferring a specific type parameter from arguments",
    "explanation": "`NoInfer` wraps a type to block the compiler from inferring it from the call site, useful for forcing a specific generic argument or fixing inference conflicts.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "In a discriminated union, what property must be shared by all members for the compiler to narrow the union?",
    "options": [
      "A method named `discriminate`",
      "A single literal type property (e.g., `kind: 'circle'`)",
      "An optional index signature",
      "The same number of properties"
    ],
    "answer": "A single literal type property (e.g., `kind: 'circle'`)",
    "explanation": "A discriminated union requires a common property with a literal type in all members. TypeScript checks this property to narrow the specific type in the union.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the type of `Array.prototype.map` in TypeScript's standard library regarding the `this` parameter?",
    "options": [
      "It ignores the `this` parameter",
      "It captures `this` from the array instance",
      "It includes an explicit `this` parameter in the callback type",
      "It uses `void` for `this`"
    ],
    "answer": "It includes an explicit `this` parameter in the callback type",
    "explanation": "TypeScript's lib definitions include `this: void` or similar for array methods to indicate that the callback should not rely on a specific `this` context unless explicitly bound.",
    "difficulty": "Advanced"
  }
]