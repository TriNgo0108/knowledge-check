[
  {
    "id": 1,
    "question": "Which of the following clauses is logically executed first by the SQL engine when processing a query?",
    "options": [
      "SELECT",
      "FROM",
      "WHERE",
      "ORDER BY"
    ],
    "answer": "FROM",
    "explanation": "The logical order of operations starts with FROM (identifying the data source), followed by WHERE, GROUP BY, HAVING, and finally SELECT and ORDER BY. While SELECT appears first in the syntax, it is processed much later.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the result of comparing NULL to NULL using the equality operator (=) in standard SQL?",
    "options": [
      "TRUE",
      "FALSE",
      "UNKNOWN",
      "ERROR"
    ],
    "answer": "UNKNOWN",
    "explanation": "NULL represents an unknown value. In SQL's three-valued logic, any comparison involving NULL (including NULL = NULL) evaluates to UNKNOWN, not TRUE or FALSE.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which aggregate function ignores NULL values in its calculation?",
    "options": [
      "COUNT(*)",
      "COUNT(1)",
      "SUM(column_name)",
      "All aggregate functions ignore NULLs"
    ],
    "answer": "SUM(column_name)",
    "explanation": "Most aggregate functions, such as SUM, AVG, MIN, and MAX, ignore NULL values. However, COUNT(*) counts rows regardless of NULL content, whereas COUNT(column_name) ignores NULLs in that specific column.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary difference between a WHERE clause and a HAVING clause?",
    "options": [
      "WHERE filters groups; HAVING filters rows",
      "WHERE filters rows before aggregation; HAVING filters groups after aggregation",
      "HAVING is used for sorting; WHERE is for filtering",
      "There is no functional difference"
    ],
    "answer": "WHERE filters rows before aggregation; HAVING filters groups after aggregation",
    "explanation": "The WHERE clause filters individual records before they are grouped and aggregated. The HAVING clause is used specifically to filter the results of aggregate functions after the GROUP BY operation has occurred.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which join type returns all records from the left table, and matched records from the right table, filling with NULLs where there is no match?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "LEFT JOIN",
    "explanation": "A LEFT JOIN (or LEFT OUTER JOIN) prioritizes the left table, returning all its rows. If no match is found in the right table, the columns for the right table return NULL.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "In SQL, which constraint ensures that a column cannot contain NULL values?",
    "options": [
      "UNIQUE",
      "PRIMARY KEY",
      "NOT NULL",
      "CHECK"
    ],
    "answer": "NOT NULL",
    "explanation": "The NOT NULL constraint specifically enforces that a column must always contain a value. While PRIMARY KEY also implies NOT NULL, the explicit constraint for this purpose is NOT NULL.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What distinguishes UNION from UNION ALL when combining two SELECT statements?",
    "options": [
      "UNION sorts the results; UNION ALL does not",
      "UNION ALL includes duplicate rows; UNION removes them",
      "UNION is faster than UNION ALL",
      "UNION requires different data types; UNION ALL does not"
    ],
    "answer": "UNION ALL includes duplicate rows; UNION removes them",
    "explanation": "UNION removes duplicate rows from the combined result set, which incurs a performance penalty for sorting. UNION ALL simply appends the results, including duplicates, and is generally faster.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which wildcard character in a LIKE clause matches exactly one character?",
    "options": [
      "%",
      "_",
      "*",
      "?"
    ],
    "answer": "_",
    "explanation": "The underscore (_) represents a single character. The percent sign (%) represents zero or more characters.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which SQL keyword is used to eliminate duplicate rows from the result set of a query?",
    "options": [
      "UNIQUE",
      "SINGLE",
      "DISTINCT",
      "REDUCE"
    ],
    "answer": "DISTINCT",
    "explanation": "The DISTINCT keyword ensures that the query returns only unique rows, removing duplicates based on the selected columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the maximum number of columns allowed in a composite index in most relational databases?",
    "options": [
      "1",
      "2",
      "16",
      "There is no fixed theoretical maximum"
    ],
    "answer": "There is no fixed theoretical maximum",
    "explanation": "While there is often a practical limit (e.g., 32 or 64 depending on the specific DBMS like SQL Server or MySQL), the SQL standard does not define a theoretical maximum, allowing for composite indexes with many columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which data type is most appropriate for storing fixed-length alphanumeric data, such as a country code of exactly 2 characters?",
    "options": [
      "VARCHAR",
      "TEXT",
      "CHAR",
      "NVARCHAR"
    ],
    "answer": "CHAR",
    "explanation": "CHAR is a fixed-length string type. If the data length is constant and short (like 'US', 'UK'), CHAR is more efficient than VARCHAR, which handles variable length.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which clause is used to limit the number of rows returned by a query in SQL Server and PostgreSQL?",
    "options": [
      "TOP",
      "LIMIT",
      "FIRST",
      "ROWNUM"
    ],
    "answer": "LIMIT",
    "explanation": "While syntax varies by dialect (e.g., TOP for SQL Server, ROWNUM for Oracle), LIMIT is the standard keyword used in MySQL, PostgreSQL, and SQLite.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What happens when you attempt to insert a string into an INTEGER column?",
    "options": [
      "The string is truncated",
      "The database attempts implicit conversion, or returns an error if it fails",
      "The value is stored as 0",
      "The column type changes to VARCHAR"
    ],
    "answer": "The database attempts implicit conversion, or returns an error if it fails",
    "explanation": "SQL engines attempt to implicitly cast the value to the target type. If the string cannot be parsed as an integer, the query fails with a data conversion error.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which transaction control command saves all changes made during the current transaction?",
    "options": [
      "SAVEPOINT",
      "COMMIT",
      "ROLLBACK",
      "KEEP"
    ],
    "answer": "COMMIT",
    "explanation": "COMMIT permanently writes the transaction changes to the database. ROLLBACK undoes them, and SAVEPOINT creates a marker within a transaction.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What does the acronym ACID stand for in the context of database transactions?",
    "options": [
      "Atomicity, Consistency, Isolation, Durability",
      "Atomicity, Concurrency, Integrity, Durability",
      "Atomicity, Consistency, Indexing, Distribution",
      "Automatic, Concurrency, Isolation, Durability"
    ],
    "answer": "Atomicity, Consistency, Isolation, Durability",
    "explanation": "ACID properties ensure that database transactions are processed reliably. 'Atomicity' ensures all-or-nothing execution; 'Consistency' ensures validity; 'Isolation' ensures concurrent transactions don't interfere; and 'Durability' ensures saved data persists.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which join returns rows when there is a match in one of the tables, similar to the union of a Left and Right join?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "FULL OUTER JOIN",
      "CROSS JOIN"
    ],
    "answer": "FULL OUTER JOIN",
    "explanation": "A FULL OUTER JOIN combines the results of both LEFT and RIGHT joins. It returns all rows from both tables, matching them where possible and inserting NULLs where there is no match.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which function returns the first non-null value in a list of arguments?",
    "options": [
      "NULLIF",
      "ISNULL",
      "COALESCE",
      "IFNULL"
    ],
    "answer": "COALESCE",
    "explanation": "COALESCE takes a list of arguments and returns the first one that is not NULL. While ISNULL or IFNULL exist in specific dialects, COALESCE is the standard SQL ANSI function for this purpose.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the primary purpose of the CHECK constraint?",
    "options": [
      "To enforce referential integrity",
      "To enforce domain integrity by limiting values",
      "To create an index",
      "To ensure a column is unique"
    ],
    "answer": "To enforce domain integrity by limiting values",
    "explanation": "A CHECK constraint limits the range of values that can be placed in a column (e.g., Age >= 18). Referential integrity is handled by FOREIGN KEYs, and uniqueness by UNIQUE/PRIMARY KEY.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which operator is used to check if a value exists within a specific set of values?",
    "options": [
      "BETWEEN",
      "EXISTS",
      "IN",
      "LIKE"
    ],
    "answer": "IN",
    "explanation": "The IN operator allows you to specify multiple values in a WHERE clause (e.g., WHERE country IN ('USA', 'Canada')). EXISTS checks for the existence of rows returned by a subquery.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which of the following correctly describes a 'CROSS JOIN'?",
    "options": [
      "Joins two tables based on a common column",
      "Returns the Cartesian product of the two tables",
      "Filters rows based on a condition",
      "Joins tables and removes duplicates"
    ],
    "answer": "Returns the Cartesian product of the two tables",
    "explanation": "A CROSS JOIN does not use an ON clause. It combines every row from the first table with every row from the second table, producing a result set size of (Rows A * Rows B).",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which SQL keyword is used to rename a column or table in the output result set?",
    "options": [
      "CHANGE",
      "RENAME",
      "AS",
      "DEFINE"
    ],
    "answer": "AS",
    "explanation": "The AS keyword is used to create an alias. Some databases allow omitting AS (e.g., SELECT col1 newname), but AS is the standard explicit keyword.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the purpose of the GROUP BY clause?",
    "options": [
      "To sort the result set",
      "To filter rows",
      "To aggregate data into summary rows",
      "To join two tables"
    ],
    "answer": "To aggregate data into summary rows",
    "explanation": "GROUP BY arranges identical data into groups. It is essential when performing aggregate functions (COUNT, SUM) on specific subsets of data rather than the whole table.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which statement is used to grant specific permissions on database objects to a user?",
    "options": [
      "ALLOW",
      "PERMIT",
      "GRANT",
      "GIVE"
    ],
    "answer": "GRANT",
    "explanation": "The GRANT command is used in SQL Data Control Language (DCL) to give specific privileges (like SELECT, INSERT) to users.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which aggregate function calculates the arithmetic mean of a set of values?",
    "options": [
      "AVG",
      "SUM",
      "MEAN",
      "MEDIAN"
    ],
    "answer": "AVG",
    "explanation": "The AVG() function returns the average value of a numeric column. There is no standard aggregate function called MEAN or MEDIAN in basic SQL.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "In a correlated subquery, how is the inner query executed?",
    "options": [
      "Only once for the entire outer query",
      "Repeatedly for every row processed by the outer query",
      "Before the outer query",
      "In parallel with the outer query"
    ],
    "answer": "Repeatedly for every row processed by the outer query",
    "explanation": "A correlated subquery references a column from the outer query, forcing the inner query to execute once for each candidate row selected by the outer query.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the main benefit of using a Stored Procedure?",
    "options": [
      "It cannot be deleted",
      "It runs automatically when a table changes",
      "It allows reusable logic and reduced network traffic",
      "It bypasses all database security"
    ],
    "answer": "It allows reusable logic and reduced network traffic",
    "explanation": "Stored procedures encapsulate complex logic on the server side. This reduces network traffic by sending only the call to the procedure rather than the full query, and it promotes code reuse.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which command is used to delete a table definition and all its data from the database?",
    "options": [
      "DELETE",
      "TRUNCATE",
      "REMOVE",
      "DROP"
    ],
    "answer": "DROP",
    "explanation": "DROP is a DDL command that removes the table structure and data entirely. TRUNCATE removes data but keeps the structure, and DELETE removes data row by row.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which type of index creates an index on more than one column of a table?",
    "options": [
      "Unique Index",
      "Composite Index",
      "Clustered Index",
      "Bitmap Index"
    ],
    "answer": "Composite Index",
    "explanation": "A composite (or multicolumn) index is an index that uses two or more columns. It can speed up queries that filter on the leading columns of the index.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the default sorting order of the ORDER BY clause?",
    "options": [
      "Random",
      "Descending",
      "Ascending",
      "Hash"
    ],
    "answer": "Ascending",
    "explanation": "If no direction is specified, ORDER BY defaults to ASC (ascending). To sort in reverse, you must explicitly specify DESC.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which comparison operator selects values within a given range?",
    "options": [
      "IN",
      "RANGE",
      "BETWEEN",
      "WITHIN"
    ],
    "answer": "BETWEEN",
    "explanation": "The BETWEEN operator selects values within a given range. It is inclusive, meaning values equal to the start and end parameters are included.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which command is used to modify the structure of an existing table, such as adding a column?",
    "options": [
      "CHANGE TABLE",
      "UPDATE TABLE",
      "ALTER TABLE",
      "MODIFY TABLE"
    ],
    "answer": "ALTER TABLE",
    "explanation": "ALTER TABLE is the DDL command used to add, delete, or modify columns in an existing table. UPDATE is used to modify data, not structure.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is a 'View' in SQL?",
    "options": [
      "A backup copy of a table",
      "A virtual table based on the result-set of an SQL statement",
      "A synonym for an index",
      "The result of a JOIN operation"
    ],
    "answer": "A virtual table based on the result-set of an SQL statement",
    "explanation": "A View is a virtual table that does not store data physically. It stores the query, and when queried, it retrieves data from the underlying base tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which function returns the current date and time in standard SQL?",
    "options": [
      "GETDATE()",
      "NOW()",
      "CURRENT_TIMESTAMP",
      "SYSDATE()"
    ],
    "answer": "CURRENT_TIMESTAMP",
    "explanation": "CURRENT_TIMESTAMP is the ANSI SQL standard function for returning the current date and time. GETDATE() (SQL Server) and SYSDATE() (Oracle) are vendor-specific.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the result of '10 / 3' in SQL if both operands are integers?",
    "options": [
      "3.33",
      "3",
      "4",
      "ERROR"
    ],
    "answer": "3",
    "explanation": "In integer division, the fractional part is truncated. 10 divided by 3 is 3.33, but integer arithmetic returns 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which set operator returns rows that are returned by the first query but not by the second?",
    "options": [
      "UNION",
      "INTERSECT",
      "EXCEPT",
      "JOIN"
    ],
    "answer": "EXCEPT",
    "explanation": "EXCEPT (or MINUS in Oracle) returns the difference between two result sets. It outputs distinct rows from the left query that are not present in the right query.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What distinguishes a window function from a standard aggregate function in SQL?",
    "options": [
      "Window functions can only be used with an ORDER BY clause",
      "Window functions aggregate rows into a single output row per group",
      "Window functions perform calculations across a set of rows while retaining individual row details",
      "Window functions require a GROUP BY clause to define the scope of calculation"
    ],
    "answer": "Window functions perform calculations across a set of rows while retaining individual row details",
    "explanation": "Standard aggregate functions collapse rows into a single result per group (e.g., SUM, COUNT), whereas window functions perform calculations across a 'window' of related rows without collapsing the result set. The key distinction is that window functions preserve the original row granularity while adding aggregated data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Consider the SQL function `PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary)`. What is the primary difference between `PERCENTILE_CONT` and `PERCENTILE_DISC`?",
    "options": [
      "PERCENTILE_CONT returns a value from the set, while PERCENTILE_DISC interpolates a value",
      "PERCENTILE_CONT interpolates a continuous result, while PERCENTILE_DISC returns an exact value from the set",
      "PERCENTILE_CONT requires an integer input, while PERCENTILE_DISC accepts a float",
      "PERCENTILE_DISC is faster because it ignores nulls, whereas PERCENTILE_CONT includes them"
    ],
    "answer": "PERCENTILE_CONT interpolates a continuous result, while PERCENTILE_DISC returns an exact value from the set",
    "explanation": "`PERCENTILE_CONT` calculates a continuous percentile, potentially returning a value that does not exist in the data (interpolation). `PERCENTILE_DISC` returns a discrete value that must actually exist in the column's data set.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When using the `RANK()` window function in SQL, how are ties handled compared to `DENSE_RANK()`?",
    "options": [
      "RANK() assigns sequential numbers without gaps, while DENSE_RANK() includes gaps for ties",
      "Both functions handle ties identically, but RANK() requires an OVER clause",
      "RANK() assigns the same value to ties but skips subsequent numbers, creating gaps in the sequence",
      "RANK() assigns a unique number to every row regardless of ties"
    ],
    "answer": "RANK() assigns the same value to ties but skips subsequent numbers, creating gaps in the sequence",
    "explanation": "When ties occur, `RANK()` assigns the same rank to all tied rows but skips the next rank numbers (e.g., 1, 2, 2, 4). `DENSE_RANK()` assigns the same rank but does not skip numbers (e.g., 1, 2, 2, 3).",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which SQL clause is used to define a subset of rows for a window function to operate on, specifically limiting the scope relative to the current row?",
    "options": [
      "PARTITION BY",
      "GROUP BY",
      "FRAME CLAUSE",
      "HAVING"
    ],
    "answer": "FRAME CLAUSE",
    "explanation": "The `FRAME CLAUSE` (e.g., `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`) defines the specific subset of rows within the partition. `PARTITION BY` groups the data into windows, but the frame clause determines the 'vicinity' of rows surrounding the current row.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is a 'Covering Index' in the context of SQL query optimization?",
    "options": [
      "An index that includes all columns of the table to prevent table scans",
      "An index containing all columns retrieved by a query (SELECT, JOIN, WHERE) to avoid accessing the table heap",
      "A composite index that covers the Primary Key and Foreign Key constraints",
      "An index used exclusively to cover NULL values in a table"
    ],
    "answer": "An index containing all columns retrieved by a query (SELECT, JOIN, WHERE) to avoid accessing the table heap",
    "explanation": "A covering index includes all columns required by a specific query. This allows the engine to satisfy the query entirely from the index structure (Index Seek/Scan) without performing expensive lookups to the main table data (Key Lookups/RID Lookups).",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Why is the order of columns in a composite (multi-column) index significant for query performance?",
    "options": [
      "The index can only be used if the query selects the columns in the exact order they appear in the index definition",
      "The leading column determines the sort order; the query can only efficiently filter if it filters on the leftmost columns",
      "Columns are stored alphabetically regardless of definition order",
      "The order only affects storage size, not query retrieval logic"
    ],
    "answer": "The leading column determines the sort order; the query can only efficiently filter if it filters on the leftmost columns",
    "explanation": "B-Tree indexes store data sorted first by the leftmost column, then the next, and so on. A query can efficiently seek using the index only if it provides filters on the leading columns (left-prefix property); skipping the first column renders the standard index seek ineffective.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which join type is logically equivalent to using a `WHERE EXISTS` subquery to filter rows?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "SEMI JOIN",
      "CROSS JOIN"
    ],
    "answer": "SEMI JOIN",
    "explanation": "A Semi Join returns rows from the left table where a match exists in the right table, stopping after the first match (duplicates on the left are kept). `WHERE EXISTS` implements this logic; explicit `INNER JOIN` would duplicate left rows if multiple matches exist on the right.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the primary performance risk associated with using `SELECT *` in a production SQL query involving views or complex joins?",
    "options": [
      "It causes a full table scan on every table involved",
      "It breaks query caching mechanisms",
      "It leads to excessive network I/O and prevents the usage of covering indexes",
      "It forces the database to use a nested loop join"
    ],
    "answer": "It leads to excessive network I/O and prevents the usage of covering indexes",
    "explanation": "`SELECT *` retrieves all columns, increasing data transfer between database and application. It also negates the benefits of covering indexes (which are built on specific columns) and can cause schema binding issues if underlying tables change.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the context of SQL execution plans, what is a 'Key Lookup' (or Bookmark Lookup)?",
    "options": [
      "A search for the Primary Key in a clustered index",
      "An operation to retrieve non-key columns from the base table that were not present in a non-clustered index",
      "The process of finding the correct index to use for a query",
      "A scan of the entire index to find matching rows"
    ],
    "answer": "An operation to retrieve non-key columns from the base table that were not present in a non-clustered index",
    "explanation": "If a non-clustered index does not contain all columns needed for the query, the database must use the clustered index key (or Row ID) stored in the non-clustered index to look up the full row in the base table. This is a random I/O operation that can be expensive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "How does a Recursive Common Table Expression (CTE) terminate in SQL?",
    "options": [
      "It automatically terminates when the recursion depth exceeds 100 levels",
      "It stops when the recursive member returns an empty set",
      "It requires an explicit `BREAK` statement in the recursive member",
      "It terminates when it encounters a duplicate primary key"
    ],
    "answer": "It stops when the recursive member returns an empty set",
    "explanation": "A recursive CTE consists of an anchor member and a recursive member joined by `UNION ALL`. The execution continues iteratively until the recursive member produces no new rows, effectively stopping the recursion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the difference between `WHERE` and `HAVING` clauses in SQL aggregation?",
    "options": [
      "WHERE filters rows before aggregation; HAVING filters groups after aggregation",
      "WHERE filters groups; HAVING filters rows",
      "WHERE is used with SELECT; HAVING is used with UPDATE",
      "There is no difference; they are interchangeable"
    ],
    "answer": "WHERE filters rows before aggregation; HAVING filters groups after aggregation",
    "explanation": "The `WHERE` clause is evaluated prior to the grouping of rows (aggregation), removing individual rows. The `HAVING` clause is evaluated after `GROUP BY` aggregation is complete, filtering the aggregated groups themselves.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which SQL window function would you use to compare a value in the current row with a value in the subsequent row without using a self-join?",
    "options": [
      "LAG()",
      "LEAD()",
      "FIRST_VALUE()",
      "LAST_VALUE()"
    ],
    "answer": "LEAD()",
    "explanation": "The `LEAD()` function accesses data from a subsequent row in the result set based on a specified offset. `LAG()` accesses data from preceding rows, while `FIRST_VALUE` and `LAST_VALUE` refer to the frame boundaries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the default frame specification for an SQL window function if an `ORDER BY` is used but no explicit frame is defined?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "ROWS BETWEEN CURRENT ROW AND CURRENT ROW",
      "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"
    ],
    "answer": "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "When `ORDER BY` is present, the default window frame includes all rows from the start of the partition up to the current row. This default uses `RANGE` logic (allowing for peer handling) rather than strict `ROWS` offset logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Why might a database optimizer choose a Table Scan over an Index Seek, even when an index exists on the filtered column?",
    "options": [
      "The database prefers to read sequential data from disk over random access",
      "The index is corrupted and needs to be rebuilt",
      "The query contains a DISTINCT clause",
      "The index is not clustered"
    ],
    "answer": "The database prefers to read sequential data from disk over random access",
    "explanation": "If the query retrieves a large percentage of rows from the table (high selectivity), the cost of random I/O from an index seek plus lookups often exceeds the cost of a sequential table scan. The optimizer chooses the scan for efficiency on high-volume data retrieval.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the 'SARGable' concept in SQL query writing?",
    "options": [
      "Ensuring the query is safe against SQL injection",
      "Writing predicates in a way that allows the engine to utilize indexes efficiently (Search ARGument ABLE)",
      "Ensuring all tables are indexed before running the query",
      "Formatting the SQL code to be readable by humans"
    ],
    "answer": "Writing predicates in a way that allows the engine to utilize indexes efficiently (Search ARGument ABLE)",
    "explanation": "SARGable refers to predicates that can be resolved efficiently using an index (e.g., `WHERE col = 5`). Operations like wrapping a column in a function (e.g., `WHERE YEAR(date) = 2023`) are generally non-SARGable because they force an index scan rather than a seek.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the result of `NULLIF(1, 1)` in SQL?",
    "options": [
      "1",
      "0",
      "NULL",
      "ERROR"
    ],
    "answer": "NULL",
    "explanation": "The `NULLIF` expression returns NULL if the two arguments are equal. Since 1 equals 1, the result is NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does a Clustered Index sort data in a database table?",
    "options": [
      "It creates a separate structure that points to the data rows",
      "It sorts and stores the data rows physically on disk based on the key columns",
      "It sorts only the non-clustered indexes",
      "It stores data in a random order for faster inserts"
    ],
    "answer": "It sorts and stores the data rows physically on disk based on the key columns",
    "explanation": "A clustered index determines the physical order of data in a table. The table data is the leaf level of the clustered index; therefore, there can be only one clustered index per table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "In the context of SQL transactions, what does the isolation level 'READ UNCOMMITTED' allow?",
    "options": [
      "Reads that only see committed data, preventing dirty reads",
      "Reads that bypass locks to read data currently being modified by other transactions (Dirty Reads)",
      "Reads that lock the entire table for the duration of the transaction",
      "Reads that wait indefinitely if data is locked"
    ],
    "answer": "Reads that bypass locks to read data currently being modified by other transactions (Dirty Reads)",
    "explanation": "READ UNCOMMITTED is the lowest isolation level. It allows a transaction to read data that has been modified but not yet committed by other transactions, leading to 'dirty reads'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the primary function of the `COALESCE` function in SQL?",
    "options": [
      "It combines two strings into one",
      "It returns the first non-NULL expression among its arguments",
      "It converts a NULL value to 0",
      "It checks if all arguments are NULL"
    ],
    "answer": "It returns the first non-NULL expression among its arguments",
    "explanation": "`COALESCE` takes a list of arguments and evaluates them in order. It returns the value of the first argument that is not NULL. If all arguments are NULL, it returns NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which set operator returns distinct rows from the combined result sets of two queries?",
    "options": [
      "UNION ALL",
      "UNION",
      "INTERSECT ALL",
      "EXCEPT ALL"
    ],
    "answer": "UNION",
    "explanation": "`UNION` combines the result sets of two queries and removes duplicate rows. `UNION ALL` combines them but retains duplicates, which is generally faster because it skips the duplicate elimination step.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the difference between `DELETE` and `TRUNCATE`?",
    "options": [
      "DELETE can be rolled back, while TRUNCATE cannot",
      "TRUNCATE is a DDL operation that deallocates data pages and cannot use a WHERE clause",
      "DELETE removes the table structure, while TRUNCATE only removes data",
      "TRUNCATE fires triggers, while DELETE does not"
    ],
    "answer": "TRUNCATE is a DDL operation that deallocates data pages and cannot use a WHERE clause",
    "explanation": "`TRUNCATE` is a DDL command that marks data pages for deallocation (effectively emptying the table instantly) and cannot filter rows with a WHERE clause. `DELETE` is a DML command that logs row-by-row deletions and allows filtering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which SQL clause is used to perform a 'Cross Join' between two tables?",
    "options": [
      "JOIN ON ...",
      "NATURAL JOIN",
      "CROSS JOIN or using a JOIN with no ON condition",
      "FULL OUTER JOIN"
    ],
    "answer": "CROSS JOIN or using a JOIN with no ON condition",
    "explanation": "A Cross Join returns the Cartesian product of the two tables, meaning every row from the first table is joined to every row of the second table. This is specified by `CROSS JOIN` or implicitly by omitting the join condition in standard SQL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the purpose of the `PARTITION BY` clause inside an `OVER()` statement for window functions?",
    "options": [
      "To sort the rows within the window",
      "To limit the number of rows returned by the function",
      "To divide the result set into partitions to which the window function is applied independently",
      "To create physical table partitions"
    ],
    "answer": "To divide the result set into partitions to which the window function is applied independently",
    "explanation": "`PARTITION BY` logically groups the result set into 'buckets' or partitions. The window function calculation resets for each partition, operating independently within that specific group of rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When using the `CUME_DIST()` function in SQL, what does a return value of 1.0 indicate?",
    "options": [
      "The current row is the first row in the set",
      "The current row has the highest value in the set",
      "The current row is the last row in the set (or tied for last)",
      "The set contains 100 rows"
    ],
    "answer": "The current row is the last row in the set (or tied for last)",
    "explanation": "`CUME_DIST()` calculates the cumulative distribution of a value in a set, ranging from 0 to 1. A value of 1.0 indicates that the current row is the maximum value or last position within the partition (100% of rows are <= this value).",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "In a SQL execution plan, what does a 'Hash Match' (Inner Join) operator typically indicate?",
    "options": [
      "The join is performed on two sorted sets of data",
      "The join is performed by iterating over one row set for every row in the other",
      "The join is performed by building a hash table on the smaller input and probing it with the larger input",
      "The join is performed using a full text index"
    ],
    "answer": "The join is performed by building a hash table on the smaller input and probing it with the larger input",
    "explanation": "A Hash Match Join is efficient for large, unsorted inputs. It builds a hash table in memory from one input (usually the smaller table) and probes it with rows from the other input to find matches.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the 'N+1 select problem' in the context of database applications?",
    "options": [
      "Executing one query to get a list of items, and then N queries to get details for each item",
      "Using N+1 tables in a single JOIN query",
      "A query that returns N+1 rows more than expected",
      "A recursive CTE that executes N+1 times"
    ],
    "answer": "Executing one query to get a list of items, and then N queries to get details for each item",
    "explanation": "The N+1 problem occurs when an application executes an initial query (1) to retrieve a list of records, and then subsequently executes a separate query for each of the N records to fetch related data. This generates massive network traffic and load.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the result of `SELECT SUBSTRING('SQL', 0, 1)` in many SQL dialects (like T-SQL)?",
    "options": [
      "'S'",
      "'Q'",
      "'' (Empty string) or Error",
      "NULL"
    ],
    "answer": "'' (Empty string) or Error",
    "explanation": "While 1-based indexing is standard (starting at 1), passing 0 as a start position often results in an empty string or an error depending on the specific SQL dialect (e.g., PostgreSQL returns empty string, some others error). It generally does not return the first character.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which of the following correctly describes the `GROUPING SETS` extension?",
    "options": [
      "It allows filtering of groups based on a condition",
      "It allows generating multiple grouping levels in a single query pass",
      "It sorts the groups in descending order",
      "It merges two separate GROUP BY queries into a FULL OUTER JOIN"
    ],
    "answer": "It allows generating multiple grouping levels in a single query pass",
    "explanation": "`GROUPING SETS` defines multiple groupings within a single `GROUP BY` clause. It effectively generates a result set equivalent to the `UNION ALL` of several aggregation queries with different groupings in one efficient pass.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Why is `TRUNCATE` generally faster than `DELETE` when removing all data?",
    "options": [
      "TRUNCATE operates asynchronously in the background",
      "TRUNCATE logs page deallocations rather than logging individual row deletions",
      "TRUNCATE drops the table and recreates it",
      "TRUNCATE bypasses the transaction log"
    ],
    "answer": "TRUNCATE logs page deallocations rather than logging individual row deletions",
    "explanation": "`DELETE` scans the table and logs every single row deletion in the transaction log. `TRUNCATE` simply deallocates the data pages used to store the table data, logging only the page deallocation, which is near-instantaneous.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What does the `ANY` or `SOME` operator do in a SQL subquery?",
    "options": [
      "It returns TRUE if the subquery returns any rows at all",
      "It returns TRUE if the comparison between the column value and ANY value in the list returns TRUE",
      "It returns the first value found in the subquery",
      "It checks if all values in the subquery are equal"
    ],
    "answer": "It returns TRUE if the comparison between the column value and ANY value in the list returns TRUE",
    "explanation": "The `ANY` operator is used with a comparison operation (e.g., `> ANY`). It returns true if the comparison is true for at least one of the values returned by the subquery.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which SQL constraint ensures that a column cannot contain NULL values?",
    "options": [
      "UNIQUE",
      "PRIMARY KEY",
      "NOT NULL",
      "CHECK"
    ],
    "answer": "NOT NULL",
    "explanation": "The `NOT NULL` constraint enforces that a column must have a value; attempting to insert a NULL will fail. While `PRIMARY KEY` also implies `NOT NULL`, the `NOT NULL` constraint is the specific mechanism designed for this purpose.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In PostgreSQL or standard SQL, what is the syntax for a 'Lateral Join' (`LATERAL` key word)?",
    "options": [
      "It allows the right side of the join to reference columns from the left side",
      "It creates a cross join that ignores duplicate rows",
      "It forces the join to be evaluated in parallel",
      "It prevents the optimizer from using indexes"
    ],
    "answer": "It allows the right side of the join to reference columns from the left side",
    "explanation": "A `LATERAL` join allows a subquery or table-valued function on the right side of the join to reference columns from tables appearing on the left side of the join. This enables correlated subqueries to be executed efficiently in a `FROM` or `JOIN` context.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is a 'Materialized View' compared to a standard 'View'?",
    "options": [
      "A standard view stores data physically; a materialized view does not",
      "A materialized view stores the result of the query physically on disk and must be refreshed",
      "A materialized view is read-only, while standard views are always updatable",
      "There is no difference; they are synonyms"
    ],
    "answer": "A materialized view stores the result of the query physically on disk and must be refreshed",
    "explanation": "A standard view is just a stored query that runs at execution time. A materialized view pre-computes and stores the result set physically; it offers faster reads but requires a refresh process to update data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the primary use case for the `ROW_NUMBER()` window function?",
    "options": [
      "Calculating a running total",
      "Assigning a unique sequential integer to rows within a partition, regardless of ties",
      "Finding gaps in ID sequences",
      "Ranking items by value, skipping numbers on ties"
    ],
    "answer": "Assigning a unique sequential integer to rows within a partition, regardless of ties",
    "explanation": "`ROW_NUMBER()` assigns a unique number to every row (1, 2, 3). Unlike `RANK()` or `DENSE_RANK()`, it does not handle ties specially; if two rows have the same value, they will get different arbitrary row numbers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "When defining a `FOREIGN KEY` constraint, what does `ON DELETE CASCADE` do?",
    "options": [
      "It prevents the deletion of a parent record if child records exist",
      "It sets the foreign key value in child records to NULL if the parent record is deleted",
      "It automatically deletes child records when the parent record is deleted",
      "It defaults to deleting the child table"
    ],
    "answer": "It automatically deletes child records when the parent record is deleted",
    "explanation": "`ON DELETE CASCADE` ensures referential integrity by propagating a deletion. If a row in the parent table is deleted, the database automatically deletes all corresponding rows in the child table that reference that primary key.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of SQL window functions, what is the specific functional difference between using the `ROWS` frame clause versus the `RANGE` frame clause when defining a window frame?",
    "options": [
      "`ROWS` operates on physical offsets, while `RANGE` operates on logical values, treating peers (ties) as a single group.",
      "`ROWS` calculates percentiles, while `RANGE` calculates rankings.",
      "`ROWS` requires an `ORDER BY` clause, whereas `RANGE` does not.",
      "`ROWS` allows aggregation, while `RANGE` is restricted to ranking functions."
    ],
    "answer": "`ROWS` operates on physical offsets, while `RANGE` operates on logical values, treating peers (ties) as a single group.",
    "explanation": "`RANGE` considers the values of the `ORDER BY` column; if multiple rows share the same value (peers), they are included in the frame boundary. `ROWS` strictly counts a specific number of physical rows relative to the current row, regardless of value duplication.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Consider a composite B-Tree index on columns `(A, B, C)`. Which of the following query predicates will **NOT** be able to perform an index seek (traversal) using this index?",
    "options": [
      "WHERE A = 1 AND B = 2",
      "WHERE A = 1 AND C = 3",
      "WHERE A = 1 AND B > 5 AND C = 2",
      "WHERE A = 1 ORDER BY B"
    ],
    "answer": "WHERE A = 1 AND C = 3",
    "explanation": "B-Tree indexes are left-prefixed. To use the index for seeking, the query must filter on the leading column (A). Once column B is skipped in the `WHERE` clause (jumping to C), the database cannot use the ordered structure to seek on C efficiently without scanning the range defined by A.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary technical risk associated with using the `NOT IN` predicate against a subquery that returns NULL values?",
    "options": [
      "The query will throw a constraint violation error.",
      "The query will return an empty result set due to NULL propagation and three-valued logic.",
      "The query will perform a full table scan regardless of indexes.",
      "The database engine will automatically convert `NOT IN` to `NOT EXISTS`."
    ],
    "answer": "The query will return an empty result set due to NULL propagation and three-valued logic.",
    "explanation": "SQL uses three-valued logic (TRUE, FALSE, UNKNOWN). If the subquery returns a NULL, the comparison `val != NULL` evaluates to `UNKNOWN`, causing the `NOT IN` condition to filter out all rows, effectively returning an empty set even if matches exist.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "In PostgreSQL, what is the definition of a 'Covering Index', and how does it improve query performance?",
    "options": [
      "An index that includes all columns of the table, eliminating the need for the heap table.",
      "An index containing all columns retrieved by a specific query (SELECT, JOIN, WHERE), allowing the index-only scan to bypass the heap.",
      "An index that spans multiple tables using a foreign key to cover joins.",
      "An index created automatically by the optimizer to cover the most frequent queries."
    ],
    "answer": "An index containing all columns retrieved by a specific query (SELECT, JOIN, WHERE), allowing the index-only scan to bypass the heap.",
    "explanation": "A covering index includes all columns required by the query. This enables an 'Index-Only Scan,' where the database retrieves data directly from the index structure without looking up the corresponding rows in the main table (heap), drastically reducing I/O.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When writing a Recursive CTE (Common Table Expression), which clause is strictly required to prevent the recursion from running infinitely?",
    "options": [
      "The `LIMIT` clause",
      "The `UNION ALL` terminator",
      "The `CYCLE` clause (or equivalent manual check) to stop recursion on a detected loop",
      "The `MAXRECURSION` hint"
    ],
    "answer": "The `CYCLE` clause (or equivalent manual check) to stop recursion on a detected loop",
    "explanation": "Without a mechanism to detect cycles (like the `CYCLE` clause in standard SQL or checking `depth` in the `WHERE` clause), a recursive CTE on a graph with cycles will enter an infinite loop. `MAXRECURSION` is a safety limit, not a structural logic check.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the fundamental difference between `RANK()` and `DENSE_RANK()` window functions regarding tie-handling?",
    "options": [
      "`RANK()` assigns a unique number to every row, while `DENSE_RANK()` skips numbers.",
      "`RANK()` returns 1 for the top row, while `DENSE_RANK()` returns 0.",
      "`RANK()` leaves gaps in the sequence when there are ties (e.g., 1, 2, 2, 4), while `DENSE_RANK()` does not (e.g., 1, 2, 2, 3).",
      "`DENSE_RANK()` can only be used with numeric types, whereas `RANK()` works with strings."
    ],
    "answer": "`RANK()` leaves gaps in the sequence when there are ties (e.g., 1, 2, 2, 4), while `DENSE_RANK()` does not (e.g., 1, 2, 2, 3).",
    "explanation": "When rows tie, both assign the same rank. However, `RANK()` counts the tied rows to determine the next rank (creating a gap), whereas `DENSE_RANK()` increments the rank by exactly 1 for the next distinct value.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Why is a `LATERAL` join necessary when joining to a table-valued function (or subquery) that references columns from a previous table in the same `FROM` clause?",
    "options": [
      "Standard SQL does not allow subqueries in the `FROM` clause.",
      "The optimizer cannot flatten the query without the `LATERAL` keyword.",
      "Without `LATERAL`, the right side of the join cannot reference columns from the left side because the right side is evaluated independently.",
      "`LATERAL` is required to enforce the join order."
    ],
    "answer": "Without `LATERAL`, the right side of the join cannot reference columns from the left side because the right side is evaluated independently.",
    "explanation": "In a standard join, each table expression is evaluated independently. `LATERAL` allows the subquery to reference values from the preceding table expression on the left side of the join, effectively iterating over the source row-by-row.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the specific performance impact of using the `SELECT *` syntax in a high-volume OLTP application?",
    "options": [
      "It locks the entire table for the duration of the transaction.",
      "It prevents the use of Covering Indexes and increases network I/O by fetching unnecessary columns.",
      "It forces the database to use a Table Scan instead of an Index Scan.",
      "It causes fragmentation in the index pages."
    ],
    "answer": "It prevents the use of Covering Indexes and increases network I/O by fetching unnecessary columns.",
    "explanation": "`SELECT *` retrieves all columns. If an index does not contain all columns, the database must perform expensive Key Lookups (or Row Fetches) to get the missing data from the heap, and it consumes bandwidth transferring data that the application might not need.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the context of ACID properties, how does 'Isolation' level 'Read Committed' differ from 'Repeatable Read' regarding phenomena?",
    "options": [
      "Read Committed prevents Non-Repeatable Reads, while Repeatable Read prevents Phantoms.",
      "Read Committed prevents Phantoms, while Repeatable Read prevents Dirty Reads.",
      "Read Committed prevents Dirty Reads but allows Non-Repeatable Reads; Repeatable Read prevents Non-Repeatable Reads but may allow Phantoms.",
      "Read Committed allows Dirty Reads; Repeatable Read prevents them."
    ],
    "answer": "Read Committed prevents Dirty Reads but allows Non-Repeatable Reads; Repeatable Read prevents Non-Repeatable Reads but may allow Phantoms.",
    "explanation": "Read Committed only guarantees you see committed data. If you read twice, the data might change (Non-Repeatable Read). Repeatable Read guarantees that if you read a row twice, the value is the same (locking the row), though new rows might appear (Phantoms) depending on the implementation.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the 'Optimization Fence' behavior associated with Common Table Expresses (CTEs) in PostgreSQL (prior to v12) and some other databases?",
    "options": [
      "The CTE is materialized into a temporary store, preventing predicate pushdown into the CTE definition.",
      "The CTE is fully optimized and merged into the main query plan like a subquery.",
      "The CTE cannot contain window functions.",
      "The CTE forces a parallel execution plan."
    ],
    "answer": "The CTE is materialized into a temporary store, preventing predicate pushdown into the CTE definition.",
    "explanation": "Historically, optimizing a CTE required materializing the entire result set first. This acts as a fence, stopping the optimizer from moving specific filters (`WHERE` clauses) from the outer query into the CTE logic, which can harm performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Consider an index on a string column. Why might a query using `WHERE LOWER(name) = 'bob'` fail to use the index effectively, even if the index exists?",
    "options": [
      "The index is stored in binary format.",
      "The function applied to the column (`LOWER(name)`) forces a row-by-row scan (Function Dependency) rather than a lookup against the raw index values.",
      "String indexes are automatically case-insensitive.",
      "The query requires a composite index on `(name, id)`."
    ],
    "answer": "The function applied to the column (`LOWER(name)`) forces a row-by-row scan (Function Dependency) rather than a lookup against the raw index values.",
    "explanation": "Standard B-Tree indexes store the raw values of the column. Wrapping the column in a function (`LOWER`) means the database must compute the function for every row to compare it, rendering the standard index useless unless a functional index (on `LOWER(name)`) exists.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In a columnar storage database (used often for OLAP), what is the primary technical advantage of this architecture over Row-based storage (OLTP) for analytical queries?",
    "options": [
      "Single-row inserts are faster due to memory locality.",
      "Only the required columns for a query are read from disk, significantly reducing I/O for wide tables.",
      "Foreign keys are enforced more strictly.",
      "ACID compliance is higher in columnar databases."
    ],
    "answer": "Only the required columns for a query are read from disk, significantly reducing I/O for wide tables.",
    "explanation": "Analytical queries often access only a few columns (e.g., sum of sales) across millions of rows. Columnar storage stores data for each column contiguously, allowing the engine to read only the specific column data pages and ignore the rest of the table.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What distinguishes an `Anti-Join` pattern from a standard `LEFT JOIN` when filtering for non-matching records?",
    "options": [
      "An Anti-Join uses `WHERE NOT EXISTS`, which often stops scanning upon finding the first match (semi-join behavior), whereas `LEFT JOIN ... WHERE right.id IS NULL` must potentially join all matches.",
      "An Anti-Join creates a Cartesian product.",
      "An Anti-Join is a reserved keyword in SQL, unlike `LEFT JOIN`.",
      "There is no performance difference; the query optimizer treats them identically."
    ],
    "answer": "An Anti-Join uses `WHERE NOT EXISTS`, which often stops scanning upon finding the first match (semi-join behavior), whereas `LEFT JOIN ... WHERE right.id IS NULL` must potentially join all matches.",
    "explanation": "`NOT EXISTS` is a semi-join anti-pattern; the optimizer stops looking for a row in the right table as soon as it finds *one* match. `LEFT JOIN` constructs a result set containing all matches before filtering, which can be more expensive.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the purpose of the `VACUUM` operation in PostgreSQL (and similar processes in other MVCC databases)?",
    "options": [
      "To update the statistics used by the query planner.",
      "To reclaim storage occupied by dead tuples (rows that are no longer visible to any transaction).",
      "To rebuild all indexes from scratch.",
      "To defragment the file system on the hard drive."
    ],
    "answer": "To reclaim storage occupied by dead tuples (rows that are no longer visible to any transaction).",
    "explanation": "MVCC systems create new versions of rows on updates/deletes, leaving old versions behind. `VACUUM` scans for these 'dead' tuples that are no longer visible to any active transaction and marks the space as reusable for future data.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How does the `GROUPING SETS` extension differ from a standard `GROUP BY` clause?",
    "options": [
      "`GROUPING SETS` allows calculating multiple levels of aggregation in a single query pass, avoiding the need for multiple `UNION ALL` statements.",
      "`GROUPING SETS` applies a filter to the groups before aggregation.",
      "`GROUPING SETS` sorts the data before grouping.",
      "`GROUPING SETS` is limited to only two columns."
    ],
    "answer": "`GROUPING SETS` allows calculating multiple levels of aggregation in a single query pass, avoiding the need for multiple `UNION ALL` statements.",
    "explanation": "Without `GROUPING SETS`, generating reports with subtotals and grand totals requires writing separate queries (often using `ROLLUP` or `CUBE`) and combining them with `UNION ALL`. `GROUPING SETS` lets you define all groupings in one clause.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In the context of execution plans, what is a 'Hash Join', and in which scenario is it typically most efficient?",
    "options": [
      "It is efficient for joining large, unsorted, unindexed datasets by building a hash table of the smaller input in memory.",
      "It is efficient for joining sorted datasets by merging streams.",
      "It is efficient for small lookups using a Nested Loop iteration.",
      "It is used primarily for Full Text Search indexes."
    ],
    "answer": "It is efficient for joining large, unsorted, unindexed datasets by building a hash table of the smaller input in memory.",
    "explanation": "A Hash Join builds an in-memory hash table (or spills to disk) from one input and probes it with the other. It is generally the fastest algorithm for large datasets where no useful index exists for a Merge Join.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the function of the `WITH (NOLOCK)` hint in SQL Server (Transaction Isolation Level Read Uncommitted)?",
    "options": [
      "It locks the table permanently to prevent schema changes.",
      "It allows reading data that is currently being modified by other transactions, potentially reading uncommitted or 'dirty' data.",
      "It forces the query to wait for locks to be released.",
      "It creates a snapshot of the data."
    ],
    "answer": "It allows reading data that is currently being modified by other transactions, potentially reading uncommitted or 'dirty' data.",
    "explanation": "`NOLOCK` (or Read Uncommitted) bypasses standard locking protocols. This removes read-blocking but introduces the risk of reading data that might be rolled back later (Dirty Reads) or reading data multiple times/not at all.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the 'Lost Update' problem in concurrency control?",
    "options": [
      "Two transactions read the same value and update it, with the second update overwriting the first one based on stale read data.",
      "A transaction is lost due to a network failure.",
      "A transaction updates a row that has already been deleted.",
      "The database log is lost."
    ],
    "answer": "Two transactions read the same value and update it, with the second update overwriting the first one based on stale read data.",
    "explanation": "Lost Update occurs when Transaction A reads V, Transaction B reads V, both calculate V+1, and both write. The final result is V+1 (or just B's version), effectively losing A's update logic because neither locked the resource exclusively during the read.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "When is the `NATURAL JOIN` syntax generally discouraged in production engineering?",
    "options": [
      "It is slower than explicit `INNER JOIN`.",
      "It relies on implicit column names to determine the join condition, which is fragile to schema changes and creates ambiguity.",
      "It does not support `ON` clauses.",
      "It creates a Cartesian product."
    ],
    "answer": "It relies on implicit column names to determine the join condition, which is fragile to schema changes and creates ambiguity.",
    "explanation": "A `NATURAL JOIN` automatically joins columns with the same name. If a column is added to both tables later, the join behavior changes silently. Explicit `ON` clauses are safer and more maintainable.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "In database normalization, what specific anomaly does the Third Normal Form (3NF) aim to prevent that Second Normal Form (2NF) does not?",
    "options": [
      "Partial dependency of non-key attributes on a composite key.",
      "Transitive dependency of non-key attributes on other non-key attributes.",
      "Multi-valued dependencies.",
      "Insertion anomalies only."
    ],
    "answer": "Transitive dependency of non-key attributes on other non-key attributes.",
    "explanation": "2NF addresses partial dependencies (attributes depending on only part of a composite key). 3NF goes further to eliminate transitive dependencies, where non-key attributes depend on other non-key attributes rather than directly on the primary key.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the primary disadvantage of using a UUID (specifically UUID v4) as a Primary Key in a high-write B-Tree indexed table?",
    "options": [
      "UUIDs run out of unique values faster than integers.",
      "The random nature of UUID v4 causes high index fragmentation and page splitting because new values are inserted randomly rather than sequentially at the end.",
      "UUIDs are incompatible with Foreign Keys.",
      "Querying a UUID requires more CPU than querying an Integer."
    ],
    "answer": "The random nature of UUID v4 causes high index fragmentation and page splitting because new values are inserted randomly rather than sequentially at the end.",
    "explanation": "B-Trees perform best with sequential inserts (filling leaf pages). Random UUIDs force the database to insert rows into random leaf pages, causing expensive page splits, cache misses, and fragmentation.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "How does `PERCENTILE_CONT()` differ from `PERCENTILE_DISC()` in SQL window functions?",
    "options": [
      "`PERCENTILE_CONT()` returns a value from the set, while `PERCENTILE_DISC()` interpolates.",
      "`PERCENTILE_CONT()` interpolates a continuous value (which may not exist in the set), while `PERCENTILE_DISC()` returns an actual value from the set.",
      "`PERCENTILE_CONT()` works only on integers, while `PERCENTILE_DISC()` works on floats.",
      "There is no difference; they are aliases."
    ],
    "answer": "`PERCENTILE_CONT()` interpolates a continuous value (which may not exist in the set), while `PERCENTILE_DISC()` returns an actual value from the set.",
    "explanation": "If the desired percentile falls between two values (e.g., median of 4 and 10), `PERCENTILE_CONT` calculates 8.0 (interpolation). `PERCENTILE_DISC` returns 4 or 10, whichever is closer (or defined by the implementation), but always a discrete value present in the data.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the 'Halting Problem' in the context of Recursive CTEs?",
    "options": [
      "The database crashing due to recursion.",
      "Determining if a recursive CTE will stop or run infinitely is undecidable for the optimizer in the general case.",
      "The `LIMIT` clause failing.",
      "The inability to use aggregates."
    ],
    "answer": "Determining if a recursive CTE will stop or run infinitely is undecidable for the optimizer in the general case.",
    "explanation": "Because recursive CTEs can contain complex logic and termination conditions, the query planner cannot mathematically prove in all cases whether the recursion will terminate. This is why manual limits (like `MAXRECURSION`) are often enforced.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is 'Write Amplification' in the context of database indexing?",
    "options": [
      "The phenomenon where a single logical update requires multiple physical I/O writes to update the table and all associated indexes.",
      "The database writing data to multiple replicas.",
      "Writing the data to the Write-Ahead Log (WAL) and the data file.",
      "Compressing data before writing."
    ],
    "answer": "The phenomenon where a single logical update requires multiple physical I/O writes to update the table and all associated indexes.",
    "explanation": "Every index on a table must be updated when the indexed columns change. More indexes mean more writes to disk (amplification), slowing down INSERT/UPDATE/DELETE performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Which type of Join algorithm is most efficient when joining a small table (build input) to a very large table (probe input) where no indexes exist?",
    "options": [
      "Nested Loop Join",
      "Hash Join",
      "Merge Join",
      "Cartesian Join"
    ],
    "answer": "Hash Join",
    "explanation": "A Hash Join loads the smaller table into a hash table in memory (once) and then streams through the large table once to check for matches. A Nested Loop would scan the large table repeatedly (once per row in the small table), and Merge Sort is expensive if data isn't sorted.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the 'Phantom Read' anomaly?",
    "options": [
      "Reading data that has been modified but not committed.",
      "Reading the same row twice and getting different values.",
      "Executing the same query twice within a transaction and retrieving a different set of rows because new rows were added by another transaction.",
      "Reading non-existent data."
    ],
    "answer": "Executing the same query twice within a transaction and retrieving a different set of rows because new rows were added by another transaction.",
    "explanation": "Phantom reads occur when a transaction reads a set of rows matching a condition, and another transaction inserts/deletes a row that matches that condition. The first transaction sees 'phantoms' (new or missing rows) if it re-runs the query.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Why is a 'Clustered Index' on a column that is frequently updated generally bad for performance?",
    "options": [
      "Clustered indexes do not support updates.",
      "Updating the clustering key forces the row to physically move on disk, causing fragmentation and forwarded records.",
      "It forces the table to be converted to a heap.",
      "It increases the size of the transaction log."
    ],
    "answer": "Updating the clustering key forces the row to physically move on disk, causing fragmentation and forwarded records.",
    "explanation": "The clustering key determines the physical order of data. If the key changes, the row must move to a new location to maintain sort order. This moves are expensive, cause page fragmentation, and leave forwarding pointers.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the primary function of the `CHECK` constraint in SQL?",
    "options": [
      "To validate data integrity by ensuring a column's value satisfies a boolean predicate (e.g., price > 0).",
      "To check if a table exists before dropping it.",
      "To validate foreign key relationships.",
      "To grant permissions on a table."
    ],
    "answer": "To validate data integrity by ensuring a column's value satisfies a boolean predicate (e.g., price > 0).",
    "explanation": "`CHECK` constraints enforce domain integrity. They limit the values that can be placed in a column (e.g., `age >= 18`). They are evaluated on `INSERT` or `UPDATE`.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "In a `PARTITIONED` table, what is 'Partition Pruning'?",
    "options": [
      "The process of deleting old partitions.",
      "The optimizer skipping scanning of partitions that cannot contain data relevant to the query based on the WHERE clause.",
      "The process of merging two partitions into one.",
      "Rebuilding indexes on partitions."
    ],
    "answer": "The optimizer skipping scanning of partitions that cannot contain data relevant to the query based on the WHERE clause.",
    "explanation": "If a table is partitioned by date (e.g., by year) and the query asks for `WHERE year = 2023`, the engine can 'prune' (ignore) all physical storage partitions for years 2020-2022, significantly reducing I/O.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the 'Write-Ahead Log' (WAL) protocol?",
    "options": [
      "Data must be written to the log file on stable storage before it is written to the actual data file.",
      "Data must be written to the data file before the log.",
      "Data is written simultaneously to the log and data file.",
      "The log is written after the transaction commits."
    ],
    "answer": "Data must be written to the log file on stable storage before it is written to the actual data file.",
    "explanation": "WAL ensures atomicity and durability. Modifications are written to a sequential log *first*. If the database crashes before applying the change to the data file, the change can be recovered (replayed) from the log upon restart.",
    "difficulty": "Advanced"
  }
]