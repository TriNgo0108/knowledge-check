[
  {
    "id": 1,
    "question": "Which keyword is used to define a variable whose type is inferred by the compiler from the initialization expression on the right side?",
    "options": [
      "dynamic",
      "var",
      "object",
      "let"
    ],
    "answer": "var",
    "explanation": "The `var` keyword instructs the compiler to infer the type of the variable from the expression used to initialize it. The type is determined at compile time and cannot be changed later, unlike `dynamic`.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the correct signature for the entry point method of a C# application?",
    "options": [
      "static void Main(string[] args)",
      "public static int main(string[] args)",
      "static void Start(string[] args)",
      "public void Main(string[] args)"
    ],
    "answer": "static void Main(string[] args)",
    "explanation": "The standard entry point requires `static` (does not require an instance), `void` or `int` return type, and the exact casing `Main`. While it can be `private`, `static` is mandatory.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In C#, which feature allows a method to accept a variable number of arguments of a specific type?",
    "options": [
      "params",
      "varargs",
      "args",
      "optional"
    ],
    "answer": "params",
    "explanation": "The `params` keyword allows a method parameter to accept a variable number of arguments, effectively creating an array from the arguments passed at the call site.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which access modifier restricts access to a member to only within the same class or struct in which it is declared?",
    "options": [
      "private",
      "protected",
      "internal",
      "public"
    ],
    "answer": "private",
    "explanation": "The `private` keyword is the most restrictive access modifier, limiting member accessibility to only the containing type. `protected` allows derived classes access, while `internal` allows access within the same assembly.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the primary difference between a 'class' and a 'struct' in C#?",
    "options": [
      "A class is a reference type, while a struct is a value type",
      "A class is a value type, while a struct is a reference type",
      "Structs cannot implement interfaces",
      "Classes do not support inheritance"
    ],
    "answer": "A class is a reference type, while a struct is a value type",
    "explanation": "Classes are reference types stored on the heap, and variables hold a reference to the data. Structs are value types stored wherever they are defined (often on the stack), and variables hold the actual data.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which operator is used to determine if a specific type is compatible with the type of a given object at runtime?",
    "options": [
      "is",
      "as",
      "typeof",
      "::"
    ],
    "answer": "is",
    "explanation": "The `is` operator checks if an object is compatible with a given type or evaluates a type against a pattern. The `as` operator performs a cast returning null if it fails, rather than a boolean.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "In the context of C# Generics, what syntax is used to specify that a type parameter 'T' must be a reference type?",
    "options": [
      "where T : class",
      "where T : struct",
      "where T : new()",
      "where T : interface"
    ],
    "answer": "where T : class",
    "explanation": "Generic constraints use the `where` clause. `where T : class` restricts the type argument to be a reference type. `where T : struct` restricts it to value types.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which statement correctly describes the execution behavior of standard LINQ operators like 'Where' or 'Select'?",
    "options": [
      "They are executed immediately when the query variable is defined",
      "They are deferred until the query variable is iterated over",
      "They are executed only when the application is compiled",
      "They run on a background thread automatically"
    ],
    "answer": "They are deferred until the query variable is iterated over",
    "explanation": "Standard LINQ query operators use deferred execution, meaning the query is not actually run until you iterate over the results (e.g., with a `foreach` loop) or force evaluation with `ToList`.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the return type of an async method that does not return a meaningful value?",
    "options": [
      "Task",
      "void",
      "Task<Void>",
      "async"
    ],
    "answer": "Task",
    "explanation": "Async methods should return `Task` to represent an ongoing operation without a return value, allowing the caller to await completion. `void` should only be used for event handlers.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which keyword allows you to verify that an object is not null before accessing its members, preventing a NullReferenceException?",
    "options": [
      "?. (null-conditional operator)",
      "?? (null-coalescing operator)",
      "! (null-forgiving operator)",
      ":: (namespace alias qualifier)"
    ],
    "answer": "?. (null-conditional operator)",
    "explanation": "The null-conditional operator `?.` short-circuits the evaluation and returns null if the left-hand operand is null, instead of throwing an exception. `??` provides a default value if null.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the purpose of the 'using' statement when declaring an object?",
    "options": [
      "To automatically dispose of the object when it goes out of scope",
      "To import a namespace into the current file",
      "To declare a variable that cannot be modified",
      "To inherit from a specific base class"
    ],
    "answer": "To automatically dispose of the object when it goes out of scope",
    "explanation": "The `using` statement ensures that the `Dispose` method is called on an object implementing `IDisposable` once the scope of the statement is exited, even if an exception occurs.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which keyword is used to explicitly implement an interface member with a specific name to resolve naming conflicts?",
    "options": [
      "There is no keyword; it is done by omitting the access modifier",
      "explicit",
      "implements",
      "override"
    ],
    "answer": "There is no keyword; it is done by omitting the access modifier",
    "explanation": "Explicit interface implementation is achieved by prefixing the member name with the interface name (e.g., `void IDisposable.Dispose()`) and omitting any access modifier like `public`.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In C# string interpolation, which character is used to prefix the string literal to allow embedded expressions?",
    "options": [
      "@",
      "$",
      "#",
      "&"
    ],
    "answer": "$",
    "explanation": "The `$` character identifies a string as an interpolated string, allowing expressions to be embedded directly within braces `{}`. The `@` character is used for verbatim strings.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the difference between 'const' and 'readonly'?",
    "options": [
      "'const' is compile-time constant, while 'readonly' can be assigned at runtime",
      "'readonly' must be initialized at compile time",
      "'const' can only be modified in the constructor",
      "There is no difference"
    ],
    "answer": "'const' is compile-time constant, while 'readonly' can be assigned at runtime",
    "explanation": "`const` values are evaluated at compile time and must be assigned a value at declaration. `readonly` fields can be assigned at declaration or in a constructor, allowing runtime calculation.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which method is implicitly called when an object is created using the 'new' keyword?",
    "options": [
      "Constructor",
      "Initializer",
      "Finalizer",
      "Accessor"
    ],
    "answer": "Constructor",
    "explanation": "The constructor is a special method that is run automatically when an instance of a class is created to initialize its data. Finalizers are run during garbage collection.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which LINQ method projects each element of a sequence into a new form?",
    "options": [
      "Select",
      "Where",
      "OrderBy",
      "GroupBy"
    ],
    "answer": "Select",
    "explanation": "`Select` is used for projection, transforming each element in a collection into a different type or shape. `Where` is used for filtering, and `OrderBy` for sorting.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the result of the expression 'null ?? \"default\"'?",
    "options": [
      "\"default\"",
      "null",
      "True",
      "A NullReferenceException"
    ],
    "answer": "\"default\"",
    "explanation": "The `??` operator is the null-coalescing operator. It returns the left-hand operand if it is not null; otherwise, it returns the right-hand operand.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which access modifier allows a method to be accessible only within its own class or derived classes, regardless of assembly?",
    "options": [
      "protected",
      "protected internal",
      "private protected",
      "internal"
    ],
    "answer": "protected",
    "explanation": "`protected` members are accessible within their own class and by derived class instances. `internal` restricts access to the current assembly only.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What does the 'await' keyword do in an asynchronous method?",
    "options": [
      "It suspends the method execution until the awaited task completes",
      "It forces the method to run on a new thread immediately",
      "It converts a Task into a Thread",
      "It throws an exception if the task takes too long"
    ],
    "answer": "It suspends the method execution until the awaited task completes",
    "explanation": "`await` yields control to the caller while the awaited task runs, suspending the execution of the current method without blocking the thread, resuming when the task finishes.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which class provides methods for creating, manipulating, and searching strings securely and efficiently?",
    "options": [
      "System.String",
      "System.Text",
      "System.Text.StringBuilder",
      "System.Char"
    ],
    "answer": "System.String",
    "explanation": "`System.String` (or `string`) is the standard class for text manipulation. `StringBuilder` is used specifically for efficient modifications when many changes are required.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the term for the ability to take more than one form, specifically where a derived class provides a specific implementation of a method defined in a base class?",
    "options": [
      "Polymorphism",
      "Encapsulation",
      "Inheritance",
      "Abstraction"
    ],
    "answer": "Polymorphism",
    "explanation": "Polymorphism allows objects to be treated as instances of their parent class rather than their actual class. Method overriding via `virtual` and `override` is a primary implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which pattern matching feature allows you to check the type of a variable and assign it to a new variable in a single step?",
    "options": [
      "Type pattern",
      "Property pattern",
      "Relational pattern",
      "Var pattern"
    ],
    "answer": "Type pattern",
    "explanation": "The type pattern (e.g., `if (obj is string s)`) performs a runtime type check and assigns the result to a new variable if the check succeeds.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which constraint must be applied to a Generic Type parameter to ensure the type has a public parameterless constructor?",
    "options": [
      "where T : new()",
      "where T : struct",
      "where T : class",
      "where T : base()"
    ],
    "answer": "where T : new()",
    "explanation": "The constraint `new()` specifies that the type argument must have a public parameterless constructor. This allows you to create instances of `T` using `new T()`.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the default value of a boolean variable in C#?",
    "options": [
      "false",
      "null",
      "0",
      "true"
    ],
    "answer": "false",
    "explanation": "In C#, boolean variables default to `false`. Numeric types default to `0` (or `0.0`), and reference types default to `null`.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which operator is used to access members of a namespace or type?",
    "options": [
      ". (dot)",
      "-> (arrow)",
      ":: (double colon)",
      "/ (slash)"
    ],
    "answer": ". (dot)",
    "explanation": "The dot operator (`.`) is the standard member access operator in C#. The `::` operator is used for namespace aliases, and `->` is used with pointers in unsafe code.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In C#, what is an 'Indexer'?",
    "options": [
      "A class member that allows an object to be indexed like an array",
      "A database index attribute",
      "A variable that stores the position of an element",
      "A method that sorts an array"
    ],
    "answer": "A class member that allows an object to be indexed like an array",
    "explanation": "Indexers allow instances of a class or struct to be indexed just like arrays, using `this[int index]` syntax to define get and set accessors.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which C# feature allows you to define a method body within a struct or class declaration without a specific name?",
    "options": [
      "Lambda expression",
      "Anonymous method",
      "Local function",
      "Expression body"
    ],
    "answer": "Lambda expression",
    "explanation": "Lambda expressions provide a concise syntax to define anonymous methods using the `=>` operator. Local functions are named methods declared inside other methods.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What happens when you divide an integer by zero in C#?",
    "options": [
      "A DivideByZeroException is thrown",
      "The result is Infinity",
      "The result is 0",
      "The program ignores the operation"
    ],
    "answer": "A DivideByZeroException is thrown",
    "explanation": "Integer division by zero triggers a `DivideByZeroException`. Floating-point division by zero results in `Infinity` or `NaN` (Not a Number).",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which statement is used to immediately transfer control to the start of the enclosing loop?",
    "options": [
      "continue",
      "break",
      "goto",
      "return"
    ],
    "answer": "continue",
    "explanation": "The `continue` statement skips the remaining code in the current iteration and proceeds to the next iteration of the loop. `break` exits the loop entirely.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the result of the expression 'true && false'?",
    "options": [
      "false",
      "true",
      "null",
      "1"
    ],
    "answer": "false",
    "explanation": "The `&&` operator performs a logical AND operation. The result is only `true` if both operands are `true`. Since one operand is `false`, the result is `false`.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which attribute is used to indicate that a method is deprecated during compilation?",
    "options": [
      "[Obsolete]",
      "[Deprecated]",
      "[Legacy]",
      "[Old]"
    ],
    "answer": "[Obsolete]",
    "explanation": "The `[Obsolete]` attribute marks a program entity as one that is no longer recommended for use, causing compiler warnings or errors if the element is used.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "In a switch expression, which symbol separates the pattern match from the result expression?",
    "options": [
      "=>",
      "->",
      ":",
      "|"
    ],
    "answer": "=>",
    "explanation": "Switch expressions use the `=>` token to separate the match pattern from the result expression, enclosed in braces `{ }` with commas separating arms.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which method from the System.Convert class converts a string representation of a number to its 32-bit signed integer equivalent?",
    "options": [
      "Convert.ToInt32",
      "Convert.ParseInt",
      "Convert.Integer",
      "Convert.ChangeType"
    ],
    "answer": "Convert.ToInt32",
    "explanation": "`Convert.ToInt32(string)` is the standard method to convert a string to an integer. `int.Parse` is a common alternative, but `ChangeType` is for generic conversion.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the main characteristic of a 'static' class?",
    "options": [
      "It cannot be instantiated and must contain only static members",
      "It can only be inherited from",
      "It allows only private constructors",
      "It is automatically garbage collected"
    ],
    "answer": "It cannot be instantiated and must contain only static members",
    "explanation": "A static class is fundamentally a sealed abstract class that cannot be instantiated. It serves as a container for static members (methods, properties) and is often used for extensions.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which block of code in a try-catch-finally structure is guaranteed to execute regardless of whether an exception occurred?",
    "options": [
      "finally",
      "catch",
      "try",
      "throw"
    ],
    "answer": "finally",
    "explanation": "The `finally` block executes after the `try` and any `catch` blocks complete, ensuring that code within it runs regardless of whether an exception was thrown or caught.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary benefit of using `ConfigureAwait(false)` on an awaited Task in a library code?",
    "options": [
      "It forces the continuation to run on a new thread to improve parallelism",
      "It captures the current synchronization context to ensure thread safety",
      "It optimizes performance by avoiding the overhead of marshaling the continuation back to the original context",
      "It prevents the task from being cancelled before completion"
    ],
    "answer": "It optimizes performance by avoiding the overhead of marshaling the continuation back to the original context",
    "explanation": "Library code typically does not need the synchronization context (like the UI thread). Using `ConfigureAwait(false)` tells the runtime that the continuation can run on the thread pool, reducing context switching overhead and avoiding potential deadlocks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In LINQ, what distinguishes the `OrderBy` operator from the `Sort` method found in lists?",
    "options": [
      "`OrderBy` modifies the original collection in-place, whereas `Sort` returns a new sorted collection",
      "`OrderBy` performs a stable sort by default, whereas `Sort` is unstable",
      "`OrderBy` is a deferred execution operator that returns a new sequence, whereas `Sort` acts immediately on the list",
      "`OrderBy` can only sort primitive types, whereas `Sort` supports complex objects"
    ],
    "answer": "`OrderBy` is a deferred execution operator that returns a new sequence, whereas `Sort` acts immediately on the list",
    "explanation": "LINQ operators like `OrderBy` use deferred execution and return an `IOrderedEnumerable`, leaving the source unchanged. List.Sort() is an immediate, in-place operation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What constraint must be placed on a generic type parameter to ensure it is a value type?",
    "options": [
      "where T : class",
      "where T : struct",
      "where T : new()",
      "where T : ValueType"
    ],
    "answer": "where T : struct",
    "explanation": "The `struct` constraint restricts the type parameter `T` to value types. The `class` constraint restricts `T` to reference types, and `new()` requires a parameterless constructor.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which interface defines a method to release unmanaged resources deterministically?",
    "options": [
      "IDisposable",
      "IFinalizable",
      "IResource",
      "IGC"
    ],
    "answer": "IDisposable",
    "explanation": "The `IDisposable` interface provides a `Dispose` method for releasing unmanaged resources explicitly. Finalizers (implicitly `IDisposable`'s counterpart) are non-deterministic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the result of using a `yield return` statement in a C# method?",
    "options": [
      "The method compiles to a standard void method returning null",
      "The method is transformed by the compiler into a state machine that implements IEnumerable",
      "The method executes synchronously and blocks the thread until all values are generated",
      "The method returns a generic List containing all computed values immediately"
    ],
    "answer": "The method is transformed by the compiler into a state machine that implements IEnumerable",
    "explanation": "Iterator blocks using `yield return` allow lazy evaluation. The compiler generates a custom state machine class behind the scenes to manage the iteration flow.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Why is `StringBuilder` generally preferred over string concatenation (`+`) within a loop?",
    "options": [
      "`StringBuilder` is a value type and allocates memory on the stack",
      "String concatenation creates a new string object for every modification due to string immutability",
      "`StringBuilder` automatically runs on a background thread",
      "String concatenation throws an exception if the loop exceeds 100 iterations"
    ],
    "answer": "String concatenation creates a new string object for every modification due to string immutability",
    "explanation": "Strings are immutable, meaning `+` creates a new object in memory for every append. `StringBuilder` uses a mutable internal buffer to avoid excessive allocations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the difference between `Task.Wait()` and `await Task`?",
    "options": [
      "`Wait` is asynchronous and does not block the thread; `await` blocks synchronously",
      "`Wait` blocks the current thread until the task completes; `await` yields control back to the caller",
      "`Wait` can only be used on methods returning void; `await` is for Tasks",
      "There is no difference; they are interchangeable syntaxes"
    ],
    "answer": "`Wait` blocks the current thread until the task completes; `await` yields control back to the caller",
    "explanation": "`Task.Wait()` is a synchronous blocking call. `await` is a non-blocking keyword that registers a continuation and yields control to the calling context.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the purpose of the `volatile` keyword in C#?",
    "options": [
      "To make a variable thread-safe by locking access to it",
      "To indicate that a field might be modified by multiple threads, preventing compiler optimizations that cache values",
      "To ensure a variable is stored in the CPU L1 cache",
      "To declare a variable that cannot be changed after initialization"
    ],
    "answer": "To indicate that a field might be modified by multiple threads, preventing compiler optimizations that cache values",
    "explanation": "The `volatile` keyword informs the compiler that the field is subject to concurrent modification, ensuring the most up-to-date value is always read, though it does not replace locks for complex synchronization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which keyword is used to prevent a class from being inherited?",
    "options": [
      "sealed",
      "abstract",
      "static",
      "internal"
    ],
    "answer": "sealed",
    "explanation": "The `sealed` modifier prevents derivation from the class. `abstract` requires inheritance, `static` prevents instantiation, and `internal` is an access modifier.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In the context of C# generics, what is covariance?",
    "options": [
      "The ability to assign a more derived type to a generic type parameter defined as a base type (typically for interfaces)",
      "The ability to convert a generic type to a non-generic type implicitly",
      "The restriction of a generic type to only value types",
      "The process of the compiler inferring the generic type argument from the method signature"
    ],
    "answer": "The ability to assign a more derived type to a generic type parameter defined as a base type (typically for interfaces)",
    "explanation": "Covariance allows you to use a more derived type than originally specified (e.g., `IEnumerable<string>` to `IEnumerable<object>`), typically valid for output parameters.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What happens when you rethrow an exception using `throw ex;` inside a catch block instead of just `throw;`?",
    "options": [
      "The exception is ignored and execution continues",
      "The stack trace is preserved exactly as it was when the exception was thrown",
      "The stack trace is reset to the current line of code, losing the original source of the error",
      "The application terminates immediately due to a stack overflow"
    ],
    "answer": "The stack trace is reset to the current line of code, losing the original source of the error",
    "explanation": "Using `throw ex` creates a new exception object, overwriting the stack trace to point to the `catch` block. Using bare `throw;` re-throws the original exception while preserving the stack trace.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the default behavior for the access modifier of a class member if no modifier is specified?",
    "options": [
      "public",
      "internal",
      "private",
      "protected"
    ],
    "answer": "private",
    "explanation": "In C#, class members (fields, methods, properties) are `private` by default, meaning they are only accessible within the containing class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When defining a property in C#, what is the difference between a field and a property?",
    "options": [
      "Fields store data and allow logic; properties only store raw data",
      "Properties provide accessors (get/set) allowing logic, validation, and encapsulation, whereas fields are direct data members",
      "Fields are public by default, while properties are private",
      "Properties must be static, whereas fields can be instance members"
    ],
    "answer": "Properties provide accessors (get/set) allowing logic, validation, and encapsulation, whereas fields are direct data members",
    "explanation": "Properties act as smart wrappers around data using `get` and `set` accessors. Fields are simply variables holding data, exposing implementation details directly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which method is called by the Garbage Collector before an object's memory is reclaimed, allowing resource cleanup?",
    "options": [
      "Dispose()",
      "Finalize()",
      "Close()",
      "Destructor()"
    ],
    "answer": "Finalize()",
    "explanation": "The `Finalize` method (implemented via a C# destructor syntax `~ClassName`) is called by the GC during finalization. `Dispose` is intended for deterministic cleanup by the caller.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How does C# handle integer overflow by default?",
    "options": [
      "It automatically promotes the integer to a larger type like long",
      "It throws an OverflowException immediately",
      "It wraps around silently (e.g., 255 + 1 becomes 0 in a byte)",
      "It halts the program execution"
    ],
    "answer": "It wraps around silently (e.g., 255 + 1 becomes 0 in a byte)",
    "explanation": "In an `unchecked` context (the default), C# allows arithmetic overflow and wraps the value (discards the most significant bits). You can use `checked` to force an exception.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the result of the expression `null ?? \"default\"`?",
    "options": [
      "null",
      "An exception is thrown",
      "\"default\"",
      "String.Empty"
    ],
    "answer": "\"default\"",
    "explanation": "The null-coalescing operator `??` returns the left-hand operand if it is not null; otherwise, it returns the right-hand operand.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What is a characteristic of the `ValueTask` type compared to `Task`?",
    "options": [
      "`ValueTask` is a reference type, whereas `Task` is a value type",
      "`ValueTask` can avoid heap allocations for asynchronous operations that complete synchronously",
      "`ValueTask` automatically retries failed operations",
      "`ValueTask` is strictly faster than `Task` in all scenarios"
    ],
    "answer": "`ValueTask` can avoid heap allocations for asynchronous operations that complete synchronously",
    "explanation": "`ValueTask` is a value type that can wrap a `Task` or a simple result. For async methods that often complete synchronously or very quickly, it reduces memory pressure by avoiding `Task` allocation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which of the following best describes the `params` keyword in a method signature?",
    "options": [
      "It enforces strict type checking for all arguments",
      "It allows the method to accept a variable number of arguments of a specific type as an array",
      "It makes method parameters optional by assigning default values",
      "It passes arguments by reference instead of by value"
    ],
    "answer": "It allows the method to accept a variable number of arguments of a specific type as an array",
    "explanation": "The `params` keyword lets you define a method that accepts a variable number of arguments (e.g., `void M(params int[] x)`), which are compiled into an array.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the consequence of marking a method as `async void` instead of `async Task`?",
    "options": [
      "The method runs synchronously",
      "The caller cannot await the method and exceptions inside the method crash the process or are unobservable to the caller",
      "The method is automatically garbage collected",
      "It provides better performance than `async Task`"
    ],
    "answer": "The caller cannot await the method and exceptions inside the method crash the process or are unobservable to the caller",
    "explanation": "`async void` is primarily for event handlers. Because there is no `Task` to track the operation, exceptions propagate directly to the synchronization context, often crashing the application.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the purpose of the `nameof` operator?",
    "options": [
      "To convert a string value to a type name at runtime",
      "To return the string name of a variable, type, or member as a compile-time constant",
      "To retrieve the value of a variable by its string name",
      "To check if a variable name is valid according to naming conventions"
    ],
    "answer": "To return the string name of a variable, type, or member as a compile-time constant",
    "explanation": "`nameof` is evaluated at compile time, useful for preventing magic strings (e.g., in `ArgumentException` or data binding) and ensuring refactoring safety.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which access modifier allows a method to be accessed by any code in the same assembly, but restricts access to external assemblies?",
    "options": [
      "public",
      "protected",
      "internal",
      "protected internal"
    ],
    "answer": "internal",
    "explanation": "The `internal` keyword restricts access to the current assembly. `public` allows external access, and `protected` is restricted to derived classes regardless of assembly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In a C# pattern matching `switch` expression, what symbol is used to denote the default case?",
    "options": [
      "default",
      "_",
      "else",
      "*"
    ],
    "answer": "_",
    "explanation": "The discard pattern `_` is used in switch expressions to represent the 'default' case when no other patterns match.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the primary use of the `Unsafe` class in C#?",
    "options": [
      "To generate random passwords",
      "To perform low-level memory manipulations bypassing safety checks (like pointer arithmetic)",
      "To encrypt data in memory",
      "To manage thread synchronization"
    ],
    "answer": "To perform low-level memory manipulations bypassing safety checks (like pointer arithmetic)",
    "explanation": "The `System.Runtime.CompilerServices.Unsafe` class provides high-performance operations that ignore normal type safety and safety checks, useful for advanced optimization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which of the following correctly describes a closure in C#?",
    "options": [
      "A method that prevents the calling code from accessing variables",
      "A class generated by the compiler to hold captured local variables from an outer scope for use in a lambda or anonymous method",
      "A way to close a file stream automatically",
      "A keyword used to restrict generic type parameters"
    ],
    "answer": "A class generated by the compiler to hold captured local variables from an outer scope for use in a lambda or anonymous method",
    "explanation": "When a lambda captures a variable, the compiler generates a closure class to store the variable, ensuring the variable's lifetime extends beyond the original method scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What does the `[Serializable]` attribute indicate?",
    "options": [
      "The class can be stored in a database",
      "The object can be serialized to a stream (like binary or JSON) for storage or transport",
      "The class is thread-safe",
      "The class cannot be inherited from"
    ],
    "answer": "The object can be serialized to a stream (like binary or JSON) for storage or transport",
    "explanation": "This attribute marks types as being serializable, allowing them to be persisted or remoted. Note that JSON serializers often ignore this specific attribute, but binary formatters require it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the difference between `IComparable` and `IComparer`?",
    "options": [
      "`IComparable` is used to compare two objects for sorting; `IComparer` is used to sort a list",
      "`IComparable` defines a method for comparing the current instance with another object; `IComparer` defines a separate comparison strategy",
      "`IComparable` is for comparing strings; `IComparer` is for integers",
      "There is no difference; they are synonyms"
    ],
    "answer": "`IComparable` defines a method for comparing the current instance with another object; `IComparer` defines a separate comparison strategy",
    "explanation": "`IComparable` (method `CompareTo`) is implemented on the object itself. `IComparer` (method `Compare`) is a separate helper class used to define custom sorting logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is a `Span` primarily used for?",
    "options": [
      "Handling exceptions across threads",
      "Providing a type-safe and memory-efficient representation of a contiguous region of arbitrary memory",
      "Replacing all array usage in C# completely",
      "Creating asynchronous database queries"
    ],
    "answer": "Providing a type-safe and memory-efficient representation of a contiguous region of arbitrary memory",
    "explanation": "`Span` allows safe manipulation of memory (arrays, stack memory, pointers) without allocation overhead, significantly improving performance in parsing and data processing scenarios.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the purpose of the `CallerMemberName` attribute?",
    "options": [
      "To reflect the name of the method calling the current method at compile time",
      "To encrypt the name of the member",
      "To ensure the method is only called by specific members",
      "To generate XML documentation automatically"
    ],
    "answer": "To reflect the name of the method calling the current method at compile time",
    "explanation": "This attribute (often used in `INotifyPropertyChanged` implementations) allows the compiler to automatically insert the name of the calling method/property as an argument.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "How does the `lock` statement work internally?",
    "options": [
      "It uses a Mutex to lock the operating system process",
      "It compiles to a `Monitor.Enter` and `Monitor.Exit` block wrapped in a try/finally",
      "It freezes the thread indefinitely",
      "It serializes the object for transport"
    ],
    "answer": "It compiles to a `Monitor.Enter` and `Monitor.Exit` block wrapped in a try/finally",
    "explanation": "The `lock` statement is syntactic sugar for `Monitor.Enter` (acquire lock) and `Monitor.Exit` (release lock) within a `try...finally` block to ensure the lock is released even if an exception occurs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the behavior of the `as` operator if the cast fails?",
    "options": [
      "It throws an `InvalidCastException`",
      "It returns `null` instead of throwing an exception",
      "It returns the default value of the type",
      "It returns the original object"
    ],
    "answer": "It returns `null` instead of throwing an exception",
    "explanation": "Unlike a direct cast `()`, the `as` operator performs a safe conversion. If the types are incompatible, it returns `null` (works only with reference types or nullable types).",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is an `init` accessor in C#?",
    "options": [
      "A method that initializes the constructor",
      "A setter that can only be called during object construction or initialization",
      "A getter that returns the initial memory address",
      "A property that cannot be read"
    ],
    "answer": "A setter that can only be called during object construction or initialization",
    "explanation": "The `init` accessor enforces immutability by allowing the property to be set only during object creation (e.g., in the constructor or an object initializer), preventing modification afterwards.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which generic collection class provides O(1) access time by index and O(1) insertion at the end?",
    "options": [
      "Dictionary<TKey, TValue>",
      "LinkedList",
      "List",
      "SortedList"
    ],
    "answer": "List",
    "explanation": "`List` is backed by an array, providing O(1) index access and amortized O(1) addition at the end. `Dictionary` uses keys, and `LinkedList` has O(1) insertion but O(n) index access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What happens when you mark a field `readonly`?",
    "options": [
      "The field can only be modified within the constructor of the declaring class",
      "The field becomes a constant and must be set at compile time",
      "The field cannot be read, only written to",
      "The field is shared across all instances of the class"
    ],
    "answer": "The field can only be modified within the constructor of the declaring class",
    "explanation": "`readonly` ensures the field can only be assigned during declaration or in the constructor. It differs from `const` (which is compile-time constant) as `readonly` values can be calculated at runtime.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the effect of the `in` keyword on a method parameter?",
    "options": [
      "The parameter is passed by reference and can be modified",
      "The parameter is passed by reference but cannot be modified (read-only reference)",
      "The parameter is passed by value",
      "The parameter is optional"
    ],
    "answer": "The parameter is passed by reference but cannot be modified (read-only reference)",
    "explanation": "The `in` parameter modifier passes arguments by reference, avoiding the copy overhead of structs, while ensuring the method cannot modify the value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is a key feature of C# `record` types?",
    "options": [
      "They are always abstract and cannot be instantiated",
      "They provide built-in value-based equality and concise syntax for immutable data models",
      "They are implicitly unsafe and allow pointer arithmetic",
      "They can only contain static methods"
    ],
    "answer": "They provide built-in value-based equality and concise syntax for immutable data models",
    "explanation": "Records are designed for data-centric models. They provide value-based equality (two records are equal if their properties are equal) and concise syntax for immutability.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "When implementing a generic interface with a covariant type parameter, what is the strict constraint on the usage of that type parameter within the interface members?",
    "options": [
      "The type parameter can only be used as a return type of methods, not as a type of method arguments",
      "The type parameter must be constrained to a reference type using the `class` constraint",
      "The type parameter must be invariant and can only be used in private nested classes",
      "The type parameter must be used as a type argument for all generic methods defined in the interface"
    ],
    "answer": "The type parameter can only be used as a return type of methods, not as a type of method arguments",
    "explanation": "Covariance permits a more derived type than specified, but type safety is violated if you allow writing into the generic structure (method arguments). Therefore, covariant parameters (marked `out`) are restricted to output positions only.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary benefit of using `ValueTask` over `Task` in a high-throughput asynchronous method that completes synchronously in the hot path?",
    "options": [
      "It ensures the method runs on a dedicated I/O thread pool",
      "It avoids the heap allocation of a `Task` object by wrapping a synchronous result or an `IValueTaskSource`",
      "It automatically converts the method into a state machine implemented as a struct",
      "It enables the compiler to perform lock-free optimizations on the await statement"
    ],
    "answer": "It avoids the heap allocation of a `Task` object by wrapping a synchronous result or an `IValueTaskSource`",
    "explanation": "While `Task` is a reference type requiring a heap allocation, `ValueTask` is a struct with a small footprint. In hot paths where operations often complete synchronously, `ValueTask` significantly reduces GC pressure by avoiding object allocation.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Why does the C# compiler prevent defining a finalizer (destructor) within a struct?",
    "options": [
      "Structs are value types and deterministic finalization conflicts with the implicit memory management of the stack",
      "The Garbage Collector only tracks reference types, therefore it cannot identify when a struct goes out of scope",
      "Structs cannot inherit from `Object`, which is required to define a `Finalize` method",
      "Finalizers can only be defined within classes that implement the `IDisposable` interface"
    ],
    "answer": "The Garbage Collector only tracks reference types, therefore it cannot identify when a struct goes out of scope",
    "explanation": "Finalizers are called by the Garbage Collector during the reclamation of memory. Since structs are either stack-allocated or inline inside other objects, the GC does not track their individual lifecycles, making finalization impossible.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "When using `Span` to manipulate memory, why is it invalid to store a `Span` in a field of a class, or to box it?",
    "options": [
      "`Span` is a ref struct, which is stack-only to ensure memory safety and prevent access to freed stack memory",
      "`Span` contains a raw pointer that violates the Common Language Specification (CLS) rules",
      "The CLR restricts usage of by-ref types to prevent pointer arithmetic security exploits",
      "`Span` is immutable by design and cannot be serialized into the heap"
    ],
    "answer": "`Span` is a ref struct, which is stack-only to ensure memory safety and prevent access to freed stack memory",
    "explanation": "A `ref struct` cannot be moved to the managed heap (boxed or stored in a class). This restriction ensures that the span never outlives the memory it references (e.g., the stack frame), preventing access violations.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of iterator blocks (`yield return`), how does the C# compiler handle exceptions thrown during the `MoveNext()` call?",
    "options": [
      "The exception is caught and wrapped in an `IteratorExecutionException` when the enumerator is disposed",
      "The exception propagates immediately to the caller, and the enumerator becomes unusable for subsequent calls",
      "The exception is stored in a state field and re-thrown when the caller accesses the `Current` property",
      "The exception is suppressed automatically to allow `foreach` loops to complete gracefully"
    ],
    "answer": "The exception propagates immediately to the caller, and the enumerator becomes unusable for subsequent calls",
    "explanation": "If code inside the iterator block throws an exception, it bubbles up to the caller of `MoveNext()`. The state machine transitions to a 'closed' state, so subsequent calls to `MoveNext()` or `Dispose` will not re-execute the faulty logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the specific purpose of `volatile` field in C# regarding compiler optimizations and memory barriers?",
    "options": [
      "It forces the CPU cache to flush the write to main memory immediately, bypassing L1/L2 caches",
      "It prevents the compiler from caching the field in a register and ensures acquire/release semantics for reads and writes",
      "It enables lock-free read-write access by using hardware-level `CompareExchange` instructions",
      "It guarantees that the field is only accessed by a single thread at a time, replacing the need for `lock`"
    ],
    "answer": "It prevents the compiler from caching the field in a register and ensures acquire/release semantics for reads and writes",
    "explanation": "The `volatile` keyword instructs the compiler to disable specific optimizations that might cache values in registers and introduces a full memory fence (acquire on read, release on write), ensuring visibility across threads.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "When implementing `IEquatable`, why is it generally necessary to also override `Object.GetHashCode`?",
    "options": [
      "The `EqualityComparer` requires `GetHashCode` to implement value equality checks",
      "If two objects are equal according to `Equals`, they must return the same hash code to function correctly in hash-based collections like `Dictionary`",
      "The compiler forces the override to ensure boxing operations do not lose type information",
      "Overriding `GetHashCode` is the only way to ensure the `==` operator works correctly for value types"
    ],
    "answer": "If two objects are equal according to `Equals`, they must return the same hash code to function correctly in hash-based collections like `Dictionary`",
    "explanation": "Hash-based collections rely on `GetHashCode` to bucket objects. If `Equals` returns true but the hash codes differ, the collection will fail to find the object or treat it as a distinct entry.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the runtime behavior difference between `await Task.Delay(1000)` and `Thread.Sleep(1000)` in an async context?",
    "options": [
      "`Task.Delay` returns a `Task` that completes after the time, whereas `Thread.Sleep` blocks the current thread",
      "`Task.Delay` runs a timer callback on the UI thread, while `Thread.Sleep` runs on the background thread",
      "`Task.Delay` is synchronous and blocks the thread pool thread, while `Thread.Sleep` yields control to the processor",
      "There is no difference; they both result in the operating system pausing the executing thread"
    ],
    "answer": "`Task.Delay` returns a `Task` that completes after the time, whereas `Thread.Sleep` blocks the current thread",
    "explanation": "`Task.Delay` is asynchronous; it registers a timer and returns an uncompleted task, allowing the thread to be released for other work. `Thread.Sleep` is a blocking call that holds the thread in a wait state, consuming resources.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "How does the compiler ensure that `IEnumerable` queries using LINQ are not executed immediately?",
    "options": [
      "The compiler wraps the query in a delegate that is only invoked when `GetEnumerator` is called",
      "By rewriting the query to construct an expression tree that is later traversed",
      "The query operators accept `IEnumerable` but return a concrete class that holds the source and delegates, deferring execution",
      "The runtime intercepts the call and pauses execution until the `foreach` loop is entered"
    ],
    "answer": "The query operators accept `IEnumerable` but return a concrete class that holds the source and delegates, deferring execution",
    "explanation": "Standard LINQ operators like `Where` and `Select` return an iterator (often a `WhereEnumerableIterator`) that stores the inputs. The logic runs only when the returned sequence is iterated over (e.g., `foreach`), not when the object is created.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What distinguishes the behavior of `Enumerable.Select` (LINQ to Objects) from `Queryable.Select` (LINQ to Providers)?",
    "options": [
      "`Enumerable.Select` accepts an `Expression<Func<>>` while `Queryable.Select` accepts a `Func<>` delegate",
      "`Enumerable.Select` executes a delegate in memory, while `Queryable.Select` builds an expression tree for translation (e.g., to SQL)",
      "`Enumerable.Select` is optimized for parallel execution, whereas `Queryable.Select` is strictly sequential",
      "`Queryable.Select` cannot be used with in-memory collections and throws an exception if the provider is not SQL-based"
    ],
    "answer": "`Enumerable.Select` executes a delegate in memory, while `Queryable.Select` builds an expression tree for translation (e.g., to SQL)",
    "explanation": "`Enumerable` works on delegates (actual code execution). `Queryable` works on expression trees (data structure representation of code), allowing providers like Entity Framework to parse the tree and generate SQL queries.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In a generic class `class Foo where T : Bar`, why can the compiler not guarantee that a default instance of `T` can be instantiated?",
    "options": [
      "`T` is a reference type and `new` constraints are not allowed on classes",
      "The constraint `where T : Bar` does not enforce that `Bar` has a parameterless constructor",
      "The CLR prevents instantiation of generic types that inherit from specific base classes",
      "Value types cannot be instantiated using the `default` keyword inside generic classes"
    ],
    "answer": "The constraint `where T : Bar` does not enforce that `Bar` has a parameterless constructor",
    "explanation": "Generic constraints only enforce the specific capability requested (e.g., base class, interface). To ensure `T` can be instantiated, you must explicitly add the `new()` constraint, otherwise `T` might lack an accessible parameterless constructor.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the significance of the `in` modifier on a generic type parameter in an interface definition (e.g., `interface IMatcher<in T>`)?",
    "options": [
      "It specifies that the type parameter is contravariant, allowing `IMatcher<Base>` to be used where `IMatcher<Derived>` is required",
      "It specifies that the type parameter is covariant, allowing `IMatcher<Derived>` to be used where `IMatcher<Base>` is required",
      "It forces all arguments of type `T` to be passed by reference (`ref`) for performance",
      "It restricts the generic type `T` to be a value type (struct) only"
    ],
    "answer": "It specifies that the type parameter is contravariant, allowing `IMatcher<Base>` to be used where `IMatcher<Derived>` is required",
    "explanation": "The `in` keyword designates a type parameter for contravariance. This means the interface can accept a generic type argument that is a base class of the type originally specified, provided `T` is only used as input (method arguments).",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "Why is it dangerous to execute `async void` methods, particularly in environments like ASP.NET Core or UI frameworks?",
    "options": [
      "`async void` methods cannot return a value, causing data loss",
      "Exceptions thrown in `async void` methods cannot be caught by the caller and often crash the process or unobserved task exceptions",
      "The `await` keyword is not allowed inside methods marked `async void`",
      "`async void` methods are compiled synchronously, causing thread pool starvation"
    ],
    "answer": "Exceptions thrown in `async void` methods cannot be caught by the caller and often crash the process or unobserved task exceptions",
    "explanation": "Unlike `async Task`, `async void` has no way to return a task handle to the caller, so the caller cannot await it or catch exceptions. Unhandled exceptions in `async void` propagate directly to the synchronization context, often leading to application crashes.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does the C# compiler optimize the usage of `foreach` on a `List` compared to a standard `IEnumerable`?",
    "options": [
      "The compiler unrolls the `foreach` loop into raw pointer arithmetic for direct memory access",
      "The compiler detects the `List` type and emits a `for` loop accessing the underlying array via an index operator to avoid struct boxing",
      "The compiler generates a call to `List.GetEnumerator()` which is always inlined by the JIT",
      "The compiler converts the `List` into a `Span` to enable hardware acceleration"
    ],
    "answer": "The compiler detects the `List` type and emits a `for` loop accessing the underlying array via an index operator to avoid struct boxing",
    "explanation": "The compiler treats arrays and lists specifically. For `List`, it avoids the `IEnumerator` interface and boxing the `List Enumerator` struct. Instead, it emits a `for` loop using `list[i]`, which is significantly faster.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the specific function of the `Math.Max` method in the context of array growth logic within `List`?",
    "options": [
      "It calculates the median value of the array to optimize binary searches during insertion",
      "It is used to double the current capacity when the array is full, unless the new count is smaller than the default capacity",
      "It caps the new capacity to `Array.MaxArrayLength` to prevent OutOfMemoryExceptions",
      "It determines the geometric progression factor (usually 2x) versus linear growth for small arrays"
    ],
    "answer": "It caps the new capacity to `Array.MaxArrayLength` to prevent OutOfMemoryExceptions",
    "explanation": "While growth logic typically doubles the size, checks must be made to ensure the requested capacity does not exceed the maximum allowed length of an array (approx 2GB on 64-bit), which is where `Math.Max` and comparisons against limits are critical.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What happens to a lambda expression captured by a variable if the loop variable is declared `var i` (pre C# 5.0) versus `var i` (C# 5.0+) inside a `foreach` loop?",
    "options": [
      "Pre C# 5.0, all closures capture the same variable reference, leading to all delegates seeing the final value; C# 5.0 treats the loop variable as logically new per iteration",
      "Pre C# 5.0, the lambda creates a copy of the variable, whereas C# 5.0 captures by reference",
      "C# 5.0 introduces a breaking change where lambdas cannot capture loop variables at all to prevent memory leaks",
      "There is no difference; the behavior has been consistent since .NET Framework 1.0"
    ],
    "answer": "Pre C# 5.0, all closures capture the same variable reference, leading to all delegates seeing the final value; C# 5.0 treats the loop variable as logically new per iteration",
    "explanation": "Prior to C# 5.0, the `foreach` loop variable was not treated as new per iteration, causing closures to share the reference. C# 5.0 changed this to define the variable per iteration, ensuring closures capture distinct values.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In the context of Reflection, what does the `MakeGenericMethod` method accomplish?",
    "options": [
      "It creates a new generic type definition for a class based on a method signature",
      "It converts a non-generic static method into a generic method at runtime",
      "It binds the generic type arguments of an open generic method definition to construct a specific MethodInfo that can be invoked",
      "It recompiles the IL of a method to replace generic types with concrete types for JIT compilation"
    ],
    "answer": "It binds the generic type arguments of an open generic method definition to construct a specific MethodInfo that can be invoked",
    "explanation": "To invoke a generic method via reflection, you first get the `MethodInfo` of the generic definition (open), then call `MakeGenericMethod` with specific types (closed) to get a `MethodInfo` that can be passed to `Invoke`.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the primary technical limitation of `Expression` trees compared to Delegate-based LINQ queries?",
    "options": [
      "Expression trees cannot be serialized to remote servers",
      "Expression trees cannot contain statement bodies (blocks, loops, assignments), only single expressions",
      "Expression trees are interpreted at runtime, making them significantly slower than delegates",
      "Expression trees cannot capture local variables or closure contexts"
    ],
    "answer": "Expression trees cannot contain statement bodies (blocks, loops, assignments), only single expressions",
    "explanation": "System.Linq.Expressions represents code as a data structure of logic, not flow control. While limited, this allows parsing. Delegates represent executable code blocks (IL) and can contain full C# syntax, but cannot be parsed.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Why is using `String.Intern` generally discouraged for high-volume dynamic data processing?",
    "options": [
      "It creates a hard dependency on the Garbage Collector to clear the string pool",
      "It adds strings to the Intern Pool, which is not garbage collected during the application's lifetime, potentially causing memory leaks",
      "It causes thread contention because the intern table uses a global lock",
      "It modifies the string instance, breaking immutability contracts"
    ],
    "answer": "It adds strings to the Intern Pool, which is not garbage collected during the application's lifetime, potentially causing memory leaks",
    "explanation": "The intern pool is per-AppDomain and effectively static memory. If you intern unique strings dynamically (e.g., user input), you fill the heap with data that cannot be evicted until the AppDomain unloads.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the behavior of the `is null` pattern matching check compared to `object.ReferenceEquals(obj, null)`?",
    "options": [
      "`is null` uses overloaded equality operators, while `ReferenceEquals` strictly checks memory addresses",
      "`is null` performs a pattern match that checks for null and is syntactic sugar for `ReferenceEquals` on reference types, but handles lifted conversions on nullable value types",
      "`ReferenceEquals` can throw a NullReferenceException if the instance is actually null",
      "`is null` is purely a compile-time construct and generates no IL code"
    ],
    "answer": "`is null` performs a pattern match that checks for null and is syntactic sugar for `ReferenceEquals` on reference types, but handles lifted conversions on nullable value types",
    "explanation": "The `is null` pattern provides a consistent syntax for null checking. It avoids issues with overloaded operators (unlike `obj == null`) and handles `Nullable` struct checking efficiently via boxing or direct access to the `HasValue` property.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What distinguishes `MemoryMarshal.Cast` from `Unsafe.As` in the context of memory reinterpretation?",
    "options": [
      "`MemoryMarshal.Cast` validates the length of the span based on the size of types, while `Unsafe.As` does not",
      "`Unsafe.As` performs a memory copy, whereas `MemoryMarshal.Cast` creates a view over the existing memory",
      "`MemoryMarshal.Cast` only works on value types, while `Unsafe.As` works on reference types",
      "`Unsafe.As` checks for type safety at runtime, whereas `MemoryMarshal.Cast` is unchecked"
    ],
    "answer": "`MemoryMarshal.Cast` validates the length of the span based on the size of types, while `Unsafe.As` does not",
    "explanation": "`MemoryMarshal.Cast` reinterprets a Span of one type to another (e.g., byte to int). It ensures the byte lengths match (length * sizeof(TFrom) == length * sizeof(TTo)). `Unsafe.As` is a primitive cast that does not verify length.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "How does `ConfigureAwait(false)` affect the execution context of a continuation in an ASP.NET Core application?",
    "options": [
      "It forces the continuation to run on a dedicated I/O completion port thread",
      "It prevents the continuation from capturing the synchronization context, meaning it runs on a ThreadPool thread",
      "It instructs the Task scheduler to prioritize the continuation over other pending tasks",
      "It captures the current culture and UI culture, but ignores the HttpContext"
    ],
    "answer": "It prevents the continuation from capturing the synchronization context, meaning it runs on a ThreadPool thread",
    "explanation": "`ConfigureAwait(true)` (default) attempts to marshal the continuation back to the original context (e.g., UI thread or ASP.NET request context). `ConfigureAwait(false)` bypasses this, reducing overhead and improving scalability in backend services.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the behavior of the `stackalloc` operator when used within an expression?",
    "options": [
      "It allocates memory on the heap that is managed by the GC",
      "It allocates a block of memory on the stack that is automatically discarded when the method returns",
      "It allocates memory in the Large Object Heap (LOH) to avoid fragmentation",
      "It returns a pointer that must be manually freed using `free()`"
    ],
    "answer": "It allocates a block of memory on the stack that is automatically discarded when the method returns",
    "explanation": "`stackalloc` creates an unmanaged block of memory on the stack frame. It is extremely fast and does not create GC pressure, but it is unsafe to return or reference this memory outside the scope of the method (e.g., via `Span`).",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "When using `Parallel.ForEach`, what mechanism prevents the creation of a separate Task for every single element in a large collection?",
    "options": [
      "The compiler unrolls the loop into a standard `foreach` during the JIT tier 1 compilation",
      "It employs a range partitioner that divides the work into chunks and dynamically adjusts the load using work-stealing",
      "It forces the application to run in a single thread to avoid overhead",
      "`Parallel.ForEach` limits the maximum degree of parallelism to 2 regardless of the core count"
    ],
    "answer": "It employs a range partitioner that divides the work into chunks and dynamically adjusts the load using work-stealing",
    "explanation": "Creating a Task per item creates massive overhead. The Task Parallel Library (TPL) uses partitioners to group items into batches and work-stealing algorithms to balance load across threads efficiently.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Why is it invalid to implement an interface property implicitly using a getter-only auto-property if the interface definition defines both `get` and `set` accessors?",
    "options": [
      "The CLR requires that the backing field of a property is writable to support serialization",
      "The contract requires mutability; implementing only a getter violates the contract and the compiler flags an error",
      "Interfaces cannot define setters, so the code would not compile in the first place",
      "The getter-only auto-property creates a readonly backing field that cannot be mapped to the interface's metadata slot"
    ],
    "answer": "The contract requires mutability; implementing only a getter violates the contract and the compiler flags an error",
    "explanation": "A class implementing an interface must satisfy all members of that interface. If the interface defines a property with `get` and `set`, the implementing class must provide both, or explicitly implement the interface and use a private setter, though simple implicit implementation must match the signature.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the purpose of the `Ephemeral` generation (Gen 0, Gen 1) in the .NET Garbage Collector?",
    "options": [
      "To store objects that have finalizers, ensuring they are cleaned up last",
      "To manage short-lived objects that are frequently allocated and collected, optimizing for high allocation rates",
      "To isolate large objects (LOH) from small objects to reduce fragmentation",
      "To provide a dedicated pool for string interning and assembly loading"
    ],
    "answer": "To manage short-lived objects that are frequently allocated and collected, optimizing for high allocation rates",
    "explanation": "The GC is generational. Gen 0 and Gen 1 hold ephemeral (short-lived) objects. Collecting these generations is fast and happens frequently, which optimizes scenarios like web requests where many temporary objects are created.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "In the context of Structs, why does accessing a property on a readonly struct result in defensive copying if the property is not `readonly` itself?",
    "options": [
      "The compiler generates a copy to protect the `this` instance from accidental modification within the property getter",
      "The property getter of a struct returns a value type, which is always copied",
      "Because the struct is readonly, the compiler assumes the property might modify internal state and copies the struct to allow the mutation to be discarded",
      "Structs are always copied when passed to methods, and property access is internally a method call"
    ],
    "answer": "Because the struct is readonly, the compiler assumes the property might modify internal state and copies the struct to allow the mutation to be discarded",
    "explanation": "If a struct is marked `readonly`, the compiler treats the instance as an invariant variable. If a non-readonly property is called, the compiler defensively copies the struct to prevent the (discarded) mutation of the original readonly instance.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the function of the `IteratorStateMachine` attribute applied by the C# compiler?",
    "options": [
      "It signals the CLR to execute the method in a background thread",
      "It informs the debugger and the runtime that the method has been rewritten into a state machine structure",
      "It optimizes the method by converting it into a native function pointer",
      "It marks the method as `unsafe` to allow access to memory addresses"
    ],
    "answer": "It informs the debugger and the runtime that the method has been rewritten into a state machine structure",
    "explanation": "When the compiler generates a state machine for `async` or `iterator` methods (yield), it applies `IteratorStateMachine` or `AsyncStateMachine`. This allows tools like debuggers to step through the original source code rather than the generated spaghetti code.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "How does `Unsafe.SizeOf()` differ from `Marshal.SizeOf()` when used to determine the size of a struct?",
    "options": [
      "`Unsafe.SizeOf` returns the size in bytes as managed by the CLR (including padding), while `Marshal.SizeOf` returns the unmanaged size after marshaling",
      "`Marshal.SizeOf` is computed at compile time, while `Unsafe.SizeOf` is calculated at runtime",
      "`Unsafe.SizeOf` only works for reference types, while `Marshal.SizeOf` works for value types",
      "There is no difference; they are aliases for the same Win32 API call"
    ],
    "answer": "`Unsafe.SizeOf` returns the size in bytes as managed by the CLR (including padding), while `Marshal.SizeOf` returns the unmanaged size after marshaling",
    "explanation": "`Unsafe.SizeOf` reflects the actual managed memory layout. `Marshal.SizeOf` calculates the size required to represent the type in unmanaged memory (e.g., for P/Invoke), which can differ due to type mappings (like `bool` being 1 byte in CLR but 4 bytes in some unmanaged contexts).",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the specific effect of using `SuppressFinalize(this)` inside the `Dispose` method of a class implementing the Disposable pattern?",
    "options": [
      "It immediately destroys the object and frees its memory",
      "It tells the Garbage Collector that the object has already been cleaned up, preventing the finalizer from running a second time",
      "It removes the object from the finalization queue entirely, making it a root object",
      "It converts the object from a reference type to a value type to optimize stack usage"
    ],
    "answer": "It tells the Garbage Collector that the object has already been cleaned up, preventing the finalizer from running a second time",
    "explanation": "If `Dispose` cleans up unmanaged resources, there is no need for the finalizer to run. Calling `GC.SuppressFinalize` removes the object from the finalization queue (f-reachable queue), reducing performance overhead and ensuring resources aren't released twice.",
    "difficulty": "Advanced"
  }
]