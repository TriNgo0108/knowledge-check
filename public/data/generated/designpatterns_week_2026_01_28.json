[
  {
    "id": 1,
    "question": "What does the acronym SOLID stand for in software design?",
    "options": [
      "Single, Open, Liskov, Interface, Dependency",
      "Simple, Object-oriented, Linear, Isolated, Distributed",
      "Structure, Object, Logic, Interface, Data",
      "Standard, Operation, Loop, Input, Definition"
    ],
    "answer": "Single, Open, Liskov, Interface, Dependency",
    "explanation": "SOLID is an acronym representing five design principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. The other options provide terms that sound technical but do not form the correct mnemonic for these specific principles.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "According to the Single Responsibility Principle (SRP), a class should have how many reasons to change?",
    "options": [
      "Zero reasons",
      "Only one reason",
      "Two or three reasons",
      "As many reasons as needed"
    ],
    "answer": "Only one reason",
    "explanation": "The Single Responsibility Principle states that a class should have one and only one reason to change, meaning it should have only one job or responsibility. If a class has multiple reasons to change, it likely handles too many distinct tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary focus of Creational Design Patterns?",
    "options": [
      "How objects are created",
      "How classes communicate with each other",
      "How objects are composed to form larger structures",
      "How data is stored in a database"
    ],
    "answer": "How objects are created",
    "explanation": "Creational patterns focus specifically on object creation mechanisms. Their goal is to make object creation more flexible and reusable. Structural patterns focus on composition, and Behavioral patterns focus on communication.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which principle is specifically concerned with avoiding duplication in code?",
    "options": [
      "KISS",
      "DRY",
      "YAGNI",
      "SOLID"
    ],
    "answer": "DRY",
    "explanation": "DRY stands for \"Don't Repeat Yourself\" and focuses on avoiding duplication. KISS focuses on simplicity, YAGNI focuses on avoiding unnecessary features, and SOLID is a set of broader object-oriented principles.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What does the Dependency Inversion Principle (DIP) emphasize to induce low coupling?",
    "options": [
      "Abstractions",
      "Concrete classes",
      "Global variables",
      "Direct database connections"
    ],
    "answer": "Abstractions",
    "explanation": "The Dependency Inversion Principle emphasizes the importance of abstractions to induce low coupling. By depending on abstractions rather than concrete details, modules become less tightly coupled and easier to update or test.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which of the following is an example of a Behavioral Design Pattern?",
    "options": [
      "Observer",
      "Singleton",
      "Adapter",
      "Builder"
    ],
    "answer": "Observer",
    "explanation": "Observer is a Behavioral pattern focused on communication between objects. Singleton and Builder are Creational patterns, and Adapter is a Structural pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the main goal of Structural Design Patterns?",
    "options": [
      "To form larger, efficient structures without losing flexibility",
      "To manage complex relationships between objects",
      "To ensure objects are created only once",
      "To reduce the size of the compiled code"
    ],
    "answer": "To form larger, efficient structures without losing flexibility",
    "explanation": "Structural patterns focus on how classes and objects are composed to form larger structures. Their goal is to achieve this efficiency while maintaining flexibility in the design.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which of the following is listed as a Creational Design Pattern?",
    "options": [
      "Factory Method",
      "Facade",
      "Strategy",
      "Command"
    ],
    "answer": "Factory Method",
    "explanation": "Factory Method is categorized as a Creational pattern because it deals with object creation. Facade is Structural, while Strategy and Command are Behavioral patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is a primary benefit of adhering to SOLID principles?",
    "options": [
      "Code becomes easier to maintain, extend, and test",
      "Code compiles significantly faster",
      "Programs require zero memory usage",
      "Developers do not need to write comments"
    ],
    "answer": "Code becomes easier to maintain, extend, and test",
    "explanation": "SOLID principles are important because they guide developers toward code that is easier to maintain, extend, and test, especially as systems grow in complexity. They do not directly affect compilation speed or memory usage.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What does the KISS principle encourage developers to do?",
    "options": [
      "Keep every solution as simple and direct as possible",
      "Keep all code in a single file",
      "Ensure every variable is a global constant",
      "Use the most complex algorithms available"
    ],
    "answer": "Keep every solution as simple and direct as possible",
    "explanation": "KISS stands for \"Keep It Simple, Stupid\" (or variations thereof) and encourages simplicity and directness in solutions. It discourages unnecessary complexity or convoluted logic.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What does the 'L' in the SOLID acronym stand for?",
    "options": [
      "Liskov Substitution Principle",
      "Logic Separation Principle",
      "Low Latency Principle",
      "Language Independence Principle"
    ],
    "answer": "Liskov Substitution Principle",
    "explanation": "The 'L' in SOLID stands for Liskov Substitution Principle. The other options are principles that sound plausible but are not part of the standard SOLID acronym.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which design pattern is categorized as a Structural Pattern?",
    "options": [
      "Decorator",
      "Iterator",
      "Prototype",
      "State"
    ],
    "answer": "Decorator",
    "explanation": "Decorator is a Structural pattern focused on composing objects. Iterator and State are Behavioral patterns, and Prototype is a Creational pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the main difference between DRY and KISS as described in the text?",
    "options": [
      "DRY focuses on avoiding duplication, while KISS encourages simplicity",
      "DRY focuses on simplicity, while KISS focuses on avoiding duplication",
      "DRY is for object-oriented code, while KISS is for procedural code",
      "There is no difference between the two principles"
    ],
    "answer": "DRY focuses on avoiding duplication, while KISS encourages simplicity",
    "explanation": "The text specifically states that DRY focuses on avoiding duplication in code, while KISS encourages keeping every solution as simple and direct as possible. They address different aspects of code quality.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What happens if a class has multiple responsibilities according to the SRP explanation?",
    "options": [
      "A change in one responsibility might require changes in the others",
      "The class will automatically become private",
      "The code will run faster due to increased complexity",
      "The compiler will refuse to run the program"
    ],
    "answer": "A change in one responsibility might require changes in the others",
    "explanation": "If a class has multiple responsibilities, a change in one area can unexpectedly force changes in other areas, leading to tightly coupled code that is harder to maintain and understand.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Who is credited with grouping the five principles under the acronym SOLID?",
    "options": [
      "Robert C. Martin",
      "Donald Knuth",
      "Alan Turing",
      "Bill Gates"
    ],
    "answer": "Robert C. Martin",
    "explanation": "Robert C. Martin (Uncle Bob) grouped these five principles under the acronym SOLID in the early 2000s. The other individuals are famous in computer science but are not associated with this specific grouping.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which of the following is an example of a Creational Pattern?",
    "options": [
      "Prototype",
      "Bridge",
      "Template Method",
      "Proxy"
    ],
    "answer": "Prototype",
    "explanation": "Prototype is a Creational pattern focused on object creation. Bridge and Proxy are Structural patterns, and Template Method is a Behavioral pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the primary focus of Behavioral Design Patterns?",
    "options": [
      "Communication between objects",
      "Object creation mechanisms",
      "Class composition and structure",
      "Database schema design"
    ],
    "answer": "Communication between objects",
    "explanation": "Behavioral patterns are concerned with communication between objects and how they distribute responsibility. Creational patterns handle creation, and Structural patterns handle composition.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "According to the text, applying SOLID principles like god-rules can lead to what negative outcome?",
    "options": [
      "Overengineering",
      "Under-engineering",
      "Faster execution",
      "Fewer bugs"
    ],
    "answer": "Overengineering",
    "explanation": "Applying SOLID principles everywhere without context, treating them as god-rules, usually leads to overengineering. This happens when principles are applied even when they do not help the specific situation.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What does the 'I' in the SOLID acronym stand for?",
    "options": [
      "Interface Segregation Principle",
      "Integration Implementation Principle",
      "Instantiation Inheritance Principle",
      "Integer Iteration Principle"
    ],
    "answer": "Interface Segregation Principle",
    "explanation": "The 'I' in SOLID stands for Interface Segregation Principle. The other options are terms that use the letter 'I' but are not the correct names of the principle.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which design pattern is classified as a Structural Pattern?",
    "options": [
      "Facade",
      "Strategy",
      "Singleton",
      "Command"
    ],
    "answer": "Facade",
    "explanation": "Facade is a Structural pattern used to compose interfaces. Strategy and Command are Behavioral patterns, and Singleton is a Creational pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the definition of the Single Responsibility Principle (SRP)?",
    "options": [
      "A class should have only one responsibility or job",
      "A class should be open for extension but closed for modification",
      "Derived classes must be substitutable for their base classes",
      "Clients should not be forced to depend on interfaces they do not use"
    ],
    "answer": "A class should have only one responsibility or job",
    "explanation": "SRP dictates that a class should have one reason to change, meaning it has only one responsibility. The other options describe the Open/Closed, Liskov Substitution, and Interface Segregation principles, respectively.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the goal of Behavioral patterns?",
    "options": [
      "To manage complex relationships and responsibilities between objects",
      "To optimize database queries",
      "To create visual user interfaces",
      "To encrypt sensitive data"
    ],
    "answer": "To manage complex relationships and responsibilities between objects",
    "explanation": "Behavioral patterns aim to manage complex relationships and responsibilities between objects, specifically focusing on communication and interaction.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the result of decoupling code components using the Dependency Inversion Principle?",
    "options": [
      "It allows independent updates and easier testing",
      "It makes the code run slower",
      "It forces all classes to inherit from a single parent",
      "It prevents the code from being compiled"
    ],
    "answer": "It allows independent updates and easier testing",
    "explanation": "Decoupling code components allows for independent updates and easier testing because modules are not reliant on the specific implementation details of one another.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which pattern is an example of a Behavioral Design Pattern?",
    "options": [
      "Command",
      "Abstract Factory",
      "Composite",
      "Flyweight"
    ],
    "answer": "Command",
    "explanation": "Command is a Behavioral pattern that encapsulates a request as an object. Abstract Factory is Creational, while Composite and Flyweight are Structural patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What does the 'D' in the SOLID acronym stand for?",
    "options": [
      "Dependency Inversion Principle",
      "Data Definition Principle",
      "Dynamic Design Principle",
      "Default Destructor Principle"
    ],
    "answer": "Dependency Inversion Principle",
    "explanation": "The 'D' in SOLID stands for Dependency Inversion Principle. The other options are incorrect terms that do not represent this specific design principle.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which of the following is listed as a main software design principle alongside DRY, YAGNI, and KISS?",
    "options": [
      "SOLID",
      "SOAP",
      "REST",
      "HTTP"
    ],
    "answer": "SOLID",
    "explanation": "The text lists DRY, YAGNI, KISS, and SOLID as the main software design principles. SOAP, REST, and HTTP are communication protocols or architectural styles, not design principles.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "How do software design principles generally improve code quality?",
    "options": [
      "By guiding developers toward cleaner architecture and fewer dependencies",
      "By increasing the number of lines of code",
      "By making the code harder to read for security purposes",
      "By eliminating the need for testing"
    ],
    "answer": "By guiding developers toward cleaner architecture and fewer dependencies",
    "explanation": "Software design principles improve code quality by guiding developers toward cleaner architecture, fewer dependencies, and easier long-term maintenance. They do not aim to increase lines of code or remove the need for testing.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which design pattern is categorized as a Creational Pattern?",
    "options": [
      "Builder",
      "Adapter",
      "Observer",
      "State"
    ],
    "answer": "Builder",
    "explanation": "Builder is a Creational pattern focused on constructing complex objects step-by-step. Adapter is Structural, while Observer and State are Behavioral patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What trait is considered critical for robust architectures according to the text on the Dependency Inversion Principle?",
    "options": [
      "Low coupling",
      "High complexity",
      "Hard coding",
      "Global state"
    ],
    "answer": "Low coupling",
    "explanation": "The text states that the Dependency Inversion Principle emphasizes abstractions to induce low coupling, which is a critical trait of robust architectures allowing for independent updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What does the 'O' in the SOLID acronym stand for?",
    "options": [
      "Open/Closed Principle",
      "Object-Oriented Principle",
      "Operator Overloading Principle",
      "Order of Operations Principle"
    ],
    "answer": "Open/Closed Principle",
    "explanation": "The 'O' in SOLID stands for Open/Closed Principle. The other options refer to general programming concepts or mathematical rules, not the specific design principle.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which design pattern is classified as a Behavioral Pattern?",
    "options": [
      "Iterator",
      "Decorator",
      "Singleton",
      "Bridge"
    ],
    "answer": "Iterator",
    "explanation": "Iterator is a Behavioral pattern used to traverse the elements of a collection. Decorator and Bridge are Structural patterns, and Singleton is a Creational pattern.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the primary purpose of the Dependency Inversion Principle in plain English?",
    "options": [
      "Reducing dependencies by disentangling modules and abstracting details",
      "Creating as many objects as possible",
      "Ensuring all classes are static",
      "Writing all code in a single line"
    ],
    "answer": "Reducing dependencies by disentangling modules and abstracting details",
    "explanation": "In plain English, the Dependency Inversion Principle suggests reducing dependencies by disentangling modules and abstracting details where possible to reduce coupling.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which of the following is an example of a Structural Design Pattern?",
    "options": [
      "Proxy",
      "Factory Method",
      "Template Method",
      "Prototype"
    ],
    "answer": "Proxy",
    "explanation": "Proxy is a Structural pattern that provides a surrogate or placeholder for another object to control access to it. Factory Method and Prototype are Creational, and Template Method is Behavioral.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Services within a microservices architecture should be highly cohesive and have what type of coupling between them?",
    "options": [
      "Low",
      "High",
      "Medium",
      "Variable"
    ],
    "answer": "Low",
    "explanation": "The text states that while services should be highly cohesive (self-contained), the coupling between services should be low to ensure they can function independently.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the goal of Creational patterns regarding object creation?",
    "options": [
      "To make object creation more flexible and reusable",
      "To make object creation as difficult as possible",
      "To create objects only at compile time",
      "To restrict object creation to a single class"
    ],
    "answer": "To make object creation more flexible and reusable",
    "explanation": "Creational patterns aim to solve the problem of creating objects in a flexible and reusable manner, abstracting the instantiation process.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "A developer has created a `User` class that handles user authentication, data storage, email notifications, and logging. Which SOLID principle is most directly violated by this implementation?",
    "options": [
      "The Single Responsibility Principle",
      "The Open/Closed Principle",
      "The Liskov Substitution Principle",
      "The Interface Segregation Principle"
    ],
    "answer": "The Single Responsibility Principle",
    "explanation": "The Single Responsibility Principle (SRP) states that a class should have one and only one reason to change, meaning it should have only one responsibility. In this case, the `User` class has multiple responsibilities: authentication, data storage, email notifications, and logging. Each of these areas might change independently, making the class harder to maintain and test. SRP violation leads to tightly coupled code where changes in one area might inadvertently affect others. The other principles address different concerns: Open/Closed focuses on extension without modification, Liskov Substitution deals with substitutability of subclasses, and Interface Segregation emphasizes creating focused interfaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "When implementing the Dependency Inversion Principle, which approach correctly demonstrates the principle in action?",
    "options": [
      "Creating a service class that directly instantiates its database connection",
      "Having a high-level module depend on both abstractions and concrete implementations",
      "Passing database interface dependencies through the constructor rather than creating them internally",
      "Moving all business logic into the database layer to reduce dependencies"
    ],
    "answer": "Passing database interface dependencies through the constructor rather than creating them internally",
    "explanation": "The Dependency Inversion Principle (DIP) states that high-level modules should not depend on low-level modules; both should depend on abstractions. By passing dependencies through constructors (dependency injection), you're depending on abstractions (interfaces) rather than concrete implementations. This allows for easier testing with mocks and independent updates to modules. Direct instantiation creates tight coupling to concrete implementations. Depending on both abstractions and concrete implementations still violates DIP. Moving logic to the database layer is an architectural decision unrelated to DIP and often creates an anemic domain model.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "A system needs to support multiple payment processors (PayPal, Stripe, CreditCard). New payment methods are expected to be added regularly. Which design pattern best supports adding new payment types without modifying existing payment processing logic?",
    "options": [
      "Singleton Pattern",
      "Adapter Pattern",
      "Strategy Pattern",
      "Proxy Pattern"
    ],
    "answer": "Strategy Pattern",
    "explanation": "The Strategy Pattern is ideal for this scenario because it defines a family of algorithms (payment processing), encapsulates each one, and makes them interchangeable. You can define a `PaymentStrategy` interface and create concrete implementations for each payment method. This allows the payment processing logic to remain unchanged when adding new strategies, adhering to the Open/Closed Principle. Singleton ensures only one instance exists, which doesn't address the extensibility need. Adapter helps make incompatible interfaces work together, but Strategy is better for swappable algorithms. Proxy controls access to objects rather than providing multiple implementation strategies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When working with a legacy third-party API that has an incompatible interface, which design pattern allows you to integrate it without modifying your existing codebase or the third-party library?",
    "options": [
      "Decorator Pattern",
      "Facade Pattern",
      "Adapter Pattern",
      "Bridge Pattern"
    ],
    "answer": "Adapter Pattern",
    "explanation": "The Adapter Pattern is specifically designed to solve interface incompatibility problems. It wraps the third-party API and translates calls from your code's expected interface to the API's actual interface, allowing integration without modifying either side. Decorator adds behavior dynamically without changing the interface. Facade simplifies a complex subsystem but doesn't change interfaces. Bridge separates abstraction from implementation to allow both to vary independently, but is more about design-time separation than integrating incompatible existing interfaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "A development team is debating whether to use inheritance or composition for their new feature. Which statement accurately represents the 'composition over inheritance' principle?",
    "options": [
      "Inheritance should always be avoided because it causes tight coupling",
      "Composition allows behavior to be changed at runtime, while inheritance is determined at compile time",
      "Composition results in better performance than inheritance in all scenarios",
      "Inheritance provides more flexibility because classes can inherit from multiple parents"
    ],
    "answer": "Composition allows behavior to be changed at runtime, while inheritance is determined at compile time",
    "explanation": "Composition over inheritance is preferred because it provides greater flexibility. With composition, you can change an object's behavior at runtime by swapping its composed components, whereas inheritance creates a static hierarchy determined at compile time. Composition also avoids the fragile base class problem and makes testing easier. Inheritance isn't always bad—it has valid use cases—but should be used judiciously. Performance differences vary by language and implementation, with neither being universally better. Multiple inheritance introduces complexity and ambiguity (the diamond problem), which many languages avoid or restrict.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When applying the Open/Closed Principle, which statement correctly describes how a class should be designed?",
    "options": [
      "Classes should be open for modification but closed for extension",
      "Classes should be open for extension but closed for modification",
      "Classes should be both open for modification and extension",
      "Classes should have all methods marked as final to prevent changes"
    ],
    "answer": "Classes should be open for extension but closed for modification",
    "explanation": "The Open/Closed Principle (OCP) states that software entities should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing, tested code. This is typically achieved through abstractions, polymorphism, and design patterns like Strategy and Decorator. Being open for modification would introduce risks and require re-testing existing functionality. While you can extend existing classes, the goal is to avoid modifying their source code. Making everything final prevents extension entirely, which contradicts the principle's intent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "A team has identified that several classes implement a large interface with methods they don't use. Which refactoring approach best addresses this issue while adhering to SOLID principles?",
    "options": [
      "Create a base class with default implementations for unused methods",
      "Split the large interface into smaller, role-specific interfaces",
      "Remove the unused methods from the interface and handle them elsewhere",
      "Add flags to the interface to indicate which methods are required"
    ],
    "answer": "Split the large interface into smaller, role-specific interfaces",
    "explanation": "This approach follows the Interface Segregation Principle (ISP), which states that clients shouldn't be forced to depend on interfaces they don't use. By splitting a large interface into smaller, focused ones, classes can implement only the methods relevant to their purpose. This reduces coupling and makes the code easier to understand and maintain. A base class with default implementations doesn't solve the dependency problem—classes still depend on methods they don't need. Removing methods breaks the contract for classes that do use them. Adding flags adds complexity and doesn't eliminate unnecessary dependencies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "When considering the Builder pattern, which scenario represents the most appropriate use case?",
    "options": [
      "Creating simple objects with only 2-3 required parameters",
      "When you need to ensure only one instance of a class exists",
      "Constructing complex objects with many optional parameters in a readable way",
      "When you need to create objects based on a prototype instance"
    ],
    "answer": "Constructing complex objects with many optional parameters in a readable way",
    "explanation": "The Builder pattern shines when constructing complex objects with many optional parameters, as it avoids the telescoping constructor problem and improves readability. Instead of multiple constructors or long parameter lists, builders provide a fluent API for step-by-step construction. For simple objects with few parameters, direct instantiation or simple factories are more appropriate. Singleton ensures a single instance, which is unrelated to object construction complexity. Prototype creates objects by cloning existing ones, useful when object creation is expensive, not for managing parameter complexity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In the context of Liskov Substitution Principle, which implementation would violate the principle?",
    "options": [
      "A Square class inheriting from Rectangle and overriding setWidth to maintain equal sides",
      "A UserRepository interface implemented by SqlUserRepository and InMemoryUserRepository",
      "A Logger interface implemented by FileLogger and ConsoleLogger",
      "A PaymentProcessor interface implemented by CreditCardPayment and PayPalPayment"
    ],
    "answer": "A Square class inheriting from Rectangle and overriding setWidth to maintain equal sides",
    "explanation": "The Liskov Substitution Principle (LSP) states that subtypes must be substitutable for their base types without altering program correctness. A Square inheriting from Rectangle violates LSP because squares don't behave like rectangles—a square's width and height are coupled, while a rectangle's are independent. Setting a square's width shouldn't change its height if it's being treated as a rectangle, breaking the expected behavior. The other examples show proper substitutable implementations where each subclass fulfills the interface contract without unexpected side effects, allowing them to be used interchangeably.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "A developer is considering whether to apply the Singleton pattern to their database connection class. Which statement represents a valid concern about using Singleton?",
    "options": [
      "Singleton prevents multiple database connections, limiting concurrent queries",
      "Singleton makes unit testing difficult due to global state and hidden dependencies",
      "Singleton increases memory usage by creating multiple instances",
      "Singleton pattern violates the Single Responsibility Principle"
    ],
    "answer": "Singleton makes unit testing difficult due to global state and hidden dependencies",
    "explanation": "Singletons create global state, which makes unit testing challenging because tests can share state and interfere with each other. They also hide dependencies—classes that use the Singleton don't declare it as a dependency, making the relationships opaque. While preventing multiple connections is actually the intended behavior of a connection pool (which is appropriate), the global access pattern is the problem. Singleton doesn't create multiple instances—it ensures only one exists. Singleton can violate SRP (managing both its responsibility and its own lifecycle), but the testing difficulty is a more immediate practical concern for development teams.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "When distinguishing between the Facade and Adapter patterns, what is the key difference in their purpose?",
    "options": [
      "Facade adds behavior to objects, while Adapter changes interfaces",
      "Facade simplifies a complex subsystem, while Adapter makes incompatible interfaces work together",
      "Adapter is for new systems, while Facade is only for legacy code",
      "Facade changes the underlying implementation, while Adapter only wraps it"
    ],
    "answer": "Facade simplifies a complex subsystem, while Adapter makes incompatible interfaces work together",
    "explanation": "The Facade pattern provides a simplified interface to a complex subsystem, making it easier to use without hiding the underlying complexity completely. It doesn't change interfaces but provides a unified entry point. The Adapter pattern specifically addresses interface incompatibility—it translates between different interfaces, enabling classes that couldn't otherwise work together to collaborate. Both can be used in new and legacy systems. Neither changes the underlying implementation—both wrap existing code to provide a different interface, but for different purposes (simplification vs. compatibility translation).",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "A system requires objects to notify multiple subscribers when state changes occur. The number and type of subscribers may vary at runtime. Which design pattern best addresses this requirement?",
    "options": [
      "Command Pattern",
      "Observer Pattern",
      "Mediator Pattern",
      "Chain of Responsibility Pattern"
    ],
    "answer": "Observer Pattern",
    "explanation": "The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified automatically. This is ideal for publish-subscribe scenarios where subscribers can dynamically register and unregister. Command encapsulates requests as objects, useful for undo/redo or queuing operations, not notification. Mediator defines an object that encapsulates how a set of objects interact, reducing direct coupling between them, but it's more about centralizing communication than one-to-many notifications. Chain of Responsibility passes a request along a chain of handlers until one handles it, which is different from notifying multiple interested parties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When applying the DRY (Don't Repeat Yourself) principle, which scenario represents an inappropriate application of the principle?",
    "options": [
      "Extracting a repeated calculation into a shared utility method",
      "Creating a base class to hold common fields shared by all child classes",
      "Combining two functions that coincidentally have similar implementations but different purposes",
      "Using a configuration constant instead of magic numbers scattered throughout the code"
    ],
    "answer": "Combining two functions that coincidentally have similar implementations but different purposes",
    "explanation": "DRY should be applied when code duplication represents the same concept or business logic. Combining functions that merely have similar implementations but serve different purposes violates the Single Responsibility Principle and creates confusion. Such coincidental similarity should be accepted as separate concerns, as future requirements may cause them to diverge further. Extracting repeated calculations, creating appropriate base classes for shared behavior, and using constants instead of magic numbers are all appropriate applications of DRY that improve maintainability without introducing conceptual coupling.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "A team is implementing a feature that requires undo/redo functionality for user actions. Which design pattern is most suitable for this requirement?",
    "options": [
      "Memento Pattern",
      "State Pattern",
      "Command Pattern",
      "Strategy Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command Pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. Each command can implement undo() to reverse its effects, making it ideal for undo/redo functionality. Memento captures and restores an object's internal state without violating encapsulation, which could work but is more about state snapshots than operations. State Pattern allows an object to alter its behavior when its internal state changes, useful for state machines but not specifically for undo/redo. Strategy Pattern defines interchangeable algorithms, useful for runtime flexibility but not for operation reversal.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "When implementing the Proxy pattern, which scenario would NOT be an appropriate use case?",
    "options": [
      "Lazy initialization of expensive-to-create objects",
      "Controlling access to sensitive objects based on user permissions",
      "Adding logging to all method calls of a service without modifying the service",
      "Changing the interface of a third-party library to match your application's needs"
    ],
    "answer": "Changing the interface of a third-party library to match your application's needs",
    "explanation": "Changing an interface to match your needs is the purpose of the Adapter pattern, not the Proxy pattern. Proxy provides a surrogate or placeholder to control access to an object while maintaining the same interface. Appropriate Proxy use cases include: Virtual Proxy (lazy initialization), Protection Proxy (access control), and Smart Reference (adding behavior like logging). The key distinction is that Proxy maintains the same interface as the real subject, while Adapter changes the interface to make incompatible interfaces work together. Using Proxy when you need Adapter would result in clients still having to work with the incompatible interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In a microservices architecture, how should the Dependency Inversion Principle influence service boundary design?",
    "options": [
      "Services should depend directly on each other's concrete implementations",
      "Services should define clear contracts (interfaces/APIs) and depend on those abstractions",
      "All services should inherit from a common BaseService class",
      "Services should avoid any dependencies to maintain complete autonomy"
    ],
    "answer": "Services should define clear contracts (interfaces/APIs) and depend on those abstractions",
    "explanation": "In microservices, Dependency Inversion means services should depend on well-defined contracts (APIs, message schemas) rather than concrete implementations. This allows services to evolve independently—the internal implementation of a service can change without breaking consumers as long as the contract remains stable. Direct dependencies on concrete implementations create tight coupling, defeating microservices' benefits. Inheriting from a common base class would introduce inappropriate coupling between unrelated services. While services should be autonomous, they inevitably need to collaborate; DIP ensures this collaboration happens through stable abstractions rather than brittle direct references.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which statement accurately describes a key difference between the Abstract Factory and Factory Method patterns?",
    "options": [
      "Abstract Factory creates one product, while Factory Method creates families of related products",
      "Factory Method uses inheritance, while Abstract Factory typically uses composition",
      "Abstract Factory is for simple objects, while Factory Method is for complex objects",
      "Factory Method is a creational pattern, while Abstract Factory is a structural pattern"
    ],
    "answer": "Factory Method uses inheritance, while Abstract Factory typically uses composition",
    "explanation": "Factory Method defines an interface for creating an object but lets subclasses decide which class to instantiate, relying on inheritance. Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes, typically implemented through composition with multiple factory methods. The key distinction is that Abstract Factory works with multiple product types (families), while Factory Method deals with a single product type. Both are creational patterns—this is not a distinguishing factor. Neither is specifically for simple vs. complex objects; the choice depends on the creation scenario, not object complexity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "A developer is applying YAGNI (You Aren't Gonna Need It) principle but is concerned about being unprepared for future requirements. How should YAGNI be correctly interpreted?",
    "options": [
      "Never plan ahead or consider extensibility in your design",
      "Don't implement functionality until it's actually needed, but design for reasonable change",
      "Write the simplest possible code regardless of maintainability concerns",
      "Remove all abstraction because it adds unnecessary complexity"
    ],
    "answer": "Don't implement functionality until it's actually needed, but design for reasonable change",
    "explanation": "YAGNI advises against implementing features or flexibility that you anticipate might be needed in the future but aren't required now. It doesn't mean avoiding all design considerations or writing unmaintainable code. You should still follow good practices (like SOLID) that make reasonable future changes possible, but avoid premature optimization and over-engineering for hypothetical scenarios. This prevents wasted effort on features that never materialize and reduces complexity. Writing unmaintainable code violates other principles and creates technical debt. Appropriate abstraction remains valuable when it addresses current needs effectively.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "When using the Decorator pattern, how does it differ from simple inheritance for extending behavior?",
    "options": [
      "Decorator is compile-time, while inheritance is runtime",
      "Decorator adds behavior dynamically without affecting other objects of the same class",
      "Inheritance always causes more classes than the Decorator pattern",
      "Decorator can only add behavior to interfaces, not concrete classes"
    ],
    "answer": "Decorator adds behavior dynamically without affecting other objects of the same class",
    "explanation": "The Decorator pattern attaches additional responsibilities to an object dynamically at runtime. Unlike inheritance, which creates a static class hierarchy, decorators allow you to combine behaviors in various combinations by wrapping objects. This is more flexible than inheritance, where behavior is fixed at compile time and applies to all instances of a subclass. Decorator works with concrete objects, not just interfaces. Both approaches can result in many classes—Decorator avoids class explosion for behavior combinations compared to inheritance. The key advantage is the runtime composability and the ability to add behavior to individual objects rather than entire classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "A system needs to represent a complex document structure where individual elements (paragraphs, images) and groups of elements (sections, chapters) need to be treated uniformly. Which pattern best addresses this requirement?",
    "options": [
      "Decorator Pattern",
      "Flyweight Pattern",
      "Composite Pattern",
      "Bridge Pattern"
    ],
    "answer": "Composite Pattern",
    "explanation": "The Composite Pattern composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions of objects uniformly. In a document structure, both leaf elements (paragraphs) and composite elements (sections containing paragraphs) can implement the same interface, enabling operations like rendering or word counting to work recursively across the structure. Decorator adds behavior without changing structure. Flyweight reduces memory usage by sharing intrinsic state. Bridge separates abstraction from implementation, useful when both can vary independently, not for representing hierarchies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "When considering the Template Method pattern, which scenario represents its most appropriate application?",
    "options": [
      "When algorithms in different subclasses should have different structure",
      "When you want to define the skeleton of an algorithm while allowing subclasses to override specific steps",
      "When you need to hide the entire algorithm implementation from subclasses",
      "When you want to change an object's behavior based on its internal state"
    ],
    "answer": "When you want to define the skeleton of an algorithm while allowing subclasses to override specific steps",
    "explanation": "The Template Method pattern defines the skeleton of an algorithm in a base class but lets subclasses override specific steps without changing the algorithm's structure. This promotes code reuse by invariant parts while allowing customization for variant parts. The base class controls the overall flow, ensuring the algorithm's integrity while providing extension points. If algorithms should have different structures, Template Method is not appropriate—Strategy or complete overriding would be better. Template Method doesn't hide the entire algorithm—it makes the structure visible while allowing step customization. State Pattern manages behavior changes based on internal state, which is different from Template Method's algorithm skeleton approach.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "A developer is concerned that their system has too many direct dependencies between components, making it difficult to change one component without affecting others. Which principle or pattern would most directly address this concern?",
    "options": [
      "Singleton Pattern to reduce the number of instances",
      "Law of Demeter to reduce coupling between objects",
      "Factory Pattern to centralize object creation",
      "Inheritance to share common behavior"
    ],
    "answer": "Law of Demeter to reduce coupling between objects",
    "explanation": "The Law of Demeter (also known as the Principle of Least Knowledge) states that an object should only talk to its immediate neighbors, avoiding knowledge of the internal structure of other objects. This reduces coupling by limiting the number of direct dependencies and preventing 'train wrecks' like `a.b.c.d.method()`. Singleton doesn't reduce coupling—it often increases it through global access. Factory centralizes creation but doesn't reduce runtime coupling between components. Inheritance creates tight coupling between parent and child classes, potentially making changes more difficult rather than easier. The Law of Demeter specifically targets excessive direct dependencies as a coupling reduction strategy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "When should the State pattern be preferred over using simple conditional statements (if/else or switch) to manage an object's behavior?",
    "options": [
      "When there are only 2-3 possible states",
      "When state transitions are simple and straightforward",
      "When the object's behavior changes significantly based on its state and transitions are complex",
      "When you need to optimize for maximum performance"
    ],
    "answer": "When the object's behavior changes significantly based on its state and transitions are complex",
    "explanation": "The State pattern is beneficial when an object's behavior varies significantly depending on its state, especially when there are many states, complex transitions, or when states need their own data and behavior. The pattern encapsulates state-specific logic in separate classes, making the code more maintainable and eliminating large conditional statements. For 2-3 simple states, conditionals are often more straightforward and don't warrant the pattern's overhead. If transitions are simple, the pattern's benefits are reduced. State pattern can add slight performance overhead due to object creation and indirection, so if raw performance is the only concern, conditionals might be faster but at the cost of maintainability for complex scenarios.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When implementing the Prototype pattern, what is the primary advantage over creating new objects using constructors?",
    "options": [
      "Prototype always uses less memory than constructor instantiation",
      "Prototype eliminates the need for classes altogether",
      "Prototype allows creating new objects by cloning existing ones, bypassing expensive initialization",
      "Prototype provides better encapsulation than constructors"
    ],
    "answer": "Prototype allows creating new objects by cloning existing ones, bypassing expensive initialization",
    "explanation": "The Prototype pattern creates new objects by cloning existing ones, which is particularly useful when object initialization is expensive (complex calculations, database queries, resource loading). Cloning is typically faster than re-running the initialization logic. Prototype doesn't inherently use less memory—a cloned object has similar memory footprint. You still need classes to define the objects being cloned. Encapsulation is similar between both approaches; the key benefit is performance for expensive initialization and flexibility when you need to create objects similar to existing ones without knowing their concrete classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "A system processes orders that go through multiple validation steps (inventory check, fraud detection, credit check). Some steps may stop the processing chain early. Which pattern best models this scenario?",
    "options": [
      "Observer Pattern",
      "Strategy Pattern",
      "Chain of Responsibility Pattern",
      "Command Pattern"
    ],
    "answer": "Chain of Responsibility Pattern",
    "explanation": "Chain of Responsibility passes a request along a chain of handlers, where each handler can either process the request or pass it to the next handler. This is ideal for validation pipelines where each check is a handler that can either approve (pass to next), reject (stop chain), or require more information. Observer notifies multiple subscribers of events, not sequential processing. Strategy defines interchangeable algorithms but doesn't handle sequential processing with early termination. Command encapsulates requests for undo/redo or queuing, not multi-step validation with potential early exit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "When would the Bridge pattern be more appropriate than simple inheritance?",
    "options": [
      "When you have a permanent, fixed relationship between abstraction and implementation",
      "When you want to avoid a permanent binding between abstraction and implementation, allowing both to vary independently",
      "When you need to ensure only one implementation exists for each abstraction",
      "When performance is the only concern and you need the fastest possible dispatch"
    ],
    "answer": "When you want to avoid a permanent binding between abstraction and implementation, allowing both to vary independently",
    "explanation": "The Bridge pattern decouples an abstraction from its implementation, allowing both to vary independently. This prevents the explosion of subclass combinations that would occur if you used inheritance to connect every abstraction variant with every implementation variant. For example, if you have multiple shapes (abstraction) and multiple rendering engines (implementation), Bridge allows adding new shapes or renderers without exponential subclass growth. Permanent binding suggests simple inheritance is sufficient. Bridge supports multiple implementations, not just one. Bridge adds a level of indirection that may have slight performance overhead compared to direct inheritance, though the difference is usually negligible.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "How does the KISS (Keep It Simple, Stupid) principle relate to applying design patterns?",
    "options": [
      "KISS means never using design patterns because they add complexity",
      "KISS means using the simplest pattern that solves the problem, avoiding over-engineering",
      "KISS means always writing procedural code instead of object-oriented code",
      "KISS means removing all comments and documentation to reduce code size"
    ],
    "answer": "KISS means using the simplest pattern that solves the problem, avoiding over-engineering",
    "explanation": "KISS advocates for simplicity and avoiding unnecessary complexity. When applied to design patterns, it means choosing the simplest solution that adequately addresses the problem—sometimes that's a pattern, sometimes it's straightforward code without a named pattern. Over-engineering by applying patterns where they're not needed violates KISS. KISS doesn't mean avoiding patterns entirely—patterns exist to solve real problems elegantly. Procedural vs. OO isn't a KISS determination—both can be simple or complex depending on the problem. Removing documentation reduces clarity and maintainability, contrary to KISS's goal of keeping systems understandable and workable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "In a system with high cohesion and low coupling, which characteristic would you expect to find?",
    "options": [
      "Each module handles many unrelated responsibilities",
      "Modules have minimal dependencies on each other and focused, related functionality within themselves",
      "All modules share a common dependency to simplify the architecture",
      "Changes in one module frequently require changes in many other modules"
    ],
    "answer": "Modules have minimal dependencies on each other and focused, related functionality within themselves",
    "explanation": "High cohesion means elements within a module are strongly related and work together to fulfill a well-defined responsibility. Low coupling means modules have minimal dependencies on each other. Together, these characteristics create maintainable systems where modules can be understood, tested, and modified independently. Modules with many unrelated responsibilities have low cohesion, violating SRP. Shared common dependencies increase coupling rather than reduce it. If changes in one module frequently require changes in others, the system has high coupling, which is the opposite of the desired low coupling architecture.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "When would you use the Iterator pattern rather than simply exposing a collection's internal structure?",
    "options": [
      "When you want to allow clients to modify the collection's internal structure directly",
      "When you want to provide a uniform way to traverse different aggregate structures without exposing their internal representation",
      "When you need the fastest possible iteration performance regardless of encapsulation",
      "When the collection will never change its internal implementation"
    ],
    "answer": "When you want to provide a uniform way to traverse different aggregate structures without exposing their internal representation",
    "explanation": "The Iterator pattern provides a way to access elements of an aggregate object sequentially without exposing its underlying representation. This allows you to change the collection's internal implementation without affecting client code, as the iterator interface remains stable. It also provides uniform traversal across different collection types. Iterator controls access rather than allowing direct modification. While there may be slight performance overhead compared to direct access, the encapsulation and flexibility benefits usually outweigh this. Even if the collection implementation won't change, Iterator provides a cleaner separation of concerns and a standard traversal interface.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "When using dependency injection, which approach provides the most flexibility for testing and configuration?",
    "options": [
      "Constructor injection for required dependencies and property injection for optional ones",
      "Using only property (setter) injection for all dependencies",
      "Creating dependencies directly within the class methods that need them",
      "Using service locator pattern to resolve dependencies on demand"
    ],
    "answer": "Constructor injection for required dependencies and property injection for optional ones",
    "explanation": "Constructor injection makes required dependencies explicit and ensures objects are always in a valid state, while property injection allows optional dependencies to be omitted without preventing object creation. This combination provides clarity, testability (required dependencies are easily mocked in constructors), and flexibility (optional dependencies can be swapped or omitted). Using only property injection can lead to objects in invalid state if required dependencies aren't set. Creating dependencies within methods creates tight coupling and makes testing difficult. Service locator pattern hides dependencies, making the relationship unclear and still coupling to the locator itself.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "When evaluating whether to introduce an abstraction (interface or abstract class), which question is most critical to ask?",
    "options": [
      "Will this abstraction reduce the total number of classes in the system?",
      "Do I have multiple implementations that need to be treated polymorphically?",
      "Will this abstraction allow me to write code with fewer characters?",
      "Can I use this abstraction to avoid learning the details of concrete classes?"
    ],
    "answer": "Do I have multiple implementations that need to be treated polymorphically?",
    "explanation": "The primary reason to introduce an abstraction is when you need multiple implementations to be used interchangeably. This supports polymorphism, dependency inversion, and the Open/Closed Principle. Premature abstraction without multiple implementations or a clear need for substitutability is over-engineering. Abstractions often increase the total number of classes (interface + implementations), not reduce them. While abstractions can improve code clarity, character count is not a meaningful metric. Understanding concrete classes is still valuable; abstractions don't replace that knowledge but rather provide stable contracts for interaction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "A system needs to process different file types (CSV, JSON, XML). Each file type has unique parsing logic but should produce a common data structure. Which pattern best accommodates this requirement?",
    "options": [
      "Singleton Pattern",
      "Adapter Pattern",
      "Factory Method Pattern",
      "Proxy Pattern"
    ],
    "answer": "Factory Method Pattern",
    "explanation": "Factory Method is appropriate here because it defines an interface for creating objects but lets subclasses decide which class to instantiate. You can define a `FileParserFactory` with methods like `createParser(FileType)` that returns the appropriate parser implementation. Each parser (CSVParser, JSONParser, XMLParser) implements a common interface, producing the same data structure. This encapsulates the creation logic and makes it easy to add new file types. Singleton ensures only one instance, which doesn't address the multiple implementation need. Adapter makes incompatible interfaces work together, but here we have different implementations of the same purpose, not incompatible interfaces. Proxy controls access, not creation or implementation variation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "When designing for extensibility, which approach best adheres to the Open/Closed Principle while maintaining code clarity?",
    "options": [
      "Adding conditional statements to handle new cases in existing methods",
      "Defining extension points (interfaces, hooks, events) that allow behavior to be added without modifying existing code",
      "Copying existing code and modifying it for new requirements",
      "Making all methods virtual to allow unlimited overriding"
    ],
    "answer": "Defining extension points (interfaces, hooks, events) that allow behavior to be added without modifying existing code",
    "explanation": "Open/Closed Principle is achieved by designing extension points—interfaces for new implementations, hooks for customization, or events for subscribers. These allow new functionality to be added without modifying existing, tested code. Conditional statements require modifying existing code when adding cases, violating OCP. Copying and modifying code violates DRY and creates maintenance burden. Making all methods virtual doesn't provide structure for extension—it just allows overriding anywhere, which can lead to unexpected behavior and doesn't guide where extensions should occur. Well-defined extension points make the system both extensible and understandable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "A legacy application has a single monolithic class handling all business logic. The team wants to refactor it but is overwhelmed by the scope. What is the most practical approach?",
    "options": [
      "Rewrite the entire application from scratch using all SOLID principles",
      "Identify distinct responsibilities and gradually extract them into separate classes through iterative refactoring",
      "Add interfaces to the monolithic class without changing its structure",
      "Apply all 23 GoF design patterns to ensure future flexibility"
    ],
    "answer": "Identify distinct responsibilities and gradually extract them into separate classes through iterative refactoring",
    "explanation": "Incremental refactoring by identifying and extracting separate responsibilities is the most practical approach. This follows the Strangler Fig pattern, allowing gradual improvement while keeping the system functional. Each extraction can be tested independently, reducing risk. Rewriting from scratch is risky and often fails to capture all business nuances. Adding interfaces without structural change doesn't address the monolith's maintainability issues. Applying all design patterns would be over-engineering and likely increase complexity rather than reduce it. Focused, iterative changes based on clear responsibilities provide the best balance of progress and risk management.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "According to the Dependency Inversion Principle (DIP), what is the primary mechanism used to decouple high-level modules from low-level modules?",
    "options": [
      "Inheriting from concrete base classes to ensure code reuse",
      "Depending on abstractions rather than concrete implementations",
      "Using static factory methods to hide object creation logic",
      "Implementing the Singleton pattern to limit instance creation"
    ],
    "answer": "Depending on abstractions rather than concrete implementations",
    "explanation": "The Dependency Inversion Principle states that high-level modules should not depend on low-level modules; both should depend on abstractions. This decouples the system, allowing independent updates and easier testing. Inheriting from concrete classes increases coupling, static factories are a creational pattern not specific to DIP, and Singleton is a specific creational pattern that often creates global state issues, violating DIP.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "The Single Responsibility Principle (SRP) states that a class should have only one reason to change. In a practical scenario involving a `User` class, which of the following designs would most likely violate SRP?",
    "options": [
      "A `User` class that holds user data and delegates persistence to a separate `UserRepository` interface",
      "A `User` class that calculates its own statistics, handles its own database persistence, and manages authentication logic",
      "A `User` class containing properties for `username` and `email`, with methods to validate those properties",
      "A `User` class that accepts a `Logger` interface dependency to write logs, separating the act of logging from business logic"
    ],
    "answer": "A `User` class that calculates its own statistics, handles its own database persistence, and manages authentication logic",
    "explanation": "SRP is violated when a class has multiple responsibilities—in this case, data modeling, business logic (statistics), persistence, and security (authentication). This creates 'tightly coupled code' where a change in the database schema or authentication provider forces changes to the User entity. Delegating persistence or using dependency injection (Options A and D) promotes separation of concerns.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "When applying SOLID principles, what architectural smell indicates that the principles have been applied dogmatically rather than pragmatically, often leading to overengineering?",
    "options": [
      "The presence of multiple small interfaces and classes that require constant navigation to understand simple workflows",
      "The absence of duplicate code across different modules of the application",
      "The use of design patterns explicitly named after their Gang of Four definitions",
      "A reliance on automated unit tests to verify behavior"
    ],
    "answer": "The presence of multiple small interfaces and classes that require constant navigation to understand simple workflows",
    "explanation": "While SOLID encourages modularity, applying it 'like god-rules' often leads to overengineering—characterized by excessive abstraction, indirection, and fragmentation. This makes the codebase harder to understand and navigate (fragmentation). The absence of duplicate code (Option B) is generally desired (DRY), and using standard patterns (Option C) is good practice if used correctly.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which Creational pattern is best suited for scenarios where the cost of creating a new object is expensive, and you need to create new objects by cloning a prototype instance rather than building from scratch?",
    "options": [
      "Builder Pattern",
      "Factory Method Pattern",
      "Prototype Pattern",
      "Singleton Pattern"
    ],
    "answer": "Prototype Pattern",
    "explanation": "The Prototype pattern specifies the kind of objects to create using a prototypical instance and creates new objects by copying this prototype. This avoids the inherent cost of creation and improves performance when object initialization is expensive. The Builder pattern focuses on constructing complex objects step-by-step, Factory Method defines an interface for creation, and Singleton restricts instantiation to one object.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the key distinction between the Adapter pattern and the Facade pattern in terms of their structural intent?",
    "options": [
      "Adapter changes the interface of an existing object, while Facade provides a simplified interface to a complex subsystem",
      "Adapter adds new functionality dynamically, while Facade removes functionality to reduce complexity",
      "Adapter is used at compile time, while Facade is strictly a runtime pattern",
      "Facade is used to connect incompatible interfaces, while Adapter is used to hide legacy systems"
    ],
    "answer": "Adapter changes the interface of an existing object, while Facade provides a simplified interface to a complex subsystem",
    "explanation": "The Adapter pattern acts as a bridge between two incompatible interfaces, wrapping an object to make it compatible with another client expectation. The Facade pattern provides a unified, high-level interface to a set of interfaces in a subsystem, making the subsystem easier to use without changing the underlying interfaces.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of Structural patterns, the Composite pattern allows you to compose objects into tree structures. What critical constraint must client code respect to treat individual and composite objects uniformly?",
    "options": [
      "The client must maintain a separate registry for leaf nodes to avoid recursion loops",
      "The client must check the type of the object (Leaf vs Composite) before invoking methods",
      "The client must be aware of the specific implementation details of the composite structure",
      "The client must treat individual objects and compositions of objects uniformly through a common interface"
    ],
    "answer": "The client must treat individual objects and compositions of objects uniformly through a common interface",
    "explanation": "The core power of the Composite pattern is that clients can treat individual objects (Leaf) and compositions (Composite) identically. If the client has to check types (Option B), the pattern's benefit of simplifying client code is lost. The pattern uses recursion to handle operations on the tree structure transparently.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which Behavioral pattern is most appropriate for defining a skeleton of an algorithm in a base class, while deferring specific steps to subclasses without changing the algorithm's structure?",
    "options": [
      "Strategy Pattern",
      "Command Pattern",
      "Template Method Pattern",
      "Observer Pattern"
    ],
    "answer": "Template Method Pattern",
    "explanation": "The Template Method pattern defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable, but does not enforce a fixed skeleton.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "When implementing the Observer pattern, what is a common 'gotcha' regarding memory management in garbage-collected languages?",
    "options": [
      "Observers are never deallocated because the subject creates strong references to them",
      "The subject class cannot be serialized if it has observers attached",
      "Observers must be instantiated using the Singleton pattern to ensure thread safety",
      "The notification order is guaranteed to be alphabetical by observer class name"
    ],
    "answer": "Observers are never deallocated because the subject creates strong references to them",
    "explanation": "If a Subject holds a strong reference to an Observer, the Observer cannot be garbage collected even if it is no longer needed elsewhere in the application, leading to memory leaks. This is often solved by using weak references. Serialization and thread safety are separate concerns, and notification order is implementation-dependent (often FIFO), not alphabetical.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "The Strategy pattern and State pattern are structurally similar. What is the defining behavioral difference that determines when to use one over the other?",
    "options": [
      "State pattern is used for sorting algorithms, while Strategy is used for searching",
      "Strategy pattern allows the client to change the behavior explicitly, while State pattern transitions behavior automatically based on internal state",
      "Strategy pattern creates objects, while State pattern destroys objects",
      "State pattern is restricted to a maximum of three states, while Strategy supports unlimited behaviors"
    ],
    "answer": "Strategy pattern allows the client to change the behavior explicitly, while State pattern transitions behavior automatically based on internal state",
    "explanation": "While both rely on composition and polymorphism, the Strategy pattern typically passes the desired behavior to the context object (explicit configuration). The State pattern allows the Context to change its behavior by changing its internal state object, often with the State objects handling the transition logic themselves implicitly.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In the Builder pattern, why is it recommended to enforce the use of a static inner class or a separate director for the construction process rather than using a massive constructor with many optional parameters?",
    "options": [
      "To ensure that the object is always immutable",
      "To improve performance by avoiding reflection",
      "To avoid the 'telescoping constructor' problem and improve code readability",
      "To prevent the use of setter methods after construction"
    ],
    "answer": "To avoid the 'telescoping constructor' problem and improve code readability",
    "explanation": "The telescoping constructor problem occurs when you have a complex object with many optional parameters, leading to a constructor list that is hard to read and prone to errors (e.g., passing two integers of the same type in the wrong order). The Builder pattern separates the construction logic from the representation, allowing for readable, step-by-step construction. While immutability is often a result, the primary reason is handling complexity.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Which structural pattern is specifically designed to decouple an abstraction from its implementation so that the two can vary independently?",
    "options": [
      "Adapter Pattern",
      "Bridge Pattern",
      "Decorator Pattern",
      "Proxy Pattern"
    ],
    "answer": "Bridge Pattern",
    "explanation": "The Bridge pattern is used to separate an abstraction from its implementation so that the two can be modified independently without affecting each other. Adapter is used to make incompatible interfaces work together. Decorator adds responsibilities dynamically. Proxy controls access to an object. Bridge is distinct because it is used up-front in design, whereas Adapter is often used to integrate existing code.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "When using the Decorator pattern, how does it differ from simple subclassing for extending functionality?",
    "options": [
      "Subclassing is static and applies to the whole class, while Decorator provides dynamic, flexible addition of responsibilities to individual objects",
      "Subclassing is faster at runtime than using the Decorator pattern",
      "Decorator pattern modifies the class source code directly, whereas subclassing creates a new file",
      "Subclassing requires a factory, whereas Decorator does not"
    ],
    "answer": "Subclassing is static and applies to the whole class, while Decorator provides dynamic, flexible addition of responsibilities to individual objects",
    "explanation": "Subclassing creates a new type at compile time, affecting all instances. The Decorator pattern allows you to attach additional responsibilities to an individual object dynamically at runtime without affecting other objects of the same class. This provides a much more flexible alternative to subclassing for extending functionality.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In a microservices architecture, services should be highly cohesive. Which design pattern violation is most likely to occur if a service tries to do too many things (low cohesion)?",
    "options": [
      "The service becomes easier to deploy but harder to test",
      "The service becomes a 'God Service' or monolith, leading to tightly coupled deployment and scaling issues",
      "The service automatically implements the Singleton pattern",
      "The service shifts from a Behavioral pattern to a Creational pattern"
    ],
    "answer": "The service becomes a 'God Service' or monolith, leading to tightly coupled deployment and scaling issues",
    "explanation": "Low cohesion within a service means it handles unrelated business logic. This aggregates too much responsibility into a single unit, effectively creating a distributed monolith or 'God Service'. This violates the goal of independent deployability and scalability mentioned in the source text.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "The Liskov Substitution Principle (LSP) implies that objects of a superclass should be replaceable with objects of a subclass without breaking the application. Which of the following scenarios violates LSP?",
    "options": [
      "A subclass overrides a method to perform a specialized calculation while maintaining the same return type",
      "A subclass throws a specific checked exception that the superclass contract does not declare",
      "A subclass adds a new method that is not present in the superclass",
      "A subclass calls the superclass method within its own implementation using `super()`"
    ],
    "answer": "A subclass throws a specific checked exception that the superclass contract does not declare",
    "explanation": "LSP requires that the subtype must not require the client to catch exceptions that the base type did not specify. If a superclass method does not throw an exception, the subclass should not throw one (that the client isn't expecting), as this breaks the 'replaceability' rule. Adding new methods (Option C) is acceptable (subtype can have more behavior), but it cannot change the expected behavior of existing interface contracts in a way that breaks the parent.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "Which design pattern utilizes a shared interface to encapsulate a request as an object, thereby allowing parameterization of clients with different requests, queuing of requests, and logging of operations?",
    "options": [
      "Memento Pattern",
      "Command Pattern",
      "Visitor Pattern",
      "Mediator Pattern"
    ],
    "answer": "Command Pattern",
    "explanation": "The Command pattern turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations. Memento captures state, Visitor separates algorithms from structure, and Mediator reduces chaotic dependencies between objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the primary risk of implementing the Singleton pattern in a multi-threaded environment without proper synchronization?",
    "options": [
      "The program will consume infinite memory",
      "Multiple instances of the Singleton class may be created",
      "The Singleton will fail to compile",
      "The program will suffer from stack overflow"
    ],
    "answer": "Multiple instances of the Singleton class may be created",
    "explanation": "In a race condition (e.g., lazy initialization), two threads may simultaneously evaluate the check for the instance existence, find it null, and both create an instance. This violates the Singleton constraint. Synchronization or double-checked locking is required to ensure atomicity during creation.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "The Interface Segregation Principle (ISP) advocates for many small, specific interfaces rather than one large, general-purpose interface. What is the negative consequence of violating ISP?",
    "options": [
      "Code execution speed decreases significantly",
      "Clients are forced to depend on methods they do not use, leading to unnecessary coupling and potential compilation errors if the interface changes",
      "The system becomes impossible to serialize",
      "It prevents the use of the Factory pattern"
    ],
    "answer": "Clients are forced to depend on methods they do not use, leading to unnecessary coupling and potential compilation errors if the interface changes",
    "explanation": "ISP violation creates 'fat interfaces' (interface pollution). If a class implements a fat interface but only uses a few methods, it still depends on the entire contract. Changes to unused methods force the implementing class to recompile and change, increasing coupling and fragility.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Which Creational pattern is focused on creating families of related or dependent objects without specifying their concrete classes?",
    "options": [
      "Abstract Factory Pattern",
      "Factory Method Pattern",
      "Builder Pattern",
      "Prototype Pattern"
    ],
    "answer": "Abstract Factory Pattern",
    "explanation": "The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. This is distinct from the Factory Method, which creates a single object via inheritance. Abstract Factory uses composition to delegate object creation to a separate factory object.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the context of the Proxy pattern, what distinguishes a 'Virtual Proxy' from a 'Protection Proxy'?",
    "options": [
      "Virtual Proxy creates expensive objects on demand, while Protection Proxy controls access based on access rights",
      "Virtual Proxy is used for security, while Protection Proxy is used for performance",
      "Virtual Proxy works only over a network, while Protection Proxy works only in memory",
      "Virtual Proxy increases the size of the object, while Protection Proxy decreases it"
    ],
    "answer": "Virtual Proxy creates expensive objects on demand, while Protection Proxy controls access based on access rights",
    "explanation": "A Virtual Proxy acts as a placeholder for expensive-to-create objects, instantiating them only when needed (optimization). A Protection Proxy controls access to the real object based on access rights (security). Both act as surrogates, but their intent differs.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "The Open/Closed Principle (OCP) states that software entities should be open for extension but closed for modification. Which design pattern most directly supports this principle by using composition instead of inheritance to add behaviors?",
    "options": [
      "Decorator Pattern",
      "Singleton Pattern",
      "MVC Pattern",
      "Abstract Factory Pattern"
    ],
    "answer": "Decorator Pattern",
    "explanation": "The Decorator pattern is the quintessential example of OCP. It allows you to add new responsibilities to objects dynamically without altering the code of the class (closed for modification) by wrapping them in decorator objects (open for extension). This avoids the rigid class hierarchy explosion that often occurs when trying to extend functionality solely through inheritance.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "Which Behavioral pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly?",
    "options": [
      "Mediator Pattern",
      "Observer Pattern",
      "Command Pattern",
      "State Pattern"
    ],
    "answer": "Mediator Pattern",
    "explanation": "The Mediator pattern defines an object that encapsulates how a set of objects interact. It promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. Observer is a one-to-many dependency, Command is request encapsulation, and State is internal state management.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "When implementing the Repository pattern, what is the primary architectural benefit regarding the domain logic?",
    "options": [
      "It duplicates the logic of the database engine to improve speed",
      "It provides a collection-like interface for accessing domain objects, abstracting the underlying persistence logic",
      "It forces the database schema to match the object model exactly",
      "It eliminates the need for a data mapper"
    ],
    "answer": "It provides a collection-like interface for accessing domain objects, abstracting the underlying persistence logic",
    "explanation": "The Repository pattern mediates between the domain and data mapping layers, acting like an in-memory domain object collection. The goal is to separate the logic that retrieves the data (persistence infrastructure) from the business logic (domain), making the domain ignorant of database details.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In the Chain of Responsibility pattern, how is the request handled if no handler in the chain processes it?",
    "options": [
      "The request automatically retries from the beginning of the chain",
      "The request is discarded silently unless a default handler is implemented at the end of the chain",
      "The application throws a runtime exception",
      "The request is sent to a Singleton logger"
    ],
    "answer": "The request is discarded silently unless a default handler is implemented at the end of the chain",
    "explanation": "In the standard Chain of Responsibility, the request passes along the chain until a handler handles it. If it reaches the end of the chain and no handler processes it, it typically falls off the end (is discarded). Safe implementations often add a default 'do nothing' or 'log error' handler at the very end to ensure termination.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the 'Double Dispatch' mechanism, and which Behavioral pattern relies on it to perform operations on a group of related object structures without modifying the classes of the elements on which it operates?",
    "options": [
      "It is a method overloading technique used by the Factory Method pattern",
      "It is a mechanism where the operation executed depends on the types of two requests, utilized by the Visitor pattern",
      "It is a type of thread synchronization used by the Active Object pattern",
      "It is a database transaction isolation level used by the Unit of Work pattern"
    ],
    "answer": "It is a mechanism where the operation executed depends on the types of two requests, utilized by the Visitor pattern",
    "explanation": "Double dispatch means that the operation performed depends on the runtime type of *two* objects: the visitor and the element being visited. The Visitor pattern uses this to separate operations from the object structure. It allows you to define new operations without changing the classes of the elements they work on.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Which design pattern would you use to ensure that an object has only one instance globally, but also provide a global point of access to it, specifically when lazy initialization and controlled access are required?",
    "options": [
      "Monostate Pattern",
      "Singleton Pattern",
      "Prototype Pattern",
      "Service Locator Pattern"
    ],
    "answer": "Singleton Pattern",
    "explanation": "The Singleton pattern ensures a class has only one instance and provides a global point of access to it. It is specifically designed for scenarios where exactly one object is needed to coordinate actions across the system. Monostate achieves a similar effect (behavioral singularity) via static fields but allows instantiation of multiple objects that share state. Service Locator is a dependency injection pattern, not an instance restriction pattern.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the primary disadvantage of using the Prototype pattern compared to creating a new object via a constructor?",
    "options": [
      "Prototype is always slower than a constructor call",
      "Prototype can be complex to implement when objects have circular references or deep copying requirements",
      "Prototype prevents the use of inheritance",
      "Prototype requires the use of global variables"
    ],
    "answer": "Prototype can be complex to implement when objects have circular references or deep copying requirements",
    "explanation": "The Prototype pattern relies on cloning (copying). Deep copying an object graph can be complex and error-prone, especially if objects contain circular references or references to external resources (like database connections) that shouldn't be copied. Constructors are generally straightforward for simple initialization.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the Flyweight pattern improve performance in applications with a large number of similar objects?",
    "options": [
      "By compressing the objects using standard ZIP algorithms",
      "By sharing intrinsic state (common, immutable data) among objects to reduce memory footprint",
      "By storing objects on a disk rather than in RAM",
      "By preventing the creation of any new objects after the first ten"
    ],
    "answer": "By sharing intrinsic state (common, immutable data) among objects to reduce memory footprint",
    "explanation": "The Flyweight pattern reduces the cost of complex object models by sharing common, immutable 'intrinsic' state across many objects. Instead of storing that state in every object, it is stored once in a flyweight object. The 'extrinsic' state (unique data) is passed in by the client context.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which pattern is specifically designed to separate the algorithms from the object structure they operate on, allowing the addition of new operations without changing the classes of the elements?",
    "options": [
      "Iterator Pattern",
      "Visitor Pattern",
      "Strategy Pattern",
      "Composite Pattern"
    ],
    "answer": "Visitor Pattern",
    "explanation": "The Visitor pattern represents an operation to be performed on the elements of an object structure. It lets you define a new operation without changing the classes of the elements on which it operates. This is useful when the object structure is stable but the operations need to vary frequently.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of the 'Inversion of Control' (IoC) principle, how does the Dependency Injection (DI) pattern differ from the Service Locator pattern?",
    "options": [
      "DI asks for dependencies, while Service Locator creates dependencies internally",
      "DI requires the consumer to ask a locator for dependencies, while Service Locator pushes dependencies to the consumer",
      "DI pushes dependencies into the consumer (usually via constructor), while Service Locator requires the consumer to ask a registry for them",
      "DI is a compile-time pattern, while Service Locator is a runtime pattern"
    ],
    "answer": "DI pushes dependencies into the consumer (usually via constructor), while Service Locator requires the consumer to ask a registry for them",
    "explanation": "With Dependency Injection, the class is given its dependencies (push) by a framework or constructor, making the class's dependencies explicit in the signature. With Service Locator, the class has a dependency on the Locator itself and pulls its dependencies from it (ask), which hides the dependencies and makes the class harder to test and reason about.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "When applying the SOLID principles, which principle is most directly related to the concept of 'Composition over Inheritance'?",
    "options": [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Dependency Inversion Principle",
      "Liskov Substitution Principle"
    ],
    "answer": "Open/Closed Principle",
    "explanation": "Composition over Inheritance is a strategy often used to satisfy the Open/Closed Principle. Rigid inheritance hierarchies are brittle; changing a base class breaks all subclasses. Using composition (e.g., Strategy or Decorator patterns) allows you to add new functionality (Open for extension) by changing how objects are composed, without modifying existing code (Closed for modification).",
    "difficulty": "Advanced"
  }
]