[
  {
    "id": 1,
    "question": "Which keyword is used to declare a variable with a type that cannot be changed at runtime in TypeScript?",
    "options": [
      "const",
      "let",
      "var",
      "static"
    ],
    "answer": "const",
    "explanation": "While `const` prevents reassignment in JavaScript and TypeScript, TypeScript's type system prevents changing the data type of a variable regardless of whether `let` or `const` is used.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the correct syntax to assign a string type to a variable?",
    "options": [
      "let name: string = \"John\";",
      "string let name = \"John\";",
      "let name = \"John\": string;",
      "let string name = \"John\";"
    ],
    "answer": "let name: string = \"John\";",
    "explanation": "In TypeScript, the type annotation follows the variable name, separated by a colon (`:`).",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which basic type represents a sequence of characters in TypeScript?",
    "options": [
      "text",
      "str",
      "string",
      "char"
    ],
    "answer": "string",
    "explanation": "TypeScript uses the lowercase `string` type (based on the JavaScript primitive) for text data.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the return type of a function that does not return a value?",
    "options": [
      "null",
      "undefined",
      "void",
      "never"
    ],
    "answer": "void",
    "explanation": "The `void` type indicates that a function does not return any value. `null` and `undefined` are valid values, but `void` is the correct return type annotation.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which of the following is NOT a valid basic type in TypeScript?",
    "options": [
      "boolean",
      "void",
      "integer",
      "string"
    ],
    "answer": "integer",
    "explanation": "TypeScript does not have an `integer` type; it uses `number` for all numeric values (integers and floats).",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "How do you define an array of numbers in TypeScript?",
    "options": [
      "Array[number]",
      "number[]",
      "numbers[]",
      "Array<numbers>"
    ],
    "answer": "number[]",
    "explanation": "The syntax `number[]` indicates an array where every element is a number. `Array<number>` is also valid but `Array[number]` is incorrect syntax.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is a Tuple in TypeScript?",
    "options": [
      "An array with a fixed number of elements of specific types",
      "A key-value pair data structure",
      "A type that cannot be changed",
      "A function that returns two values"
    ],
    "answer": "An array with a fixed number of elements of specific types",
    "explanation": "Tuples allow you to express an array where the type of a fixed number of elements is known, e.g., `[string, number]`.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which keyword is used to create custom types for objects?",
    "options": [
      "object",
      "type",
      "schema",
      "structure"
    ],
    "answer": "type",
    "explanation": "The `type` keyword (alias) is used to define custom type shapes, including object types. `interface` is also used, but `object` is a type, not a keyword for defining them.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the difference between `interface` and `type` for object definitions?",
    "options": [
      "Interfaces are hoisted, type aliases are not",
      "Type aliases cannot define object shapes",
      "Interfaces are compiled to JavaScript objects",
      "There is no difference"
    ],
    "answer": "Interfaces are hoisted, type aliases are not",
    "explanation": "Interfaces can be declared before they are used due to hoisting, while type aliases must be declared before use. Both can define object shapes.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "How do you make a property optional in an interface?",
    "options": [
      "Using the `?` symbol after the property name",
      "Using the `optional` keyword",
      "Setting the property to `null`",
      "Wrapping the property in square brackets"
    ],
    "answer": "Using the `?` symbol after the property name",
    "explanation": "Appending a question mark (e.g., `age?: number`) marks a property as optional in TypeScript interfaces and types.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which union type allows a variable to be a string or a number?",
    "options": [
      "string & number",
      "string + number",
      "string | number",
      "string, number"
    ],
    "answer": "string | number",
    "explanation": "The vertical bar `|` represents a Union Type, meaning the value can be any one of the listed types.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What does the `enum` type allow you to define?",
    "options": [
      "A set of named numeric constants",
      "A dynamic list of strings",
      "A type that excludes specific values",
      "A generic function signature"
    ],
    "answer": "A set of named numeric constants",
    "explanation": "Enums allow a developer to define a set of named constants, often used to represent a fixed set of choices.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the `any` type used for?",
    "options": [
      "To allow any type of value, opting out of type checking",
      "To represent the absence of a value",
      "To define a generic type",
      "To represent a collection of mixed types"
    ],
    "answer": "To allow any type of value, opting out of type checking",
    "explanation": "`any` is a special type that turns off type checking, allowing you to assign any value to it without compiler errors.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which type is the type-safe counterpart of `any`?",
    "options": [
      "unknown",
      "never",
      "void",
      "mixed"
    ],
    "answer": "unknown",
    "explanation": "`unknown` forces you to perform type checks before using the value, whereas `any` allows arbitrary operations.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "How do you explicitly cast a variable to a type?",
    "options": [
      "let x = variable as string;",
      "let x = cast(variable, string);",
      "let x = <string>variable;",
      "Both A and C"
    ],
    "answer": "Both A and C",
    "explanation": "TypeScript allows type assertions using the `as` keyword or the angle-bracket syntax `<Type>`.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What does `Partial<T>` utility type do?",
    "options": [
      "Makes all properties of `T` optional",
      "Makes all properties of `T` required",
      "Removes null and undefined from `T`",
      "Creates a new type excluding properties from `T`"
    ],
    "answer": "Makes all properties of `T` optional",
    "explanation": "`Partial` constructs a type with all properties of `T` set to optional, useful for updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which operator is used to access the type of a variable or property?",
    "options": [
      "typeof",
      "instanceof",
      "type",
      ":"
    ],
    "answer": "typeof",
    "explanation": "In a type context, `typeof` extracts the type of a variable or property expression.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the purpose of Generics in TypeScript?",
    "options": [
      "To create reusable components that work with a variety of types",
      "To speed up the execution of functions",
      "To enforce strict null checks",
      "To define interfaces only"
    ],
    "answer": "To create reusable components that work with a variety of types",
    "explanation": "Generics allow you to write code that can handle different types while maintaining type safety, such as `List<T>`.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which symbol is used for generic type parameters?",
    "options": [
      "< >",
      "( )",
      "[ ]",
      "{ }"
    ],
    "answer": "< >",
    "explanation": "Angle brackets (e.g., `<T>`) are used to declare generic type parameters in functions, classes, and interfaces.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the behavior of the `readonly` modifier?",
    "options": [
      "Prevents modification of a property after initialization",
      "Makes a property private",
      "Allows a property to be modified only once",
      "Hides the property from the object instance"
    ],
    "answer": "Prevents modification of a property after initialization",
    "explanation": "The `readonly` keyword ensures that a property cannot be reassigned once it has been set.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the `keyof` operator used for?",
    "options": [
      "To create a union type of all keys in an object type",
      "To get the value of a specific key",
      "To check if a key exists in an object",
      "To iterate over object properties"
    ],
    "answer": "To create a union type of all keys in an object type",
    "explanation": "`keyof T` produces a string or number literal union of the property names of type `T`.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which utility type creates a new type by excluding properties from another type?",
    "options": [
      "Omit<T, K>",
      "Exclude<T, U>",
      "Pick<T, K>",
      "Ignore<T, K>"
    ],
    "answer": "Omit<T, K>",
    "explanation": "`Omit` constructs a type by picking all properties from `T` and then removing `K`. `Exclude` removes types from a union, not properties from an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "How do you define a function that takes a string and returns a number?",
    "options": [
      "function myFunc(arg: string): number { return 0; }",
      "function myFunc(arg: string) returns number { return 0; }",
      "function myFunc: string => number { return 0; }",
      "function myFunc(number arg): string { return ''; }"
    ],
    "answer": "function myFunc(arg: string): number { return 0; }",
    "explanation": "Function syntax is `(arg: Type): ReturnType`. The colon separates the parameter list from the return type.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the `never` type?",
    "options": [
      "The type of values that never occur, such as in functions that always throw",
      "The type of variables that are not defined yet",
      "An alias for the `null` type",
      "The type of functions that return nothing"
    ],
    "answer": "The type of values that never occur, such as in functions that always throw",
    "explanation": "`never` represents the type of values that never occur, used for functions that throw errors or infinite loops.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What does the `NonNullable<T>` utility type do?",
    "options": [
      "Removes `null` and `undefined` from `T`",
      "Ensures `T` is not a boolean",
      "Converts `T` to a number",
      "Makes `T` optional"
    ],
    "answer": "Removes `null` and `undefined` from `T`",
    "explanation": "`NonNullable` creates a new type by excluding `null` and `undefined` from the provided type.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which file is the configuration file for a TypeScript project?",
    "options": [
      "tsconfig.json",
      "typescript.json",
      "package.json",
      "ts.json"
    ],
    "answer": "tsconfig.json",
    "explanation": "`tsconfig.json` specifies the root files and the compiler options required to build the project.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the `Pick<T, K>` utility type used for?",
    "options": [
      "Constructing a type by picking the set of properties `K` from `T`",
      "Selecting the first `K` properties from `T`",
      "Picking a random value from `T`",
      "Filtering properties based on a condition"
    ],
    "answer": "Constructing a type by picking the set of properties `K` from `T`",
    "explanation": "`Pick` allows you to create a new object type by selecting only specific properties from an existing type.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is a Type Guard?",
    "options": [
      "A runtime check that ensures the type of a variable within a conditional block",
      "A keyword that locks a variable to a specific type",
      "A compiler directive to ignore types",
      "A comment describing the type"
    ],
    "answer": "A runtime check that ensures the type of a variable within a conditional block",
    "explanation": "Type guards (e.g., `typeof x === \"string\"`) allow the TypeScript compiler to narrow down the type of a variable.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which access modifier is the default for class members?",
    "options": [
      "public",
      "private",
      "protected",
      "internal"
    ],
    "answer": "public",
    "explanation": "In TypeScript, class members are `public` by default unless marked otherwise.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "How do you implement an interface in a class?",
    "options": [
      "Using the `implements` keyword",
      "Using the `extends` keyword",
      "Using the `interface` keyword",
      "Using the `inherits` keyword"
    ],
    "answer": "Using the `implements` keyword",
    "explanation": "Classes use `implements` to adhere to the structure defined by an interface, whereas `extends` is used for inheritance.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What does the `??` operator do?",
    "options": [
      "Returns the right-hand operand when the left is null or undefined",
      "Returns the right-hand operand when the left is falsy",
      "Checks if two values are equal in type",
      "Concatenates two strings"
    ],
    "answer": "Returns the right-hand operand when the left is null or undefined",
    "explanation": "The Nullish Coalescing Operator (`??`) is a logical operator that returns the right-hand side operand only when the left side is `null` or `undefined`.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the `Record<Keys, Type>` utility type?",
    "options": [
      "An object type constructed with keys of type `Keys` and values of type `Type`",
      "A list of historical actions",
      "A type that records function calls",
      "A type that stores a tuple of values"
    ],
    "answer": "An object type constructed with keys of type `Keys` and values of type `Type`",
    "explanation": "`Record` is used to map keys to values, useful for defining dictionary-like objects (e.g., `Record<string, number>`).",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the difference between `interface` and `type` when extending?",
    "options": [
      "Interfaces can extend multiple interfaces; types use intersections",
      "Types can extend interfaces, but interfaces cannot extend types",
      "Only types can be extended",
      "They cannot be extended"
    ],
    "answer": "Interfaces can extend multiple interfaces; types use intersections",
    "explanation": "Interfaces support declaration merging and extend via `extends`. Types are merged using the `&` intersection operator.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which command compiles a TypeScript file named `main.ts`?",
    "options": [
      "tsc main.ts",
      "node main.ts",
      "npm start main.ts",
      "ts compile main.ts"
    ],
    "answer": "tsc main.ts",
    "explanation": "The `tsc` (TypeScript Compiler) command is used to transpile `.ts` files into `.js` files.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "How does TypeScript check types?",
    "options": [
      "Statically at compile time",
      "Dynamically at runtime",
      "Both at compile time and runtime",
      "Only when explicitly requested"
    ],
    "answer": "Statically at compile time",
    "explanation": "TypeScript performs static type checking during the compilation process; once compiled to JavaScript, type information is erased.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary difference between the `unknown` and `any` types in TypeScript?",
    "options": [
      "`any` allows arbitrary property access, while `unknown` requires type narrowing before operations",
      "`unknown` is used for object types, while `any` is used for primitive types",
      "`any` is implicitly compatible with all types, but `unknown` is not compatible with any type other than itself",
      "`unknown` performs runtime type checking, while `any` performs compile-time checking"
    ],
    "answer": "`any` allows arbitrary property access, while `unknown` requires type narrowing before operations",
    "explanation": "`any` effectively turns off type checking, allowing any operation. `unknown` is the type-safe counterpart, forcing developers to prove the type via assertions or guards before usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which utility type constructs a type by picking the set of keys `K` from type `T`?",
    "options": [
      "Extract",
      "Pick",
      "Omit",
      "Record"
    ],
    "answer": "Pick",
    "explanation": "`Pick<T, K>` constructs a type by picking the set of properties `K` from `T`. `Omit` is the inverse, creating a type by removing `K`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How does TypeScript's structural typing system affect interface compatibility?",
    "options": [
      "Interfaces are only compatible if they explicitly extend each other",
      "Interfaces are compatible if they contain the same name, regardless of structure",
      "Interfaces are compatible if they have identical or compatible property structures (duck typing)",
      "Interfaces are never compatible with type aliases"
    ],
    "answer": "Interfaces are compatible if they have identical or compatible property structures (duck typing)",
    "explanation": "TypeScript uses structural typing; an object is valid if its shape matches the required interface, even if it wasn't explicitly declared to implement it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the purpose of the `infer` keyword within conditional types?",
    "options": [
      "To explicitly cast a variable to a different type",
      "To infer the type of a variable within a generic function",
      "To capture a type from a generic constraint for use in the true branch of a conditional",
      "To check if a type extends a specific class"
    ],
    "answer": "To capture a type from a generic constraint for use in the true branch of a conditional",
    "explanation": "`infer` is used in conditional types to declare a type variable that TypeScript will infer from the type being checked, allowing for type extraction (e.g., extracting the return type of a function).",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which statement accurately describes `void` versus `never` in TypeScript?",
    "options": [
      "`void` represents a function that returns null, while `never` represents a function that returns undefined",
      "`void` represents the absence of a return value type, while `never` represents a value that never occurs",
      "`void` functions must not return anything, while `never` functions can return any type",
      "There is no difference; they are interchangeable"
    ],
    "answer": "`void` represents the absence of a return value type, while `never` represents a value that never occurs",
    "explanation": "`void` is used for functions that don't return a meaningful value (often returning undefined). `never` is used for functions that throw errors or loop infinitely, indicating code is unreachable after the call.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the result of the `keyof` operator when applied to a type?",
    "options": [
      "An array of the object's property values",
      "A union type of the object's property names (keys)",
      "The first key found in the object",
      "A boolean indicating if the object has keys"
    ],
    "answer": "A union type of the object's property names (keys)",
    "explanation": "The `keyof` operator produces a string or number literal union of the known public property names of the input type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Which feature allows TypeScript to narrow down the type of a variable within a conditional block?",
    "options": [
      "Type Assertion",
      "Type Guard",
      "Type Alias",
      "Type Casting"
    ],
    "answer": "Type Guard",
    "explanation": "Type guards (e.g., `typeof x === 'string'` or `x instanceof Array`) are runtime checks that allow the TypeScript compiler to narrow the type of a variable in specific code blocks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the output type of `ReturnType<typeof setTimeout>`?",
    "options": [
      "number",
      "NodeJS.Timeout",
      "void",
      "never"
    ],
    "answer": "NodeJS.Timeout",
    "explanation": "In Node.js environments, `setTimeout` returns a `NodeJS.Timeout` object (or a number in older browser environments), not the timer ID directly typed as `number` depending on the specific lib definitions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What does the `as const` assertion do to an object literal?",
    "options": [
      "It casts the object to a generic `const` type",
      "It infers the most specific literal type for all properties and makes them readonly",
      "It prevents the object from being garbage collected",
      "It allows the object properties to be modified only if they are primitives"
    ],
    "answer": "It infers the most specific literal type for all properties and makes them readonly",
    "explanation": "`as const` creates an immutable type where string properties become string literals, numbers become number literals, and the object becomes readonly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "How can you define a type that represents all subsets of properties of a given Interface `User`?",
    "options": [
      "Required<User>",
      "Partial<User>",
      "Pick<User, keyof User>",
      "Omit<User, never>"
    ],
    "answer": "Partial<User>",
    "explanation": "The `Partial<T>` utility type constructs a type with all properties of `T` set to optional.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is a 'Discriminated Union' in TypeScript?",
    "options": [
      "A union of types that share a common, literal-type property used to distinguish between them",
      "A union type that has been stripped of its null and undefined values",
      "A type that combines all properties of multiple interfaces into one",
      "A type alias for the `|` operator"
    ],
    "answer": "A union of types that share a common, literal-type property used to distinguish between them",
    "explanation": "Discriminated unions allow TypeScript to narrow types based on a specific shared property (the discriminant), enabling type-safe access to unique properties of each union member.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which utility type constructs a type by excluding `null` and `undefined` from type `T`?",
    "options": [
      "NonNullable",
      "NotNull",
      "Defined",
      "Required"
    ],
    "answer": "NonNullable",
    "explanation": "`NonNullable<T>` creates a new type by removing `null` and `undefined` from `T`. It is equivalent to `T extends null | undefined ? never : T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What happens when `strictNullChecks` is enabled in `tsconfig.json`?",
    "options": [
      "All variables are automatically typed as `never`",
      "`null` and `undefined` are only allowed if explicitly typed or part of a union",
      "Variables are never allowed to be `null`",
      "It removes the ability to use optional parameters"
    ],
    "answer": "`null` and `undefined` are only allowed if explicitly typed or part of a union",
    "explanation": "When enabled, `null` and `undefined` are distinct types. Variables that might be null must be handled, preventing many 'cannot read property of undefined' runtime errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which operator is used to query the type of a variable or property in TypeScript?",
    "options": [
      "typeof",
      "instanceof",
      "typeof()",
      "typeOf"
    ],
    "answer": "typeof",
    "explanation": "In a type context, `typeof` retrieves the type of a variable or property, distinct from the JavaScript operator which returns a string.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the purpose of `tsconfig.json`?",
    "options": [
      "To manage project dependencies and scripts",
      "To configure how the TypeScript compiler behaves and which files to compile",
      "To define the runtime behavior of the application",
      "To store user environment variables"
    ],
    "answer": "To configure how the TypeScript compiler behaves and which files to compile",
    "explanation": "The `tsconfig.json` file defines the root files and the compiler options required to build the project.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the `Parameters` utility type used for?",
    "options": [
      "To extract the return type of a function",
      "To construct a tuple type of the parameters taken by a function type",
      "To make all parameters of a function optional",
      "To enforce parameters to be of a specific type"
    ],
    "answer": "To construct a tuple type of the parameters taken by a function type",
    "explanation": "`Parameters<T>` extracts the parameter types from a function type `T` and returns them as a tuple.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In TypeScript, which keyword is used to define an abstract method within an abstract class?",
    "options": [
      "interface",
      "virtual",
      "abstract",
      "static"
    ],
    "answer": "abstract",
    "explanation": "The `abstract` keyword is used to define methods that must be implemented by derived classes but have no implementation in the base class.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "How do Template Literal Types enhance TypeScript's type system?",
    "options": [
      "They allow strings to be automatically converted to numbers",
      "They enable the definition of string types based on string manipulation patterns",
      "They enforce runtime string formatting",
      "They create string aliases for better readability"
    ],
    "answer": "They enable the definition of string types based on string manipulation patterns",
    "explanation": "Template Literal types allow building string types by concatenating literal types and unions, effectively enabling type-level string parsing and validation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the `satisfies` operator introduced in TypeScript 4.9 used for?",
    "options": [
      "To check if an interface satisfies a class contract",
      "To validate that an expression matches a specific type without losing type information of the expression",
      "To cast a value to `any`",
      "To assert that a variable is not null"
    ],
    "answer": "To validate that an expression matches a specific type without losing type information of the expression",
    "explanation": "Unlike type annotations which widen the literal type, `satisfies` ensures the value conforms to the type but retains the specific literal type for inference.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the result of using `enum` in TypeScript?",
    "options": [
      "It creates a type that is always compatible with `number` but not `string`",
      "It generates both a type and a runtime object that maps the enum members to their values",
      "It is purely a compile-time construct and generates no JavaScript code",
      "It is equivalent to a `const` object"
    ],
    "answer": "It generates both a type and a runtime object that maps the enum members to their values",
    "explanation": "Standard enums are real objects that exist at runtime, allowing reverse mapping (name -> value, value -> name) for numeric enums.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "How does the `ThisType` utility function work?",
    "options": [
      "It creates a type that represents the global 'this' object",
      "It statically identifies the type of 'this' within object literals for method chaining",
      "It binds a function to a specific class instance",
      "It automatically infers 'this' context without needing configuration"
    ],
    "answer": "It statically identifies the type of 'this' within object literals for method chaining",
    "explanation": "`ThisType<T>` does not transform the type; it signals to the compiler that `this` inside the methods of the annotated object literal should be of type `T`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the `Record<Keys, Type>` utility used for?",
    "options": [
      "To record all changes made to an object",
      "To construct an object type whose property keys are of a specific type and values are another type",
      "To log type errors to the console",
      "To create a dictionary of function types"
    ],
    "answer": "To construct an object type whose property keys are of a specific type and values are another type",
    "explanation": "`Record<K, T>` creates an object type where all keys are `K` and all values are `T`, effectively mapping a union of keys to a value type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the function overloading syntax in TypeScript?",
    "options": [
      "Defining multiple functions with the same name and different parameter counts or types in the same scope",
      "Using the `overload` keyword before the function definition",
      "Creating a generic function with a constraint",
      "Defining a function inside a namespace"
    ],
    "answer": "Defining multiple functions with the same name and different parameter counts or types in the same scope",
    "explanation": "Overloading allows multiple function signatures to be defined, followed by a single implementation signature that must be compatible with all overloads.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which TypeScript feature allows you to import a type only for type checking, ensuring it is removed in compilation?",
    "options": [
      "import type",
      "import {}",
      "const import",
      "type require"
    ],
    "answer": "import type",
    "explanation": "`import type { Foo }` ensures that the import is completely erased during emission, ensuring no runtime overhead for type-only imports.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is 'Branding' in TypeScript advanced typing?",
    "options": [
      "A feature to apply CSS styles to components",
      "A pattern to simulate nominal typing by intersecting with a unique generic type",
      "The process of compiling TypeScript to JavaScript",
      "A way to name variables"
    ],
    "answer": "A pattern to simulate nominal typing by intersecting with a unique generic type",
    "explanation": "Since TypeScript is structurally typed, branding (e.g., `interface USD { __brand: unique symbol }`) prevents distinct types from being interchangeable even if their structures are identical.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How do you define a recursive type in TypeScript?",
    "options": [
      "By using the `self` keyword",
      "By referencing the type alias within its own definition, often using conditional types to terminate the recursion",
      "By using the `super` keyword",
      "Recursive types are not supported in TypeScript"
    ],
    "answer": "By referencing the type alias within its own definition, often using conditional types to terminate the recursion",
    "explanation": "Recursive types can be defined by having an interface or type alias refer to itself, which is useful for tree structures or deep type manipulation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Under TypeScript's 'strictFunctionTypes' or 'strict' mode, how are parameter types in function types treated regarding variance?",
    "options": [
      "Bivariant, allowing arguments to be subtypes or supertypes",
      "Covariant, allowing arguments to be subtypes only",
      "Contravariant, allowing arguments to be supertypes only",
      "Invariant, requiring exact type matches for arguments"
    ],
    "answer": "Contravariant, allowing arguments to be supertypes only",
    "explanation": "Strict mode enforces contravariance for function parameters (or bi-variance for methods due to practicality), meaning you can pass a function accepting a supertype where a function accepting a subtype is expected. By default, TypeScript allows bivariance for soundness-compromising compatibility.",
    "difficulty": "Advanced"
  },
  {
    "id": 63,
    "question": "What is the primary difference between the `satisfies` operator and a standard type annotation?",
    "options": [
      "`satisfies` erases the specific type information, keeping only the base type",
      "`satisfies` ensures the expression matches the type but retains the specific inferred type of the expression",
      "`satisfies` performs runtime validation of the data structure",
      "Type annotations allow widening of literals, while `satisfies` prevents it"
    ],
    "answer": "`satisfies` ensures the expression matches the type but retains the specific inferred type of the expression",
    "explanation": "The `satisfies` operator validates that a value conforms to a specific type without widening the value to that type, preserving more specific literal types (e.g., specific string literals instead of just `string`).",
    "difficulty": "Advanced"
  },
  {
    "id": 64,
    "question": "When does a Conditional Type `T extends U ? X : Y` distribute over union types in `T`?",
    "options": [
      "Only if `U` is a union type",
      "When the `T` parameter is a naked type parameter (unwrapped)",
      "Conditional types never distribute over unions automatically",
      "Only when the `--strictDistribution` flag is enabled"
    ],
    "answer": "When the `T` parameter is a naked type parameter (unwrapped)",
    "explanation": "Distributive Conditional Types occur when the checked type (`T`) is a naked type parameter. TypeScript automatically maps the conditional type over each constituent of the union.",
    "difficulty": "Advanced"
  },
  {
    "id": 65,
    "question": "How can you implement nominal typing (branding) in TypeScript's structural type system to prevent distinct but structurally identical types from being assigned to each other?",
    "options": [
      "Using the `unique` keyword on the type declaration",
      "Adding a private property using a `unique symbol` type to the interface",
      "Applying the `@nominal` decorator to the class",
      "Declaring the type in a `namespace` to scope it"
    ],
    "answer": "Adding a private property using a `unique symbol` type to the interface",
    "explanation": "Because structural typing compares shapes, adding a property with a unique symbol type (which is impossible to forge outside its scope) creates a 'brand' that makes structurally similar objects incompatible.",
    "difficulty": "Advanced"
  },
  {
    "id": 66,
    "question": "What is the behavior of the `ThisType<T>` utility in TypeScript?",
    "options": [
      "It explicitly types the `this` parameter of all functions in the current scope",
      "It transforms the current type into a class that extends `T`",
      "It statically identifies the type of `this` within object literals that contain methods",
      "It asserts that a function is a bound function of type `T`"
    ],
    "answer": "It statically identifies the type of `this` within object literals that contain methods",
    "explanation": "`ThisType<T>` does not transform a type; it serves as a marker for a contextual object literal. If a containing object literal type has a `ThisType<T>` marker, the `this` type inside its methods is inferred as `T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 67,
    "question": "What compiler error occurs when a TypeScript type recursion exceeds the instantiation depth limit (e.g., 50 or 1000 levels)?",
    "options": [
      "Type 'X' is not generic",
      "Excessive stack depth comparing types 'X' and 'Y'",
      "Type instantiation is excessively deep and possibly infinite",
      "Circular reference detected in type definition"
    ],
    "answer": "Type instantiation is excessively deep and possibly infinite",
    "explanation": "TypeScript limits recursive type instantiation to prevent compiler hangs (stack overflow). When this limit is hit, it throws 'Type instantiation is excessively deep and possibly infinite'.",
    "difficulty": "Advanced"
  },
  {
    "id": 68,
    "question": "In TypeScript 4.0+, variadic tuple types allow the spread operator to be generic. What represents a tuple type that starts with a string, has a generic middle, and ends with a boolean?",
    "options": [
      "`[string, ...T[], boolean]`",
      "`[string, T..., boolean]`",
      "`[string, ...Array<T>, boolean]`",
      "`[string] extends T ? T : [boolean]`"
    ],
    "answer": "`[string, ...Array<T>, boolean]`",
    "explanation": "While `...T[]` is often accepted syntax in specific positions, the strictly standard way to represent a generic variadic rest of a tuple is `...Array<T>` or `...[T]` depending on context, but `...Array<T>` acts as the generic sequence.",
    "difficulty": "Advanced"
  },
  {
    "id": 69,
    "question": "When using `keyof` on a type with an index signature (e.g., `{ [k: string]: any }`), what is the resulting type?",
    "options": [
      "`string | number`",
      "`string`",
      "`number`",
      "`never`"
    ],
    "answer": "`string | number`",
    "explanation": "JavaScript object keys are coerced to strings, but TypeScript includes `number` in the keyof result for types with string index signatures to allow numeric access syntax.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "How does TypeScript handle the `this` parameter in a function type definition?",
    "options": [
      "It is erased during compilation and only used for static type checking",
      "It becomes the first argument in the generated JavaScript function",
      "It is ignored if the function is an arrow function",
      "It enforces that the function must be a class method"
    ],
    "answer": "It is erased during compilation and only used for static type checking",
    "explanation": "The `this` parameter is a purely compile-time syntactical artifact for type-checking the context of a function call; it does not exist in the emitted JavaScript code.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the result of applying the `keyof` operator to a type that includes a 'unique symbol' key?",
    "options": [
      "It returns `typeof Symbol`",
      "It returns the specific literal type of that unique symbol",
      "It omits the symbol key from the union",
      "It throws a compilation error"
    ],
    "answer": "It returns the specific literal type of that unique symbol",
    "explanation": "Unlike regular symbols, `unique symbol`s are literal types. `keyof` includes this specific literal type in the resulting union, allowing strict access to that specific property.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What utility type construct is equivalent to `T extends (...args: any) => infer R ? R : any`?",
    "options": [
      "`Parameters`",
      "`ReturnType`",
      "`InstanceType`",
      "`ThisParameterType`"
    ],
    "answer": "`ReturnType`",
    "explanation": "This conditional type infers the return type `R` of a function type `T`. The built-in utility `ReturnType<T>` abstracts this pattern.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In mapped types, how can you remove the `readonly` modifier from all properties of a type?",
    "options": [
      "`-readonly`",
      "`mutable`",
      "`!readonly`",
      "`ReadonlyWriter`"
    ],
    "answer": "`-readonly`",
    "explanation": "Mapped types support adding modifiers with `readonly` or `?`, and removing them with `-readonly` or `-?`. To make properties mutable, use `{ -readonly [P in keyof T]: T[P] }`.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "How does the `Omit<T, K>` utility type differ from `Exclude<T, K>`?",
    "options": [
      "`Omit` removes keys from an object type; `Exclude` removes constituent types from a union",
      "`Exclude` removes keys from an object type; `Omit` removes constituent types from a union",
      "`Omit` is for primitive types; `Exclude` is for object types",
      "There is no difference; they are aliases"
    ],
    "answer": "`Omit` removes keys from an object type; `Exclude` removes constituent types from a union",
    "explanation": "`Exclude` acts on Unions (e.g., `string | number`), removing matching members. `Omit` acts on Objects, constructing a new type by picking all keys except those specified in `K`.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What feature introduced in TypeScript 4.1 allows for the manipulation of string literal types via pattern matching?",
    "options": [
      "Conditional Type Strings",
      "Template Literal Types",
      "String Intrinsic Manipulation",
      "Regex Type Guards"
    ],
    "answer": "Template Literal Types",
    "explanation": "Template Literal Types allow embedding types within strings using `${...}` syntax, enabling powerful string manipulation and type generation based on string patterns.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the result of `keyof any` in TypeScript?",
    "options": [
      "`string | number`",
      "`string | number | symbol`",
      "`any`",
      "`never`"
    ],
    "answer": "`string | number | symbol`",
    "explanation": "`keyof any` returns the set of all possible types used as object keys in JavaScript/TypeScript: strings, numbers, and symbols.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How does TypeScript handle excess property checking for object literals assigned to a typed variable?",
    "options": [
      "It always allows excess properties",
      "It only checks excess properties if the object literal is freshly created",
      "It checks excess properties only when `strictNullChecks` is on",
      "It removes excess properties at runtime"
    ],
    "answer": "It only checks excess properties if the object literal is freshly created",
    "explanation": "Excess property checking is a special heuristic that applies only when object literals are assigned directly to a target type. It prevents typos but does not apply to existing variables or widened types.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Which `tsconfig.json` option preserves the `this` context of methods passed as callbacks, preventing them from becoming `undefined`?",
    "options": [
      "`noImplicitThis`",
      "`strictBindCallApply`",
      "`useStrictForThis`",
      "`preserveThis`"
    ],
    "answer": "`noImplicitThis`",
    "explanation": "While `noImplicitThis` flags errors on `this` of type `any`, the behavior of ensuring context is usually handled by compiler options regarding function binding, but specifically, `noImplicitThis` is the check that ensures `this` is typed correctly to identify context loss. (Note: In pure TS config, `noImplicitThis` forces explicit `this` typing).",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What happens when you use the `as const` assertion on an array literal?",
    "options": [
      "The array becomes readonly, and elements are inferred as their literal types (e.g., '2' instead of string)",
      "The array becomes a constant variable that cannot be reassigned",
      "The array is optimized for garbage collection",
      "The array elements are converted to enums"
    ],
    "answer": "The array becomes readonly, and elements are inferred as their literal types (e.g., '2' instead of string)",
    "explanation": "`as const` creates an immutable readonly tuple where the type is narrowed to the specific literal values provided, rather than widening them to primitives like `string` or `number`.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the output type of the `Awaited<T>` utility?",
    "options": [
      "The unwrapped type of a Promise, recursively unwrapping nested Promises",
      "The Promise constructor type",
      "The type of the `await` keyword, but only one level deep",
      "The type `T` if it is not a Promise, otherwise `never`"
    ],
    "answer": "The unwrapped type of a Promise, recursively unwrapping nested Promises",
    "explanation": "`Awaited` (introduced in TS 4.5) recursively unwraps Promises to retrieve the final resolution type. It mimics the behavior of `await` at the type level.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which variance rule applies to generic types in TypeScript regarding their type parameters?",
    "options": [
      "Type parameters are always invariant",
      "Type parameters are covariant by default",
      "Variance depends on whether the parameter is used in input or output position",
      "Type parameters are contravariant by default"
    ],
    "answer": "Variance depends on whether the parameter is used in input or output position",
    "explanation": "TypeScript checks variance based on usage. Parameters used only in outputs (returns) are covariant. Parameters used only in inputs (arguments) are contravariant. Used in both results in invariance.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In the context of Template Literal Types, how do you convert a union of strings to uppercase?",
    "options": [
      "`Uppercase`",
      "`toUpper`",
      "`String.toUpper`",
      "`Capitalize`"
    ],
    "answer": "`Uppercase`",
    "explanation": "TypeScript provides four intrinsic string manipulation types: `Uppercase`, `Lowercase`, `Capitalize`, and `Uncapitalize`. `Uppercase` converts the entire string union to uppercase.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What does the `--noUncheckedIndexedAccess` compiler flag do?",
    "options": [
      "It prevents accessing arrays by numeric index",
      "It adds `undefined` to the return type of index access operations (e.g., `arr[0]`, `obj['key']`)",
      "It forces all arrays to be typed as `ReadonlyArray`",
      "It disables implicit any types for index signatures"
    ],
    "answer": "It adds `undefined` to the return type of index access operations (e.g., `arr[0]`, `obj['key']`)",
    "explanation": "By default, TypeScript assumes index access always returns the value type (e.g., `string[]` index returns `string`). This flag makes it realistic by returning `T | undefined`, forcing safe checking.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How can you enforce that a class constructor is not callable without the `new` keyword?",
    "options": [
      "Using the `@constructor` decorator",
      "Setting the `class` property `newable` to true",
      "Enabling `noImplicitThis`",
      "It is enforced by default; classes cannot be called as functions"
    ],
    "answer": "It is enforced by default; classes cannot be called as functions",
    "explanation": "TypeScript classes emit functions that require `new`. Calling a class constructor as a function is a compile-time error. (Note: While JS allows this in some legacy patterns, TS enforces safety).",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the behavior of the `NonNullable` utility type?",
    "options": [
      "It removes `null` and `undefined` from type `T`",
      "It ensures the type is not `void`",
      "It checks if a variable is null at runtime",
      "It creates a type that accepts only `null` or `undefined`"
    ],
    "answer": "It removes `null` and `undefined` from type `T`",
    "explanation": "`NonNullable` constructs a type by excluding `null` and `undefined` from `T`. It is equivalent to `T & {}` or `T extends null | undefined ? never : T`.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "When using a declaration merge for a class and an interface, what can the interface add to the class?",
    "options": [
      "Implementation logic and computed properties",
      "Additional type definitions for members, but not implementation",
      "Private constructors",
      "Static property initialization"
    ],
    "answer": "Additional type definitions for members, but not implementation",
    "explanation": "Interface merging with a class allows adding type definitions (method signatures, properties). It cannot add implementation code (function bodies) or initialization logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "How does the `infer` keyword behave when used within a contravariant position (e.g., function parameters) in a conditional type?",
    "options": [
      "It infers a union of all possible arguments",
      "It infers an intersection of arguments",
      "It fails to compile",
      "It infers the base type `any`"
    ],
    "answer": "It infers an intersection of arguments",
    "explanation": "Inference in contravariant positions (like function parameters) results in an intersection type (e.g., `(x: A) => void` and `(x: B) => void` infers `A & B`).",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the relationship between `unknown` and `any` regarding type safety?",
    "options": [
      "`unknown` is the top type (`any` is the bottom type)",
      "`any` is the top type; `unknown` is a top type that forces type narrowing before use",
      "`unknown` is a subtype of `any`",
      "They are identical except for naming"
    ],
    "answer": "`any` is the top type; `unknown` is a top type that forces type narrowing before use",
    "explanation": "Both are top types. However, `any` disables type checking completely, while `unknown` enforces strict checking by requiring the value to be narrowed (checked) before any operation can be performed on it.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which type operator allows you to create a new type by picking a set of properties `K` from type `T`?",
    "options": [
      "`Pick`",
      "`Select`",
      "`Omit`",
      "`Extract`"
    ],
    "answer": "`Pick`",
    "explanation": "The `Pick` utility type constructs a type by picking the set of properties `K` (string literal or union of literals) from `T`. `Omit` does the opposite by excluding `K`.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How do you define a recursive type alias in TypeScript without encountering the 'Type alias X circularly references itself' error?",
    "options": [
      "Use `type` keyword exclusively",
      "Use an interface, or use a type wrapper that delays the recursion",
      "Enable `--recursiveTypes` flag",
      "Use the `recursive` keyword"
    ],
    "answer": "Use an interface, or use a type wrapper that delays the recursion",
    "explanation": "Interfaces are implicitly recursive. Type aliases cannot be directly recursive; they must be wrapped in a structure (like an object or tuple) or use an interface to break the cycle.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the `Parameters` utility type used for?",
    "options": [
      "Extracting the parameter types of a function type into a tuple",
      "Extracting the return type of a constructor",
      "Validating runtime arguments",
      "Creating function overloads"
    ],
    "answer": "Extracting the parameter types of a function type into a tuple",
    "explanation": "`Parameters` takes a function type `T` and produces a tuple type of the types of `T`'s parameters. It is often used for utility functions wrapping other functions.",
    "difficulty": "Advanced"
  }
]