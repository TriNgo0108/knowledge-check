[
  {
    "id": 1,
    "question": "Which keyword must be used to declare a variable whose value cannot be changed after initialization?",
    "options": [
      "static",
      "constant",
      "readonly",
      "final"
    ],
    "answer": "readonly",
    "explanation": "While 'const' is used for compile-time constants, 'readonly' is used for runtime constants that can be assigned only in the constructor or at declaration. 'final' is not a C# keyword.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the correct signature for the entry point of a C# application?",
    "options": [
      "static void Main(string[] args)",
      "public void main(String[] args)",
      "static int start()",
      "void Main()"
    ],
    "answer": "static void Main(string[] args)",
    "explanation": "The standard entry point is a static method named Main returning void or int, optionally accepting a string array for command-line arguments. Method names are case-sensitive.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which data type should be used to store a logical value of true or false?",
    "options": [
      "bool",
      "boolean",
      "bit",
      "int"
    ],
    "answer": "bool",
    "explanation": "C# uses the alias 'bool' for the System.Boolean structure to store true/false values. 'boolean' is used in Java, not C#.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the primary purpose of the 'using' statement in C#?",
    "options": [
      "To import namespaces into the current scope",
      "To allocate memory on the stack",
      "To ensure that an object implementing IDisposable is disposed of correctly",
      "To inherit from multiple classes"
    ],
    "answer": "To ensure that an object implementing IDisposable is disposed of correctly",
    "explanation": "While 'using' directives import namespaces, the 'using' statement ensures that Dispose() is called on objects implementing IDisposable, even if an exception occurs. The context of the question implies the statement usage.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which operator is used to determine the type of an object at runtime?",
    "options": [
      "typeof",
      "is",
      "as",
      "sizeof"
    ],
    "answer": "is",
    "explanation": "The 'is' operator checks if an object is compatible with a given type or evaluates a pattern. 'typeof' gets the Type object for a type at compile time.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "In C#, all types derive from a single base type. What is it?",
    "options": [
      "Object",
      "Base",
      "Root",
      "ValueType"
    ],
    "answer": "Object",
    "explanation": "Every type in C#, including value types, ultimately derives from the System.Object class (usually aliased as 'object').",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the default value of a boolean variable declared in a method?",
    "options": [
      "true",
      "false",
      "null",
      "0"
    ],
    "answer": "false",
    "explanation": "Instance fields are initialized to default values (false for bool), but local variables must be explicitly assigned before use. However, the default value of the type itself is false.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which access modifier allows access to the member from any code in the same assembly or derived classes in other assemblies?",
    "options": [
      "public",
      "internal",
      "protected",
      "protected internal"
    ],
    "answer": "protected internal",
    "explanation": "The 'protected internal' accessibility level restricts access to the current assembly or types derived from the containing class, acting as a union of both.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which keyword is used to create a new instance of a class?",
    "options": [
      "new",
      "object",
      "create",
      "instanceof"
    ],
    "answer": "new",
    "explanation": "The 'new' keyword performs three actions: allocates memory, initializes the object's fields, and returns a reference to the memory address.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What character is used to denote a String Verbatim (ignoring escape sequences) in C#?",
    "options": [
      "@",
      "&",
      "#",
      "!"
    ],
    "answer": "@",
    "explanation": "Prepending a string with '@' creates a verbatim string literal where escape sequences like '\\' are processed as literal characters.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which interface defines a method to compare two objects?",
    "options": [
      "IComparable",
      "IEquatable",
      "IComparer",
      "IDisposable"
    ],
    "answer": "IComparable",
    "explanation": "IComparable defines a generic CompareTo(T) method used for sorting purposes. IEquatable is for equality checks.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What does the '??' operator do in C#?",
    "options": [
      "Performs a bitwise left shift",
      "Returns the left-hand operand if it is not null, otherwise returns the right-hand operand",
      "Checks if two values are equal",
      "Performs a logical null check"
    ],
    "answer": "Returns the left-hand operand if it is not null, otherwise returns the right-hand operand",
    "explanation": "The 'null-coalescing operator' (??) provides a concise syntax for returning a default value if the left side evaluates to null.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which of the following is a correct way to declare a Generic List of integers?",
    "options": [
      "List<int> myList = new List<int>();",
      "ArrayList<int> myList = new ArrayList<int>();",
      "int[] myList = new List();",
      "GenericList myList = new GenericList();"
    ],
    "answer": "List<int> myList = new List<int>();",
    "explanation": "System.Collections.Generic.List is the strongly-typed generic list. The type parameter <int> specifies the element type.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the main advantage of using Generics in C#?",
    "options": [
      "They reduce the memory footprint of the application",
      "They increase code reuse and provide type safety without casting",
      "They automatically compile to C code",
      "They prevent the use of inheritance"
    ],
    "answer": "They increase code reuse and provide type safety without casting",
    "explanation": "Generics allow developers to define type-safe data structures without committing to a specific data type, reducing runtime errors and boxing overhead.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which keyword is used to create a method that accepts a variable number of arguments?",
    "options": [
      "params",
      "var",
      "args",
      "wildcard"
    ],
    "answer": "params",
    "explanation": "The 'params' keyword allows a method parameter to accept a variable number of arguments of a specific type, essentially an array.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "In LINQ, which method is used to filter a sequence based on a predicate?",
    "options": [
      "Select",
      "Where",
      "OrderBy",
      "GroupBy"
    ],
    "answer": "Where",
    "explanation": "The 'Where' operator filters a collection based on a boolean condition (predicate), returning only elements that satisfy the condition.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What does LINQ stand for?",
    "options": [
      "Language Integrated Query",
      "Linked Query",
      "List Integrated Query",
      "Logic Interface for Querying"
    ],
    "answer": "Language Integrated Query",
    "explanation": "LINQ provides a consistent syntax for querying data from in-memory collections (objects), databases (Entity Framework), and XML.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which LINQ operator is used to transform data from one type to another?",
    "options": [
      "OfType",
      "Select",
      "Cast",
      "First"
    ],
    "answer": "Select",
    "explanation": "The 'Select' operator performs a projection, transforming each element in a collection into a new form, often using a lambda expression.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What must be included at the top of a file to use LINQ extension methods?",
    "options": [
      "using System.Linq;",
      "using System.Data;",
      "using System.Collections;",
      "using System.Query;"
    ],
    "answer": "using System.Linq;",
    "explanation": "The extension methods for LINQ, such as Where and Select, reside in the System.Linq namespace.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the correct syntax for a Lambda expression in C#?",
    "options": [
      "x => x > 5",
      "function(x) { return x > 5 }",
      "x => { x > 5 }",
      "(x) > 5 =>"
    ],
    "answer": "x => x > 5",
    "explanation": "C# Lambda expressions use the '=>' (goes to) operator. The left side lists input parameters, and the right side contains the expression or statement block.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which type acts as a blueprint for a delegate?",
    "options": [
      "Interface",
      "Abstract Class",
      "Struct",
      "Enum"
    ],
    "answer": "Interface",
    "explanation": "Unlike abstract classes or structs, a delegate is a type-safe function pointer. However, conceptually, delegates most closely resemble interfaces with a single method definition. In the context of blueprints for behavior, interfaces are the closest 'beginner' conceptual match, but strictly, a delegate type *is* the blueprint. For the purpose of a distractor set focusing on types: The answer is 'Interface' implies the contract nature, though technically a Delegate type itself is the blueprint. Wait, this is a bit ambiguous. Let's refine the question to be more precise about 'Delegate' itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the technical definition of a Delegate in C#?",
    "options": [
      "A type that represents references to methods with a specific parameter list and return type",
      "A class that inherits from System.Object",
      "A keyword used to call a base class constructor",
      "A variable that stores memory addresses"
    ],
    "answer": "A type that represents references to methods with a specific parameter list and return type",
    "explanation": "A delegate is a type-safe function pointer, defining a specific method signature (return type and parameters) that any assigned method must match.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which predefined delegate type is used for a method that returns a value?",
    "options": [
      "Action",
      "Func",
      "Predicate",
      "EventHandler"
    ],
    "answer": "Func",
    "explanation": "Func encapsulates a method that has a return value (the last type parameter is the return type). Action encapsulates a method that returns void.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "How do you mark a method as asynchronous in C#?",
    "options": [
      "Add the 'async' keyword before the return type",
      "Add the 'await' keyword before the return type",
      "Set the return type to 'Void'",
      "Add the 'threaded' keyword"
    ],
    "answer": "Add the 'async' keyword before the return type",
    "explanation": "The 'async' modifier is placed in the method signature to enable the use of the 'await' keyword within the method body.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which return type should be used for an asynchronous method that returns a result?",
    "options": [
      "Task",
      "void",
      "string",
      "TaskResult"
    ],
    "answer": "Task",
    "explanation": "Async methods that return a value should return Task<TResult>, where TResult is the type of the returned value.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What happens when the 'await' keyword is applied to a Task that has not yet completed?",
    "options": [
      "The application crashes",
      "The method returns immediately to the caller, and execution resumes later when the Task completes",
      "The thread blocks until the Task completes",
      "The Task is cancelled automatically"
    ],
    "answer": "The method returns immediately to the caller, and execution resumes later when the Task completes",
    "explanation": "Await captures the current context and yields control to the caller, preventing thread blocking, and resumes execution when the awaited operation completes.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which keyword is used to throw an exception explicitly?",
    "options": [
      "throw",
      "catch",
      "try",
      "raise"
    ],
    "answer": "throw",
    "explanation": "The 'throw' keyword is used to signal the occurrence of an exception during program execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which block executes code regardless of whether an exception occurred or not?",
    "options": [
      "finally",
      "catch",
      "lastly",
      "try"
    ],
    "answer": "finally",
    "explanation": "The 'finally' block is guaranteed to execute after the 'try' and any 'catch' blocks, making it ideal for cleanup code.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is Pattern Matching in C#?",
    "options": [
      "A feature that tests whether an expression matches a specific pattern or shape",
      "A regex engine for string manipulation",
      "A way to design UI interfaces",
      "A method to encrypt data"
    ],
    "answer": "A feature that tests whether an expression matches a specific pattern or shape",
    "explanation": "Pattern matching allows conditional logic based on the type or value of data, often used with 'is' expressions or 'switch' statements.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which feature was introduced in C# 9.0 to define immutable data types?",
    "options": [
      "record",
      "struct",
      "enum",
      "class"
    ],
    "answer": "record",
    "explanation": "A 'record' is a reference type that provides built-in functionality for encapsulating data with primarily read-only behavior, offering value-based equality.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which operator checks if an object is of a specific type and casts it to that type in a single operation?",
    "options": [
      "as",
      "is",
      "cast",
      "?:"
    ],
    "answer": "as",
    "explanation": "The 'as' operator performs a safe cast, returning the object as the specified type if compatible, or null if the cast fails (unlike a direct cast which throws an exception).",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the result of the string interpolation expression: $\"Value: {10}\"?",
    "options": [
      "Value: 10",
      "Value: {10}",
      "{0}",
      "Value: {}"
    ],
    "answer": "Value: 10",
    "explanation": "String interpolation replaces expressions inside curly braces with their string representation. The expression {10} evaluates to the integer 10, which is converted to \"10\".",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which access modifier restricts access to the current class only?",
    "options": [
      "private",
      "internal",
      "public",
      "protected"
    ],
    "answer": "private",
    "explanation": "Members marked 'private' are accessible only within the body or scope of the class or struct in which they are declared.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of the 'virtual' keyword?",
    "options": [
      "To allow a method to be overridden in derived classes",
      "To prevent a class from being inherited",
      "To indicate a method is static",
      "To make a class abstract"
    ],
    "answer": "To allow a method to be overridden in derived classes",
    "explanation": "The 'virtual' keyword enables a method, property, or indexer to be overridden by a derived class using the 'override' keyword.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which method in the String class is used to compare two strings while ignoring case?",
    "options": [
      "Equals",
      "Compare",
      "CompareTo",
      "Contains"
    ],
    "answer": "Equals",
    "explanation": "While 'Compare' returns an integer, 'Equals' returns a boolean. Specifically, string.Equals(a, b, StringComparison.OrdinalIgnoreCase) is the standard way to perform case-insensitive comparison.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which namespace contains the fundamental classes and base types for the .NET Framework?",
    "options": [
      "System",
      "Microsoft",
      "Base",
      "Core"
    ],
    "answer": "System",
    "explanation": "The System namespace contains fundamental classes and base classes that define commonly-used value and reference data types, events and event handlers, interfaces, attributes, and processing exceptions.",
    "difficulty": "Beginner"
  },
  {
    "id": 37,
    "question": "In C#, what distinguishes a 'struct' from a 'class' regarding memory management?",
    "options": [
      "Structs are reference types allocated on the heap, while classes are value types allocated on the stack",
      "Classes are reference types allocated on the heap, while structs are value types often allocated on the stack",
      "Structs cannot implement interfaces, whereas classes can",
      "Classes support inheritance but structs support multiple inheritance"
    ],
    "answer": "Classes are reference types allocated on the heap, while structs are value types often allocated on the stack",
    "explanation": "Classes are reference types stored on the heap, subject to garbage collection. Structs are value types typically stored on the stack (or inline within containing types) and have different assignment semantics (copying vs. reference).",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary risk of using 'async void' methods in C# instead of 'async Task'?",
    "options": [
      "The method runs synchronously, blocking the calling thread",
      "Exceptions thrown inside the method cannot be caught by the caller",
      "The method cannot use the 'await' keyword",
      "It causes a compile-time error in .NET 6 and later"
    ],
    "answer": "Exceptions thrown inside the method cannot be caught by the caller",
    "explanation": "Unlike `Task`, `async void` methods do not return a task object that can be awaited, making it impossible for the caller to catch or handle exceptions raised within the method. They are typically reserved for event handlers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which C# feature allows you to invoke a method supplied as a parameter, enabling deferred execution and custom behavior injection?",
    "options": [
      "Abstract Classes",
      "Delegates",
      "Generics",
      "Anonymous Types"
    ],
    "answer": "Delegates",
    "explanation": "A delegate is a type-safe function pointer that references a method. Delegates are used to pass methods as arguments to other methods and are the foundation of events and LINQ.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "When using LINQ to Objects, what is the behavior of the 'Where' clause regarding execution timing?",
    "options": [
      "It executes immediately and returns a list of filtered objects",
      "It uses deferred execution, filtering the sequence only when the result is iterated",
      "It executes in parallel by default using multiple threads",
      "It modifies the original source collection in place"
    ],
    "answer": "It uses deferred execution, filtering the sequence only when the result is iterated",
    "explanation": "Standard LINQ operators like `Where` return an `IEnumerable` that implements deferred execution. The filtering logic is applied only when the collection is iterated over (e.g., via `foreach`), not when the method is called.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the result of 'boxing' a value type in C#?",
    "options": [
      "Converting a value type to a reference type by storing it on the heap",
      "Converting a reference type to a value type",
      "Allocating memory on the stack for a reference type",
      "Removing the type safety of the value type"
    ],
    "answer": "Converting a value type to a reference type by storing it on the heap",
    "explanation": "Boxing is the process of converting a value type to the type `object` or to any interface type implemented by this value type. The Common Language Runtime (CLR) wraps the value type inside a `System.Object` and stores it on the managed heap.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the purpose of the 'yield return' statement in an iterator method?",
    "options": [
      "To immediately return the entire collection to the caller",
      "To exit the method and stop execution permanently",
      "To return each element one at a time, maintaining state between calls",
      "To convert a method into an asynchronous operation"
    ],
    "answer": "To return each element one at a time, maintaining state between calls",
    "explanation": "The `yield return` statement is used to return elements one by one lazily. The compiler generates a state machine that preserves the method's state between iterations, allowing for efficient enumeration of large or infinite sequences.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In C#, what is the difference between 'String' and 'string'?",
    "options": [
      "'string' is a value type, while 'String' is a reference type",
      "'string' is for concatenation, while 'String' is for comparison",
      "They are identical; 'string' is an alias for the System.String class",
      "'String' is deprecated in modern .NET versions"
    ],
    "answer": "They are identical; 'string' is an alias for the System.String class",
    "explanation": "In C#, `string` is simply a keyword alias for the `System.String` class. They compile to the same Intermediate Language (IL) code and can be used interchangeably.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which generic constraint restricts a generic type parameter to value types only?",
    "options": [
      "where T : class",
      "where T : struct",
      "where T : new()",
      "where T : interface"
    ],
    "answer": "where T : struct",
    "explanation": "The `struct` constraint restricts the type parameter `T` to value types. The `class` constraint restricts `T` to reference types, while `new()` requires a public parameterless constructor.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What happens when you access a generic dictionary using a key that does not exist?",
    "options": [
      "It returns null for reference types or default value for value types",
      "It returns the first item in the dictionary",
      "It throws a KeyNotFoundException",
      "It automatically adds the key with a default value"
    ],
    "answer": "It throws a KeyNotFoundException",
    "explanation": "Using the indexer (`dictionary[key]`) throws a `KeyNotFoundException` if the key does not exist. To avoid this, use the `TryGetValue` method or `ContainsKey` check, or the `GetValueOrDefault` method.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the primary function of the 'using' statement in C#?",
    "options": [
      "To import namespaces into the current file",
      "To explicitly call the Garbage Collector",
      "To ensure that an object implementing IDisposable is disposed of correctly",
      "To define a block of code that runs on a background thread"
    ],
    "answer": "To ensure that an object implementing IDisposable is disposed of correctly",
    "explanation": "While `using` imports namespaces at the top of a file, the `using` statement ensures that `Dispose()` is called on an `IDisposable` object, even if an exception occurs within the block.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Why is 'StringBuilder' generally preferred over standard string concatenation (+) in loops?",
    "options": [
      "Strings are immutable; concatenation creates a new object instance every time",
      "StringBuilder runs on a background thread",
      "String concatenation is not supported in loops",
      "StringBuilder automatically encrypts the data"
    ],
    "answer": "Strings are immutable; concatenation creates a new object instance every time",
    "explanation": "Strings in C# are immutable. Using `+` or `+=` in a loop creates a new string object for every iteration, allocating memory repeatedly. `StringBuilder` uses a mutable buffer to modify the string efficiently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the difference between 'IQueryable' and 'IEnumerable' when querying a database with Entity Framework?",
    "options": [
      "'IEnumerable' executes the query on the database server, while 'IQueryable' fetches all data first",
      "'IQueryable' builds an expression tree that translates to SQL (server-side), while 'IEnumerable' fetches data into memory first (client-side)",
      "'IEnumerable' can only be used with SQL Server, while 'IQueryable' is for Oracle",
      "There is no difference; they are interchangeable"
    ],
    "answer": "'IQueryable' builds an expression tree that translates to SQL (server-side), while 'IEnumerable' fetches data into memory first (client-side)",
    "explanation": "`IQueryable` allows the query provider (like Entity Framework) to translate the LINQ query into SQL for efficient server-side execution. `IEnumerable` executes in-memory, potentially retrieving entire tables before filtering.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which access modifier allows access to the member only from within the same class or derived classes in the same assembly?",
    "options": [
      "protected",
      "internal",
      "protected internal",
      "private protected"
    ],
    "answer": "private protected",
    "explanation": "`private protected` limits access to the containing class or types derived from the containing class within the same assembly. `protected` allows external assembly derived types; `internal` allows any type in the assembly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the result of the 'is' operator in the expression: `if (obj is MyClass c)`?",
    "options": [
      "It returns true if obj is null",
      "It checks if obj is an instance of MyClass and casts it to variable c if true",
      "It creates a new instance of MyClass",
      "It throws an exception if obj is not of type MyClass"
    ],
    "answer": "It checks if obj is an instance of MyClass and casts it to variable c if true",
    "explanation": "This is a Type Pattern Match. It tests if `obj` is compatible with `MyClass`; if true, it assigns the variable `c` with the cast value, enabling safe usage of `c` within the scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In C# pattern matching, what is the purpose of the 'relational pattern'?",
    "options": [
      "To check if a type is related to another type via inheritance",
      "To match inputs against constants using comparison operators like <, >, or =",
      "To recursively match data structures",
      "To define relationships between properties"
    ],
    "answer": "To match inputs against constants using comparison operators like <, >, or =",
    "explanation": "Relational patterns allow you to compare a value to a constant using standard relational operators, such as `x when x > 100`. This is distinct from Type patterns or Property patterns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What does the 'volatile' keyword signify when applied to a field?",
    "options": [
      "The field value cannot be changed after initialization",
      "The field is stored in a CPU register for faster access",
      "Compiler optimizations are restricted to ensure the most up-to-date value is read across threads",
      "The field is automatically thread-safe for write operations"
    ],
    "answer": "Compiler optimizations are restricted to ensure the most up-to-date value is read across threads",
    "explanation": "The `volatile` keyword indicates that a field might be modified by multiple threads concurrently. It prevents the compiler from caching the value in a register, ensuring every read retrieves the latest value from memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "How does the 'Action' delegate differ from the 'Func' delegate?",
    "options": [
      "'Action' is used for events, while 'Func' is used for LINQ",
      "'Action' does not return a value, while 'Func' always returns a value",
      "'Action' accepts parameters, while 'Func' does not",
      "'Func' is synchronous, while 'Action' is asynchronous"
    ],
    "answer": "'Action' does not return a value, while 'Func' always returns a value",
    "explanation": "Both `Action` and `Func` are predefined delegate types. `Action` encapsulates a method that takes parameters (0-16) and returns `void`. `Func` encapsulates a method that takes parameters and returns a value of the specified type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the behavior of the 'await' keyword when applied to a completed Task?",
    "options": [
      "It throws an exception because the task is already finished",
      "It blocks the thread until the next tick",
      "It returns the result immediately without yielding control",
      "It restarts the task from the beginning"
    ],
    "answer": "It returns the result immediately without yielding control",
    "explanation": "If a `Task` is already completed (e.g., `Task.CompletedTask` or a cached result), `await` detects the completion and executes the rest of the method synchronously, avoiding the overhead of creating a state machine suspension.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which C# feature provides a way to define deconstructors to break down an object into its component parts?",
    "options": [
      "Destructors (Finalizers)",
      "Extension Methods with 'ref'",
      "Deconstruct methods",
      "Tuples with named elements"
    ],
    "answer": "Deconstruct methods",
    "explanation": "A `Deconstruct` method allows you to deconstruct a type into its constituent variables. This enables syntax like `var (x, y) = myPoint` to work seamlessly with tuples or custom classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is a 'Null-Conditional Operator'?",
    "options": [
      "The '?:' ternary operator used for checking nulls",
      "The '?.' operator used to safely access members only if the object is not null",
      "The '??' operator used to assign a default value",
      "The '!' null-forgiving operator"
    ],
    "answer": "The '?.' operator used to safely access members only if the object is not null",
    "explanation": "The `?.` operator evaluates the left side; if it is null, it returns null immediately without throwing a `NullReferenceException`. If the object is not null, it proceeds with the member access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the context of C# Records (record types), what is 'value-based equality'?",
    "options": [
      "Two record variables are equal if they reference the exact same memory location",
      "Two record instances are equal if all their property values are equal",
      "Records cannot be compared using the '==' operator",
      "Records must implement the IEquatable interface manually"
    ],
    "answer": "Two record instances are equal if all their property values are equal",
    "explanation": "Records are primarily designed for immutable data. The compiler synthesizes `Equals` and `GetHashCode` methods to compare values of properties/fields rather than reference identity (address), differing from standard classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the 'Coalescing Assignment Operator' (??=) used for?",
    "options": [
      "To check if a value is equal to another",
      "To assign the result of a ternary expression",
      "To assign the right-hand operand to the left-hand operand only if the left-hand operand evaluates to null",
      "To concatenate strings safely"
    ],
    "answer": "To assign the right-hand operand to the left-hand operand only if the left-hand operand evaluates to null",
    "explanation": "The `??=` operator assigns the value of the right-hand side to the left-hand side only if the left-hand side evaluates to `null`. This simplifies null-checking initialization logic like `if (x == null) x = y;`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the primary use of the 'nameof' operator?",
    "options": [
      "To return the fully qualified name of the current class",
      "To get the string name of a variable, type, or member at compile time",
      "To verify if a class name exists in the assembly",
      "To generate unique IDs for objects"
    ],
    "answer": "To get the string name of a variable, type, or member at compile time",
    "explanation": "`nameof` is a compile-time operator that resolves the identifier to its string representation. It is useful for avoiding hardcoded magic strings in logging, argument validation, and binding.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the effect of marking a class as 'static'?",
    "options": [
      "The class can be instantiated, but all members must be static",
      "The class cannot be instantiated and must contain only static members",
      "The class is stored in the stack instead of the heap",
      "Members of the class are automatically thread-safe"
    ],
    "answer": "The class cannot be instantiated and must contain only static members",
    "explanation": "A static class cannot be instantiated, cannot be used as a base class, and can contain only static members. It is commonly used for utility or helper methods (e.g., `System.Math`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Which interface must a class implement to support iteration with 'foreach'?",
    "options": [
      "IEnumerable",
      "IEnumerator",
      "ICollection",
      "IQueryable"
    ],
    "answer": "IEnumerable",
    "explanation": "To be enumerable in a `foreach` loop, a collection must implement `IEnumerable`. This interface requires a `GetEnumerator` method that returns an `IEnumerator` to traverse the collection.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the difference between 'Task.Wait()' and 'Task.Result'?",
    "options": [
      "'Wait' throws an AggregateException, while 'Result' unwraps the inner exception",
      "'Wait' is asynchronous, while 'Result' is synchronous",
      "'Result' returns void, while 'Wait' returns the generic value",
      "There is no functional difference"
    ],
    "answer": "'Wait' throws an AggregateException, while 'Result' unwraps the inner exception",
    "explanation": "Both `Wait()` and `Result` block the thread synchronously. However, when a task faults, `Wait()` wraps the exception in an `AggregateException`, while accessing `Result` unwraps and throws the actual exception directly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the role of 'ConfigureAwait(false)' in an async library method?",
    "options": [
      "To force the method to run on the UI thread",
      "To capture the current synchronization context and continue on it",
      "To avoid capturing the current synchronization context, allowing continuation on a thread pool thread",
      "To cancel the asynchronous operation"
    ],
    "answer": "To avoid capturing the current synchronization context, allowing continuation on a thread pool thread",
    "explanation": "Calling `ConfigureAwait(false)` signals that the continuation does not need the original context (e.g., the UI context). This improves performance in library code by reducing the need to marshal back to the original thread.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is a 'closure' in the context of C# lambdas?",
    "options": [
      "The final method that ends the program",
      "The process of garbage collecting unused lambdas",
      "A function that captures variables from the surrounding scope, extending their lifetime",
      "A lambda expression that explicitly returns 'void'"
    ],
    "answer": "A function that captures variables from the surrounding scope, extending their lifetime",
    "explanation": "A closure occurs when a lambda or anonymous function captures local variables. The compiler generates a class to hold these variables, keeping them alive even after the local scope has completed execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which interface defines a contract for releasing unmanaged resources deterministically?",
    "options": [
      "IDisposable",
      "IAsyncDisposable",
      "ICloneable",
      "IFormattable"
    ],
    "answer": "IDisposable",
    "explanation": "The `IDisposable` interface provides a `Dispose` method for releasing unmanaged resources (file handles, database connections) explicitly. `IAsyncDisposable` is the asynchronous counterpart.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What happens when you attempt to modify a 'foreach' iteration variable?",
    "options": [
      "The collection is updated in real-time",
      "A compiler error occurs",
      "The variable is treated as 'ref' automatically",
      "The loop skips the next item"
    ],
    "answer": "A compiler error occurs",
    "explanation": "The iteration variable of a `foreach` loop is read-only. Attempting to assign a new value to it (e.g., `item = newValue`) results in a compile-time error because the loop enumerates an immutable view of the elements.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In LINQ, what does the 'Select' projection operator do?",
    "options": [
      "Filters a sequence based on a predicate",
      "Groups elements by a key",
      "Transforms each element in a sequence into a new form",
      "Sorts the elements in ascending order"
    ],
    "answer": "Transforms each element in a sequence into a new form",
    "explanation": "`Select` is a projection operator. It takes a transformation function (lambda) and applies it to every element in the collection, creating a new collection with the transformed values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the 'ref struct' constraint introduced in newer versions of C#?",
    "options": [
      "It ensures the struct is stored on the heap",
      "It forces the struct to be passed by reference to methods",
      "It guarantees the struct is allocated only on the stack and cannot be boxed",
      "It makes the struct immutable"
    ],
    "answer": "It guarantees the struct is allocated only on the stack and cannot be boxed",
    "explanation": "A `ref struct` restricts allocation to the stack. It cannot be boxed, assigned to variables of type `object`, `dynamic`, or interface types, and cannot be used as a generic type argument.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "How does the 'as' operator differ from a direct cast?",
    "options": [
      "'as' works only with value types",
      "'as' returns null if the conversion fails, while a direct cast throws an exception",
      "'as' performs the conversion slower than a cast",
      "Direct cast returns null, while 'as' throws an exception"
    ],
    "answer": "'as' returns null if the conversion fails, while a direct cast throws an exception",
    "explanation": "The `as` operator is used for safe reference type or nullable conversions. If the cast is invalid, it returns `null` instead of throwing an `InvalidCastException` like a standard cast `(Type)obj` would.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is the purpose of the 'Lazy' type?",
    "options": [
      "To delay the loading of an assembly until runtime",
      "To defer the creation of a resource-intensive object until it is first accessed",
      "To run a method in the background thread pool",
      "To improve compilation speed"
    ],
    "answer": "To defer the creation of a resource-intensive object until it is first accessed",
    "explanation": "The `Lazy` class provides lazy initialization support. The object is not created until the `Value` property is accessed for the first time, optimizing startup time and memory usage if the object is never used.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What is the difference between 'Task.WhenAll' and 'Task.WaitAll'?",
    "options": [
      "'WhenAll' runs tasks asynchronously, while 'WaitAll' blocks the thread",
      "'WaitAll' returns a Task, while 'WhenAll' returns void",
      "'WhenAll' can only accept two arguments",
      "'WaitAll' is used for starting tasks, 'WhenAll' is for stopping them"
    ],
    "answer": "'WhenAll' runs tasks asynchronously, while 'WaitAll' blocks the thread",
    "explanation": "`Task.WhenAll` is an asynchronous operation that returns a Task completing when all input tasks are done. `Task.WaitAll` is a blocking call that halts the current thread until all tasks are finished.",
    "difficulty": "Intermediate"
  },
  {
    "id": 72,
    "question": "When implementing a generic interface with a covariant type parameter (out T), which of the following operations is strictly prohibited on the generic type T within the interface members?",
    "options": [
      "Returning T as a function return type",
      "Using T as a type constraint in a generic method",
      "Passing T as a method parameter",
      "Accessing static members of T"
    ],
    "answer": "Passing T as a method parameter",
    "explanation": "Covariance allows a generic type to be treated as a more derived type, which is safe for return types but unsafe for input parameters. Passing T would require contravariance (in T).",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In C#, what is the primary consequence of marking a method as `async void` instead of `async Task`?",
    "options": [
      "The method runs synchronously on the calling thread",
      "Exceptions thrown inside the method propagate directly to the caller's synchronization context",
      "The method cannot be awaited by the caller",
      "The compiler optimizes the method to use lock-free execution"
    ],
    "answer": "Exceptions thrown inside the method propagate directly to the caller's synchronization context",
    "explanation": "Unlike `async Task`, `async void` methods have no way to return the exception to an awaiter. Therefore, unhandled exceptions escape the async boundary and trigger the synchronization context's unobserved exception handler (often crashing the process in UI apps).",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which C# feature allows you to defer the execution of a query expression until the results are actually iterated over, and can potentially cause multiple database executions if iterated repeatedly?",
    "options": [
      "Eager loading with .ToList()",
      "Deferred execution implemented by IEnumerable",
      "Immediate execution with .Count()",
      "Compiled query caching"
    ],
    "answer": "Deferred execution implemented by IEnumerable",
    "explanation": "Standard LINQ operators (like `Where` or `Select`) returning `IEnumerable` utilize deferred execution, meaning the logic is stored as a delegate chain and executed only during iteration, re-running on every iteration.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the fundamental difference between `IQueryable` and `IEnumerable` regarding data source filtering?",
    "options": [
      "IEnumerable filters data in-memory, while IQueryable builds an expression tree to filter at the data source",
      "IEnumerable builds an expression tree, while IQueryable filters in-memory",
      "IEnumerable requires a database connection, while IQueryable works only with arrays",
      "IEnumerable supports lazy loading, while IQueryable does not"
    ],
    "answer": "IEnumerable filters data in-memory, while IQueryable builds an expression tree to filter at the data source",
    "explanation": "`IEnumerable` executes the query logic locally on the client machine after retrieving the data. `IQueryable` captures the logic into an Expression Tree, allowing the LINQ provider (like Entity Framework) to translate it into native SQL for server-side execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "When using `Task.WhenAll`, what happens if one of the supplied Tasks throws an exception?",
    "options": [
      "The exception is immediately thrown on the calling thread, cancelling remaining tasks",
      "The method returns a completed Task that ignores the exception",
      "The returned Task transitions to a Faulted state containing all exceptions in an AggregateException",
      "The method catches the exception and returns null"
    ],
    "answer": "The returned Task transitions to a Faulted state containing all exceptions in an AggregateException",
    "explanation": "`Task.WhenAll` waits for all tasks to complete. If any fault, the resulting task contains an `AggregateException` holding all exceptions thrown by the supplied tasks.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of C# memory management, what specific constraint is applied to `ref struct` types?",
    "options": [
      "They can only be allocated on the heap",
      "They cannot implement interfaces",
      "They are implicitly nullable",
      "They cannot be used as type arguments in generics"
    ],
    "answer": "They cannot implement interfaces",
    "explanation": "`ref struct` types are stack-allocated and cannot be boxed. Since boxing is required to cast to an interface type, `ref struct` types are forbidden from implementing interfaces to ensure escape safety.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the purpose of the `volatile` keyword in C#?",
    "options": [
      "It makes a variable thread-safe by wrapping all access in a lock",
      "It ensures that reads and writes to the field are not optimized away or reordered by the compiler/CPU",
      "It forces a variable to be stored on the stack instead of the heap",
      "It prevents the Garbage Collector from moving the object in memory"
    ],
    "answer": "It ensures that reads and writes to the field are not optimized away or reordered by the compiler/CPU",
    "explanation": "The `volatile` keyword indicates that a field might be modified by multiple threads executing concurrently. It disables certain compiler optimizations (caching in registers) to ensure the most up-to-date value is fetched from memory.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which statement accurately describes the behavior of `string` interning in C#?",
    "options": [
      "The CLR automatically interns every string literal, but strings created at runtime are not interned by default",
      "All strings, whether literals or runtime-created, are automatically interned to save memory",
      "String interning is disabled by default and must be enabled via a configuration file",
      "Interning occurs only when a string is explicitly converted to a `StringBuilder`"
    ],
    "answer": "The CLR automatically interns every string literal, but strings created at runtime are not interned by default",
    "explanation": "While the CLR maintains an intern pool for string literals to save memory, dynamically created strings (via `ToString`, concatenation, etc.) are not interned automatically unless explicitly done so via `String.Intern`.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the primary purpose of the `yield return` statement in an iterator method?",
    "options": [
      "To immediately return the first result and terminate the method",
      "To compile the method into a state machine that generates a sequence of values lazily",
      "To convert the method into an asynchronous operation",
      "To optimize memory by forcing the collection to be allocated on the stack"
    ],
    "answer": "To compile the method into a state machine that generates a sequence of values lazily",
    "explanation": "`yield return` instructs the compiler to generate a custom state machine class (implementing `IEnumerable`/`IEnumerator`). This allows the method to maintain state between calls and return items one by one as they are requested.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Why does C# prohibit boxing a `Nullable` type where `HasValue` is false?",
    "options": [
      "It creates a memory leak in the Large Object Heap",
      "The compiler cannot determine the underlying type at compile time",
      "It results in a null reference, which cannot be boxed",
      "It violates the type safety constraints of the Common Type System"
    ],
    "answer": "It results in a null reference, which cannot be boxed",
    "explanation": "A `Nullable` with no value is conceptually null. When boxing, if it is null, the result is a null reference, not a boxed value type. A non-null `Nullable` boxes to the underlying value type, stripping the `Nullable` wrapper.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the function of the `System.Runtime.CompilerServices.SafeHandle` class?",
    "options": [
      "To manage memory allocation for unmanaged arrays",
      "To provide critical finalization of OS handles ensuring they are released even if the AppDomain is unloaded",
      "To wrap exceptions that occur during serialization",
      "To enforce thread safety on standard value types"
    ],
    "answer": "To provide critical finalization of OS handles ensuring they are released even if the AppDomain is unloaded",
    "explanation": "`SafeHandle` wraps an operating system handle (like a file handle). It ensures the handle is released via a \"critical finalizer\" that runs even in extreme conditions (like host termination or stack overflow), preventing resource leaks.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In the .NET Garbage Collector, what is the primary distinction between generation 0 and generation 2?",
    "options": [
      "Generation 0 is for large objects, while Generation 2 is for small objects",
      "Generation 0 collects short-lived objects frequently, while Generation 2 collects long-lived objects less frequently",
      "Generation 0 is compacted, while Generation 2 is swept but not compacted",
      "Generation 0 resides on the LOH (Large Object Heap), while Generation 2 resides on the SOH"
    ],
    "answer": "Generation 0 collects short-lived objects frequently, while Generation 2 collects long-lived objects less frequently",
    "explanation": "The GC is generational. Gen 0 is for new, short-lived objects and is collected very often. Objects that survive Gen 0 collections are promoted to Gen 1, and eventually Gen 2, which is collected much less frequently.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the result of using the `stackalloc` keyword in C#?",
    "options": [
      "It allocates memory on the garbage-collected heap",
      "It creates a delegate that points to a method on the stack",
      "It allocates a block of memory on the stack frame that is automatically discarded upon method exit",
      "It forces a value type to be pinned in memory to prevent movement by the GC"
    ],
    "answer": "It allocates a block of memory on the stack frame that is automatically discarded upon method exit",
    "explanation": "`stackalloc` is used to allocate an unmanaged block of memory on the stack. It is extremely fast and does not require garbage collection, but the memory is only valid for the duration of the method execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What does the `[StructLayout(LayoutKind.Sequential)]` attribute guarantee for a struct?",
    "options": [
      "The CLR will reorder fields to minimize memory usage",
      "The fields will be laid out in memory sequentially in the order they are declared",
      "The struct will be allocated on the Large Object Heap",
      "The struct cannot contain reference types as members"
    ],
    "answer": "The fields will be laid out in memory sequentially in the order they are declared",
    "explanation": "By default, the CLR may reorder fields for memory packing. `LayoutKind.Sequential` forces the CLR to preserve the exact declaration order of fields in memory, which is critical for P/Invoke calls to native libraries.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "When implementing `IEquatable`, why is it recommended to also override `Object.GetHashCode`?",
    "options": [
      "To enable the struct to be used in dictionary keys or hash sets",
      "To ensure the `==` operator works correctly for value types",
      "To allow the struct to be serialized by the BinaryFormatter",
      "To satisfy the requirements of the generic `IComparable` interface"
    ],
    "answer": "To enable the struct to be used in dictionary keys or hash sets",
    "explanation": "Collections like `Dictionary` and `HashSet` rely on `GetHashCode` to bucket items. If two objects are equal (per `Equals`), they *must* return the same hash code, or they will be lost in the hash table.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the purpose of the `fixed` statement in C#?",
    "options": [
      "To prevent a value type from being boxed during a cast operation",
      "To pin a managed variable in memory so its address can be used by a pointer",
      "To declare a constant variable that cannot be changed by the JIT compiler",
      "To lock a critical section of code to ensure thread safety"
    ],
    "answer": "To pin a managed variable in memory so its address can be used by a pointer",
    "explanation": "The Garbage Collector moves objects in memory. The `fixed` statement prevents this movement (pins the object) so that a pointer to it remains valid during the execution of the statement.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "Which of the following best describes the behavior of a C# `record` type defined as `public record Person(string Name);`?",
    "options": [
      "It creates a reference type with value-based equality semantics and primary constructor",
      "It creates a value type with reference-based equality semantics",
      "It creates an abstract base class that must be inherited by concrete classes",
      "It creates an immutable struct that cannot be instantiated"
    ],
    "answer": "It creates a reference type with value-based equality semantics and primary constructor",
    "explanation": "Records are reference types (classes) that are primarily designed for data storage. They offer built-in value-based equality (comparing property values) and concise syntax for immutable properties via primary constructors.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is a 'Critical Finalizer' in the .NET runtime?",
    "options": [
      "A finalizer that runs on a dedicated high-priority thread to ensure execution",
      "A mechanism guaranteed to execute even if the process is terminating abruptly or resources are corrupted",
      "A finalizer optimized for the Large Object Heap",
      "A specific exception type thrown when the GC fails to collect an object"
    ],
    "answer": "A mechanism guaranteed to execute even if the process is terminating abruptly or resources are corrupted",
    "explanation": "Constrained execution regions (CERs) and critical finalizers allow the runtime to guarantee that cleanup code runs even under extreme conditions like out-of-memory or stack overflow, primarily used by `SafeHandle` and `CriticalFinalizerObject`.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What happens when you use the `await` keyword on a completed Task?",
    "options": [
      "The thread blocks until the Task is confirmed to be complete",
      "The method resumes immediately on the same thread without yielding",
      "The result is discarded and a null reference is returned",
      "The Task is restarted from the beginning"
    ],
    "answer": "The method resumes immediately on the same thread without yielding",
    "explanation": "If a `Task` is already completed (e.g., from a cache or a synchronous return), `await` sees the `IsCompleted` property is true and executes synchronously, returning the result immediately without suspending the async state machine.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In the context of reflection, what does `MakeGenericMethod` do?",
    "options": [
      "Creates a new instance of a generic class at runtime",
      "Binds a generic method definition to specific type arguments to create an invokable MethodInfo",
      "Compiles a lambda expression into a strongly typed delegate",
      "Converts a static method into an extension method"
    ],
    "answer": "Binds a generic method definition to specific type arguments to create an invokable MethodInfo",
    "explanation": "Reflection represents a generic method as an open definition (e.g., `List<T>.Add`). You use `MakeGenericMethod` to supply the concrete type(s) (e.g., `int`), closing the type so the method can be invoked via `Invoke`.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the difference between `Monitor.Enter` and the `lock` statement?",
    "options": [
      "`lock` creates a thread, `Monitor.Enter` does not",
      "`Monitor.Enter` allows for try/finally precision and timeout specification, `lock` is syntactic sugar",
      "`lock` is atomic, `Monitor.Enter` is not",
      "`Monitor.Enter` works only on static objects"
    ],
    "answer": "`Monitor.Enter` allows for try/finally precision and timeout specification, `lock` is syntactic sugar",
    "explanation": "The `lock` statement is a language convenience that compiles down to a `try`/`finally` block using `Monitor.Enter` and `Monitor.Exit`. Using `Monitor` explicitly allows you to pass a timeout value, whereas `lock` waits indefinitely.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "Which feature introduced in C# 9 allows a method to omit the class declaration when writing top-level statements?",
    "options": [
      "Program.cs simplification",
      "Top-level statements",
      "Partial methods",
      "Static classes"
    ],
    "answer": "Top-level statements",
    "explanation": "Top-level statements allow the developer to write code (like statements or method declarations) directly at the file level without declaring a `class Program` or a `static void Main` method, reducing boilerplate.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What does the `[MethodImpl(MethodImplOptions.AggressiveInlining)]` attribute suggest to the JIT compiler?",
    "options": [
      "The method should be compiled to native code before the application starts",
      "The method body should be ignored during optimization",
      "The method call should be replaced by the body of the method to avoid call overhead",
      "The method should run on a background thread"
    ],
    "answer": "The method call should be replaced by the body of the method to avoid call overhead",
    "explanation": "AggressiveInlining is a hint to the JIT compiler to insert the method's machine code directly at the call site. This eliminates the overhead of the stack frame manipulation (push/pop) but increases code size.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "How does the `Volatile.Read` method differ from a standard read of a shared variable?",
    "options": [
      "It performs an atomic read-write operation",
      "It acquires a memory barrier (fence), ensuring the read is not reordered or cached",
      "It locks the variable for the duration of the read",
      "It converts the variable to a reference type before reading"
    ],
    "answer": "It acquires a memory barrier (fence), ensuring the read is not reordered or cached",
    "explanation": "`Volatile.Read` and `Volatile.Write` introduce a full memory barrier. This prevents the compiler/CPU from caching the value in a register or reordering instructions across the read/write, ensuring visibility across threads.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the primary use of the `System.Threading.Interlocked` class?",
    "options": [
      "To manage thread creation and pooling",
      "To perform atomic operations on variables that are shared by multiple threads",
      "To synchronize access to complex object graphs",
      "To handle exceptions occurring on background threads"
    ],
    "answer": "To perform atomic operations on variables that are shared by multiple threads",
    "explanation": "The `Interlocked` class provides methods (like `Increment`, `Exchange`, `CompareExchange`) that rely on CPU atomic instructions. They guarantee atomicity without the overhead of a lock or `Monitor`.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the role of the `SynchronizationContext` class in asynchronous programming?",
    "options": [
      "It serializes the execution of asynchronous callbacks to a specific context (like a UI thread)",
      "It creates a new thread for every Task spawned",
      "It manages the locking mechanism for the database connection pool",
      "It acts as a factory for creating CancellationToken instances"
    ],
    "answer": "It serializes the execution of asynchronous callbacks to a specific context (like a UI thread)",
    "explanation": "In UI frameworks (WinForms, WPF), the `SynchronizationContext` ensures that code executed after an `await` is marshaled back to the UI thread, preventing illegal cross-thread access to UI components.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Why might a developer use the `Unsafe.As` method found in `System.Runtime.CompilerServices`?",
    "options": [
      "To bypass the garbage collector completely for an object",
      "To reinterpret a reference of one type as another without changing the underlying memory address (casting)",
      "To execute code with higher privileges than the current user",
      "To disable all compiler optimizations for a specific block"
    ],
    "answer": "To reinterpret a reference of one type as another without changing the underlying memory address (casting)",
    "explanation": "`Unsafe.As` allows casting between compatible or unrelated types without performing the safety checks typically enforced by the CLR (like `isinst`), effectively bypassing type safety for performance or specialized data manipulation.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Which condition will trigger a `NullReferenceException`?",
    "options": [
      "Calling an instance method on a struct instance",
      "Attempting to unbox a null value to a value type",
      "Accessing a member of a class that has been disposed",
      "Invoking a member on a reference type instance that points to null"
    ],
    "answer": "Invoking a member on a reference type instance that points to null",
    "explanation": "A `NullReferenceException` occurs when code attempts to access a member (field, property, or method) on a reference type variable that actually holds the value `null`. Attempting to unbox null throws `InvalidOperationException`.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the effect of the `in` modifier on a generic type parameter in an interface, such as `interface IMatcher<in T>`?",
    "options": [
      "It restricts T to value types only",
      "It makes T contravariant, allowing the interface to be referenced with a more derived type",
      "It prevents T from being used as a return type",
      "It passes T by reference instead of by value"
    ],
    "answer": "It makes T contravariant, allowing the interface to be referenced with a more derived type",
    "explanation": "The `in` keyword establishes contravariance. It allows you to use `IMatcher<Base>` where `IMatcher<Derived>` is expected, typically used for input parameters (writing data).",
    "difficulty": "Advanced"
  },
  {
    "id": 101,
    "question": "What distinguishes a `Span` from a `Memory` in C#?",
    "options": [
      "`Span` is a reference type, while `Memory` is a value type",
      "`Span` can only represent contiguous memory on the stack, while `Memory` can be stored on the heap",
      "`Span` supports slicing, while `Memory` does not",
      "`Memory` requires the `unsafe` context to be used"
    ],
    "answer": "`Span` can only represent contiguous memory on the stack, while `Memory` can be stored on the heap",
    "explanation": "`Span` is a ref struct, meaning it cannot leave the stack (cannot be boxed, stored in fields, or used across `await` boundaries). `Memory` is a normal struct that can be stored on the heap, allowing it to be used in async methods or collections.",
    "difficulty": "Advanced"
  }
]