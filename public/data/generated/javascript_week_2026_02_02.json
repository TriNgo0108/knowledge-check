[
  {
    "id": 1,
    "question": "Which of the following best describes the behavior of the `typeof` operator when applied to `null`?",
    "options": [
      "It returns 'null'.",
      "It returns 'undefined'.",
      "It returns 'object'.",
      "It returns 'primitive'."
    ],
    "answer": "It returns 'object'.",
    "explanation": "This is a legacy bug in JavaScript where `typeof null` returns 'object'. This is technically incorrect as `null` is a primitive type, but changing it would break existing web code.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the specific technical term for the internal V8 mechanism that compiles 'hot' (frequently executed) bytecode into optimized machine code?",
    "options": [
      "Ignition",
      "TurboFan",
      "Orinoco",
      "SpiderMonkey"
    ],
    "answer": "TurboFan",
    "explanation": "TurboFan is V8's optimizing compiler. It takes bytecode from the Ignition interpreter and compiles it into highly efficient machine code for performance-critical functions.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In the context of the JavaScript Event Loop, which type of task has a higher priority and is processed before other I/O callbacks?",
    "options": [
      "Macrotasks (setTimeout)",
      "Microtasks (Promises)",
      "Web Workers",
      "IO callbacks"
    ],
    "answer": "Microtasks (Promises)",
    "explanation": "The event loop processes the microtask queue (Promises, queueMicrotask) to completion after every callback in the call stack finishes, before moving to the next macrotask.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which keyword creates a variable that cannot be reassigned but is still mutable if it holds an object?",
    "options": [
      "var",
      "let",
      "const",
      "static"
    ],
    "answer": "const",
    "explanation": "`const` prevents reassignment of the identifier. However, if the identifier holds an object or array, the contents (properties or elements) of that object can still be modified.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the result of the strict equality comparison `NaN === NaN`?",
    "options": [
      "true",
      "false",
      "undefined",
      "TypeError"
    ],
    "answer": "false",
    "explanation": "NaN is the only value in JavaScript that is not equal to itself. To reliably check for NaN, one must use `Number.isNaN(value)`.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which memory segment in the V8 engine is responsible for storing primitive values, references to objects, and function execution frames?",
    "options": [
      "The Heap",
      "The Stack",
      "The Queue",
      "The Buffer"
    ],
    "answer": "The Stack",
    "explanation": "The Call Stack manages execution contexts (frames), primitives, and object pointers. The Heap is used for dynamic memory allocation of objects and strings.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which feature allows a function to access variables from its outer (enclosing) scope even after the outer function has returned?",
    "options": [
      "Hoisting",
      "Closure",
      "Recursion",
      "Scope Chain"
    ],
    "answer": "Closure",
    "explanation": "A closure is the combination of a function bundled with references to its surrounding state (the lexical environment). It preserves the outer scope even after the outer function has finished execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What distinguishes the `==` operator from the `===` operator in JavaScript?",
    "options": [
      "`==` compares value, while `===` compares reference.",
      "`==` performs type coercion, while `===` checks for strict equality without coercion.",
      "`===` is used for assignment, while `==` is used for comparison.",
      "There is no difference; they are functionally identical."
    ],
    "answer": "`==` performs type coercion, while `===` checks for strict equality without coercion.",
    "explanation": "`==` attempts to convert operands to the same type before comparing. `===` returns `false` immediately if the operands are of different types.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "In the V8 garbage collection process, which algorithm is typically used to manage memory for 'long-lived' objects (Old Generation)?",
    "options": [
      "Scavenge",
      "Mark-Sweep-Compact",
      "Reference Counting",
      "Stop-the-World"
    ],
    "answer": "Mark-Sweep-Compact",
    "explanation": "V8 uses Scavenge (Cheney's algorithm) for the Young Generation (short-lived objects) and Mark-Sweep-Compact for the Old Generation (long-lived objects) to handle memory fragmentation.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the output of `console.log(1 + '1')` in JavaScript?",
    "options": [
      "2",
      "'11'",
      "NaN",
      "TypeError"
    ],
    "answer": "'11'",
    "explanation": "The `+` operator triggers type coercion. When a number is added to a string, the number is converted to a string, and concatenation occurs.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which phase of the Execution Context involves the JavaScript engine allocating memory for variables and function declarations prior to code execution?",
    "options": [
      "Compilation Phase",
      "Execution Phase",
      "Creation Phase",
      "Validation Phase"
    ],
    "answer": "Creation Phase",
    "explanation": "During the Creation Phase, the engine sets up the Scope Chain, creates the Variable Object (allocating memory for declarations), and determines the value of `this`. This is effectively what 'Hoisting' describes.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which statement accurately describes the behavior of `var` regarding its scope?",
    "options": [
      "It is block-scoped.",
      "It is function-scoped.",
      "It is module-scoped.",
      "It is globally scoped only."
    ],
    "answer": "It is function-scoped.",
    "explanation": "`var` declarations are scoped to the function they are declared in (or globally if outside a function). Unlike `let` and `const`, they ignore block boundaries like `if` or `for` loops.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the primary purpose of the Abstract Syntax Tree (AST) in the JavaScript compilation pipeline?",
    "options": [
      "To optimize memory usage.",
      "To represent the code structure as a tree of nodes for compilation.",
      "To handle asynchronous callbacks.",
      "To manage the call stack."
    ],
    "answer": "To represent the code structure as a tree of nodes for compilation.",
    "explanation": "The Parser generates the AST from source code. This tree structure is then used by the Ignition interpreter to generate bytecode.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which method is used to create a new object with a specified prototype object?",
    "options": [
      "Object.create()",
      "Object.assign()",
      "Object.prototype.init()",
      "new Object()"
    ],
    "answer": "Object.create()",
    "explanation": "`Object.create(proto)` creates a new object and sets its `[[Prototype]]` to the provided argument. `new Object()` or `{}` creates an object linked to `Object.prototype`.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the result of `console.log(typeof undefined)`?",
    "options": [
      "'undefined'",
      "'null'",
      "'object'",
      "'number'"
    ],
    "answer": "'undefined'",
    "explanation": "`undefined` is a primitive type in JavaScript, and the `typeof` operator correctly returns the string 'undefined' for it.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which of the following occurs when a JavaScript function is declared as an Arrow Function?",
    "options": [
      "It creates its own `this` context.",
      "It lexically binds `this` from the enclosing parent scope.",
      "It cannot access global variables.",
      "It is always hoisted."
    ],
    "answer": "It lexically binds `this` from the enclosing parent scope.",
    "explanation": "Arrow functions do not have their own `this` context; instead, they close over the `this` value of the surrounding lexical scope. They are also not hoisted.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "In a JavaScript `try...catch` block, which component is optional?",
    "options": [
      "The `try` block.",
      "The `catch` block.",
      "The `finally` block.",
      "Both `catch` and `finally` are optional."
    ],
    "answer": "The `finally` block.",
    "explanation": "The `finally` block is optional. A `try` block must be followed by either a `catch` block, a `finally` block, or both.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which global function executes a specified code string after a specified delay (in milliseconds) but does not block the main thread?",
    "options": [
      "setInterval()",
      "setTimeout()",
      "process.nextTick()",
      "Promise.resolve()"
    ],
    "answer": "setTimeout()",
    "explanation": "`setTimeout()` registers a callback to be executed once after the delay. It is non-blocking and relies on the libuv/thread pool for timing and the Event Loop for execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which concept refers to the fact that an inner function has access to the variables and parameters of its outer function, even after the outer function has returned?",
    "options": [
      "Hoisting",
      "Currying",
      "Scope Chain",
      "Event Bubbling"
    ],
    "answer": "Scope Chain",
    "explanation": "When a variable is referenced, the engine looks in the current scope, then the outer scope, and so on, up to the global scope. This chain lookup remains valid for closures.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What value does the Boolean() function return when passed an empty string (`\"\"`)?",
    "options": [
      "true",
      "false",
      "undefined",
      "null"
    ],
    "answer": "false",
    "explanation": "In JavaScript, empty strings are falsy values. Therefore, `Boolean(\"\")` evaluates to `false`.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which built-in array method iterates over the array elements and returns a new array with the results of calling a provided function on every element?",
    "options": [
      "forEach()",
      "map()",
      "filter()",
      "reduce()"
    ],
    "answer": "map()",
    "explanation": "`map()` creates a new array populated with the results of calling a provided function on every element in the calling array. `forEach()` returns `undefined`.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the default value of the `this` keyword in a function running in strict mode ('use strict')?",
    "options": [
      "The global object (window in browsers).",
      "undefined",
      "null",
      "The function itself."
    ],
    "answer": "undefined",
    "explanation": "In strict mode, if a function is called without a context object, `this` is `undefined`. In non-strict (sloppy) mode, it defaults to the global object.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which JavaScript operation is synchronous and blocks the main thread until completion?",
    "options": [
      "Network I/O",
      "File System I/O (Node.js)",
      "JavaScript execution (CPU-bound task)",
      "Timer execution"
    ],
    "answer": "JavaScript execution (CPU-bound task)",
    "explanation": "The execution of JavaScript code (calculations, loops) is synchronous and blocks the main thread. I/O and timers are delegated to the OS/libuv and are non-blocking.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the purpose of the `delete` operator in JavaScript?",
    "options": [
      "To remove an object from memory.",
      "To remove a property from an object.",
      "To clear a variable's value.",
      "To remove an element from an array."
    ],
    "answer": "To remove a property from an object.",
    "explanation": "The `delete` operator removes a specific property from an object. It does not free memory directly (the GC handles that) nor does it remove variables.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which of the following is NOT a valid JavaScript primitive type?",
    "options": [
      "Symbol",
      "BigInt",
      "Object",
      "Boolean"
    ],
    "answer": "Object",
    "explanation": "JavaScript has 7 primitive types: String, Number, BigInt, Boolean, Undefined, Symbol, and Null. `Object` is a reference type.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the result of the expression `true + 0`?",
    "options": [
      "1",
      "true",
      "0",
      "NaN"
    ],
    "answer": "1",
    "explanation": "In arithmetic operations, `true` is coerced to `1` and `false` is coerced to `0`. Thus, `1 + 0` equals `1`.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the specific term for the error that occurs when a variable is used before it has been declared in the temporal dead zone (TDZ)?",
    "options": [
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "RangeError"
    ],
    "answer": "ReferenceError",
    "explanation": "Accessing a `let` or `const` variable between the start of the scope and its declaration line (the TDZ) throws a ReferenceError.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which operator determines if an object or its prototype chain contains a property with the specified name?",
    "options": [
      "=",
      "==",
      "in",
      "instanceof"
    ],
    "answer": "in",
    "explanation": "The `in` operator returns `true` if the specified property is in the specified object or its prototype chain. `hasOwnProperty` checks only the object itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which component of V8 is responsible for optimizing property access by tracking the 'shape' or 'hidden class' of objects?",
    "options": [
      "Inline Caches (ICs)",
      "The AST Generator",
      "The Garbage Collector",
      "The Parser"
    ],
    "answer": "Inline Caches (ICs)",
    "explanation": "Inline Caches are a technique used by V8 to optimize property access by learning the types of objects passed to a function and caching the lookup location based on hidden classes.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What happens when you attempt to change the `length` property of an array to a value smaller than the current number of elements?",
    "options": [
      "The array throws a RangeError.",
      "The array is resized and elements exceeding the new length are removed.",
      "The array length remains unchanged.",
      "The array becomes a sparse array with empty slots."
    ],
    "answer": "The array is resized and elements exceeding the new length are removed.",
    "explanation": "Setting `array.length = n` truncates the array if `n` is smaller than the current length, effectively deleting the excess elements.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which term describes the process of converting an object to a JSON string?",
    "options": [
      "Parsing",
      "Serialization",
      "Encoding",
      "Compilation"
    ],
    "answer": "Serialization",
    "explanation": "Serialization (specifically JSON serialization) is converting a data structure (object) into a format (JSON string) suitable for transmission or storage.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "In the V8 execution model, what is the final stage of processing a Promise rejection if no `.catch()` handler is attached?",
    "options": [
      "It is silently ignored.",
      "It triggers an `unhandledrejection` event.",
      "It causes an immediate script crash.",
      "It is retried indefinitely."
    ],
    "answer": "It triggers an `unhandledrejection` event.",
    "explanation": "If a promise is rejected and no handler is available (or the rejection happens asynchronously), the runtime emits an 'unhandledrejection' event.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the output of `function foo() { return a; } var a = 5; console.log(foo());`?",
    "options": [
      "ReferenceError",
      "undefined",
      "5",
      "null"
    ],
    "answer": "5",
    "explanation": "`var` declarations are hoisted. `a` is initialized to `undefined` at the top of the scope and assigned `5` before `foo()` is called, so it returns `5`.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which keyword stops the current loop iteration and continues execution with the next iteration?",
    "options": [
      "break",
      "continue",
      "return",
      "skip"
    ],
    "answer": "continue",
    "explanation": "`continue` jumps to the next iteration of the loop. `break` exits the loop entirely. `return` exits the function.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the primary role of the 'Call Stack' in the V8 runtime?",
    "options": [
      "To store resolved Promise callbacks.",
      "To keep track of the function execution flow.",
      "To manage memory for objects.",
      "To parse JavaScript source code."
    ],
    "answer": "To keep track of the function execution flow.",
    "explanation": "The Call Stack is a LIFO (Last In, First Out) data structure that records where we are in the program's execution, specifically what function is currently running and what functions are called from within it.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which V8 component is responsible for generating bytecode from the Abstract Syntax Tree (AST) during the initial execution of a script?",
    "options": [
      "TurboFan",
      "Ignition",
      "SpiderMonkey",
      "Orinoco"
    ],
    "answer": "Ignition",
    "explanation": "Ignition is V8's interpreter, which generates bytecode from the AST. TurboFan is the optimizing compiler that runs later for hot code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In the context of the JavaScript Event Loop, how are tasks from the Microtask queue prioritized compared to the Macrotask queue?",
    "options": [
      "Macrotasks are processed entirely before the Microtask queue is checked.",
      "Microtasks are processed after every Macrotask completes.",
      "Both queues are processed simultaneously in parallel threads.",
      "Microtasks are processed only when the call stack is empty and no Macrotasks are pending."
    ],
    "answer": "Microtasks are processed after every Macrotask completes.",
    "explanation": "The event loop processes a single macrotask, then drains the entire microtask queue before picking up the next macrotask. Microtasks have higher priority (e.g., Promises) than macrotasks (e.g., setTimeout).",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary consequence of adding a new property to an object instance *after* its instantiation in V8?",
    "options": [
      "V8 creates a new Hidden Class, triggering deoptimization of inline caches.",
      "The object is moved from the Stack to the Heap.",
      "The Garbage Collector immediately reclaims the old object structure.",
      "The property is added without performance impact as objects are dynamic by design."
    ],
    "answer": "V8 creates a new Hidden Class, triggering deoptimization of inline caches.",
    "explanation": "V8 uses Hidden Classes to optimize property access. Changing an object's structure (shape) forces V8 to generate a new Hidden Class and transition to it, invalidating previous optimizations (inline caches).",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "During the Creation Phase of the Execution Context, how are variable declarations using `var` handled?",
    "options": [
      "They are initialized to `undefined` and hoisted to the top of their scope.",
      "They are allocated in the Heap but remain uninitialized until the code reaches their definition.",
      "They are ignored until the Execution Phase.",
      "They are compiled directly into machine code addresses."
    ],
    "answer": "They are initialized to `undefined` and hoisted to the top of their scope.",
    "explanation": "In the creation phase, memory is allocated for `var` variables, and they are initialized with the value `undefined`. This creates the effect of hoisting.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which garbage collection algorithm in V8 is specifically designed to handle the 'Old Generation' of objects (long-lived objects)?",
    "options": [
      "Scavenge",
      "Mark-Sweep-Compact",
      "Reference Counting",
      "Cheney's Algorithm"
    ],
    "answer": "Mark-Sweep-Compact",
    "explanation": "The Old Generation uses Mark-Sweep-Compact (or Mark-Compact) to manage memory fragmentation and reclaim memory from long-lived objects. Scavenge is used for the Young Generation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What specific value does the `this` keyword refer to when used inside an Arrow Function?",
    "options": [
      "The global object (window or global).",
      "The object that invoked the function.",
      "The enclosing lexical context's `this` value.",
      "`undefined` in strict mode."
    ],
    "answer": "The enclosing lexical context's `this` value.",
    "explanation": "Arrow functions do not have their own `this` context; they capture the `this` value of the surrounding lexical scope. Standard functions bind `this` based on how they are called.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What type of task is a fulfilled Promise's `.then()` callback placed in within the Node.js environment?",
    "options": [
      "Macrotask Queue",
      "Microtask Queue",
      "Check Queue",
      "I/O Polling Queue"
    ],
    "answer": "Microtask Queue",
    "explanation": "Promise callbacks are specifically handled by the Microtask queue (often referred to as `nextTickQueue` or `PromiseJobs`), distinct from the Macrotask queue used for timers and I/O.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the output of `console.log(typeof null)` in JavaScript?",
    "options": [
      "'null'",
      "'undefined'",
      "'object'",
      "'number'"
    ],
    "answer": "'object'",
    "explanation": "This is a historical bug in JavaScript. `typeof null` returns 'object' due to legacy type tag representation in the engine's early implementation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which of the following operations represents a 'Shallow Copy' of an object in JavaScript?",
    "options": [
      "`JSON.parse(JSON.stringify(obj))`",
      "`Object.assign({}, obj)`",
      "`structuredClone(obj)`",
      "Creating a new object and manually assigning all nested properties."
    ],
    "answer": "`Object.assign({}, obj)`",
    "explanation": "`Object.assign` copies properties by reference, meaning nested objects are shared between the original and the copy. `structuredClone` and `JSON.stringify`/`parse` create deep copies.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the result of the expression `[] + []` in JavaScript?",
    "options": [
      "SyntaxError",
      "NaN",
      "[]",
      "\"\""
    ],
    "answer": "\"\"",
    "explanation": "When using the `+` operator with arrays, JavaScript converts the arrays to strings first. An empty array converts to an empty string, resulting in `\"\" + \"\"`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which phase of V8's garbage collection occurs in the 'Young Generation' space and is designed for speed?",
    "options": [
      "Mark-Sweep",
      "Scavenge",
      "Compaction",
      "Incremental Marking"
    ],
    "answer": "Scavenge",
    "explanation": "The Young Generation uses the Scavenge algorithm, which is fast because it only processes the small portion of memory where short-lived objects reside. It copies live objects to/from 'To' and 'From' spaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the V8 compilation pipeline, what is the input source for the TurboFan optimizing compiler?",
    "options": [
      "JavaScript Source Code",
      "Abstract Syntax Tree (AST)",
      "Bytecode generated by Ignition",
      "Machine Code"
    ],
    "answer": "Bytecode generated by Ignition",
    "explanation": "TurboFan takes the bytecode generated by Ignition (along with feedback types) as input to generate optimized machine code. This allows V8 to parse code only once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Why are function declarations preferred over function expressions (e.g., `const func = () => {}`) for optimization in some V8 contexts?",
    "options": [
      "Function declarations are stored on the stack.",
      "Function declarations allow for easier 'monomorphic' state assumption for the engine.",
      "Function expressions cannot be parsed by Ignition.",
      "Function declarations are always compiled to machine code immediately."
    ],
    "answer": "Function declarations allow for easier 'monomorphic' state assumption for the engine.",
    "explanation": "While both produce objects, named function declarations are easily resolvable by the compiler during the creation phase, aiding predictability. However, strict preference depends on specific engine versioning and context.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which method ensures an object cannot be modified by preventing new properties from being added or existing properties from being removed?",
    "options": [
      "`Object.preventExtensions()`",
      "`Object.freeze()`",
      "`Object.seal()`",
      "`Object.close()`"
    ],
    "answer": "`Object.seal()`",
    "explanation": "`Object.seal()` prevents additions and deletions but allows modification of existing property values. `Object.preventExtensions()` allows deletions. `Object.freeze()` prevents all changes including value modification.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the specific technical role of libuv in a Node.js application?",
    "options": [
      "Parsing JavaScript syntax into an AST.",
      "Managing the Event Loop and asynchronous I/O operations.",
      "Compiling bytecode to machine code.",
      "Allocating Heap memory for objects."
    ],
    "answer": "Managing the Event Loop and asynchronous I/O operations.",
    "explanation": "libuv is a C library that handles the asynchronous I/O operations (thread pool, file system, network) and implements the Event Loop pattern in Node.js.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the 'Temporal Dead Zone' (TDZ) in the context of `let` and `const`?",
    "options": [
      "The time between variable declaration and initialization.",
      "The period after program startup before the Event Loop begins.",
      "The duration a Promise takes to resolve.",
      "The time it takes for the Garbage Collector to free a variable."
    ],
    "answer": "The time between variable declaration and initialization.",
    "explanation": "The TDZ is the scope from the start of the block until the variable is actually declared. Accessing the variable in this zone throws a ReferenceError.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "When using `Promise.all`, what is the behavior if one of the input Promises rejects?",
    "options": [
      "It waits for all other Promises to settle before rejecting.",
      "It immediately rejects with the reason of the first rejected Promise.",
      "It catches the error and returns `undefined`.",
      "It ignores the rejection and resolves with the fulfilled values."
    ],
    "answer": "It immediately rejects with the reason of the first rejected Promise.",
    "explanation": "`Promise.all` is fail-fast: it rejects as soon as any input promise rejects, without waiting for the rest of the pending promises to complete.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which statement accurately describes the behavior of the `async` keyword regarding function return values?",
    "options": [
      "It forces the function to return `null` if no value is specified.",
      "It automatically wraps the returned value in a `Promise`.",
      "It prevents the function from returning any value.",
      "It converts synchronous errors into warnings."
    ],
    "answer": "It automatically wraps the returned value in a `Promise`.",
    "explanation": "Calling an async function always returns a Promise. If the function returns a non-Promise value, it is wrapped in a resolved Promise.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "In JavaScript's Prototype Chain, what determines the `[[Prototype]]` of a newly created object via `new Constructor()`?",
    "options": [
      "The `Object.prototype` property.",
      "The `Constructor.prototype` property at the time of instantiation.",
      "The `__proto__` property of the global window.",
      "The `prototype` property of the object itself."
    ],
    "answer": "The `Constructor.prototype` property at the time of instantiation.",
    "explanation": "When using `new`, the object's internal `[[Prototype]]` link is set to the object referenced by the constructor function's `prototype` property.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What occurs when `JSON.stringify()` encounters a value that is `undefined`, a function, or a symbol?",
    "options": [
      "It converts them to `null`.",
      "It throws a TypeError.",
      "It omits them entirely from the returned string.",
      "It converts them to the string 'undefined'."
    ],
    "answer": "It omits them entirely from the returned string.",
    "explanation": "When object values are `undefined`, functions, or symbols, they are excluded from the stringification process. If found in an array, they become `null`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the primary purpose of 'Inline Caches' (ICs) in V8?",
    "options": [
      "To store frequently called function bytecode.",
      "To optimize property access by memorizing the location of properties on objects.",
      "To inline CSS directly into the HTML.",
      "To cache the results of HTTP requests."
    ],
    "answer": "To optimize property access by memorizing the location of properties on objects.",
    "explanation": "Inline Caches are a crucial optimization technique that assumes objects maintain the same structure (Hidden Class). They cache the memory offset for a property lookup to avoid expensive dictionary searches.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which data structure is most suitable for implementing a 'Last In, First Out' (LIFO) processing mechanism in JavaScript?",
    "options": [
      "Queue",
      "Array (using push/shift)",
      "Array (using push/pop)",
      "Linked List (using head/tail pointers)"
    ],
    "answer": "Array (using push/pop)",
    "explanation": "JavaScript arrays can function as a Stack using `push` (add to end) and `pop` (remove from end). This adheres to LIFO principles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the result of `console.log(1 + '1')` in JavaScript?",
    "options": [
      "2",
      "NaN",
      "\"11\"",
      "11"
    ],
    "answer": "\"11\"",
    "explanation": "The `+` operator triggers type coercion to String when one operand is a String. The number 1 is converted to \"1\", resulting in concatenation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "How does V8 handle 'Smi' (Small Integer) values differently from 'Heap Numbers'?",
    "options": [
      "Smi values are pointers to objects on the Heap.",
      "Smi values are stored directly as raw 31-bit or 32-bit integers for performance.",
      "Smi values are always converted to floats before calculation.",
      "There is no difference; all numbers are Heap Numbers."
    ],
    "answer": "Smi values are stored directly as raw 31-bit or 32-bit integers for performance.",
    "explanation": "V8 stores small integers (Smis) directly as immediate values (usually in registers or on the stack) to avoid the overhead of allocating full Heap Number objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What distinguishes `WeakMap` from `Map` in terms of garbage collection?",
    "options": [
      "`WeakMap` keys are not enumerable.",
      "`WeakMap` holds 'weak' references to keys, allowing them to be garbage collected if no other reference exists.",
      "`WeakMap` can only store primitive values as keys.",
      "`WeakMap` stores data in the Stack rather than the Heap."
    ],
    "answer": "`WeakMap` holds 'weak' references to keys, allowing them to be garbage collected if no other reference exists.",
    "explanation": "References to key objects in a `WeakMap` are weak, meaning they do not prevent garbage collection. `Map` references are strong.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What does the `delete` operator do to a property on an object in V8?",
    "options": [
      "It sets the property value to `undefined`.",
      "It removes the property and causes V8 to transition the object to a new Hidden Class.",
      "It permanently removes the property but maintains the object's Hidden Class.",
      "It throws an error if the property is configurable."
    ],
    "answer": "It removes the property and causes V8 to transition the object to a new Hidden Class.",
    "explanation": "Deleting properties changes the object's structure (shape). This forces V8 to transition the object to a new Hidden Class, degrading optimization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "In the context of Closures, which part of memory is responsible for keeping the variables alive after the outer function has returned?",
    "options": [
      "The Call Stack",
      "The Execution Context",
      "The Heap",
      "The Register"
    ],
    "answer": "The Heap",
    "explanation": "The scope chain (and variables) of a closure is allocated on the Heap, as the Stack frame of the outer function is destroyed upon return. The variables persist because they are referenced by the inner function.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which of the following methods can be used to inspect the internal `[[Class]]` or type tag of an object more reliably than `typeof`?",
    "options": [
      "`Object.prototype.toString.call(obj)`",
      "`obj.getType()`",
      "`Object.getPrototypeOf(obj)`",
      "`obj.instanceof`"
    ],
    "answer": "`Object.prototype.toString.call(obj)`",
    "explanation": "This method returns the standard internal class string (e.g., `[object Array]`, `[object Date]`), providing a more specific type check than `typeof`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the result of `2 == null`?",
    "options": [
      "true",
      "false",
      "undefined",
      "TypeError"
    ],
    "answer": "false",
    "explanation": "Abstract equality comparison (`==`) does not coerce numbers to null/undefined. `null` is only loosely equal to `undefined`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the purpose of 'Debouncing' in JavaScript event handling?",
    "options": [
      "To limit the rate of execution of a function to once per every X milliseconds.",
      "To delay the execution of a function until after a pause in events.",
      "To ensure a function executes exactly once.",
      "To convert a synchronous function to an asynchronous one."
    ],
    "answer": "To delay the execution of a function until after a pause in events.",
    "explanation": "Debouncing forces a function to wait until a certain amount of time has passed without the event being triggered. Throttling enforces a maximum execution frequency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the output of `console.log(typeof NaN)`?",
    "options": [
      "'NaN'",
      "'number'",
      "'undefined'",
      "'object'"
    ],
    "answer": "'number'",
    "explanation": "Despite standing for 'Not-A-Number', `NaN` is technically a numeric value type in IEEE 754 floating-point representation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "When using `Proxy` objects, which trap handler is triggered when using the `in` operator?",
    "options": [
      "`has`",
      "`get`",
      "`in`",
      "`check`"
    ],
    "answer": "`has`",
    "explanation": "The `has` trap intercepts the `in` operator (e.g., `'prop' in obj`). The `get` trap intercepts property access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the behavior of `Function.prototype.bind()`?",
    "options": [
      "It creates a new function with a specific `this` value and initial arguments.",
      "It modifies the original function's `this` context permanently.",
      "It executes the function immediately with the provided arguments.",
      "It copies the function's prototype chain to a new object."
    ],
    "answer": "It creates a new function with a specific `this` value and initial arguments.",
    "explanation": "`bind` returns a new bound function (exotic function object). It does not invoke the function (unlike `call`/`apply`) nor changes the original.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "In a generator function, what does the `yield*` expression do?",
    "options": [
      "It delegates to another generator or iterable object.",
      "It yields the control flow back to the operating system.",
      "It creates an infinite loop of yielded values.",
      "It pauses the generator indefinitely until a specific timeout."
    ],
    "answer": "It delegates to another generator or iterable object.",
    "explanation": "`yield*` iterates over the provided iterable/generator and yields each of its values. This is used for nesting generators.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "Which statement regarding 'Modules' vs 'Scripts' in JavaScript is correct?",
    "options": [
      "Modules automatically use Strict Mode, Scripts do not.",
      "Scripts are isolated from the global scope, Modules are not.",
      "Modules share a top-level `this` that points to the global object.",
      "Scripts allow top-level `await`, Modules do not."
    ],
    "answer": "Modules automatically use Strict Mode, Scripts do not.",
    "explanation": "JavaScript Modules are implicitly in strict mode. Scripts are not strict unless the `'use strict';` directive is present.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the V8 engine's compilation pipeline, what is the specific input format consumed by the optimizing compiler (TurboFan) to generate optimized machine code?",
    "options": [
      "The raw JavaScript source string",
      "The Abstract Syntax Tree (AST) generated by the parser",
      "The bytecode generated by the Ignition interpreter",
      "The machine code output from the baseline compiler"
    ],
    "answer": "The bytecode generated by the Ignition interpreter",
    "explanation": "TurboFan consumes the bytecode produced by Ignition. Using bytecode instead of the AST saves memory and CPU cycles, as the AST does not need to be retained or regenerated during the optimization phase.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "How does V8's 'Hidden Class' (or 'Map') mechanism specifically impact property access performance?",
    "options": [
      "It caches the result of property lookups in a global hash map to avoid future traversals.",
      "It converts object properties into numerical indices to allow access via inline C-style memory offsets.",
      "It creates a direct pointer from the object's prototype to the specific value in the heap.",
      "It serializes the object into a JSON string to speed up transmission over the network."
    ],
    "answer": "It converts object properties into numerical indices to allow access via inline C-style memory offsets.",
    "explanation": "Hidden Classes allow V8 to treat JavaScript objects like C++ structs. Once the shape is known, property access is converted into a fixed memory offset lookup, eliminating the need for expensive dynamic dictionary searches.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "During the 'Creation Phase' of the Execution Context, how are `var`, `let`, and `const` declarations specifically handled in memory?",
    "options": [
      "All variables are initialized to `undefined`, while `let` and `const` throw a ReferenceError.",
      "`var` is initialized to `undefined`, while `let` and `const` remain uninitialized (in the Temporal Dead Zone).",
      "All variables are hoisted to the top of the scope with their assigned values.",
      "Only functions are initialized; all variables are skipped until the Execution Phase."
    ],
    "answer": "`var` is initialized to `undefined`, while `let` and `const` remain uninitialized (in the Temporal Dead Zone).",
    "explanation": "During the creation phase, memory is allocated for all variables. `var` is specifically initialized with the value `undefined`, whereas `let` and `const` are put in the TDZ and remain uninitialized until the execution phase reaches their declaration line.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What distinguishes the 'Microtask Queue' (Job Queue) from the 'Macrotask Queue' (Event Queue) in the JavaScript Event Loop?",
    "options": [
      "Macrotasks are handled by the browser UI thread, while Microtasks are handled by the V8 engine.",
      "The Event Loop drains the Microtask Queue completely after every task in the Call Stack finishes, before moving to the next Macrotask.",
      "Macrotasks have higher priority and execute before Microtasks to prevent UI blocking.",
      "There is no difference; they are simply two names for the same FIFO queue used by libuv."
    ],
    "answer": "The Event Loop drains the Microtask Queue completely after every task in the Call Stack finishes, before moving to the next Macrotask.",
    "explanation": "Microtasks (like Promises) have higher priority. After the main script or a macrotask completes, the engine enters a microtask checkpoint and executes *all* queued microtasks before picking up the next macrotask from the event queue.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of V8's Garbage Collection (Orinoco), what is the primary disadvantage of using the 'Scavenge' algorithm for the Old Generation space?",
    "options": [
      "It is a stop-the-world algorithm that pauses the entire application for too long.",
      "It requires twice the memory size of the young generation (semi-space copy collection).",
      "It cannot handle objects that have circular references.",
      "It fragments memory, requiring frequent compaction pauses."
    ],
    "answer": "It requires twice the memory size of the young generation (semi-space copy collection).",
    "explanation": "Scavenge (Cheney's algorithm) is a copy collector. It is fast and efficient for the young generation but requires splitting the memory space into two equal halves (From-space and To-space), effectively doubling the memory footprint for that generation.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which specific coding pattern will trigger 'deoptimization' in V8 by causing a 'Hidden Class' change?",
    "options": [
      "Accessing array elements using a numerical index.",
      "Adding a new property to an object after it has been instantiated.",
      "Passing an object as an argument to a function.",
      "Using a closure to access a variable in the outer scope."
    ],
    "answer": "Adding a new property to an object after it has been instantiated.",
    "explanation": "V8 creates Hidden Classes based on the initial structure. Adding properties dynamically forces V8 to create a new Hidden Class and transition the old object to it, invalidating previous optimizations (Inline Caches) that relied on the old structure.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "How does the `process.nextTick()` queue in Node.js relate to the Promise Microtask Queue regarding execution timing?",
    "options": [
      "`process.nextTick()` has higher priority and runs immediately after the current operation completes, before Promise microtasks.",
      "Promise microtasks always run before `process.nextTick()` callbacks.",
      "`process.nextTick()` is a Macrotask and runs in the next Event Loop iteration.",
      "They are merged into a single queue and executed in the order they were received."
    ],
    "answer": "`process.nextTick()` has higher priority and runs immediately after the current operation completes, before Promise microtasks.",
    "explanation": "In Node.js, `process.nextTick` has its own queue that is processed *before* the microtask queue (Promises). This creates a priority hierarchy: current operation -> nextTick -> Promises -> Macrotasks.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the specific technical reason V8 uses 'Inline Caches' (ICs)?",
    "options": [
      "To store the machine code of frequently called functions directly inside the caller's bytecode.",
      "To cache the lookup result of object property access (type and offset) to skip repeated hidden class lookups.",
      "To inline HTML and CSS strings directly into the JavaScript DOM manipulation functions.",
      "To cache network responses in the browser's memory to avoid repeated HTTP requests."
    ],
    "answer": "To cache the lookup result of object property access (type and offset) to skip repeated hidden class lookups.",
    "explanation": "Inline Caches remember the location (offset) of a property on an object's Hidden Class. If the same object type is encountered again, V8 uses the cached offset instead of performing a slow property lookup.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In V8's 'Generational' garbage collection, why is the 'Young Generation' designed to be small and use the 'Scavenge' algorithm?",
    "options": [
      "Because most objects die young (infant mortality), Scavenge is efficient for this by only copying surviving objects.",
      "To force frequent garbage collections, reducing overall memory pressure on the operating system.",
      "Because the Young Generation stores long-lived DOM nodes that require complex Mark-Sweep algorithms.",
      "To prevent the 'Mark-Sweep-Compact' algorithm from fragmenting the heap space."
    ],
    "answer": "Because most objects die young (infant mortality), Scavenge is efficient for this by only copying surviving objects.",
    "explanation": "Generational hypothesis states that most objects are short-lived. Scavenge is ideal here because it is very fast at reclaiming memory from dead objects (which are simply abandoned) and only costs time for the few that survive.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "When `await` is encountered in an `async` function, what is the immediate step taken by the JavaScript engine regarding the current function execution?",
    "options": [
      "The function execution pauses, the value is wrapped in a Promise, and the rest of the function is scheduled as a microtask.",
      "The thread blocks until the awaited Promise resolves.",
      "The function returns `undefined` immediately to the caller without scheduling a callback.",
      "The execution moves to the next line of code immediately (fire-and-forget)."
    ],
    "answer": "The function execution pauses, the value is wrapped in a Promise, and the rest of the function is scheduled as a microtask.",
    "explanation": "`await` yields control back to the caller. The awaited value is converted to a Promise. When that Promise resolves, the continuation of the `async` function is queued in the microtask queue to resume execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which V8 component is responsible for converting the Abstract Syntax Tree (AST) into Bytecode for the first time?",
    "options": [
      "TurboFan",
      "Ignition",
      "Orinoco",
      "SpiderMonkey"
    ],
    "answer": "Ignition",
    "explanation": "Ignition is V8's interpreter. It takes the AST generated by the parser and generates bytecode, which is then executed or used as input for the optimizing compiler TurboFan.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Why does V8 implement 'On-Stack Replacement' (OSR)?",
    "options": [
      "To replace the currently running function with a newer version from the server without reloading the page.",
      "To switch a function from the interpreter to optimized machine code *while it is currently running*.",
      "To move objects from the Stack to the Heap when they exceed a certain size limit.",
      "To replace the old context with a new one when navigating to a different website."
    ],
    "answer": "To switch a function from the interpreter to optimized machine code *while it is currently running*.",
    "explanation": "Without OSR, a function only gets optimized after it completes a full execution and becomes 'hot'. OSR allows V8 to switch to optimized code mid-execution (e.g., in the middle of a long loop) without waiting for the function to restart.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the result of executing a JavaScript function that exceeds the maximum call stack size?",
    "options": [
      "A `MemoryLimitExceeded` error is thrown by the Garbage Collector.",
      "A `RangeError` is thrown specifically labeled as 'Maximum call stack size exceeded'.",
      "The browser tab crashes immediately without an error.",
      "The function automatically converts to a tail-call optimized version."
    ],
    "answer": "A `RangeError` is thrown specifically labeled as 'Maximum call stack size exceeded'.",
    "explanation": "Recursion consumes stack frames. When the stack pointer exceeds the limit set by the V8 flag `--stack_size`, the runtime throws a `RangeError` to prevent memory corruption.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does 'Shrinking' the code of a function in V8 specifically affect performance?",
    "options": [
      "It reduces the file size on the hard disk, making download faster.",
      "It deoptimizes the function to ensure it runs slower to save battery life.",
      "It allows the function to be inlined into other functions, removing call overhead.",
      "It removes comments and whitespace from the source code."
    ],
    "answer": "It allows the function to be inlined into other functions, removing call overhead.",
    "explanation": "Inlining is a powerful optimization where the function's body is copied directly into the caller. Large functions cannot be inlined due to code bloat. Therefore, keeping functions small increases the likelihood of inlining, which eliminates call setup overhead.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "In the context of the V8 engine, what is 'Smi' (Small Integer)?",
    "options": [
      "A specialized C++ class for handling arbitrary-precision integers.",
      "An internal optimization that stores small integers (typically 31-bit) directly as tagged pointers to avoid heap allocation.",
      "A garbage collection algorithm for short-lived integers.",
      "The bytecode instruction set used for arithmetic operations."
    ],
    "answer": "An internal optimization that stores small integers (typically 31-bit) directly as tagged pointers to avoid heap allocation.",
    "explanation": "V8 uses 'Smis' to represent small integers efficiently. Instead of creating a full HeapObject, the value is encoded directly into the pointer (using the least significant bit as a tag), making arithmetic extremely fast and memory-efficient.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What triggers V8 to transition an object from the 'Young' generation to the 'Old' generation during Garbage Collection?",
    "options": [
      "When the object's size exceeds 1KB.",
      "When the object survives a scavenge (garbage collection) cycle in the Young generation.",
      "When the object is assigned to a global variable.",
      "When the object is accessed more than 100 times."
    ],
    "answer": "When the object survives a scavenge (garbage collection) cycle in the Young generation.",
    "explanation": "Generational collectors assume if an object survives one GC cycle in the Young space, it will likely live longer. The surviving objects are moved (promoted) to the Old generation to be managed by the Mark-Sweep-Compact algorithm.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the specific behavior difference between a 'shared array buffer' and a standard 'array buffer' in a multi-threaded context?",
    "options": [
      "Standard ArrayBuffers cannot be transferred between workers.",
      "SharedArrayBuffers allow multiple threads (agents) to access the exact same memory location simultaneously.",
      "SharedArrayBuffers are garbage collected automatically, while ArrayBuffers are not.",
      "There is no performance difference; the syntax is simply different."
    ],
    "answer": "SharedArrayBuffers allow multiple threads (agents) to access the exact same memory location simultaneously.",
    "explanation": "A standard `ArrayBuffer` is transferable (ownership moves), whereas a `SharedArrayBuffer` uses shared memory. This enables true parallelism without copying data, though it requires Atomic operations to prevent race conditions.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "Regarding V8's 'Mark-Compact' phase for the Old Generation, what is the primary purpose of the 'Compact' step?",
    "options": [
      "To destroy all objects that were not marked as live.",
      "To defragment memory by moving live objects together, eliminating gaps between them.",
      "To compress the bytecode into a smaller instruction set.",
      "To mark objects as 'read-only' to prevent modification."
    ],
    "answer": "To defragment memory by moving live objects together, eliminating gaps between them.",
    "explanation": "After sweeping (freeing dead objects), memory becomes fragmented. The Compact phase relocates live objects to contiguous regions of memory, improving allocation efficiency and cache locality.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is 'Speculative Optimization' in the context of V8's TurboFan compiler?",
    "options": [
      "Compiling all code to machine code before execution.",
      "Assuming types and shapes will remain consistent based on past execution (feedback) and optimizing accordingly.",
      "Guessing the user's intent and executing code before they click a button.",
      "Randomly selecting different optimization strategies to see which runs faster."
    ],
    "answer": "Assuming types and shapes will remain consistent based on past execution (feedback) and optimizing accordingly.",
    "explanation": "V8 collects type feedback during interpretation. TurboFan speculates that these types (e.g., 'this variable is always an integer') won't change and generates optimized machine code. If the assumption fails, the code is 'deoptimized'.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "In a Node.js environment utilizing libuv, what type of task is `setImmediate` classified as?",
    "options": [
      "A Microtask (Promise-like task).",
      "A Check phase task (Macrotask).",
      "A Timer (setTimeout) phase task.",
      "A Close Callbacks phase task."
    ],
    "answer": "A Check phase task (Macrotask).",
    "explanation": "libuv's Event Loop has phases. `setImmediate` callbacks are queued in the 'Check' phase, whereas `setTimeout` uses the 'Timers' phase. `setImmediate` runs after I/O callbacks in the same loop iteration.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "Why is the 'Temporal Dead Zone' (TDZ) significant for V8's optimization capabilities regarding `let` and `const`?",
    "options": [
      "It forces the engine to parse the code twice.",
      "It prevents dynamic accesses to the variable before initialization, allowing for stricter static type analysis.",
      "It delays the garbage collection of the variable until the block scope is exited.",
      "It automatically converts variables to Smis (Small Integers)."
    ],
    "answer": "It prevents dynamic accesses to the variable before initialization, allowing for stricter static type analysis.",
    "explanation": "By enforcing the TDZ, the engine ensures that variables are not accessed in an uninitialized state. This predictability allows the compiler to make better assumptions about variable usage and memory layout during optimization.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the behavior of `WeakMap` keys regarding Garbage Collection?",
    "options": [
      "Keys in a WeakMap are strongly referenced, preventing the garbage collector from removing them from memory.",
      "Keys in a WeakMap are weakly referenced, meaning if there is no other reference to the key object, it can be garbage collected.",
      "Keys in a WeakMap are automatically converted to primitive values to save memory.",
      "WeakMaps do not support garbage collection; they are meant for permanent data storage."
    ],
    "answer": "Keys in a WeakMap are weakly referenced, meaning if there is no other reference to the key object, it can be garbage collected.",
    "explanation": "WeakMap holds a 'weak' reference to the key. If the key object is no longer referenced elsewhere in the application, the GC can reclaim it, and the entry in the WeakMap is automatically removed.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How does the V8 engine handle 'Property Attributes' (e.g., writable, enumerable) in relation to Hidden Classes?",
    "options": [
      "It ignores them for optimization purposes and treats all properties as configurable.",
      "It creates a unique Hidden Class (Map) for every unique combination of property attributes.",
      "It stores attributes in a separate side-table that does not affect performance.",
      "It converts objects with non-default attributes into dictionary mode immediately."
    ],
    "answer": "It creates a unique Hidden Class (Map) for every unique combination of property attributes.",
    "explanation": "Changing a property attribute (e.g., from writable to read-only) changes the object's 'shape'. V8 must create a new Hidden Class to represent this new shape, potentially breaking previous optimizations if this occurs frequently.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the primary function of 'libuv' in the Node.js architecture?",
    "options": [
      "To parse JavaScript code into an AST.",
      "To execute JavaScript bytecode.",
      "To provide an asynchronous I/O abstraction and event loop (thread pool) for system operations.",
      "To manage the V8 Heap memory."
    ],
    "answer": "To provide an asynchronous I/O abstraction and event loop (thread pool) for system operations.",
    "explanation": "V8 executes JS. libuv handles the OS-level asynchronous tasks (file system, DNS, networking) via a thread pool and kernel mechanisms, then notifies the V8 event loop when tasks are complete.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "When does V8 place an object into 'Dictionary Mode'?",
    "options": [
      "When the object is used as a key in a Map.",
      "When the object has too many properties or property deletions, making Hidden Classes inefficient.",
      "When the object is created inside a `try...catch` block.",
      "When the object inherits from the `null` prototype."
    ],
    "answer": "When the object has too many properties or property deletions, making Hidden Classes inefficient.",
    "explanation": "If an object undergoes many structural changes (like deleting properties) or has a very large number of properties, maintaining the complex transition tree of Hidden Classes becomes inefficient. V8 switches to a hash-map-like structure (Dictionary Mode) for these objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the output of `console.log(typeof null)` in the V8 engine, and why?",
    "options": [
      "`'null'`, because `null` is a primitive type.",
      "`'undefined'`, because `null` represents the absence of value.",
      "`'object'`, due to a legacy bug in the original JavaScript implementation where type bits were 0.",
      "`'number'`, because `null` is equivalent to 0 in type coercion."
    ],
    "answer": "`'object'`, due to a legacy bug in the original JavaScript implementation where type bits were 0.",
    "explanation": "In JavaScript, `typeof null` returns `'object'`. This is a historical mistake in V8 and other engines stemming from the original type tag system, where null had the type tag of an object (0) and all null pointers were 0.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the mechanism V8 uses to ensure that memory allocated by C++ plugins (Addons) does not leak?",
    "options": [
      "Reference counting.",
      "Handle Scopes / Handle Isolates.",
      "Manual memory management only.",
      "The V8 Garbage Collector scans C++ stack frames."
    ],
    "answer": "Handle Scopes / Handle Isolates.",
    "explanation": "V8 uses 'Handles' (references to heap objects) organized into HandleScopes. When a HandleScope goes out of bounds, V8 knows it can potentially free the objects referenced within that scope (if no other handles exist). This is crucial for C++ integration.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Which operation is guaranteed to trigger a 'Major GC' (Mark-Sweep-Compact) in V8?",
    "options": [
      "Creating a temporary variable in a loop.",
      "Filling up the New Space (Young Generation) such that survivors must be promoted to Old Space.",
      "Executing a closure.",
      "Evaluating a regular expression."
    ],
    "answer": "Filling up the New Space (Young Generation) such that survivors must be promoted to Old Space.",
    "explanation": "While Scavenge runs on the Young Gen, a Major GC is triggered when the Old Generation fills up or when promotion from Young to Old necessitates memory management in the Old Space due to space constraints.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the specific optimization achieved by using `TypedArrays` in JavaScript?",
    "options": [
      "They allow variable type conversion at runtime.",
      "They provide a raw binary data buffer (byte array) view, enabling data to be read/written contiguously in memory without boxing overhead.",
      "They automatically compress data to reduce network payload size.",
      "They bypass the JavaScript parser and execute directly on the CPU."
    ],
    "answer": "They provide a raw binary data buffer (byte array) view, enabling data to be read/written contiguously in memory without boxing overhead.",
    "explanation": "Standard JS arrays are sparse and can hold mixed types. TypedArrays are strictly typed and backed by an ArrayBuffer, allowing V8 to treat them as C-style arrays for contiguous memory access and SIMD optimizations.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In the context of the 'Stop-The-World' garbage collection, what does the main thread actually do during this pause?",
    "options": [
      "It continues to execute JavaScript code via the interpreter.",
      "It pauses all JavaScript execution to allow the GC thread(s) to identify and update references.",
      "It pushes all callbacks to the microtask queue.",
      "It spawns a new Web Worker to handle the UI updates."
    ],
    "answer": "It pauses all JavaScript execution to allow the GC thread(s) to identify and update references.",
    "explanation": "Stop-the-world means the mutator (the JS application) is completely halted. This is necessary to ensure the GC has a consistent view of memory roots (stack variables) while tracing object graphs.",
    "difficulty": "Advanced"
  }
]