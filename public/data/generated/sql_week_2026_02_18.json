[
  {
    "id": 1,
    "question": "Which SQL clause is used to filter the results of a GROUP BY query based on a specific condition applied to the aggregated data?",
    "options": [
      "WHERE",
      "HAVING",
      "ORDER BY",
      "LIMIT"
    ],
    "answer": "HAVING",
    "explanation": "The HAVING clause filters records after they have been grouped, whereas WHERE filters rows before aggregation. HAVING is essential for applying conditions to aggregate functions like SUM or COUNT.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the result of a LEFT JOIN (or LEFT OUTER JOIN) between Table A and Table B?",
    "options": [
      "Only records that have matching values in both tables",
      "All records from Table A and matched records from Table B",
      "All records from Table B and matched records from Table A",
      "All records from both Table A and Table B"
    ],
    "answer": "All records from Table A and matched records from Table B",
    "explanation": "A LEFT JOIN prioritizes the 'left' table (the first one listed), returning all its rows and matching rows from the right table, or NULL if there is no match.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which aggregate function returns the number of non-NULL values in a specified column?",
    "options": [
      "SUM()",
      "COUNT(column_name)",
      "AVG()",
      "TOTAL()"
    ],
    "answer": "COUNT(column_name)",
    "explanation": "COUNT(column_name) specifically counts the number of non-NULL entries in that column. In contrast, COUNT(*) counts all rows regardless of NULL values in specific columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In SQL, which operator is used to search for a specified pattern in a column?",
    "options": [
      "BETWEEN",
      "LIKE",
      "IN",
      "PATTERN"
    ],
    "answer": "LIKE",
    "explanation": "The LIKE operator is used in a WHERE clause to search for a specific pattern in a column, often utilizing wildcards such as '%' (for multiple characters) and '_' (for single characters).",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the primary purpose of the SQL DISTINCT keyword?",
    "options": [
      "To remove duplicate rows from the result set",
      "To sort the result set in descending order",
      "To filter rows based on a complex condition",
      "To join two tables together"
    ],
    "answer": "To remove duplicate rows from the result set",
    "explanation": "DISTINCT is used in a SELECT statement to ensure that only unique values are returned, effectively eliminating duplicate rows from the query output.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which clause is used to sort the result set of a query in ascending or descending order?",
    "options": [
      "GROUP BY",
      "ORDER BY",
      "SORT BY",
      "ALIGN BY"
    ],
    "answer": "ORDER BY",
    "explanation": "The ORDER BY clause is used to sort the retrieved data in either ascending (ASC) or descending (DESC) order based on one or more columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does the acronym SQL stand for?",
    "options": [
      "Simple Query Language",
      "Structured Query Language",
      "Standard Query Logic",
      "String Query List"
    ],
    "answer": "Structured Query Language",
    "explanation": "SQL stands for Structured Query Language, which is the standard domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS).",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which of the following correctly retrieves all columns from a table named 'Employees'?",
    "options": [
      "SELECT all FROM Employees",
      "SELECT * FROM Employees",
      "GET * FROM Employees",
      "SELECT every_column FROM Employees"
    ],
    "answer": "SELECT * FROM Employees",
    "explanation": "The asterisk (*) wildcard character is used in SQL to specify that all columns should be retrieved from the specified table.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which constraint ensures that a column cannot contain NULL values?",
    "options": [
      "UNIQUE",
      "NOT NULL",
      "PRIMARY KEY",
      "CHECK"
    ],
    "answer": "NOT NULL",
    "explanation": "The NOT NULL constraint enforces a column to always accept a value, meaning it cannot be left empty or contain a NULL entry.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the main difference between the DELETE and TRUNCATE commands?",
    "options": [
      "DELETE removes the table structure, TRUNCATE does not",
      "TRUNCATE removes the table structure, DELETE does not",
      "DELETE can use a WHERE clause, TRUNCATE removes all rows",
      "TRUNCATE can be rolled back, DELETE cannot"
    ],
    "answer": "DELETE can use a WHERE clause, TRUNCATE removes all rows",
    "explanation": "DELETE is a DML command that can remove specific rows based on a condition, whereas TRUNCATE is a DDL command that removes all rows from a table instantly and cannot filter rows.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which operator allows you to specify multiple values in a WHERE clause?",
    "options": [
      "RANGE",
      "BETWEEN",
      "IN",
      "INCLUDE"
    ],
    "answer": "IN",
    "explanation": "The IN operator allows you to specify multiple values in a WHERE clause, functioning as a shorthand for multiple OR conditions (e.g., WHERE city IN ('Paris', 'London')).",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which clause is mandatory when using an aggregate function like SUM() or AVG() to categorize data?",
    "options": [
      "WHERE",
      "ORDER BY",
      "GROUP BY",
      "HAVING"
    ],
    "answer": "GROUP BY",
    "explanation": "The GROUP BY clause aggregates rows that have the same values into summary rows, often used in conjunction with aggregate functions like COUNT(), SUM(), or AVG().",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In the context of a JOIN operation, what does 'ON' specify?",
    "options": [
      "The columns to be retrieved",
      "The filter condition for the join",
      "The tables to be joined",
      "The sorting order"
    ],
    "answer": "The filter condition for the join",
    "explanation": "The ON keyword is used to specify the common field or condition between two tables that determines how they are joined together.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which keyword is used to combine the results of two or more SELECT statements, removing duplicate rows?",
    "options": [
      "COMBINE",
      "UNION",
      "JOIN",
      "MERGE"
    ],
    "answer": "UNION",
    "explanation": "UNION is used to combine the result sets of two or more SELECT statements. It automatically removes duplicate rows between the various select statements, unlike UNION ALL.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which data type is most appropriate for storing variable-length text strings (e.g., a user's name)?",
    "options": [
      "CHAR",
      "TEXT",
      "VARCHAR",
      "BLOB"
    ],
    "answer": "VARCHAR",
    "explanation": "VARCHAR is a standard data type for variable-length strings. It is more storage-efficient than CHAR (fixed-length) for strings of varying lengths.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the default sorting order of the ORDER BY clause if no direction is specified?",
    "options": [
      "Random",
      "Descending",
      "Ascending",
      "Index order"
    ],
    "answer": "Ascending",
    "explanation": "By default, the ORDER BY clause sorts records in ascending order (ASC). To sort in descending order, one must explicitly specify the DESC keyword.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which function returns the current date and time in most SQL dialects?",
    "options": [
      "DATE()",
      "NOW()",
      "CURRENT()",
      "GET_DATE()"
    ],
    "answer": "NOW()",
    "explanation": "NOW() is a common function in MySQL, PostgreSQL, and SQL Server to retrieve the current date and time. Note that syntax varies slightly by dialect (e.g., GETDATE in SQL Server), but NOW is the standard general answer.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the effect of using the 'AS' keyword in a SQL query?",
    "options": [
      "It creates an alias for a table or column",
      "It adds a condition to the WHERE clause",
      "It combines two tables together",
      "It sorts the query results"
    ],
    "answer": "It creates an alias for a table or column",
    "explanation": "The AS keyword is used to rename a column or table temporarily, making the output more readable or simplifying table references in complex queries.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which command is used to modify existing records in a table?",
    "options": [
      "CHANGE",
      "MODIFY",
      "UPDATE",
      "ALTER"
    ],
    "answer": "UPDATE",
    "explanation": "The UPDATE statement is used to modify existing data in a table. ALTER is used to modify the table structure (schema), not the data itself.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which statement about NULL values in SQL is correct?",
    "options": [
      "NULL represents a value of zero",
      "NULL is treated as an empty string",
      "NULL represents a missing or unknown value",
      "NULL values are equal to each other"
    ],
    "answer": "NULL represents a missing or unknown value",
    "explanation": "NULL signifies a lack of a value or an unknown value. It is not equivalent to zero, an empty string, or another NULL; checking for NULL requires the IS NULL operator.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What does the BETWEEN operator select?",
    "options": [
      "Values strictly between two numbers, excluding the endpoints",
      "Values within a given range, inclusive of the endpoints",
      "Values that match either of two specified strings",
      "Values that fall between two dates, excluding the start date"
    ],
    "answer": "Values within a given range, inclusive of the endpoints",
    "explanation": "The BETWEEN operator selects values within a given range and is inclusive, meaning the start and end values specified in the query are included in the results.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which clause is used to limit the number of rows returned by a query?",
    "options": [
      "STOP",
      "MAX",
      "LIMIT",
      "TOP"
    ],
    "answer": "LIMIT",
    "explanation": "LIMIT is used in MySQL, PostgreSQL, and SQLite to restrict the number of rows returned. (In SQL Server, TOP is used; in Oracle, ROWNUM. LIMIT is the most common generic answer).",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which constraint uniquely identifies each record in a database table?",
    "options": [
      "UNIQUE",
      "FOREIGN KEY",
      "PRIMARY KEY",
      "CHECK"
    ],
    "answer": "PRIMARY KEY",
    "explanation": "A PRIMARY KEY constraint uniquely identifies each record in a table. It must contain unique values and cannot contain NULL values.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is a FOREIGN KEY?",
    "options": [
      "A key that identifies a unique record in another table",
      "A key that encrypts sensitive data",
      "A backup copy of the primary key",
      "A field that points to the primary key in another table"
    ],
    "answer": "A field that points to the primary key in another table",
    "explanation": "A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table, establishing a relationship between the two tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which statement is used to create a new table in a database?",
    "options": [
      "MAKE TABLE",
      "CREATE TABLE",
      "ADD TABLE",
      "NEW TABLE"
    ],
    "answer": "CREATE TABLE",
    "explanation": "The CREATE TABLE statement is the standard DDL command used to create a new table in a database, defining column names and data types.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which keyword is used to retrieve data from multiple tables by linking them through a common column?",
    "options": [
      "COMBINE",
      "UNION",
      "JOIN",
      "LINK"
    ],
    "answer": "JOIN",
    "explanation": "A JOIN clause is used to combine rows from two or more tables, based on a related column between them, allowing for retrieval of data spread across normalized tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "In a window function, what defines the set of rows to which the function is applied?",
    "options": [
      "The GROUP BY clause",
      "The OVER clause",
      "The PARTITION BY clause",
      "The frame specification"
    ],
    "answer": "The OVER clause",
    "explanation": "The OVER clause defines the window or set of rows that a window function operates on. It can optionally include partitioning, ordering, and window frame specifications.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which keyword is used to rename a table or column temporarily for the duration of a query?",
    "options": [
      "RENAME",
      "TITLE",
      "ALIAS",
      "LABEL"
    ],
    "answer": "ALIAS",
    "explanation": "An alias is a temporary name given to a table or column. While the keyword used is often 'AS', the concept is called an 'alias'.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which function would you use to convert a string to uppercase?",
    "options": [
      "UPPER()",
      "UCASE()",
      "TO_UPPER()",
      "CAPITALIZE()"
    ],
    "answer": "UPPER()",
    "explanation": "UPPER() is the standard SQL function used to convert a string value to uppercase. (Some DBs like MySQL support UCASE, but UPPER is the ANSI standard).",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the primary purpose of an Index in SQL?",
    "options": [
      "To encrypt data",
      "To speed up the retrieval of data",
      "To enforce data integrity",
      "To create a backup of the table"
    ],
    "answer": "To speed up the retrieval of data",
    "explanation": "Indexes are used to retrieve data from tables more quickly. They work by creating a data structure (like a B-Tree) that allows the database engine to find rows without scanning the entire table.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which SQL statement is used to insert new data into a table?",
    "options": [
      "ADD NEW",
      "INSERT INTO",
      "CREATE RECORD",
      "UPDATE INTO"
    ],
    "answer": "INSERT INTO",
    "explanation": "The INSERT INTO statement is used to add new rows of data to a table. It specifies the table name and the values to be inserted into the columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which join returns all records when there is a match in either the left or right table?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "FULL OUTER JOIN",
    "explanation": "A FULL OUTER JOIN combines the results of both LEFT and RIGHT joins. It returns all records when there is a match in either the left or right table.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which operator selects all values that are NOT within a specified range?",
    "options": [
      "NOT LIKE",
      "NOT IN",
      "NOT BETWEEN",
      "IS NOT"
    ],
    "answer": "NOT BETWEEN",
    "explanation": "NOT BETWEEN is the logical negation of the BETWEEN operator, selecting rows where the value falls outside the specified range (excluding endpoints).",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which clause is executed first in a typical SQL statement processing order?",
    "options": [
      "SELECT",
      "WHERE",
      "FROM",
      "ORDER BY"
    ],
    "answer": "FROM",
    "explanation": "Logically, the FROM clause is evaluated first to determine the source of data, followed by WHERE, GROUP BY, HAVING, SELECT, and finally ORDER BY.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which function calculates the average value of a numeric column?",
    "options": [
      "AVG()",
      "MEAN()",
      "MEDIAN()",
      "AVERAGE()"
    ],
    "answer": "AVG()",
    "explanation": "The AVG() function returns the average value of a numeric column. It calculates the sum of the values divided by the count of the values.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which set operation retains duplicate rows from the combined result sets of two queries?",
    "options": [
      "UNION",
      "UNION ALL",
      "INTERSECT",
      "EXCEPT"
    ],
    "answer": "UNION ALL",
    "explanation": "UNION ALL concatenates the result sets including duplicates. UNION, INTERSECT, and EXCEPT implicitly apply a distinct sort to remove duplicates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "When using the RANK() window function, how are ties handled compared to DENSE_RANK()?",
    "options": [
      "Both functions assign unique numbers to every row regardless of ties",
      "RANK() skips numbers after a tie, while DENSE_RANK() does not",
      "DENSE_RANK() skips numbers after a tie, while RANK() does not",
      "Both functions handle ties identically but differ in syntax"
    ],
    "answer": "RANK() skips numbers after a tie, while DENSE_RANK() does not",
    "explanation": "If two rows tie for rank 1, RANK() assigns the next row rank 3, creating a gap. DENSE_RANK() assigns the next row rank 2, continuing the sequence.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary effect of using the 'WITH ROLLUP' extension in a GROUP BY clause?",
    "options": [
      "It creates a pivot table output",
      "It generates subtotal and grand total rows based on the grouping hierarchy",
      "It filters out NULL values from the aggregate results",
      "It randomly samples the grouped data"
    ],
    "answer": "It generates subtotal and grand total rows based on the grouping hierarchy",
    "explanation": "ROLLUP generates hierarchical aggregates (subtotals) moving from right to left through the grouping columns, culminating in a grand total.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of NULL handling, why does the query 'SELECT * FROM A WHERE id NOT IN (SELECT id FROM B)' return zero rows if table B contains a NULL?",
    "options": [
      "The optimizer ignores NULLs in subqueries automatically",
      "NOT IN evaluates to UNKNOWN for any row compared to a NULL, causing the WHERE clause to filter them out",
      "NULL is treated as 0, causing a data type mismatch",
      "The subquery fails to execute due to the NULL presence"
    ],
    "answer": "NOT IN evaluates to UNKNOWN for any row compared to a NULL, causing the WHERE clause to filter them out",
    "explanation": "Three-valued logic dictates that any comparison involving NULL returns UNKNOWN (effectively false), negating the NOT IN condition for all rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which clause is used to filter the results of a GROUP BY query after the aggregation has taken place?",
    "options": [
      "WHERE",
      "HAVING",
      "ORDER BY",
      "FILTER"
    ],
    "answer": "HAVING",
    "explanation": "WHERE filters rows before aggregation; HAVING filters groups after aggregation. HAVING is required for conditions on aggregate results like SUM or COUNT.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What distinguishes a correlated subquery from a non-correlated subquery?",
    "options": [
      "A correlated subquery cannot contain aggregate functions",
      "A correlated subquery references columns from the outer query and executes once per row",
      "A correlated subquery always returns a list of values",
      "A non-correlated subquery is slower than a correlated one"
    ],
    "answer": "A correlated subquery references columns from the outer query and executes once per row",
    "explanation": "A correlated subquery depends on values from the outer query for its execution, resulting in row-by-row processing. Non-correlated subqueries execute independently once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the purpose of the PARTITION BY clause inside a window function definition?",
    "options": [
      "To physically divide the table into separate tables on disk",
      "To group the result set into partitions to which the window function is applied independently",
      "To filter out rows containing NULL values before calculation",
      "To create a secondary sort order within the window"
    ],
    "answer": "To group the result set into partitions to which the window function is applied independently",
    "explanation": "PARTITION BY resets the window function calculation for each group of rows, similar to how GROUP BY works for aggregates, but without collapsing the rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which statement accurately describes the default frame scope when an ORDER BY is specified but no frame clause is provided?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING",
      "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN CURRENT ROW AND CURRENT ROW"
    ],
    "answer": "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "The default frame when ORDER BY is used is from the start of the partition to the current row.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "In SQL indexing, what is the primary disadvantage of creating a composite index on columns (Col_A, Col_B) for queries filtering only on Col_B?",
    "options": [
      "The index becomes too large and slow to scan",
      "The index cannot be used efficiently because the leading column is not in the filter predicate",
      "The database will automatically drop the index",
      "Composite indexes do not support character data types"
    ],
    "answer": "The index cannot be used efficiently because the leading column is not in the filter predicate",
    "explanation": "B-Tree indexes typically require the leftmost (leading) column to be in the query predicate to perform a seek. Without Col_A, the index may require a full scan.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What happens if a foreign key constraint is defined with 'ON DELETE SET NULL' and the referenced parent row is deleted?",
    "options": [
      "The child row is deleted as well",
      "The child row's foreign key column is updated to NULL",
      "The deletion is blocked with an error",
      "The entire table is truncated"
    ],
    "answer": "The child row's foreign key column is updated to NULL",
    "explanation": "ON DELETE SET NULL ensures referential integrity by nullifying the relationship in the child table when the parent record is removed, rather than deleting the child record.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which join type returns all rows from the left table, and matching rows from the right table, filling non-matching rows with NULLs?",
    "options": [
      "INNER JOIN",
      "CROSS JOIN",
      "LEFT OUTER JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "LEFT OUTER JOIN",
    "explanation": "A LEFT OUTER JOIN prioritizes the left table, returning all its rows. If no match is found in the right table, the result set contains NULLs for the right table's columns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Why is the 'NOCOUNT' option often used in stored procedures to reduce network traffic?",
    "options": [
      "It stops the database from logging errors",
      "It suppresses the sending of 'X rows affected' messages for each statement",
      "It prevents the execution of SELECT statements",
      "It compresses the result set before sending it"
    ],
    "answer": "It suppresses the sending of 'X rows affected' messages for each statement",
    "explanation": "By default, the database sends a Done-in-proc message for each statement. NOCOUNT stops this, reducing the volume of data sent over the network.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the result of a CROSS JOIN between Table A (5 rows) and Table B (3 rows)?",
    "options": [
      "A Cartesian product containing 8 rows",
      "A Cartesian product containing 15 rows",
      "An Inner Join of matching rows",
      "An error due to ambiguous column names"
    ],
    "answer": "A Cartesian product containing 15 rows",
    "explanation": "A CROSS JOIN multiplies the rows of the first table by the rows of the second table. 5 rows * 3 rows = 15 rows total.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which function returns the last value in an ordered partition, handling NULLs in a specific manner?",
    "options": [
      "LAST_VALUE()",
      "MIN()",
      "RANK()",
      "LAG()"
    ],
    "answer": "LAST_VALUE()",
    "explanation": "LAST_VALUE() is a window function specifically designed to return the last value in the ordered result set partition. LAG() typically looks back a specific offset.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "When using the CASE expression, what occurs if none of the WHEN conditions evaluate to TRUE and no ELSE clause is specified?",
    "options": [
      "The query returns an error",
      "The result is NULL",
      "The result is 0",
      "The previous WHEN result is reused"
    ],
    "answer": "The result is NULL",
    "explanation": "If no ELSE clause is provided and all WHEN conditions are false, the CASE expression returns NULL by default.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the specific use case of the CUBE() extension in SQL grouping?",
    "options": [
      "To create a single grouping level",
      "To generate super-aggregate rows for all possible combinations of the specified columns",
      "To filter rows based on a hierarchy",
      "To pivot rows into columns"
    ],
    "answer": "To generate super-aggregate rows for all possible combinations of the specified columns",
    "explanation": "CUBE generates grouping sets for every permutation of the columns, providing subtotals for every dimension combination, unlike ROLLUP which follows a hierarchy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does the ROW_NUMBER() window function differ from RANK() when sorting by a unique key?",
    "options": [
      "ROW_NUMBER() is faster, but RANK() is more accurate",
      "They produce the same sequential numbers if there are no ties",
      "ROW_NUMBER() assigns the same number to ties, RANK() does not",
      "RANK() requires an OVER clause, but ROW_NUMBER() does not"
    ],
    "answer": "They produce the same sequential numbers if there are no ties",
    "explanation": "In the absence of ties, both functions assign a unique, sequential integer to each row based on the specified order.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which SQL construct allows you to define a named result set that can be referenced within a SELECT, INSERT, UPDATE, or DELETE statement?",
    "options": [
      "Temporary Table",
      "View",
      "Cursor",
      "Common Table Expression (CTE)"
    ],
    "answer": "Common Table Expression (CTE)",
    "explanation": "A CTE is a temporary result set defined within the execution scope of a single statement. Unlike temporary tables, they are not stored as objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the primary purpose of the COALESCE() function?",
    "options": [
      "To concatenate two strings together",
      "To return the first non-NULL expression in a list",
      "To convert a value to a specific data type",
      "To count the number of distinct values"
    ],
    "answer": "To return the first non-NULL expression in a list",
    "explanation": "COALESCE takes a list of arguments and returns the value of the first one that is not NULL. It is functionally equivalent to a simplified CASE expression.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "In a MERGE statement (or Upsert), what is the consequence of omitting the WHEN NOT MATCHED clause?",
    "options": [
      "The statement will fail if a source row does not match a target row",
      "The statement will insert duplicate rows automatically",
      "The source table will be truncated",
      "The match criteria will be ignored"
    ],
    "answer": "The statement will fail if a source row does not match a target row",
    "explanation": "Without a WHEN NOT MATCHED (or INSERT) clause, the operation only handles updates. If a source row has no corresponding target row and no insert logic is defined, the behavior depends on the DBMS, often causing a skip or error depending on strictness, but fundamentally it restricts the operation to updates only.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which of the following operations cannot be performed on a View defined with a GROUP BY clause?",
    "options": [
      "SELECT",
      "INSERT",
      "DELETE",
      "ORDER BY (in the view definition itself)"
    ],
    "answer": "INSERT",
    "explanation": "Views that use aggregation (GROUP BY), DISTINCT, or set operators are inherently not updatable because a single row in the view does not map 1:1 to a single row in the base table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the impact of using 'OFFSET 0 ROWS' (or equivalent) in a subquery used for paging or view definition?",
    "options": [
      "It optimizes the query by skipping zero rows",
      "It prevents the optimizer from flattening the subquery",
      "It forces an index scan",
      "It causes an infinite loop"
    ],
    "answer": "It prevents the optimizer from flattening the subquery",
    "explanation": "Using an OFFSET (or LIMIT/OFFSET) forces the database to materialize the subquery results first, blocking query optimization techniques like subquery flattening or predicate pushdown.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What does the acronym ACID stand for in the context of SQL transactions?",
    "options": [
      "Atomicity, Consistency, Isolation, Durability",
      "Automatic, Concurrency, Indexing, Distribution",
      "Atomicity, Concurrency, Integrity, Duplication",
      "Automatic, Consistency, Indexing, Durability"
    ],
    "answer": "Atomicity, Consistency, Isolation, Durability",
    "explanation": "ACID properties ensure that database transactions are processed reliably (Atomicity), maintain valid data states (Consistency), do not interfere (Isolation), and are permanent (Durability).",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When optimizing a query, which condition generally makes a predicate 'SARGable' (Search ARGument ABLE)?",
    "options": [
      "WHERE YEAR(order_date) = 2023",
      "WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'",
      "WHERE UPPER(last_name) = 'SMITH'",
      "WHERE SUBSTRING(phone, 1, 3) = '555'"
    ],
    "answer": "WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'",
    "explanation": "SARGable predicates allow the engine to use indexes efficiently. Applying functions to columns (like YEAR or UPPER) usually forces an index scan rather than a seek.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the difference between TRUNCATE and DELETE statements?",
    "options": [
      "DELETE can be rolled back, but TRUNCATE cannot",
      "TRUNCATE can be used on indexed views, but DELETE cannot",
      "DELETE removes the table structure, TRUNCATE does not",
      "TRUNCATE fires triggers, DELETE does not"
    ],
    "answer": "DELETE can be rolled back, but TRUNCATE cannot",
    "explanation": "TRUNCATE is a DDL operation that deallocates data pages and is minimally logged, making it non-transactional in many systems (and thus not roll-backable), whereas DELETE is DML and fully logged.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "In SQL window functions, what is the difference between ROWS and RANGE framing?",
    "options": [
      "ROWS limits by physical rows; RANGE limits by values in the ORDER BY column",
      "RANGE is for numbers only; ROWS is for dates",
      "ROWS is faster but less accurate; RANGE is slower but precise",
      "There is no difference; they are aliases"
    ],
    "answer": "ROWS limits by physical rows; RANGE limits by values in the ORDER BY column",
    "explanation": "ROWS operates on a fixed physical offset of rows. RANGE operates on the logical value of the ORDER BY column, treating peers (ties) as a single group.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which Normal Form addresses the issue of transitive dependencies, where non-prime attributes depend on other non-prime attributes?",
    "options": [
      "First Normal Form (1NF)",
      "Second Normal Form (2NF)",
      "Third Normal Form (3NF)",
      "Boyce-Codd Normal Form (BCNF)"
    ],
    "answer": "Third Normal Form (3NF)",
    "explanation": "3NF requires that a table be in 2NF and that no transitive dependencies exist (non-key columns must not depend on other non-key columns).",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the specific function of the NTILE(n) window function?",
    "options": [
      "To calculate the nth percentile of a dataset",
      "To divide rows into n approximately equal buckets and assign a bucket number to each row",
      "To filter the top n rows from a result set",
      "To multiply all values in a partition by n"
    ],
    "answer": "To divide rows into n approximately equal buckets and assign a bucket number to each row",
    "explanation": "NTILE distributes the rows into a specific number of groups (tiles), allowing for easy percentile-based analysis (e.g., quartiles with NTILE(4)).",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Why is it generally advised to avoid using 'SELECT *' in production code?",
    "options": [
      "It retrieves columns in alphabetical order",
      "It prevents the use of WHERE clauses",
      "It consumes unnecessary I/O and network bandwidth, and breaks if schema changes",
      "It causes deadlocks in the database"
    ],
    "answer": "It consumes unnecessary I/O and network bandwidth, and breaks if schema changes",
    "explanation": "SELECT * retrieves all columns, potentially reading unneeded data from disk and sending it over the network. It also introduces fragility if application code relies on column order.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What does the 'INTERSECT' set operator return?",
    "options": [
      "Rows unique to the first query",
      "Rows unique to the second query",
      "Rows that are returned by both queries",
      "All rows from both queries, including duplicates"
    ],
    "answer": "Rows that are returned by both queries",
    "explanation": "INTERSECT returns the set of rows that are present in the result sets of both the left and right queries, effectively the intersection of the two sets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is a 'covering index'?",
    "options": [
      "An index that includes all columns of the table",
      "An index containing all columns required by a specific query (SELECT, JOIN, WHERE) in its leaf nodes",
      "An index used to cover up deleted data",
      "A type of bitmap index"
    ],
    "answer": "An index containing all columns required by a specific query (SELECT, JOIN, WHERE) in its leaf nodes",
    "explanation": "A covering index satisfies all fields in a query, allowing the database to retrieve results solely from the index structure without performing a lookup on the main table (Key Lookup).",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which function is used to calculate the percentage of the total sum for a specific row within a partition?",
    "options": [
      "RATIO_TO_REPORT() or SUM() OVER() / SUM() OVER()",
      "PERCENT_RANK()",
      "CUME_DIST()",
      "AVG() OVER()"
    ],
    "answer": "RATIO_TO_REPORT() or SUM() OVER() / SUM() OVER()",
    "explanation": "Calculating a percent-to-total usually involves dividing the specific value by the total value of the partition. While some dialects have RATIO_TO_REPORT, the standard approach is comparing window sums.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What does the 'NULLIF' function do?",
    "options": [
      "Returns NULL if both arguments are equal",
      "Converts a value to NULL if it matches a specific condition",
      "Checks if a value is NULL and returns a default",
      "Replaces NULL with a specified value"
    ],
    "answer": "Returns NULL if both arguments are equal",
    "explanation": "NULLIF(expr1, expr2) returns NULL if expr1 equals expr2; otherwise, it returns expr1. It is often used to prevent 'divide by zero' errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which of the following describes a 'Natural Join'?",
    "options": [
      "A join where you must explicitly define all join conditions",
      "A join that automatically combines tables based on columns with the same name and data type",
      "A join that returns only distinct rows",
      "A join that functions identically to a CROSS JOIN"
    ],
    "answer": "A join that automatically combines tables based on columns with the same name and data type",
    "explanation": "NATURAL JOIN implicitly joins tables on all columns with identical names in both tables, removing the need for an ON clause but carrying risks if schemas change.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In a recursive Common Table Expression (CTE), what constitutes the 'termination member' or 'anchor member'?",
    "options": [
      "The part of the query that deletes the data",
      "The initial SELECT statement that returns the base rows for the recursion",
      "The UNION ALL operator",
      "The recursive reference to the CTE itself"
    ],
    "answer": "The initial SELECT statement that returns the base rows for the recursion",
    "explanation": "The anchor member runs first and provides the initial result set. The recursive member builds upon this result, and recursion stops when the recursive member returns no rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of SQL window functions, what is the default window frame if an `ORDER BY` clause is specified but no explicit frame clause (`ROWS BETWEEN`, `RANGE BETWEEN`) is provided?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING",
      "GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"
    ],
    "answer": "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "When `ORDER BY` is used without a frame clause, the default scope is from the start of the partition to the current row. The default frame unit is `RANGE`, which includes all peers of the current row.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is a 'Covering Index', and how does it improve query performance?",
    "options": [
      "An index that includes all columns of the table to force a table scan",
      "An index containing all columns retrieved by a query (SELECT, JOIN, WHERE) allowing the index to satisfy the query without accessing the table data",
      "A bitmap index used specifically for data warehousing columnar storage",
      "An index created on a view to materialize the result set physically"
    ],
    "answer": "An index containing all columns retrieved by a query (SELECT, JOIN, WHERE) allowing the index to satisfy the query without accessing the table data",
    "explanation": "A covering index allows the database engine to retrieve all required data directly from the index structure. This eliminates the 'Key Lookup' or 'Bookmark Lookup' step required to fetch non-indexed columns from the heap or clustered index.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which of the following SQL operations is inherently non-deterministic and thus cannot be used as the basis for a windowed aggregate function without an `ORDER BY` within the `OVER` clause?",
    "options": [
      "SUM() OVER (PARTITION BY category)",
      "RANK() OVER (PARTITION BY category)",
      "ROW_NUMBER() OVER (PARTITION BY category)",
      "COUNT(*) OVER (PARTITION BY category)"
    ],
    "answer": "ROW_NUMBER() OVER (PARTITION BY category)",
    "explanation": "While other aggregates like SUM or COUNT result in a single value per partition, `ROW_NUMBER` assigns a unique integer to rows. Without an `ORDER BY` clause to define the sequence, the assignment of row numbers is arbitrary and non-deterministic.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the primary difference between `RANGE` and `ROWS` window frame bounds in SQL window functions?",
    "options": [
      "`ROWS` operates on the physical order of rows, while `RANGE` operates on the logical value of the ordering expression, including peer ties",
      "`RANGE` is strictly for numeric data types, whereas `ROWS` can be used for dates and strings",
      "`ROWS` allows aggregation over the entire partition, while `RANGE` is restricted to the current row",
      "There is no difference; they are interchangeable aliases in ANSI SQL"
    ],
    "answer": "`ROWS` operates on the physical order of rows, while `RANGE` operates on the logical value of the ordering expression, including peer ties",
    "explanation": "`ROWS` limits the frame based on a fixed offset from the current row (physical position). `RANGE` limits the frame based on the value of the ordering column, meaning that rows with the same value (peers) are treated as a single unit.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In the context of query optimization, what does the 'SARGable' acronym refer to?",
    "options": [
      "Search ArgumentABLE: predicates that can utilize an index seek",
      "Sort ArgumentABLE: clauses that allow in-memory sorting",
      "Scalable Relational Graph: a structure used by the query optimizer",
      "Static Argument Generation: a method for parameter sniffing"
    ],
    "answer": "Search ArgumentABLE: predicates that can utilize an index seek",
    "explanation": "SARGable refers to a predicate in a `WHERE` clause that allows the database engine to efficiently utilize an index to find rows (Index Seek), rather than scanning the entire index or table.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Consider a composite index on columns `(A, B, C)`. Which of the following queries will be able to perform an Index Seek operation effectively?",
    "options": [
      "SELECT * FROM table WHERE B = 1 AND C = 2",
      "SELECT * FROM table WHERE C = 1 AND A = 2",
      "SELECT * FROM table WHERE A = 1 AND C = 1",
      "SELECT * FROM table WHERE A = 1 AND B = 2"
    ],
    "answer": "SELECT * FROM table WHERE A = 1 AND B = 2",
    "explanation": "B-Tree indexes follow the left-to-right column order. An index seek can only be performed if the leading column (A) is constrained, and subsequent columns (B, C) must be constrained in order without gaps for a full seek.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the function of the 'Lateral Join' (or `APPLY` in T-SQL) when used with a table-valued function?",
    "options": [
      "It allows the right side of the join to reference columns from the left side for each row processed",
      "It forces a Cartesian product regardless of join conditions",
      "It enables a many-to-many relationship between two tables",
      "It prevents the optimizer from using a hash join strategy"
    ],
    "answer": "It allows the right side of the join to reference columns from the left side for each row processed",
    "explanation": "Unlike a standard subquery, a lateral correlation allows the subquery or function on the right side to access values from the current row of the table on the left, acting as a row-by-row loop.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In a Recursive Common Table Expression (CTE), what are the two required members?",
    "options": [
      "The anchor member and the recursive member",
      "The primary key and the foreign key",
      "The grouping set and the aggregate function",
      "The header definition and the trailer definition"
    ],
    "answer": "The anchor member and the recursive member",
    "explanation": "The anchor member returns the initial result set. The recursive member references the CTE itself and is executed repeatedly until it returns an empty result set, stopping the recursion.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the distinction between the `UNION` and `UNION ALL` set operators?",
    "options": [
      "`UNION ALL` sorts the result set before returning data, while `UNION` does not",
      "`UNION` removes duplicate rows and incurs a performance penalty for sorting/hashing, whereas `UNION ALL` returns all rows including duplicates",
      "`UNION` combines columns from different tables, while `UNION ALL` combines rows",
      "`UNION ALL` requires compatible data types, while `UNION` performs implicit conversion"
    ],
    "answer": "`UNION` removes duplicate rows and incurs a performance penalty for sorting/hashing, whereas `UNION ALL` returns all rows including duplicates",
    "explanation": "`UNION` performs a distinct operation to eliminate duplicates, which requires extra processing (sorting or hashing). `UNION ALL` simply concatenates the result sets, making it significantly faster when duplicates are not a concern.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "How does the `CUBE` grouping operation differ from `ROLLUP` regarding subtotals generated?",
    "options": [
      "`ROLLUP` generates subtotals for all combinations of dimensions, while `CUBE` only generates hierarchies",
      "`CUBE` generates subtotals for every possible combination of the grouping columns, while `ROLLUP` assumes a hierarchy",
      "`CUBE` is an aggregate function, while `ROLLUP` is a window function",
      "`ROLLUP` is used for spatial data, while `CUBE` is used for temporal data"
    ],
    "answer": "`CUBE` generates subtotals for every possible combination of the grouping columns, while `ROLLUP` assumes a hierarchy",
    "explanation": "`ROLLUP` creates hierarchical subtotals (e.g., Grand Total -> Country -> City). `CUBE` creates subtotals for all permutations (e.g., Grand Total, Total per Country, Total per City, Total per Country-City pair).",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What constitutes a 'Phantom Read' anomaly in database transaction isolation?",
    "options": [
      "Data is modified by a transaction after it has been read by another transaction",
      "A transaction reads data that has been modified but not committed by another transaction",
      "A new row is added (or deleted) by a transaction, affecting the result set of a previously executed query in another transaction",
      "The database server restarts unexpectedly, causing uncommitted data to appear"
    ],
    "answer": "A new row is added (or deleted) by a transaction, affecting the result set of a previously executed query in another transaction",
    "explanation": "A Phantom Read occurs when a transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows has changed due to another recently-committed transaction.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "When optimizing a query, what does the 'Hash Join' algorithm typically require that the 'Nested Loop' join does not?",
    "options": [
      "A sorted input on both the build and probe inputs",
      "Sufficient memory to build a hash table in memory for the smaller input",
      "Unique constraints on the joining columns",
      "An equijoin predicate (equality operator)"
    ],
    "answer": "Sufficient memory to build a hash table in memory for the smaller input",
    "explanation": "Hash joins build an in-memory hash table on the smaller dataset (build input) and probe it with the larger dataset. If memory is insufficient, the operation spills to disk (graceful hash join), significantly degrading performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the 'Optimization Fence' behavior associated with Common Table Expressions (CTEs) in some relational database systems (like PostgreSQL prior to v12)?",
    "options": [
      "The CTE is materialized immediately, preventing the optimizer from pushing predicates down into the CTE definition",
      "The CTE prevents the query from using parallelism",
      "The CTE forces the use of a specific index regardless of statistics",
      "The CTE limits the number of rows returned to 1000 by default"
    ],
    "answer": "The CTE is materialized immediately, preventing the optimizer from pushing predicates down into the CTE definition",
    "explanation": "Historically, CTEs acted as optimization fences where the CTE query was executed and materialized fully before the outer query ran. This prevented predicate pushdown and join reordering, potentially harming performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In the context of SQL constraints, what is the difference between `ON DELETE RESTRICT` and `ON DELETE NO ACTION`?",
    "options": [
      "`RESTRICT` allows the delete if there are no dependent child records, while `NO ACTION` checks the constraint immediately at statement start",
      "They are practically identical in preventing deletion, but `NO ACTION` can be deferred to the end of the transaction",
      "`RESTRICT` cascades the delete to child tables, while `NO ACTION` sets foreign keys to NULL",
      "`RESTRICT` is enforced at the row level, while `NO ACTION` is enforced at the table level"
    ],
    "answer": "They are practically identical in preventing deletion, but `NO ACTION` can be deferred to the end of the transaction",
    "explanation": "Both prevent the deletion of a referenced row. However, `NO ACTION` is deferrable (check can be delayed until transaction commit), whereas `RESTRICT` is immediate and non-deferrable in many implementations.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which index type is specifically designed to support queries involving the containment operators (e.g., `@>`, `<@`) on JSONB data in PostgreSQL?",
    "options": [
      "B-Tree Index",
      "GIN (Generalized Inverted Index)",
      "Hash Index",
      "GiST (Generalized Search Tree)"
    ],
    "answer": "GIN (Generalized Inverted Index)",
    "explanation": "GIN indexes are designed for cases where each index entry contains multiple values, such as arrays or JSONB documents. They are required for efficient containment checks on JSONB data.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the purpose of the `STRAIGHT_JOIN` hint in MySQL?",
    "options": [
      "To force the server to use the Nested Loop algorithm",
      "To force the table order in the join execution to match the order written in the SQL query",
      "To convert a LEFT JOIN into an INNER JOIN",
      "To bypass the query cache"
    ],
    "answer": "To force the table order in the join execution to match the order written in the SQL query",
    "explanation": "When the optimizer chooses a suboptimal join order, `STRAIGHT_JOIN` forces the tables to be joined in the exact order they appear in the `FROM` clause (left to right), overriding the optimizer's cost-based decision.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is a 'Write Skew' anomaly, and under which isolation level is it possible but often prevented by other means?",
    "options": [
      "It occurs when two concurrent updates overwrite each other in Read Committed",
      "It involves two transactions that read overlapping data sets and then diverge, causing an inconsistency, possible in Snapshot Isolation but not in Serializable",
      "It is a locking deadlock scenario specific to Repeatable Read",
      "It is data corruption caused by writing to a read-only replica"
    ],
    "answer": "It involves two transactions that read overlapping data sets and then diverge, causing an inconsistency, possible in Snapshot Isolation but not in Serializable",
    "explanation": "Write skew happens when two transactions read the same consistent snapshot but make disjoint modifications that, when combined, violate a constraint. Snapshot Isolation allows this; Serializable Isolation detects and prevents it.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What determines the 'Cardinality' of a column in the context of SQL query optimization?",
    "options": [
      "The data type of the column (e.g., INT vs VARCHAR)",
      "The percentage of unique values in the column relative to total rows",
      "The number of indexes referencing the column",
      "The physical storage size of the column on disk"
    ],
    "answer": "The percentage of unique values in the column relative to total rows",
    "explanation": "Cardinality estimates the number of distinct values in a column. High cardinality (many unique values) helps the optimizer estimate selectivity and determine whether an index scan is more efficient than a full table scan.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How does a 'Partial Index' (or Filtered Index) improve performance and storage efficiency?",
    "options": [
      "It stores only the first N bytes of a text column to reduce index size",
      "It includes only the rows that satisfy a specific WHERE clause, reducing index size and maintenance cost",
      "It partitions the index across multiple physical disks",
      "It indexes only the primary key columns of a table"
    ],
    "answer": "It includes only the rows that satisfy a specific WHERE clause, reducing index size and maintenance cost",
    "explanation": "By indexing a subset of rows (e.g., `WHERE status = 'active'`), the index is smaller and faster to scan. It also reduces the overhead of index maintenance for rows that do not match the filter.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the specific technical requirement for the `SELECT` list in a standard SQL Group By query (excluding aggregated expressions)?",
    "options": [
      "All columns must be part of the primary key",
      "Every column in the SELECT list must either appear in the GROUP BY clause or be wrapped in an aggregate function",
      "The SELECT list can contain any columns regardless of the GROUP BY clause",
      "Only one non-aggregated column is allowed in the SELECT list"
    ],
    "answer": "Every column in the SELECT list must either appear in the GROUP BY clause or be wrapped in an aggregate function",
    "explanation": "Standard SQL requires functional dependency: if a column is listed, the database must know which single group value it belongs to. It must either group by that column or aggregate it.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In SQL Server, what is the 'Key Lookup' operation found in execution plans?",
    "options": [
      "A seek operation on a clustered index",
      "A retrieval of non-key columns from the heap or clustered index that were not present in a non-clustered index",
      "A join operation used to resolve foreign key constraints",
      "A mechanism to find the correct partition in a partitioned table"
    ],
    "answer": "A retrieval of non-key columns from the heap or clustered index that were not present in a non-clustered index",
    "explanation": "When a non-clustered index covers the search criteria but not the selected columns, the engine must perform a Key Lookup ( RID or Cl Key) to fetch the remaining data from the base table.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the main advantage of using a 'Clustered Columnstore Index' over a traditional B-Tree Rowstore index?",
    "options": [
      "It provides faster retrieval of single rows by primary key",
      "It uses column-based compression for high compression ratios and performance in analytical queries (scanning aggregates)",
      "It automatically updates statistics in real-time",
      "It eliminates the need for foreign keys"
    ],
    "answer": "It uses column-based compression for high compression ratios and performance in analytical queries (scanning aggregates)",
    "explanation": "Columnstore indexes store data vertically rather than horizontally. This enables high compression and efficient batch processing for OLAP workloads involving large scans and aggregations.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "Which of the following best describes the 'N+1 Select Problem'?",
    "options": [
      "Executing one large query instead of N smaller queries to reduce network latency",
      "Executing N additional queries for every row returned by an initial query, often due to lazy loading in an ORM",
      "A recursive query that references itself N times",
      "Using `SELECT *` when only N columns are needed"
    ],
    "answer": "Executing N additional queries for every row returned by an initial query, often due to lazy loading in an ORM",
    "explanation": "The N+1 problem describes the performance anti-pattern where 1 query retrieves a list of records (e.g., authors), and then N subsequent queries retrieve related data (e.g., books) for each record individually.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What does the `FILLFACTOR` option determine when creating or rebuilding an index?",
    "options": [
      "The percentage of disk space to leave free on the storage volume",
      "The percentage of space on each leaf-level page to leave empty for future growth, reducing page splits",
      "The number of columns included in the composite index",
      "The ratio of read operations to write operations expected on the index"
    ],
    "answer": "The percentage of space on each leaf-level page to leave empty for future growth, reducing page splits",
    "explanation": "A `FILLFACTOR` of 80 means 20% of the page is left empty. This space allows new rows to be inserted or existing variable-length rows to expand without immediate expensive page splits.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "Why are 'Correlated Subqueries' generally considered less performant than equivalent Joins?",
    "options": [
      "They cannot use the GROUP BY clause",
      "They are re-executed for every row processed by the outer query, often resulting in a large number of executions",
      "They do not support the use of indexes",
      "They return data in a non-deterministic order"
    ],
    "answer": "They are re-executed for every row processed by the outer query, often resulting in a large number of executions",
    "explanation": "A correlated subquery references a column from the outer query, forcing the database to evaluate the inner query once for each candidate row in the outer query, whereas joins typically process data in sets.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the specific behavior of the `MERGE` statement (or `UPSERT`) when a row is found to match both the insert condition and the update condition simultaneously?",
    "options": [
      "It performs the INSERT and ignores the UPDATE",
      "It performs both the UPDATE and the INSERT",
      "It raises an error if the matching logic is ambiguous and not mutually exclusive",
      "It defaults to a DELETE followed by an INSERT"
    ],
    "answer": "It raises an error if the matching logic is ambiguous and not mutually exclusive",
    "explanation": "Standard SQL requires that a row cannot match the `WHEN MATCHED` clause and the `WHEN NOT MATCHED` clause simultaneously. If logic allows overlap, the engine raises an error (e.g., 'cannot update the same row twice').",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What does the 'Halloween Problem' refer to in SQL database updates?",
    "options": [
      "A deadlock occurring specifically on October 31st due to increased transaction volume",
      "An issue where an update moves a row to a new position that is subsequently scanned again by the same update cursor",
      "A buffer overflow error caused by recursive triggers",
      "The failure of scheduled jobs on a specific date"
    ],
    "answer": "An issue where an update moves a row to a new position that is subsequently scanned again by the same update cursor",
    "explanation": "If an UPDATE moves a row forward in the scan order (e.g., changing an indexed value), the cursor might encounter the row again and update it multiple times. Databases use internal spooling or versioning to prevent this.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of database normalization, what functional dependency defines 'Second Normal Form' (2NF)?",
    "options": [
      "Every non-prime attribute must be non-transitively dependent on the candidate key",
      "Every non-prime attribute must be fully functionally dependent on the entire primary key (no partial dependency)",
      "All attributes must contain only atomic (indivisible) values",
      "There must be no multi-valued dependencies"
    ],
    "answer": "Every non-prime attribute must be fully functionally dependent on the entire primary key (no partial dependency)",
    "explanation": "2NF addresses partial dependencies in tables with composite keys. It requires that attributes depend on the whole key, not just a part of it. (1NF requires atomicity; 3NF requires no transitive dependencies).",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the purpose of the `INCLUDE` clause when creating a non-clustered index in SQL Server?",
    "options": [
      "To include columns from other tables in the join",
      "To add non-key columns to the index leaf level to create a covering index without affecting the index key size or sort order",
      "To enforce a foreign key constraint on the indexed column",
      "To include filtered rows that would otherwise be excluded by the WHERE clause"
    ],
    "answer": "To add non-key columns to the index leaf level to create a covering index without affecting the index key size or sort order",
    "explanation": "`INCLUDE` columns are stored only at the leaf level. They allow queries to be covered (retrieved from index) without widening the internal b-tree structure with non-searchable columns.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What happens if a `CHECK` constraint is marked `NO VALID` (or `WITH NOCHECK` in SQL Server) when added to an existing table?",
    "options": [
      "The constraint is created but ignored for all future INSERT operations",
      "The constraint is created, but existing data is not validated; only future modifications are enforced",
      "The constraint is evaluated asynchronously in the background",
      "The constraint is disabled automatically if the table grows beyond 1000 rows"
    ],
    "answer": "The constraint is created, but existing data is not validated; only future modifications are enforced",
    "explanation": "Adding a constraint `WITH NOCHECK` allows the constraint to be created instantly without scanning the table to validate existing rows, effectively trusting that legacy data complies.",
    "difficulty": "Advanced"
  }
]