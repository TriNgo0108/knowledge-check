[
  {
    "id": 1,
    "question": "What is the primary function of the `key` prop in React lists?",
    "options": [
      "To automatically sort the list items alphabetically",
      "To help React identify which items have changed, been added, or been removed",
      "To secure the list items from unauthorized access",
      "To apply default CSS styles to the list container"
    ],
    "answer": "To help React identify which items have changed, been added, or been removed",
    "explanation": "React uses keys to match elements in the original tree with elements in the subsequent tree during reconciliation. Stable IDs allow React to mutate, move, or reuse existing DOM nodes rather than destroying and recreating them.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which syntax is used in JSX to embed a JavaScript expression?",
    "options": [
      "Double curly braces {{ }}",
      "Single curly braces { }",
      "Dollar sign and parentheses $()",
      "Backtick strings ` `"
    ],
    "answer": "Single curly braces { }",
    "explanation": "JSX allows you to embed any JavaScript expression by wrapping it in curly braces. This is distinct from HTML attributes or string literals.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What happens when you call `setState` in a React component?",
    "options": [
      "The DOM is updated immediately and synchronously",
      "The component function re-runs immediately",
      "React enqueues a re-render of the component",
      "The state variable is mutated directly in place"
    ],
    "answer": "React enqueues a re-render of the component",
    "explanation": "State updates are asynchronous and batched. React schedules an update to the component, leading to a re-render where the new state is reflected.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which hook is primarily used to perform side effects in functional components?",
    "options": [
      "useState",
      "useContext",
      "useEffect",
      "useReducer"
    ],
    "answer": "useEffect",
    "explanation": "useEffect is designed to handle side effects like data fetching, subscriptions, or DOM manipulation that occur after the render is committed to the screen.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In React, what distinguishes 'controlled components' from 'uncontrolled components'?",
    "options": [
      "Controlled components are managed by class components only",
      "Controlled components receive their current value and update callbacks via props",
      "Uncontrolled components cannot be validated",
      "Controlled components do not re-render when input changes"
    ],
    "answer": "Controlled components receive their current value and update callbacks via props",
    "explanation": "A controlled component's form data is handled by a React component state, while an uncontrolled component stores its own state internally and is queried using a ref.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Why must React components be pure functions regarding their props?",
    "options": [
      "To ensure the component can be garbage collected",
      "To allow React to optimize rendering by skipping components with unchanged props",
      "To prevent the use of state inside the component",
      "To ensure the component returns valid HTML"
    ],
    "answer": "To allow React to optimize rendering by skipping components with unchanged props",
    "explanation": "If a component's output is predictable based on its inputs (props), React can optimize performance by skipping rendering if the props haven't changed.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does the `useState` hook return?",
    "options": [
      "The current state value and a history of previous states",
      "The current state value and a function to update it",
      "The initial state value and a unique ID for the state",
      "A boolean indicating if the state is dirty and a reset function"
    ],
    "answer": "The current state value and a function to update it",
    "explanation": "useState returns an array where the first element is the current state value and the second element is a dispatch function (setter) to update that value.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which HTML attribute is used in JSX to specify a CSS class instead of the standard `class` attribute?",
    "options": [
      "style",
      "cssClass",
      "className",
      "classList"
    ],
    "answer": "className",
    "explanation": "`class` is a reserved keyword in JavaScript. JSX uses `className` to map to the HTML class attribute.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the purpose of the dependency array passed as the second argument to `useEffect`?",
    "options": [
      "To specify which DOM elements to target",
      "To define variables that, if changed, trigger the effect to run again",
      "To declare the variables the effect will mutate",
      "To limit the memory usage of the component"
    ],
    "answer": "To define variables that, if changed, trigger the effect to run again",
    "explanation": "The effect runs after every render if the array is omitted. If the array is provided, the effect only runs if one of the values in the array has changed since the previous render.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the 'Virtual DOM'?",
    "options": [
      "A direct copy of the Real DOM stored on the server",
      "A browser feature that speeds up JavaScript execution",
      "A lightweight JavaScript representation of the Real DOM",
      "A replacement for HTML in modern web applications"
    ],
    "answer": "A lightweight JavaScript representation of the Real DOM",
    "explanation": "React creates an in-memory cache of the DOM structure and computes the differences between it and the actual DOM to minimize the number of expensive DOM operations.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "How do you handle conditional rendering in JSX?",
    "options": [
      "Using the `if` statement directly inside the JSX curly braces",
      "Using the `#if` directive similar to Pug",
      "Using ternary operators or logical AND (&&) inside curly braces",
      "Using the `visible` attribute on HTML elements"
    ],
    "answer": "Using ternary operators or logical AND (&&) inside curly braces",
    "explanation": "JSX does not have special syntax for conditionals. You use JavaScript logic like `{condition ? <A /> : <B />}` or `{condition && <A />}` embedded in the markup.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the term for the process React uses to determine which parts of the UI need to be updated?",
    "options": [
      "Rendering",
      "Reconciliation",
      "Hoisting",
      "Bubbling"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation is the algorithm React uses to diff the new Virtual DOM tree against the old one to determine the minimal set of changes required for the Real DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which method allows a functional component to access the context value created by a Provider?",
    "options": [
      "useContext",
      "useReducer",
      "useContextAPI",
      "getContext"
    ],
    "answer": "useContext",
    "explanation": "The useContext hook accepts a context object and returns the current context value for that context, allowing you to consume context without a wrapper component.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the default behavior of React when rendering a list without a `key` prop?",
    "options": [
      "It throws a compile-time error preventing the build",
      "It refuses to render the list items",
      "It uses the index of the item as a fallback key",
      "It automatically assigns a unique ID based on the item's content"
    ],
    "answer": "It uses the index of the item as a fallback key",
    "explanation": "If no key is provided, React defaults to using indices as keys. This is discouraged for lists that can be reordered, as it can negatively impact performance and cause state issues.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What happens if you modify state directly in a functional component (e.g., `state.count = 5`)?",
    "options": [
      "The UI updates immediately",
      "React triggers an infinite loop",
      "The component will not re-render to reflect the change",
      "The state is reset to the initial value on the next render"
    ],
    "answer": "The component will not re-render to reflect the change",
    "explanation": "Directly mutating state bypasses React's rendering mechanisms. You must use the setter function provided by hooks so React can schedule updates and re-render the component.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which hook is used to persist values across renders without causing a re-render when updated?",
    "options": [
      "useState",
      "useEffect",
      "useRef",
      "useMemo"
    ],
    "answer": "useRef",
    "explanation": "useRef returns a mutable object that persists for the full lifetime of the component. Changing the `.current` property does not trigger a re-render.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "In JSX, how do you write an inline style object?",
    "options": [
      "style='color: red;'",
      "style={color: 'red'}",
      "style={{ color: 'red' }}",
      "style='color: red'"
    ],
    "answer": "style={{ color: 'red' }}",
    "explanation": "The `style` attribute accepts a JavaScript object, not a string. Property names must be camelCase (e.g., `backgroundColor`), and the outer braces signify a JS expression, while the inner braces signify the object.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is 'Lifting State Up' in React?",
    "options": [
      "Moving state to a higher global variable",
      "Merging the state of two components into one",
      "Moving state to the closest common ancestor of components that need it",
      "Deleting state from child components to improve memory"
    ],
    "answer": "Moving state to the closest common ancestor of components that need it",
    "explanation": "When multiple components need to share the same changing data, it is recommended to lift the shared state up to their closest common ancestor and pass it down via props.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is a 'Fragment' in React?",
    "options": [
      "A broken component that needs debugging",
      "A way to return multiple elements without adding extra nodes to the DOM",
      "A lifecycle method used for cleanup",
      "A utility to break large components into smaller files"
    ],
    "answer": "A way to return multiple elements without adding extra nodes to the DOM",
    "explanation": "Fragments (`<>...</>` or `<React.Fragment>`) let you group a list of children without adding extra wrapping divs to the DOM, keeping the DOM tree flat.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which of the following events uses camelCase naming in React?",
    "options": [
      "onclick",
      "on_click",
      "onClick",
      "ONCLICK"
    ],
    "answer": "onClick",
    "explanation": "React events are named using camelCase rather than lowercase. This is standard for JSX props to differentiate them from HTML attributes.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the result of passing an empty dependency array `[]` to `useEffect`?",
    "options": [
      "The effect runs after every single render",
      "The effect runs only once when the component mounts",
      "The effect does not run at all",
      "The effect runs only when the component unmounts"
    ],
    "answer": "The effect runs only once when the component mounts",
    "explanation": "With an empty dependency array, React checks the list and sees nothing has changed from the previous render (or it's the first render), so it executes the effect only on mount.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What does `React.StrictMode` do?",
    "options": [
      "Enforces strict TypeScript typing in components",
      "Performs additional checks and warnings only in development mode",
      "Prevents the production build if code quality issues are found",
      "Automatically fixes bugs in the component logic"
    ],
    "answer": "Performs additional checks and warnings only in development mode",
    "explanation": "StrictMode is a development tool that highlights potential problems in an application by activating additional checks and warnings, but it does not render any visible UI in production.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which hook is best suited for managing complex state logic involving multiple sub-values or derived state?",
    "options": [
      "useState",
      "useReducer",
      "useEffect",
      "useLayoutEffect"
    ],
    "answer": "useReducer",
    "explanation": "useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "How do you pass data from a child component back to a parent component?",
    "options": [
      "By directly modifying the parent's state",
      "By passing a function as a prop from the parent and calling it in the child",
      "By using a global variable",
      "By using the `export` keyword"
    ],
    "answer": "By passing a function as a prop from the parent and calling it in the child",
    "explanation": "Data flows down via props, but communication up is achieved by passing a callback function (defined in the parent) down to the child, which the child invokes.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the `children` prop in React?",
    "options": [
      "A prop that contains the number of child components",
      "A special prop that allows components to be passed as data to other components",
      "A prop used to style child elements",
      "A reference to the DOM element's children"
    ],
    "answer": "A special prop that allows components to be passed as data to other components",
    "explanation": "`children` represents the content between the opening and closing tags of a component. It enables component composition by allowing arbitrary JSX to be nested inside.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the purpose of `React.memo`?",
    "options": [
      "To memoize complex calculations within a component",
      "To prevent a component from re-rendering if its props have not changed",
      "To cache network requests automatically",
      "To optimize the bundle size of the application"
    ],
    "answer": "To prevent a component from re-rendering if its props have not changed",
    "explanation": "React.memo is a higher-order component that performs a shallow comparison of props; if props haven't changed, React skips rendering the component and reuses the last rendered result.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is 'prop drilling'?",
    "options": [
      "The process of validating prop data types",
      "Passing data through multiple layers of components to reach a deeply nested child",
      "Extracting props from an object",
      "Deleting unused props to improve performance"
    ],
    "answer": "Passing data through multiple layers of components to reach a deeply nested child",
    "explanation": "Prop drilling refers to passing data through intermediate components that don't need the data themselves, just to get it to a child component further down the tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "When does the `cleanup` function returned by `useEffect` run?",
    "options": [
      "Only when the component is deleted from the code",
      "Before the component re-renders and when the component unmounts",
      "Immediately after the effect runs",
      "Before the component mounts for the first time"
    ],
    "answer": "Before the component re-renders and when the component unmounts",
    "explanation": "Cleanup functions run to reset previous effects before the next effect runs (or before the component unmounts), preventing memory leaks and stale data.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the correct way to handle the `value` attribute of an input element in a controlled component?",
    "options": [
      "Set it directly via the DOM",
      "Set it to a state variable",
      "Leave it undefined to let the browser handle it",
      "Set it to a static string"
    ],
    "answer": "Set it to a state variable",
    "explanation": "In a controlled component, the input's value is driven by React state. You set the `value` prop to the state variable and update that state via an `onChange` handler.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the ` htmlFor` attribute used for in JSX?",
    "options": [
      "To specify a loop for list items",
      "To link a label to an input element (replaces standard HTML `for`)",
      "To add inline styles",
      "To define a unique ID for the component"
    ],
    "answer": "To link a label to an input element (replaces standard HTML `for`)",
    "explanation": "Because `for` is a reserved keyword in JavaScript, React uses `htmlFor` as the attribute name for the HTML `for` attribute, commonly used to associate labels with form inputs.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Why is it important to include a `key` prop when rendering lists of dynamic data?",
    "options": [
      "It enables CSS animations to work correctly",
      "It preserves the component state and DOM nodes correctly during updates",
      "It prevents the list from exceeding a maximum length",
      "It is required for TypeScript compilation"
    ],
    "answer": "It preserves the component state and DOM nodes correctly during updates",
    "explanation": "Keys help React identify which items correspond to which items in the previous render, ensuring that existing DOM nodes are reused and that component state (like user input) is preserved for the correct item.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which function is used to render a React application into a specific DOM element?",
    "options": [
      "ReactDOM.render()",
      "ReactDOM.createRoot().render()",
      "React.mount()",
      "React.init()"
    ],
    "answer": "ReactDOM.createRoot().render()",
    "explanation": "In React 18+, `createRoot` is the new API for creating a root, replacing the legacy `ReactDOM.render` method. It enables concurrent rendering features.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What are Synthetic Events in React?",
    "options": [
      "Events created artificially for testing purposes",
      "Cross-browser wrappers around the browser's native events",
      "Events that occur only in the Virtual DOM",
      "Macros that generate event listeners automatically"
    ],
    "answer": "Cross-browser wrappers around the browser's native events",
    "explanation": "SyntheticEvents provide a consistent API across different browsers by wrapping the browser's native event objects, normalizing properties like `stopPropagation`.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What does `useCallback` do?",
    "options": [
      "It fetches data asynchronously",
      "It returns a memoized callback function that only changes if dependencies change",
      "It caches the result of a function",
      "It handles errors in components"
    ],
    "answer": "It returns a memoized callback function that only changes if dependencies change",
    "explanation": "useCallback memoizes a function instance, preventing it from being recreated on every render unless its dependencies have changed, which is useful for passing callbacks to optimized child components.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the fundamental principle of one-way data flow in React?",
    "options": [
      "Data can only flow from parent to child components via props",
      "Data flows from child to parent components only",
      "Data flows bi-directionally between all components",
      "Data is stored in a central database and fetched by components"
    ],
    "answer": "Data can only flow from parent to child components via props",
    "explanation": "React follows a unidirectional data flow (top-down). Props are passed from parent to child, making it easier to understand where data originates and how state changes propagate.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In the context of React Fiber, what is the primary purpose of the 'work-in-progress' (WIP) tree?",
    "options": [
      "It serves as a backup in case the main application crashes during rendering.",
      "It acts as a double-buffer to calculate changes off-screen before committing them to the DOM.",
      "It stores the previous state of components to enable undo functionality.",
      "It is used to track the list of event listeners attached to the virtual DOM."
    ],
    "answer": "It acts as a double-buffer to calculate changes off-screen before committing them to the DOM.",
    "explanation": "Fiber uses double-buffering where the 'work-in-progress' tree is built in memory. Once rendering is complete, React swaps the pointer to make this tree the new 'current' tree.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What distinguishes `useLayoutEffect` from `useEffect` in React?",
    "options": [
      "useLayoutEffect runs asynchronously while useEffect runs synchronously.",
      "useLayoutEffect fires after the browser has painted, whereas useEffect fires before.",
      "useLayoutEffect fires synchronously after all DOM mutations but before the browser paints.",
      "useLayoutEffect is only supported in React Native, not in web applications."
    ],
    "answer": "useLayoutEffect fires synchronously after all DOM mutations but before the browser paints.",
    "explanation": "useLayoutEffect blocks the browser from painting to read layout from the DOM and synchronously re-render. useEffect runs after paint and is non-blocking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Why is it crucial to provide stable 'keys' when rendering dynamic lists of elements?",
    "options": [
      "Keys allow React to automatically clean up event listeners attached to list items.",
      "Keys enable React to identify which items have changed, been added, or been removed, preventing unnecessary re-creation of DOM nodes.",
      "Keys are required to establish the parent-child relationship within the React component tree.",
      "Keys allow CSS selectors to target specific list items more efficiently."
    ],
    "answer": "Keys enable React to identify which items have changed, been added, or been removed, preventing unnecessary re-creation of DOM nodes.",
    "explanation": "Without stable keys, React uses array indices, leading to state corruption and DOM thrashing if the list order changes. Keys provide a stable identity for items across re-renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In React's Fiber architecture, what is the function of 'lanes'?",
    "options": [
      "They are used to physically separate the DOM nodes in memory.",
      "They define the CSS lanes for layout flow in the browser engine.",
      "They represent priorities for updates, allowing React to schedule and render high-priority work before low-priority work.",
      "They provide a mechanism for creating distinct execution contexts for Web Workers."
    ],
    "answer": "They represent priorities for updates, allowing React to schedule and render high-priority work before low-priority work.",
    "explanation": "Lanes are a model for update prioritization (e.g., Sync vs. Transition). They allow React to schedule work, pause low-priority updates, and resume them later.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the 'reconciliation' process in React?",
    "options": [
      "The process of negotiating with the browser to allocate memory for the virtual DOM.",
      "The algorithm React uses to diff the new Virtual DOM tree against the old one to determine the minimal set of changes.",
      "The technique used to merge state changes from multiple components into a single object.",
      "The procedure for resolving conflicting props passed by different parent components."
    ],
    "answer": "The algorithm React uses to diff the new Virtual DOM tree against the old one to determine the minimal set of changes.",
    "explanation": "Reconciliation (or diffing) compares element trees to calculate which parts of the UI need updating. React then updates only the specific DOM nodes that changed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When using `useCallback`, what is the technical impact of specifying an empty dependency array `[]`?",
    "options": [
      "The callback function will be recreated on every single render.",
      "The callback function will be garbage collected immediately after the first render.",
      "The callback function will maintain a stable reference across renders, but will always reference stale initial state or props.",
      "The callback function will be executed before the component mounts."
    ],
    "answer": "The callback function will maintain a stable reference across renders, but will always reference stale initial state or props.",
    "explanation": "An empty dependency array means the closure is created once. It captures variables from the initial render, meaning subsequent updates to props/state inside the component will not be reflected in the callback.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What happens when a component throws an error during the 'Render' phase of a Lifecycle update?",
    "options": [
      "The entire application crashes and the window reloads.",
      "The error is logged to the console, but the UI remains unchanged.",
      "The error propagates up to the nearest Error Boundary, causing it to handle the error and display a fallback UI.",
      "The component automatically retries rendering with the previous state."
    ],
    "answer": "The error propagates up to the nearest Error Boundary, causing it to handle the error and display a fallback UI.",
    "explanation": "Error Boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them. They do not catch errors in event handlers or asynchronous code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "How does `React.memo` optimize a functional component?",
    "options": [
      "It automatically converts the functional component into a class component to utilize PureComponent logic.",
      "It performs a shallow comparison of props and skips re-rendering the component if props have not changed.",
      "It deep compares the state of the component to prevent unnecessary state updates.",
      "It caches the HTML output of the component to serve it directly on subsequent requests."
    ],
    "answer": "It performs a shallow comparison of props and skips re-rendering the component if props have not changed.",
    "explanation": "React.memo is a higher-order component. If props are equal (shallow comparison), it reuses the last rendered result, skipping the rendering execution of the wrapped component.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the primary risk of using indexes as 'keys' in a dynamic list when the list can be reordered or filtered?",
    "options": [
      "React will throw a runtime error due to duplicate keys.",
      "The performance of the reconciliation algorithm will degrade by 50%.",
      "Component state associated with list items may be associated with the wrong data items if the order changes.",
      "The list items will not render until the index calculation is complete."
    ],
    "answer": "Component state associated with list items may be associated with the wrong data items if the order changes.",
    "explanation": "Using index as a key relies on the position of items. If the list order changes, React recycles the DOM node at that index, potentially causing input state or internal component state to persist on the wrong data item.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In the context of 'Incremental Rendering' in Fiber, why is the ability to 'pause' rendering significant?",
    "options": [
      "It allows the browser to execute higher-priority tasks, keeping the UI responsive during heavy computation.",
      "It forces the browser to stop garbage collection to speed up rendering.",
      "It ensures that the 'Commit' phase happens before the 'Render' phase.",
      "It pauses the JavaScript execution thread completely to save battery life."
    ],
    "answer": "It allows the browser to execute higher-priority tasks, keeping the UI responsive during heavy computation.",
    "explanation": "Fiber breaks rendering into units of work. It can pause to let the browser handle user input or paint frames, preventing main thread blocking and jank.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the purpose of the 'current' property on a Fiber node?",
    "options": [
      "It stores the current React version string.",
      "It holds a reference to the most recently rendered DOM node associated with the fiber.",
      "It points to the 'work-in-progress' alternate fiber node for double buffering.",
      "It indicates the current priority lane of the update."
    ],
    "answer": "It points to the 'work-in-progress' alternate fiber node for double buffering.",
    "explanation": "The 'current' tree contains fibers representing the screen. Each fiber has an 'alternate' pointer (the WIP tree) to track pending changes. Conversely, the WIP fiber points back to 'current'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "How does React handle 'Controlled Components' in forms?",
    "options": [
      "The form elements maintain their own internal state which is queried on submission.",
      "The component's state is the single source of truth for the form input values, updated via event handlers.",
      "The browser manages the state, and React reads it only during the 'commit' phase.",
      "Controlled components are automatically managed by the Redux store without needing event handlers."
    ],
    "answer": "The component's state is the single source of truth for the form input values, updated via event handlers.",
    "explanation": "In controlled components, the input value is driven by React state. Changes are handled by a function that updates the state, re-rendering the component with the new value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the behavior of `ReactDOM.hydrate()` compared to `ReactDOM.render()`?",
    "options": [
      "`hydrate` is used for server-side rendering to attach event listeners to existing HTML markup.",
      "`hydrate` destroys the existing DOM and rebuilds it from scratch for better performance.",
      "`hydrate` is used to render components into a new container node that did not previously have content.",
      "`hydrate` bypasses the reconciliation phase to improve initial load speed."
    ],
    "answer": "`hydrate` is used for server-side rendering to attach event listeners to existing HTML markup.",
    "explanation": "Hydration preserves the markup generated on the server and attaches event listeners to it. 'render' would create a new DOM tree, ignoring the server markup.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which phase of the React render lifecycle is 'interruptible'?",
    "options": [
      "The Commit phase",
      "The Pre-render phase",
      "The Render (Reconciliation) phase",
      "The Post-commit phase"
    ],
    "answer": "The Render (Reconciliation) phase",
    "explanation": "The Render phase involves creating the Fiber tree and calculating changes; this is interruptible in Concurrent Mode. The Commit phase (applying changes to DOM) is always synchronous and uninterruptible.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is a 'Stale Closure' in the context of React Hooks?",
    "options": [
      "A closure that has been garbage collected before it is executed.",
      "A callback or effect that references variables from an old render cycle, missing recent updates.",
      "A component that has been unmounted but is still attempting to update state.",
      "An event listener that fails to trigger due to incorrect binding."
    ],
    "answer": "A callback or effect that references variables from an old render cycle, missing recent updates.",
    "explanation": "If a hook's dependency array is missing a variable, the hook retains the value from the initial render or the render when it was last updated, leading to stale data usage.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What happens during the 'beginWork' phase of the Fiber reconciliation process?",
    "options": [
      "React processes the fiber node and compares it against the alternate node to determine if it needs to update.",
      "React commits the calculated changes to the actual DOM.",
      "React cleans up side effects and destroys fibers that were removed.",
      "React executes the `componentWillUnmount` lifecycle method for all components."
    ],
    "answer": "React processes the fiber node and compares it against the alternate node to determine if it needs to update.",
    "explanation": "beginWork is the start of processing a fiber node. React determines if the node needs work based on props, queues updates, and reconciles children.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Why does React batch multiple `setState` calls?",
    "options": [
      "To ensure that the state updates are processed in a strictly sequential order.",
      "To prevent multiple re-renders by grouping updates into a single update cycle for performance.",
      "To guarantee that all state updates happen asynchronously.",
      "To allow the developer to bypass the virtual DOM."
    ],
    "answer": "To prevent multiple re-renders by grouping updates into a single update cycle for performance.",
    "explanation": "Batching ensures that expensive operations like re-rendering and DOM manipulation happen only once for a group of state changes, rather than for each individual call.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is `startTransition` used for in React 18+?",
    "options": [
      "To force a component to render on a background thread.",
      "To mark a state update as non-urgent, allowing React to keep the interface responsive during heavy renders.",
      "To transition a component from a class-based component to a functional component.",
      "To automatically lazy-load components when the network is congested."
    ],
    "answer": "To mark a state update as non-urgent, allowing React to keep the interface responsive during heavy renders.",
    "explanation": "Transitions mark updates (like filtering a large list) as low-priority. React interrupts them if higher-priority work (like typing) occurs, preventing UI blocking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the technical reason that 'Synthetic Events' wrap native browser events?",
    "options": [
      "To add support for Internet Explorer 8 and below.",
      "To ensure events have consistent properties across all browsers and to implement event pooling.",
      "To prevent the propagation of native events into the React DOM.",
      "To increase the memory usage of the application."
    ],
    "answer": "To ensure events have consistent properties across all browsers and to implement event pooling.",
    "explanation": "SyntheticEvents normalize cross-browser differences (e.g., focus behavior) and allow React to manage event memory efficiently (pooling) via the EventPluginHub system.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "When using `React.forwardRef`, what is the primary capability gained?",
    "options": [
      "The ability to pass a ref from a parent component directly to a DOM element within a child component.",
      "The ability to automatically forward all props from a grandparent to a grandchild.",
      "The ability to create a reference that points to the parent component itself.",
      "The ability to use refs to trigger re-renders without state."
    ],
    "answer": "The ability to pass a ref from a parent component directly to a DOM element within a child component.",
    "explanation": "Components do not expose their internal DOM nodes via `ref` by default. `forwardRef` creates a component that specifically accepts a `ref` prop and forwards it to a specific child element.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the primary difference between `componentDidCatch` and `getDerivedStateFromError`?",
    "options": [
      "`componentDidCatch` is static, while `getDerivedStateFromError` is an instance method.",
      "`getDerivedStateFromError` is called during the render phase to update state, while `componentDidCatch` is called after render for side effects like logging.",
      "`componentDidCatch` catches errors in event handlers, while `getDerivedStateFromError` does not.",
      "`getDerivedStateFromError` is used for functional components only."
    ],
    "answer": "`getDerivedStateFromError` is called during the render phase to update state, while `componentDidCatch` is called after render for side effects like logging.",
    "explanation": "getDerivedStateFromError is designed to update state to display a fallback UI immediately. componentDidCatch is for side effects (logging) and runs after the fallback UI is rendered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "How does `useSyncExternalStore` ensure consistency in Concurrent Mode?",
    "options": [
      "It forces external updates to run synchronously on the main thread, blocking all other renders.",
      "It provides a mechanism to read external state and subscribe to updates, preventing tearing by checking for mutations during rendering.",
      "It automatically converts external stores into React Context providers.",
      "It disables Concurrent Mode whenever the external store updates."
    ],
    "answer": "It provides a mechanism to read external state and subscribe to updates, preventing tearing by checking for mutations during rendering.",
    "explanation": "Without `useSyncExternalStore`, external updates might cause 'tearing' where different parts of the screen show different versions of data. This hook ensures reads are consistent with the current render.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is 'Context Prop Drilling'?",
    "options": [
      "A technique to pass data through the component tree without having to pass props manually at every level.",
      "The process of passing props down multiple levels of components to reach a deeply nested child, creating maintenance overhead.",
      "Using the `useReducer` hook to manage global state.",
      "The automatic merging of props from multiple sources."
    ],
    "answer": "The process of passing props down multiple levels of components to reach a deeply nested child, creating maintenance overhead.",
    "explanation": "Prop drilling refers to passing data through intermediate components that don't need the data themselves, just to get it to a descendant. Context is the solution to this problem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "In React 18+, what is 'Automatic Batching'?",
    "options": [
      "React automatically groups all state updates within a single event loop tick, regardless of where they originate.",
      "React automatically merges all class components into functional components.",
      "React groups all API requests into a single network call.",
      "React prevents the user from clicking buttons too quickly."
    ],
    "answer": "React automatically groups all state updates within a single event loop tick, regardless of where they originate.",
    "explanation": "Previously, batching only happened in React event handlers. In React 18+, updates inside promises, `setTimeout`, and native event handlers are also batched to improve performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the 'Commit Phase' in the Fiber architecture?",
    "options": [
      "The phase where React calculates the diff between the virtual DOM trees.",
      "The synchronous phase where React applies the calculated changes to the host environment (e.g., DOM).",
      "The phase where components schedule updates via `setState`.",
      "The phase where React executes `getDerivedStateFromProps`."
    ],
    "answer": "The synchronous phase where React applies the calculated changes to the host environment (e.g., DOM).",
    "explanation": "Once the work-in-progress tree is built, React enters the commit phase. This is synchronous and applies layout refs, DOM mutations, and passive effects without interruption.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Why does React recommend creating components with a capitalized name?",
    "options": [
      "To distinguish built-in React components (like `div`) from user-defined components in JSX.",
      "To ensure that the component names are unique in the global namespace.",
      "To enable the React compiler to automatically memoize the component.",
      "Because lowercase components are reserved for HTML elements only."
    ],
    "answer": "To distinguish built-in React components (like `div`) from user-defined components in JSX.",
    "explanation": "JSX compiles tags starting with lowercase to strings (HTML elements). Tags starting with uppercase are treated as React variables/identifiers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the technical implication of using `dangerouslySetInnerHTML`?",
    "options": [
      "It allows React to render HTML faster than the virtual DOM.",
      "It bypasses React's escaping mechanisms, exposing the application to Cross-Site Scripting (XSS) attacks if the data is not sanitized.",
      "It creates a new fiber node for every HTML tag found in the string.",
      "It forces the browser to repaint the entire screen."
    ],
    "answer": "It bypasses React's escaping mechanisms, exposing the application to Cross-Site Scripting (XSS) attacks if the data is not sanitized.",
    "explanation": "React escapes content by default to prevent XSS. `dangerouslySetInnerHTML` is the DOM equivalent of `innerHTML`, providing a backdoor to insert raw HTML, hence the name.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What does the 'key' prop actually do internally during reconciliation?",
    "options": [
      "It acts as a unique identifier for the component instance in memory.",
      "It is used as part of the heuristic to match elements in the old tree with elements in the new tree.",
      "It encrypts the props passed to the child component.",
      "It serves as a reference pointer to the parent component's state."
    ],
    "answer": "It is used as part of the heuristic to match elements in the old tree with elements in the new tree.",
    "explanation": "React uses the `key` prop to identify which items have changed, are added, or are removed. It enables React to map old elements to new elements efficiently without destroying and recreating the DOM unnecessarily.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is `React.lazy` used for?",
    "options": [
      "To defer the calculation of expensive state until the component is accessed.",
      "To dynamically import a component, allowing code splitting and loading it only when it is rendered.",
      "To make a component render only when the user is idle.",
      "To prevent a component from mounting if the network is slow."
    ],
    "answer": "To dynamically import a component, allowing code splitting and loading it only when it is rendered.",
    "explanation": "React.lazy lets you define a component that is loaded dynamically via a dynamic import(). This reduces the initial bundle size by loading code only when needed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "How does the `ref` attribute behave differently from standard props?",
    "options": [
      "`ref` is not a prop and is treated specially by React; it does not pass through to the component like `props.key` or `props.children`.",
      "`ref` triggers a re-render every time its value changes.",
      "`ref` can only be used on HTML elements, not on functional components.",
      "`ref` is strictly used for passing callback functions, not DOM nodes."
    ],
    "answer": "`ref` is not a prop and is treated specially by React; it does not pass through to the component like `props.key` or `props.children`.",
    "explanation": "Like `key`, `ref` is a reserved attribute handled differently during props destructuring. It is detached from `props` before being passed to the component.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the effect of `flushSync` in React 18?",
    "options": [
      "It flushes all pending state updates to the database immediately.",
      "It forces React to flush the queued updates synchronously, bypassing concurrent features for that specific scope.",
      "It invalidates the entire browser cache.",
      "It resets the component tree to its initial state."
    ],
    "answer": "It forces React to flush the queued updates synchronously, bypassing concurrent features for that specific scope.",
    "explanation": "In Concurrent Mode, updates are batched and can be delayed. `flushSync` forces a synchronous DOM update and re-render, useful for timing-critical DOM measurements.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In React's reconciliation algorithm, how are 'text nodes' (strings) handled compared to component elements?",
    "options": [
      "Text nodes are ignored during diffing and never updated.",
      "Text nodes are treated as children; if the text content changes, React updates the textContent of the corresponding DOM node.",
      "Text nodes always cause the parent component to unmount and remount.",
      "Text nodes are converted into functional components automatically."
    ],
    "answer": "Text nodes are treated as children; if the text content changes, React updates the textContent of the corresponding DOM node.",
    "explanation": "Strings are valid React children. If the previous child was a string and the new one is a string, React updates the DOM text node. If types switch (e.g., string to array), React replaces the node.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the 'Profiler' API used for in React?",
    "options": [
      "To profile the server-side rendering performance of Node.js applications.",
      "To measure the rendering performance of a React tree, identifying components that are slow or render frequently.",
      "To profile the memory usage of the JavaScript garbage collector.",
      "To analyze the network traffic generated by the application."
    ],
    "answer": "To measure the rendering performance of a React tree, identifying components that are slow or render frequently.",
    "explanation": "The Profiler measures how often a React application renders and what the 'cost' of rendering is. It helps identify optimization opportunities by timing component updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Why is it generally recommended to lift state up to the nearest common ancestor?",
    "options": [
      "To ensure that the state is accessible to all sibling components without using props.",
      "To make the state immutable and easier to debug.",
      "To share state between sibling components by placing it in the parent, acting as the single source of truth.",
      "To prevent the child components from re-rendering unnecessarily."
    ],
    "answer": "To share state between sibling components by placing it in the parent, acting as the single source of truth.",
    "explanation": "If two sibling components need the same data, the state should live in their parent. The parent passes the state down via props, ensuring consistency.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What does 'StrictMode' in React actually do?",
    "options": [
      "It checks the code for syntax errors and type mismatches at compile time.",
      "It renders the component twice in development to detect side effects and impure rendering logic.",
      "It forces all components to be written in TypeScript.",
      "It adds a strict Content Security Policy (CSP) to the application."
    ],
    "answer": "It renders the component twice in development to detect side effects and impure rendering logic.",
    "explanation": "StrictMode activates additional development-only checks, such as double-invoking component functions, lifecycle methods, and `setState` updaters to help find unsafe side-effects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In React Fiber's reconciliation algorithm, what is the specific purpose of the `childLanes` field on a fiber node?",
    "options": [
      "To track the expiration time of the update scheduled on this specific node",
      "To indicate that the fiber node itself has pending work that needs to be processed",
      "To signal that work is pending somewhere in the subtree of this fiber node",
      "To store the return fiber of the current node for traversal purposes"
    ],
    "answer": "To signal that work is pending somewhere in the subtree of this fiber node",
    "explanation": "While the `lanes` field tracks work on the fiber itself, `childLanes` is a bitwise mask that aggregates pending work from all descendants, allowing React to skip traversing branches of the tree that have no pending updates.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What distinguishes the 'Render' phase from the 'Commit' phase in React Fiber?",
    "options": [
      "The Render phase applies changes to the DOM, while the Commit phase calculates the new tree",
      "The Render phase can be interrupted and yields to the browser, while the Commit phase is synchronous and cannot be paused",
      "The Render phase executes side effects like layout mutations, while the Commit phase handles passive effects",
      "The Commit phase creates the work-in-progress tree, while the Render phase swaps it with the current tree"
    ],
    "answer": "The Render phase can be interrupted and yields to the browser, while the Commit phase is synchronous and cannot be paused",
    "explanation": "React Fiber implements incremental rendering by allowing the Render phase (building the tree) to be time-sliced and interrupted. The Commit phase must be synchronous to ensure the UI is never in an inconsistent state.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does React's 'double buffering' implementation function during a reconciliation cycle?",
    "options": [
      "React maintains two separate Virtual DOM trees and merges them during the commit phase",
      "React swaps the `current` tree pointer to point to the `workInProgress` tree only after the work is complete",
      "React clones the entire DOM into a shadow root before applying the final update",
      "React deletes the `current` tree and rebuilds it from scratch in memory before rendering"
    ],
    "answer": "React swaps the `current` tree pointer to point to the `workInProgress` tree only after the work is complete",
    "explanation": "Fiber maintains a persistent 'current' tree (what is on screen) and a draft 'work-in-progress' tree. Once the work-in-progress tree is fully rendered, React flips the root pointer to make it the new current tree.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which statement accurately describes the behavior of `useLayoutEffect` compared to `useEffect` regarding the browser paint?",
    "options": [
      "Both `useLayoutEffect` and `useEffect` run asynchronously after the browser has painted",
      "`useLayoutEffect` runs synchronously after all DOM mutations but before the browser paints, while `useEffect` runs after the paint",
      "`useLayoutEffect` runs before DOM mutations, while `useEffect` runs after DOM mutations",
      "`useLayoutEffect` can be deferred to avoid blocking the main thread, unlike `useEffect`"
    ],
    "answer": "`useLayoutEffect` runs synchronously after all DOM mutations but before the browser paints, while `useEffect` runs after the paint",
    "explanation": "`useLayoutEffect` blocks the browser from painting until the effect has run, allowing the developer to read layout from the DOM and synchronously re-render (e.g., to fix scroll position) without the user seeing a flicker.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What happens when a component throws an error during the 'Render' phase versus the 'Commit' phase?",
    "options": [
      "Errors in both phases are caught by the nearest Error Boundary in the same way",
      "Render phase errors are caught by Error Boundaries, while Commit phase errors are uncatchable and crash the application",
      "Render phase errors are uncatchable, while Commit phase errors are caught by Error Boundaries",
      "Neither phase errors can be caught by Error Boundaries unless using `ReactDOM.createPortal`"
    ],
    "answer": "Render phase errors are caught by Error Boundaries, while Commit phase errors are uncatchable and crash the application",
    "explanation": "React handles errors during rendering (before changes are committed to the screen) by triggering the nearest Error Boundary. However, if an error occurs during the commit phase (after DOM mutation), React tears down the app tree because the UI is now in an inconsistent state.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "In the context of React Server Components (RSC), which of the following is a strict limitation regarding component logic?",
    "options": [
      "Server Components cannot use the `useState` or `useEffect` hooks",
      "Server Components cannot render standard HTML elements like `<div>` or `<span>`",
      "Server Components cannot fetch data from a database or internal API",
      "Server Components cannot be imported or used by Client Components"
    ],
    "answer": "Server Components cannot use the `useState` or `useEffect` hooks",
    "explanation": "Server Components execute only once on the server to generate UI; they do not have a lifecycle or state on the client. Therefore, hooks that manage interactivity and state (`useState`, `useEffect`) are restricted to Client Components.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the primary technical reason that providing an unstable function as a prop to a pure component (or `React.memo`) causes unnecessary re-renders?",
    "options": [
      "Functions cannot be serialized for the Virtual DOM comparison",
      "React compares function props by reference identity, and a new function is created on every parent render",
      "Functions trigger a mutation in the React Fiber tree that invalidates the memoization cache",
      "Pure components automatically deep compare functions, which is computationally expensive"
    ],
    "answer": "React compares function props by reference identity, and a new function is created on every parent render",
    "explanation": "`React.memo` implements a shallow comparison of props. Since functions defined inside a component body are recreated with a new reference on every render, the shallow comparison fails, causing the child to re-render.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "How does the `key` prop influence the reconciliation process during list updates?",
    "options": [
      "It is used to pass unique identifiers to event handlers for better accessibility",
      "It determines the order in which the list items are rendered in the DOM",
      "It allows React to identify which elements have changed, been added, or been removed, rather than destroying and recreating the entire list",
      "It forces React to use the `shouldComponentUpdate` lifecycle method for every list item"
    ],
    "answer": "It allows React to identify which elements have changed, been added, or been removed, rather than destroying and recreating the entire list",
    "explanation": "Keys help React match elements in the previous tree with elements in the new tree. Without stable keys (like using an array index), React must destroy and recreate DOM nodes and component instances for every list change, losing local state.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the behavior of `flushSync` in React 18's concurrent rendering engine?",
    "options": [
      "It forces an immediate re-render of the entire application, bypassing the Virtual DOM",
      "It queues the update at the same priority as user interactions, but does not guarantee synchronous execution",
      "It forces React to flush the update synchronously, applying DOM changes immediately and pausing concurrent work",
      "It flushes all pending state updates in the batch, regardless of their priority lanes"
    ],
    "answer": "It forces React to flush the update synchronously, applying DOM changes immediately and pausing concurrent work",
    "explanation": "`flushSync` is an escape hatch that bypasses React's default asynchronous/concurrent batching. It ensures the provided callback is executed and the DOM is updated synchronously before the next line of code runs.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "In React's 'Lane' model for prioritizing updates, how are 'Transition Lanes' treated compared to 'Sync Lanes'?",
    "options": [
      "Transition Lanes are processed immediately in the same frame as Sync Lanes to ensure consistency",
      "Transition Lanes are lower priority and can be interrupted by higher-priority Sync Lanes or user input",
      "Transition Lanes are deprecated in favor of `useDeferredValue` and are no longer used internally",
      "Transition Lanes prevent the 'Commit' phase from running until all network requests are complete"
    ],
    "answer": "Transition Lanes are lower priority and can be interrupted by higher-priority Sync Lanes or user input",
    "explanation": "Transitions mark non-urgent updates (like navigating to a new page). If a high-priority event (like a keystroke) occurs, React will interrupt the work in Transition Lanes to handle the Sync Lane work first.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the definition of 'Passive Effects' in React's internal scheduling (specifically within `useEffect`)?",
    "options": [
      "Effects that run synchronously before the browser paints the screen",
      "Effects that are scheduled to run after the paint has been committed to the screen",
      "Effects that only run on the server side during Server-Side Rendering (SSR)",
      "Effects that are skipped entirely if `React.StrictMode` is enabled"
    ],
    "answer": "Effects that are scheduled to run after the paint has been committed to the screen",
    "explanation": "Passive effects (used in `useEffect`) are deferred until after the browser has painted the screen. This ensures that blocking logic does not delay the visual update of the page.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Why does modifying the state of a component directly (e.g., `state.value = 5`) fail to trigger a re-render in React?",
    "options": [
      "JavaScript objects are frozen by default and cannot be mutated without a setter",
      "React relies on object reference equality checks to detect changes; direct mutation does not trigger the scheduler",
      "React uses a Proxy to observe changes, which only works when using the `setState` function",
      "The Virtual DOM is immutable, preventing any direct modification of state objects"
    ],
    "answer": "React relies on object reference equality checks to detect changes; direct mutation does not trigger the scheduler",
    "explanation": "React's re-rendering process is triggered by calling the state updater function, which informs the scheduler of a change. Mutating the state object directly changes the data but bypasses the component's render trigger mechanism.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the primary function of the `scheduleUpdateOnFiber` function in React's internal implementation?",
    "options": [
      "To immediately invoke the `render` method of the specific component",
      "To mark the root of the fiber tree as needing work and calculate the priority lane for the update",
      "To manually flush the event queue and force the garbage collector to run",
      "To create the fiber node structure for a specific React element"
    ],
    "answer": "To mark the root of the fiber tree as needing work and calculate the priority lane for the update",
    "explanation": "This is the entry point for scheduling updates. It traverses up the fiber tree to the host root, merges the lane of the update into the root's `pendingLanes`, and requests a work slot from the scheduler.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does `startTransition` handle the race condition between a slow non-urgent update and a fast urgent update?",
    "options": [
      "It cancels the slow update immediately if a fast update occurs",
      "It queues the fast update to run only after the slow update has fully completed",
      "It allows the slow update to be interrupted by the fast update, and the slow update may restart or resume based on the latest state",
      "It blocks the main thread until the slow update transitions into a fast update"
    ],
    "answer": "It allows the slow update to be interrupted by the fast update, and the slow update may restart or resume based on the latest state",
    "explanation": "Transitions mark updates as interruptible. If a user interaction (urgent) occurs while a transition (non-urgent) is rendering, React interrupts the transition work to handle the interaction, effectively hiding latency.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What specific React optimization mechanism is triggered when a component's `render` method returns the exact same element reference as the previous render?",
    "options": [
      "React unmounts and remounts the component to reset its internal state",
      "React bails out of the reconciliation process for that subtree, skipping diffing and DOM updates",
      "React forces a deep comparison of all child props to ensure no data has changed",
      "React automatically applies `React.memo` to the component retroactively"
    ],
    "answer": "React bails out of the reconciliation process for that subtree, skipping diffing and DOM updates",
    "explanation": "If `React.createElement` returns the exact same object reference for the props/element as the previous frame, React can skip the diffing process for that subtree entirely, a form of early exit optimization.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which constraint applies to props passed to a React Component in React Server Components, but does not apply in Client Components?",
    "options": [
      "Props must be serializable (able to be converted to JSON)",
      "Props must be wrapped in a `Promise` object",
      "Props cannot contain functions or event handlers",
      "Both A and C are correct constraints for Server Components"
    ],
    "answer": "Both A and C are correct constraints for Server Components",
    "explanation": "Server Components run on the server and serialize their output to send to the client. Therefore, props must be serializable (JSON-compatible), meaning functions (which are not serializable) cannot be passed as props to Server Components.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the purpose of the `alternate` property on a Fiber node?",
    "options": [
      "To point to the sibling Fiber node in the tree list",
      "To reference the corresponding fiber node in the other tree (current or work-in-progress)",
      "To store the memoized state of the component for future restoration",
      "To link the Fiber node to its parent DOM element"
    ],
    "answer": "To reference the corresponding fiber node in the other tree (current or work-in-progress)",
    "explanation": "The `alternate` field creates a circular link between a node in the `current` tree and its counterpart in the `workInProgress` tree, allowing React to clone and reuse fiber nodes efficiently between renders.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "In the context of Synthetic Events in React, why is `e.persist()` used?",
    "options": [
      "To prevent the default browser action for the event",
      "To stop the event from bubbling up the React component tree",
      "To remove the event from the event pooling system and allow the event properties to be accessed asynchronously",
      "To ensure the event listener is never garbage collected"
    ],
    "answer": "To remove the event from the event pooling system and allow the event properties to be accessed asynchronously",
    "explanation": "In React 16 and earlier (conceptually), events were pooled for performance, nulling properties after the event handler fired. `e.persist()` removes the synthetic event from the pool, keeping it in memory for asynchronous access (though pooling is removed in React 17+, the concept remains for legacy contexts or understanding event object lifetimes).",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "How does `useId` ensure stable IDs across Server-Side Rendering (SSR) and Client Hydration?",
    "options": [
      "It generates a random UUID on the server and sends it via a cookie",
      "It uses a deterministic algorithm that counts the number of `useId` calls during the render pass, ensuring the server and client counts match",
      "It hashes the component name and props to generate a consistent ID",
      "It queries the DOM to check for existing IDs before generating a new one"
    ],
    "answer": "It uses a deterministic algorithm that counts the number of `useId` calls during the render pass, ensuring the server and client counts match",
    "explanation": "If the server tree structure matches the client tree structure, the order of `useId` hook invocations is identical. React uses this deterministic order to generate matching IDs (like `:r0:`) on both server and client, preventing hydration mismatches.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the consequence of returning a function from `useEffect` in a React component?",
    "options": [
      "The function is executed immediately to calculate the initial effect state",
      "The function is scheduled to run after the next render cycle as the cleanup logic",
      "The function is passed as a prop to the component's children",
      "The effect is ignored entirely, and a warning is logged to the console"
    ],
    "answer": "The function is scheduled to run after the next render cycle as the cleanup logic",
    "explanation": "Returning a function from `useEffect` registers a cleanup function. React executes this function before the component unmounts and before every subsequent re-render of that effect to clean up the previous effect's side effects.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "Why is it generally unsafe to call `setState` inside the `render` method of a class component?",
    "options": [
      "It causes an infinite loop because `setState` triggers a re-render, which calls `render` again",
      "It throws a runtime error because state is immutable during the render phase",
      "It bypasses the Virtual DOM diffing algorithm and causes memory leaks",
      "It is safe, but it is deprecated in React 18 in favor of `useEffect`"
    ],
    "answer": "It causes an infinite loop because `setState` triggers a re-render, which calls `render` again",
    "explanation": "The `render` method must be pure. Calling `setState` within it signals React to schedule an update, causing the component to re-render, which triggers `setState` again, creating an unrecoverable infinite loop.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the technical distinction between `hydrateRoot` and `createRoot` in React 18?",
    "options": [
      "`hydrateRoot` is used for Server-Side Rendering to attach event listeners to existing HTML, while `createRoot` is used for purely client-side rendering",
      "`createRoot` creates a legacy root, while `hydrateRoot` creates a concurrent root",
      "`hydrateRoot` is faster than `createRoot` because it skips the diffing process",
      "`hydrateRoot` forces strict mode, whereas `createRoot` disables it by default"
    ],
    "answer": "`hydrateRoot` is used for Server-Side Rendering to attach event listeners to existing HTML, while `createRoot` is used for purely client-side rendering",
    "explanation": "`hydrateRoot` assumes the HTML is already generated (likely by the server) and attempts to take over, attaching listeners and reconciling state. `createRoot` clears the container node and builds the UI from scratch.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the primary role of 'reconciliation' in React's architecture?",
    "options": [
      "To calculate the most efficient way to update the DOM based on changes in component state or props",
      "To compress the JavaScript bundle size before deploying to production",
      "To manage the network requests for data fetching in Server Components",
      "To handle the CSS-in-JS styling updates for the application"
    ],
    "answer": "To calculate the most efficient way to update the DOM based on changes in component state or props",
    "explanation": "Reconciliation is the algorithm React uses to diff the new Virtual DOM tree (elements returned by `render`) against the old tree to determine the minimal set of DOM mutations required.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the context of React 18+, what is Automatic Batching?",
    "options": [
      "React automatically groups all state updates within a single event (timeout, interval, promise) into a single re-render",
      "React automatically splits state updates into multiple renders to improve concurrency",
      "React automatically wraps all components in `React.memo` to improve performance",
      "React automatically detects and removes unused CSS classes from the DOM"
    ],
    "answer": "React automatically groups all state updates within a single event (timeout, interval, promise) into a single re-render",
    "explanation": "Prior to React 18, batching only happened inside React event handlers. In React 18, updates created *anywhere* (including timeouts, promises, and native event handlers) are automatically batched together to prevent unnecessary renders.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What happens during the 'Commit' phase when a fiber node is removed from the tree?",
    "options": [
      "React immediately calls `componentWillUnmount` but leaves the DOM node in place until the next frame",
      "React traverses the fiber tree, executing `useEffect` cleanup functions and unmounting DOM nodes synchronously",
      "React marks the fiber node as 'pending deletion' and removes it during the next render phase",
      "React moves the fiber node to a 'recycle bin' to be reused for future components"
    ],
    "answer": "React traverses the fiber tree, executing `useEffect` cleanup functions and unmounting DOM nodes synchronously",
    "explanation": "Commit is the only phase where React interacts with the DOM. When a node is deleted, its effects are destroyed (cleanup functions run) and the DOM nodes are removed from the view synchronously.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "How does the `Suspense` component handle a Promise thrown by a wrapped component?",
    "options": [
      "It catches the error and displays the nearest Error Boundary component",
      "It catches the Promise and displays its fallback UI until the Promise resolves",
      "It retries the function that threw the Promise indefinitely until it returns a value",
      "It pauses the JavaScript execution thread indefinitely"
    ],
    "answer": "It catches the Promise and displays its fallback UI until the Promise resolves",
    "explanation": "When a component wrapped in `Suspense` throws a Promise (usually a resource read), React catches it, renders the fallback, and waits. When the Promise resolves, React attempts to render the component again.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the specific utility of `useDeferredValue` compared to `useTransition`?",
    "options": [
      "`useDeferredValue` is for deferring state updates, while `useTransition` is for deferring values",
      "`useDeferredValue` allows you to defer re-rendering a non-critical part of the UI (a value), while `useTransition` marks the state update itself as non-urgent",
      "`useDeferredValue` acts as a stricter version of `useMemo` for expensive calculations",
      "`useDeferredValue` is used to force a synchronous update, unlike `useTransition`"
    ],
    "answer": "`useDeferredValue` allows you to defer re-rendering a non-critical part of the UI (a value), while `useTransition` marks the state update itself as non-urgent",
    "explanation": "While `startTransition` wraps the *setter* of a state, `useDeferredValue` wraps the *value*. It returns a previous version of the value while the new value is being calculated, allowing the UI to stay responsive.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is the behavior of `React.cloneElement` regarding the `ref` prop?",
    "options": [
      "It overwrites the original ref even if a new one is provided",
      "It ignores the new ref and keeps the original one",
      "It merges the old ref and the new ref, invoking both when the ref updates",
      "It throws an error if a ref is already present on the element"
    ],
    "answer": "It merges the old ref and the new ref, invoking both when the ref updates",
    "explanation": "Unlike other props where later props override earlier ones, `React.cloneElement` specifically handles `ref` by merging them. This ensures that if a parent adds a ref and a grandparent also adds a ref via `cloneElement`, both callbacks are invoked.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the specific benefit of using Context selectors (unofficial/experimental or via libraries) compared to standard `useContext`?",
    "options": [
      "Selectors allow you to pass data from a Client Component to a Server Component",
      "Selectors prevent the consumer component from re-rendering if the selected slice of context value has not changed, even if other parts of the context have",
      "Selectors allow you to mutate the context value directly without a dispatcher",
      "Selectors automatically serialize the context value for network transmission"
    ],
    "answer": "Selectors prevent the consumer component from re-rendering if the selected slice of context value has not changed, even if other parts of the context have",
    "explanation": "Standard `useContext` triggers a re-render whenever *any* part of the context value changes. Selectors allow a component to subscribe only to a specific slice of the state, optimizing render performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In React Strict Mode (development mode), why are effects like `useEffect` invoked twice, then cleaned up, then invoked again?",
    "options": [
      "To simulate the behavior of Server-Side Rendering hydration",
      "To ensure that components are resilient to the 'mount-unmount-remount' cycle that happens with features like `React.offscreen` or Fast Refresh",
      "To check if the component leaks memory by analyzing the cleanup function return value",
      "To force developers to write pure functions that do not rely on external global state"
    ],
    "answer": "To ensure that components are resilient to the 'mount-unmount-remount' cycle that happens with features like `React.offscreen` or Fast Refresh",
    "explanation": "React Strict Mode simulates mounting, unmounting, and remounting the component immediately. This stress-test helps ensure that cleanup logic in `useEffect` properly restores state so the component can start fresh.",
    "difficulty": "Advanced"
  }
]