[
  {
    "id": 1,
    "question": "Which class acts as the bridge between your domain or entity classes and the database?",
    "options": [
      "DbSet",
      "DbContext",
      "IQueryable",
      "SqlConnection"
    ],
    "answer": "DbContext",
    "explanation": "The DbContext is the primary class responsible for interacting with the database. It tracks changes to entities and manages database connections.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which property of the DbContext represents a collection of a specific entity type that maps to a database table?",
    "options": [
      "ICollection",
      "IList",
      "DbSet",
      "IEnumerable"
    ],
    "answer": "DbSet",
    "explanation": "DbSet corresponds to a table in the database and allows you to query and save instances of the entity type.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary purpose of the 'SaveChanges' method in Entity Framework Core?",
    "options": [
      "To execute a SQL SELECT query",
      "To persist all tracked changes to the database",
      "To configure entity relationships",
      "To create a new database connection"
    ],
    "answer": "To persist all tracked changes to the database",
    "explanation": "SaveChanges scans the Change Tracker for entities with Added, Modified, or Deleted states and generates SQL to commit these transactions.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which convention is used by Entity Framework Core to identify a property as the primary key if no key is explicitly defined?",
    "options": [
      "A property named 'Id' or '<ClassName>Id'",
      "The first string property alphabetically",
      "A property decorated with [Required]",
      "A property with the 'int' data type"
    ],
    "answer": "A property named 'Id' or '<ClassName>Id'",
    "explanation": "EF Core follows conventions where a property named 'Id' or 'ClassNameId' (e.g., 'ProductId') is automatically configured as the Primary Key.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In Entity Framework Core, what method is used to specify that a related entity should be loaded from the database as part of the initial query?",
    "options": [
      "Load()",
      "Include()",
      "ThenInclude()",
      "AsNoTracking()"
    ],
    "answer": "Include()",
    "explanation": "The Include method specifies related objects to include in the query results, implementing Eager Loading.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What attribute is used in Data Annotations to configure a property as the primary key if it does not follow the naming convention?",
    "options": [
      "[PrimaryKey]",
      "[Key]",
      "[Id]",
      "[Identity]"
    ],
    "answer": "[Key]",
    "explanation": "The [Key] attribute explicitly marks a property as the primary key, overriding the default naming conventions.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which method in the DbContext is overridden to configure the model using the Fluent API?",
    "options": [
      "OnConfiguring",
      "OnModelCreating",
      "ConfigureServices",
      "Initialize"
    ],
    "answer": "OnModelCreating",
    "explanation": "OnModelCreating allows you to configure entity properties, relationships, and mapping using the Fluent API within the ModelBuilder.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What does the 'AsNoTracking' method do when applied to a query?",
    "options": [
      "Disables lazy loading for the query",
      "Prevents the query from being cached in memory",
      "Instructs EF Core not to track the returned entities in the Change Tracker",
      "Forces the query to execute synchronously"
    ],
    "answer": "Instructs EF Core not to track the returned entities in the Change Tracker",
    "explanation": "AsNoTracking improves read-only query performance by skipping the overhead of storing entities in the context for change tracking.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which CLI command is used to scaffold a new migration based on the changes made to your entity classes?",
    "options": [
      "dotnet ef database update",
      "dotnet ef migrations add",
      "dotnet ef script generate",
      "dotnet ef model scaffold"
    ],
    "answer": "dotnet ef migrations add",
    "explanation": "The 'dotnet ef migrations add' command generates a migration file containing the code to apply schema changes based on the current model.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is a prerequisite in Entity Framework Core to enable Lazy Loading for navigation properties?",
    "options": [
      "Navigation properties must be marked with the [Lazy] attribute",
      "The navigation properties must be 'virtual'",
      "The context must be configured with 'UseLazyLoadingProxies()'",
      "All of the above"
    ],
    "answer": "The context must be configured with 'UseLazyLoadingProxies()'",
    "explanation": "While navigation properties must be 'virtual', the core enabling configuration is calling UseLazyLoadingProxies on the DbContextOptionsBuilder.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which Data Annotation attribute is used to enforce that a property cannot contain null values?",
    "options": [
      "[NotNull]",
      "[Required]",
      "[NotEmpty]",
      "[NotNullable]"
    ],
    "answer": "[Required]",
    "explanation": "The [Required] attribute indicates that a property is required, which EF Core translates into a NOT NULL constraint in the database schema.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which method is used to explicitly open a connection to the database if it is not already open?",
    "options": [
      "context.Database.EnsureCreated()",
      "context.Database.OpenConnection()",
      "context.Database.BeginTransaction()",
      "context.Connection.Open()"
    ],
    "answer": "context.Database.OpenConnection()",
    "explanation": "The Database.OpenConnection() method manually opens the underlying ADO.NET connection, though EF Core usually manages this automatically.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "In the context of EF Core Migrations, what command applies the latest migration to the database?",
    "options": [
      "dotnet ef migrations script",
      "dotnet ef migrations apply",
      "dotnet ef database update",
      "dotnet ef schema refresh"
    ],
    "answer": "dotnet ef database update",
    "explanation": "The 'dotnet ef database update' command applies pending migrations to the target database, bringing it up to date with the model.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What happens when you call the 'Update' method on a DbContext for an entity that is not currently being tracked?",
    "options": [
      "The entity is ignored by the context",
      "The entity is attached to the context and marked as 'Modified'",
      "The entity is deleted from the database",
      "An exception is thrown immediately"
    ],
    "answer": "The entity is attached to the context and marked as 'Modified'",
    "explanation": "The Update method attaches the entity to the context and sets its state to Modified, causing all properties to be updated on SaveChanges.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which Data Annotation attribute prevents a property from being mapped to a column in the database?",
    "options": [
      "[Ignore]",
      "[NotMapped]",
      "[NoColumn]",
      "[Exclude]"
    ],
    "answer": "[NotMapped]",
    "explanation": "The [NotMapped] attribute tells EF Core to exclude the specific property from the database schema generation.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the purpose of the 'InverseProperty' attribute?",
    "options": [
      "To configure a foreign key constraint",
      "To define the reverse navigation property in a relationship",
      "To prevent circular JSON serialization",
      "To create an index on the property"
    ],
    "answer": "To define the reverse navigation property in a relationship",
    "explanation": "InverseProperty is used when there are multiple navigation properties between two entities to clarify which properties pair together.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which method is used to execute a raw SQL query that returns entity instances?",
    "options": [
      "context.Database.ExecuteSqlRaw",
      "context.Set().FromSqlRaw",
      "context.SqlQuery",
      "context.Query().Execute"
    ],
    "answer": "context.Set().FromSqlRaw",
    "explanation": "FromSqlRaw allows executing a raw SQL query and mapping the results to entities, provided the results match the entity shape.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which EntityState value indicates that an entity is being tracked by the context but does not exist in the database yet?",
    "options": [
      "Modified",
      "Detached",
      "Added",
      "Unchanged"
    ],
    "answer": "Added",
    "explanation": "The 'Added' state signifies that the entity is new and must be inserted into the database upon calling SaveChanges.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How do you specify the table name for an entity using Data Annotations if it differs from the class name?",
    "options": [
      "[TableName(\"MyTable\")]",
      "[Table(\"MyTable\")]",
      "[Entity(\"MyTable\")]",
      "[MapTo(\"MyTable\")]"
    ],
    "answer": "[Table(\"MyTable\")]",
    "explanation": "The [Table] attribute allows you to explicitly define the database table name that an entity maps to.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What command is used to remove the most recent migration file (reverting the code changes only)?",
    "options": [
      "dotnet ef migrations remove",
      "dotnet ef migrations undo",
      "dotnet ef database rollback",
      "dotnet ef migrations delete"
    ],
    "answer": "dotnet ef migrations remove",
    "explanation": "The 'remove' command deletes the latest migration file, provided the migration has not yet been applied to the database.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which method generates a SQL script for all migrations from the baseline to the latest migration?",
    "options": [
      "dotnet ef migrations script",
      "dotnet ef database export",
      "dotnet ef migrations generate",
      "dotnet ef database script"
    ],
    "answer": "dotnet ef migrations script",
    "explanation": "This command generates a SQL script representing the transformations required to apply the migrations, useful for production deployment.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the default behavior of EF Core when a delete operation is performed on a principal entity that has related dependent entities?",
    "options": [
      "The dependent entities are set to null",
      "The dependent entities are deleted automatically",
      "An exception is thrown",
      "The dependent entities are orphaned"
    ],
    "answer": "An exception is thrown",
    "explanation": "By default, if a required relationship exists, EF Core throws a DbUpdateConcurrencyException because the foreign key constraint would be violated.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which method configures a relationship cascade delete behavior in Fluent API?",
    "options": [
      "OnDelete()",
      "WillCascadeOnDelete()",
      "DeleteBehavior()",
      "HasDeleteAction()"
    ],
    "answer": "OnDelete()",
    "explanation": "The OnDelete method in the Fluent API defines how a delete operation on a principal entity affects related dependent entities (e.g., Cascade, SetNull).",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the 'Change Tracker' responsible for in Entity Framework Core?",
    "options": [
      "Tracking database schema changes over time",
      "Monitoring changes to entity instances during their lifetime",
      "Recording changes to connection strings",
      "Managing database transaction logs"
    ],
    "answer": "Monitoring changes to entity instances during their lifetime",
    "explanation": "The Change Tracker is responsible for detecting changes made to entity properties so that those changes can be persisted to the database.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which method is used to explicitly set the state of an entity to 'Deleted'?",
    "options": [
      "context.Entities.Remove(entity)",
      "context.Entry(entity).State = EntityState.Deleted",
      "context.Set().Delete(entity)",
      "context.Delete(entity)"
    ],
    "answer": "context.Entry(entity).State = EntityState.Deleted",
    "explanation": "While the Remove method is common, using the Entry API to set the State directly allows for manual control over the entity's lifecycle.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which Fluent API method is used to configure an alternate key (a unique key other than the primary key)?",
    "options": [
      "HasKey()",
      "HasAlternateKey()",
      "IsUnique()",
      "HasUniqueKey()"
    ],
    "answer": "HasAlternateKey()",
    "explanation": "HasAlternateKey configures a property as an alternate key, which serves as a unique constraint and can be used as a target for foreign keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "In a Database First workflow, which command generates entity classes and a DbContext from an existing database?",
    "options": [
      "dotnet ef db scaffold",
      "dotnet ef database scaffold",
      "dotnet ef scaffold",
      "Scaffold-DbContext"
    ],
    "answer": "Scaffold-DbContext",
    "explanation": "The Scaffold-DbContext command (in Package Manager Console) reverse-engineers an existing database to create C# entity classes and a context.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the function of the 'ThenInclude' method?",
    "options": [
      "To filter the results of a query",
      "To include navigation properties of entities included at a previous level",
      "To include a list of all entities in the context",
      "To execute a stored procedure"
    ],
    "answer": "To include navigation properties of entities included at a previous level",
    "explanation": "ThenInclude is used to perform eager loading on nested navigation properties (e.g., loading Posts for a User, and then Comments for those Posts).",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which method is used to ensure the database is created if it does not exist?",
    "options": [
      "context.Database.Migrate()",
      "context.Database.Create()",
      "context.Database.EnsureCreated()",
      "context.Database.Exists()"
    ],
    "answer": "context.Database.EnsureCreated()",
    "explanation": "EnsureCreated creates the database if it does not exist, but does not use migrations; it creates the schema based on the current model.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which attribute is used to specify the data type of a column in the database, such as 'varchar' or 'decimal'?",
    "options": [
      "[Column(TypeName = \"varchar\")]",
      "[DataType(\"varchar\")]",
      "[ColumnType(\"varchar\")]",
      "[DbType(\"varchar\")]"
    ],
    "answer": "[Column(TypeName = \"varchar\")]",
    "explanation": "The Column attribute with the TypeName property allows you to specify the exact database data type, overriding EF Core's default conventions.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is a Shadow Property in Entity Framework Core?",
    "options": [
      "A property marked as private in the entity class",
      "A property that exists in the database but is not defined in the entity class",
      "A property that is ignored during query execution",
      "A property used only for caching"
    ],
    "answer": "A property that exists in the database but is not defined in the entity class",
    "explanation": "Shadow properties are defined in the model (via Fluent API) but are not declared in the entity class, often used for foreign keys or audit columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which method adds a concurrency token to a property to handle database conflicts?",
    "options": [
      "IsConcurrencyToken()",
      "IsRowVersion()",
      "HasConcurrencyCheck()",
      "UseConcurrencyToken()"
    ],
    "answer": "IsConcurrencyToken()",
    "explanation": "IsConcurrencyToken configures a property to be included in the WHERE clause during UPDATE and DELETE statements to check for concurrency conflicts.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which method creates an index on a specific property using Fluent API?",
    "options": [
      "HasIndex()",
      "UseIndex()",
      "MapIndex()",
      "ConfigureIndex()"
    ],
    "answer": "HasIndex()",
    "explanation": "The HasIndex method in Fluent API is used to create an index on a specified property or list of properties to improve query performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the primary difference between 'EnsureCreated' and 'Migrate'?",
    "options": [
      "EnsureCreated is for production, Migrate is for development",
      "EnsureCreated does not use migrations, while Migrate applies pending migration files",
      "Migrate creates the database from scratch, EnsureCreated updates it",
      "There is no difference; they do the same thing"
    ],
    "answer": "EnsureCreated does not use migrations, while Migrate applies pending migration files",
    "explanation": "EnsureCreated creates a database based on the current model immediately but bypasses migrations. Migrate applies the migration history, allowing for incremental schema updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In Entity Framework Core, what is the default behavior of the `Update()` method on a `DbContext` when passed an entity graph containing related entities?",
    "options": [
      "It attaches all entities in the graph as `Unchanged` except the root entity.",
      "It marks all entities in the graph as `Added` regardless of their primary key values.",
      "It marks all entities in the graph as `Modified`, causing every property to be updated in the database.",
      "It recursively searches the graph and only updates entities that have different property values than the database snapshot."
    ],
    "answer": "It marks all entities in the graph as `Modified`, causing every property to be updated in the database.",
    "explanation": "The `Update` method recursively tracks all reachable entities and sets their state to `Modified`. This causes an UPDATE statement to be generated for every entity in the graph when `SaveChanges` is called, even if no values actually changed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "Which method is used to explicitly configure the entity that a `DbSet` in the `DbContext` maps to when the entity type name differs from the table name?",
    "options": [
      "UseTableName",
      "ToTable",
      "HasTable",
      "MapToTable"
    ],
    "answer": "ToTable",
    "explanation": "In Fluent API, the `ToTable` method configures the table name that an entity maps to in the database. It is called within the `OnModelCreating` method or inside an entity configuration class inheriting from `IEntityTypeConfiguration`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary purpose of the `AsNoTracking()` extension method in a LINQ query?",
    "options": [
      "To disable lazy loading for the duration of the query.",
      "To prevent the query from being executed synchronously.",
      "To improve performance by indicating that the resulting entities will not be modified.",
      "To instruct EF Core to split a single query into multiple SQL queries to avoid the Cartesian explosion problem."
    ],
    "answer": "To improve performance by indicating that the resulting entities will not be modified.",
    "explanation": "`AsNoTracking` disables change tracking, which reduces overhead. This is ideal for read-only scenarios where the entities do not need to be updated back to the database.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When using Fluent API to configure a many-to-many relationship in EF Core 7.0+, which method combination is required?",
    "options": [
      "HasMany(x => x.Roles).WithMany(x => x.Users).UsingEntity<JoinType>()",
      "HasMany(x => x.Roles).WithOptional(x => x.Users)",
      "HasRequired(x => x.Roles).WithMany(x => x.Users)",
      "Entity<User>().HasMany(u => u.Roles).Entity<Role>()"
    ],
    "answer": "HasMany(x => x.Roles).WithMany(x => x.Users).UsingEntity<JoinType>()",
    "explanation": "In modern EF Core versions, `HasMany` and `WithMany` are used to define both ends of the collection navigation properties. `UsingEntity` is optionally used to configure the join entity and its columns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is a 'Shadow Property' in Entity Framework Core?",
    "options": [
      "A property defined in the C# class that is excluded from the database schema.",
      "A property that is not defined in the .NET entity class but is defined in the EF Core model and tracked by the Change Tracker.",
      "A private property that can only be accessed via reflection during migrations.",
      "A property that exists in the database but is always mapped to null in the application."
    ],
    "answer": "A property that is not defined in the .NET entity class but is defined in the EF Core model and tracked by the Change Tracker.",
    "explanation": "Shadow properties exist only in the EF Core model, not in the entity class. They are often used for foreign keys or audit columns (like `LastUpdated`) where you don't want to expose properties in the domain logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "How does the `Include()` method affect the generated SQL query when loading a one-to-many relationship?",
    "options": [
      "It generates two separate SQL queries (one for the parent, one for the children) and merges them in memory.",
      "It uses `LEFT OUTER JOIN` to fetch related data in a single round trip to the database.",
      "It executes a stored procedure that returns multiple result sets.",
      "It does not affect the SQL; it simply uses lazy loading proxies."
    ],
    "answer": "It uses `LEFT OUTER JOIN` to fetch related data in a single round trip to the database.",
    "explanation": "`Include` performs eager loading. By default, EF Core translates this into a single query utilizing joins, unless `AsSplitQuery` is used.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In EF Core Migrations, what command is used to generate a SQL script for a specific range of migrations, rather than applying them directly?",
    "options": [
      "dotnet ef database script",
      "dotnet ef migrations generate --sql",
      "dotnet ef migrations script --from Start --to End",
      "dotnet ef script update"
    ],
    "answer": "dotnet ef migrations script --from Start --to End",
    "explanation": "The `dotnet ef migrations script` command generates SQL based on migrations. Using `--from` and `--to` arguments allows generating an incremental script for a specific version range.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What happens when you call `context.Entry(entity).State = EntityState.Deleted` on an entity that is currently being tracked by the context?",
    "options": [
      "The entity is immediately removed from the database.",
      "The entity is detached from the context and no longer tracked.",
      "The entity's state is set to `Deleted`, causing a DELETE statement to be executed upon `SaveChanges`.",
      "The entity is moved to a recycle bin table instead of being deleted."
    ],
    "answer": "The entity's state is set to `Deleted`, causing a DELETE statement to be executed upon `SaveChanges`.",
    "explanation": "Setting the state to `Deleted` tells the Change Tracker that the entity should be removed. The actual deletion happens only when `SaveChanges` is called, committing the transaction.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which EF Core feature allows you to define a query filter (such as 'IsDeleted = false') that is automatically applied to all queries for a specific entity type?",
    "options": [
      "Global Filters",
      "Query Interceptors",
      "HasQueryFilter",
      "DefaultConstraint"
    ],
    "answer": "HasQueryFilter",
    "explanation": "`HasQueryFilter` in Fluent API defines a predicate expression that is automatically added to the LINQ query tree for any query involving that entity type. This is commonly used for soft-delete multi-tenancy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the result of executing a LINQ query in EF Core 3.0+ that cannot be fully translated to SQL?",
    "options": [
      "The query executes successfully, performing client-side evaluation for the non-translatable part.",
      "EF Core throws an `InvalidOperationException`.",
      "The query part that can be translated runs on the server, and the rest returns null.",
      "The transaction is automatically rolled back."
    ],
    "answer": "EF Core throws an `InvalidOperationException`.",
    "explanation": "Prior to EF Core 3.0, the framework allowed client-side evaluation. In 3.0+, EF Core throws an exception to prevent performance issues or accidental partial data retrieval.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the purpose of the `AsSplitQuery()` method in EF Core 5.0+?",
    "options": [
      "To break a large `SaveChanges` operation into multiple batches.",
      "To translate a single LINQ query with `Include` into multiple SQL queries to prevent the 'Cartesian Explosion' problem.",
      "To execute queries in parallel using multiple threads.",
      "To split the query string into smaller segments to fit the network packet size."
    ],
    "answer": "To translate a single LINQ query with `Include` into multiple SQL queries to prevent the 'Cartesian Explosion' problem.",
    "explanation": "When using multiple `Include` statements, the default behavior creates a massive JOIN (Cartesian product). `AsSplitQuery` generates separate SQL queries for each included collection, drastically improving performance in certain scenarios.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which interface must a repository implement to support asynchronous enumeration (`await foreach`) of query results?",
    "options": [
      "IAsyncEnumerable",
      "IEnumerable",
      "IQueryable",
      "Task<List>"
    ],
    "answer": "IAsyncEnumerable",
    "explanation": "EF Core's `DbSet` implements `IAsyncEnumerable`, allowing the results to be streamed asynchronously. This prevents blocking a thread while the network retrieves data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the context of EF Core transactions, what does the `CommitAsync()` method do?",
    "options": [
      "It releases the database lock but keeps the transaction open.",
      "It persists all changes made to the database within the transaction scope and releases resources.",
      "It creates a savepoint within the transaction.",
      "It detects changes in the ChangeTracker automatically."
    ],
    "answer": "It persists all changes made to the database within the transaction scope and releases resources.",
    "explanation": "Committing marks the end of a successful transaction. It writes the transaction log to the database, making the changes durable and permanent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When configuring an Owned Type (Value Object) using Fluent API, which method is used to define the ownership?",
    "options": [
      "HasEntityType",
      "OwnsOne",
      "HasValueObject",
      "Property"
    ],
    "answer": "OwnsOne",
    "explanation": "`OwnsOne` is used to configure a value object or complex type where the owned entity does not have its own identity but shares the identity of the principal entity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which command-line instruction would you use to revert the database schema to the state of a specific migration named `Migration2020`?",
    "options": [
      "dotnet ef database reset Migration2020",
      "dotnet ef database update Migration2020",
      "dotnet ef migrations rollback Migration2020",
      "dotnet ef database revert Migration2020"
    ],
    "answer": "dotnet ef database update Migration2020",
    "explanation": "The `dotnet ef database update` command accepts a migration name. If the target migration is earlier than the current state, EF Core will run the `Down` methods of subsequent migrations to revert the schema.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the behavior of the `DefaultValue` configuration in Fluent API?",
    "options": [
      "It sets a default value for the property in the C# class instance.",
      "It configures the default value constraint for the database column when creating new rows.",
      "It provides a fallback value if a query returns null.",
      "It ensures the property is never null."
    ],
    "answer": "It configures the default value constraint for the database column when creating new rows.",
    "explanation": "Setting `HasDefaultValue` in Fluent API generates a `DEFAULT` constraint in the DDL. Note that EF Core only applies this to the database schema; it does not apply to the in-memory entity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "How do you explicitly load a navigation property `Orders` for a specific `Customer` entity that is already tracked by the context?",
    "options": [
      "context.Entry(customer).Collection(c => c.Orders).Load()",
      "context.Load(customer, c => c.Orders)",
      "context.Orders.Where(o => o.CustomerId == customer.Id).ToList()",
      "customer.Orders.Include()"
    ],
    "answer": "context.Entry(customer).Collection(c => c.Orders).Load()",
    "explanation": "Explicit loading allows you to load related data on demand after the main entity is retrieved. The `Collection` method is used for collections, while `Reference` is used for singular navigation properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What does the `OnModelCreating` method in a `DbContext` class allow you to do?",
    "options": [
      "Intercept SQL queries before execution.",
      "Configure the shape of your model, relationships, and mappings using the Fluent API.",
      "Initialize the database connection string.",
      "Handle database connection failures."
    ],
    "answer": "Configure the shape of your model, relationships, and mappings using the Fluent API.",
    "explanation": "`OnModelCreating` is where the `ModelBuilder` is accessible. It is used to override conventions, set primary keys, configure relationships, and set up Fluent API configurations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the difference between `HasDefaultSchema` and `ToTable`?",
    "options": [
      "`HasDefaultSchema` sets the schema for the entire `DbContext`, while `ToTable` sets the specific table name for an entity.",
      "`HasDefaultSchema` sets the table name, while `ToTable` sets the schema.",
      "`HasDefaultSchema` is used for views, `ToTable` is for tables.",
      "There is no difference; they are aliases."
    ],
    "answer": "`HasDefaultSchema` sets the schema for the entire `DbContext`, while `ToTable` sets the specific table name for an entity.",
    "explanation": "`HasDefaultSchema` (e.g., `modelBuilder.HasDefaultSchema('hr')`) sets a prefix for all tables. `ToTable` allows specifying a specific table name, optionally including the schema explicitly (e.g., `'admin.Users'`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is 'Client-side Evaluation' in the context of older EF Core versions (pre-3.0)?",
    "options": [
      "Validating user input on the client browser.",
      "Fetching data into memory and performing LINQ operations that cannot be translated to SQL.",
      "Compiling the query on the client machine.",
      "Running business logic in JavaScript."
    ],
    "answer": "Fetching data into memory and performing LINQ operations that cannot be translated to SQL.",
    "explanation": "Client-side evaluation meant EF Core would pull all data into memory and finish filtering/projection in C# if it couldn't translate the LINQ to SQL. This was removed in 3.0 due to performance pitfalls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which exception is commonly thrown when calling `SaveChanges` if a database constraint (like a unique index) is violated?",
    "options": [
      "DbUpdateConcurrencyException",
      "DbUpdateException",
      "InvalidOperationException",
      "SqlNullValueException"
    ],
    "answer": "DbUpdateException",
    "explanation": "`DbUpdateException` wraps errors that occur while writing to the database, including constraint violations and command execution failures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the function of the `UseLazyLoadingProxies` extension method?",
    "options": [
      "It automatically implements the `ILazyLoader` service in the DbContext.",
      "It enables the creation of dynamic proxy classes for entities to enable lazy loading without explicit virtual navigation properties.",
      "It configures EF Core to use stored procedures for loading data.",
      "It turns off eager loading by default."
    ],
    "answer": "It enables the creation of dynamic proxy classes for entities to enable lazy loading without explicit virtual navigation properties.",
    "explanation": "When `UseLazyLoadingProxies` is called, EF Core uses a technique (IL weaving or dynamic proxies) to intercept property access on virtual navigation properties to load data from the database.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In EF Core, what is the `ChangeTracker.AutoDetectChangesEnabled` property used for?",
    "options": [
      "To enable schema migration detection.",
      "To disable the automatic scanning of entity instances for changes to improve performance during bulk operations.",
      "To turn off the validation of foreign keys.",
      "To disable the synchronization between the context and the database."
    ],
    "answer": "To disable the automatic scanning of entity instances for changes to improve performance during bulk operations.",
    "explanation": "Detecting changes involves scanning all tracked entities. During bulk updates or attaching large graphs, disabling this (setting to `false`) and manually calling `DetectChanges` can significantly improve performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "How do you map a C# `enum` property to a `string` column in the database using Fluent API?",
    "options": [
      "modelBuilder.Entity<MyEntity>().Property(e => e.Status).HasConversion<string>()",
      "modelBuilder.Entity<MyEntity>().Property(e => e.Status).HasColumnType('varchar')",
      "modelBuilder.Entity<MyEntity>().Property(e => e.Status).HasStringValue()",
      "modelBuilder.Entity<MyEntity>().Property(e => e.Status).IsUnicode(false)"
    ],
    "answer": "modelBuilder.Entity<MyEntity>().Property(e => e.Status).HasConversion<string>()",
    "explanation": "The `HasConversion` method configures a Value Converter. Passing `<string>` tells EF Core to convert the Enum to its string name representation for storage, rather than the default integer value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What does the `HasDiscriminator` method configure in Entity Framework Core?",
    "options": [
      "It sets up a rowversion column for concurrency checks.",
      "It configures the Table-per-Hierarchy (TPH) inheritance mapping strategy.",
      "It defines a unique index for a specific column.",
      "It configures soft-delete filtering logic."
    ],
    "answer": "It configures the Table-per-Hierarchy (TPH) inheritance mapping strategy.",
    "explanation": "TPH inheritance uses a single table for all types in a hierarchy. The discriminator column indicates which concrete type the row represents.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which method is used to execute a raw SQL command that returns non-entity types (e.g., a view model or scalar value)?",
    "options": [
      "context.Database.ExecuteSqlRaw",
      "context.Entities.FromSqlRaw",
      "context.Database.SqlQuery",
      "context.Set<Entity>().FromSqlInterpolated"
    ],
    "answer": "context.Database.SqlQuery",
    "explanation": "In EF Core 7.0+, `SqlQuery` is used for raw SQL queries that return scalar values or ad-hoc types (non-entities) without change tracking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the effect of configuring a navigation property as `IsRequired` in a one-to-many relationship?",
    "options": [
      "It ensures the foreign key column is nullable in the database schema.",
      "It ensures the foreign key column is non-nullable in the database schema.",
      "It creates a unique index on the foreign key column.",
      "It enables cascading delete by default."
    ],
    "answer": "It ensures the foreign key column is non-nullable in the database schema.",
    "explanation": "`IsRequired` signals to EF Core that the relationship is mandatory. Consequently, the foreign key constraint on the dependent entity is created as `NOT NULL`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What happens when you use `context.Database.EnsureDeleted()` followed by `context.Database.EnsureCreated()`?",
    "options": [
      "The database is dropped and recreated, losing all data.",
      "The database schema is updated incrementally without data loss.",
      "A new migration is generated based on the current model.",
      "The database connection is tested."
    ],
    "answer": "The database is dropped and recreated, losing all data.",
    "explanation": "`EnsureCreated` creates the database if it doesn't exist. Used after `EnsureDeleted`, it effectively provides a clean slate, which is useful for testing or prototyping but not production.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which EF Core feature allows you to map a single C# entity to multiple database tables (Table Splitting)?",
    "options": [
      "Using the `ToTable` method multiple times on the same entity.",
      "Using the `SplitToTable` method in Fluent API.",
      "Using `HasMany` with `WithOne`.",
      "Using Data Annotation `[Table]` on the class."
    ],
    "answer": "Using the `SplitToTable` method in Fluent API.",
    "explanation": "In EF Core 7.0+, `SplitToTable` allows an entity to be spread across multiple tables. Alternatively, older versions used complex mapping of multiple entities to the same table (Entity Splitting), but splitting one entity to many tables requires specific Fluent API calls in newer versions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the primary risk of using the `FromSqlRaw` or `FromSqlInterpolated` methods with user input?",
    "options": [
      "They generate SQL that cannot be parameterized, causing performance issues.",
      "If concatenated improperly (using `FromSqlRaw` with string concatenation), they are vulnerable to SQL Injection attacks.",
      "They disable change tracking automatically.",
      "They do not support complex types."
    ],
    "answer": "If concatenated improperly (using `FromSqlRaw` with string concatenation), they are vulnerable to SQL Injection attacks.",
    "explanation": "`FromSqlRaw` is safe if used with parameters. However, using standard C# string interpolation or concatenation to build the SQL string directly introduces SQL Injection risks. `FromSqlInterpolated` is generally preferred as it handles parameterization safely.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which configuration method prevents EF Core from creating a clustered index on the primary key?",
    "options": [
      "HasKey(x => x.Id).IsClustered(false)",
      "HasKey(x => x.Id).HasNoIndex()",
      "UseIdentityColumn()",
      "Ignore(x => x.Id)"
    ],
    "answer": "HasKey(x => x.Id).IsClustered(false)",
    "explanation": "By convention, SQL Server creates primary keys as clustered indexes. Using `.IsClustered(false)` in Fluent API overrides this behavior, useful if you want the clustered index on a different column.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "How can you check the SQL generated by EF Core for a query without actually executing it against the database?",
    "options": [
      "Use the `ToQueryString()` method on the `IQueryable` object.",
      "Use `context.Database.GenerateSQL()`.",
      "Use `ToString()` on the `DbContext`.",
      "Inspect the `DebugView` of the `ChangeTracker`."
    ],
    "answer": "Use the `ToQueryString()` method on the `IQueryable` object.",
    "explanation": "The `ToQueryString` extension method returns the SQL string that EF Core would generate for the query, allowing for debugging and analysis without execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is `ValueGenerationStrategy` in Fluent API used for?",
    "options": [
      "To define the default values for a column.",
      "To configure how the database generates values for a property (e.g., Identity, Sequence, HiLo).",
      "To set the concurrency token mode.",
      "To validate data types before insertion."
    ],
    "answer": "To configure how the database generates values for a property (e.g., Identity, Sequence, HiLo).",
    "explanation": "This configures the Value Generation strategy. It tells EF Core if the database (like SQL Server's Identity column) or the provider generates the value upon insertion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "When using `HasData` in Fluent API to seed data, what is a strict requirement regarding the entity properties?",
    "options": [
      "All navigation properties must be loaded.",
      "Only primary keys are required.",
      "All properties must be specified, or default values will be used for unspecified properties.",
      "The entity must have a public parameterless constructor."
    ],
    "answer": "Only primary keys are required.",
    "explanation": "While logical data seeding often requires full data, technically `HasData` requires primary keys to identify the rows for migration scripts, though other properties are usually needed for meaningful inserts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the difference between `SaveChanges` and `SaveChangesAsync`?",
    "options": [
      "`SaveChangesAsync` supports transactions while `SaveChanges` does not.",
      "`SaveChanges` executes synchronously, blocking the thread until the database finishes, while `SaveChangesAsync` allows the thread to be freed during the wait.",
      "`SaveChangesAsync` performs automatic change tracking, while `SaveChanges` requires manual calls to `DetectChanges`.",
      "`SaveChanges` is for SQL Server, while `SaveChangesAsync` is for PostgreSQL."
    ],
    "answer": "`SaveChanges` executes synchronously, blocking the thread until the database finishes, while `SaveChangesAsync` allows the thread to be freed during the wait.",
    "explanation": "`SaveChangesAsync` returns a Task and uses `await` to yield control back to the caller while the I/O operation completes. This is crucial for scalability in server applications.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of EF Core change tracking, what mechanism is used by default to detect changes made to entity properties?",
    "options": [
      "The `INotifyPropertyChanging` and `INotifyPropertyChanged` interfaces implemented by entities",
      "Snapshot comparison of entity data when `SaveChanges` is called",
      "SQL Server `Change Tracking` capabilities",
      "Interception of .NET property setters via dynamic proxies"
    ],
    "answer": "Snapshot comparison of entity data when `SaveChanges` is called",
    "explanation": "By default, EF Core uses snapshot change tracking, where it keeps a copy of the entity when queried and compares the current values to the snapshot when `SaveChanges` is invoked. Notification entities use `INotifyPropertyChanging`, but that is an optimization, not the default.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the primary performance benefit of using `AsNoTracking()` with a query in EF Core?",
    "options": [
      "It disables lazy loading for all entities",
      "It avoids the overhead of storing entities in the `ChangeTracker`",
      "It forces the query to execute asynchronously",
      "It converts the query to a raw SQL command"
    ],
    "answer": "It avoids the overhead of storing entities in the `ChangeTracker`",
    "explanation": "`AsNoTracking` tells EF Core not to cache the retrieved entities in the change tracker. This significantly reduces memory usage and processing time when the result set is large and the entities do not need to be updated.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "When using EF Core with a `DbContext`, what occurs if you call `Update()` on an entity that is already tracked by the context with a state of `Deleted`?",
    "options": [
      "The entity remains in the `Deleted` state",
      "The entity transitions to the `Modified` state",
      "An `InvalidOperationException` is thrown",
      "The entity transitions to the `Detached` state"
    ],
    "answer": "The entity transitions to the `Modified` state",
    "explanation": "Calling `Update` on an entity that is already being tracked forces the context to treat the entity as if it needs to be saved, overwriting the current state to `Modified` regardless of its previous state.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the function of the `HasQueryFilter` method in `OnModelCreating`?",
    "options": [
      "To create a filtered index in the database",
      "To automatically apply a predicate (WHERE clause) to all LINQ queries targeting that entity type",
      "To enforce a check constraint at the database level",
      "To validate query parameters before execution"
    ],
    "answer": "To automatically apply a predicate (WHERE clause) to all LINQ queries targeting that entity type",
    "explanation": "Global query filters allow developers to define a LINQ predicate that is automatically applied to any query involving a specific entity type, commonly used for implementing soft-delete (e.g., `IsDeleted = false`).",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "How does EF Core handle relationships if you delete a principal entity (e.g., Author) while the dependents (e.g., Books) are still loaded in the context and the foreign key is nullable?",
    "options": [
      "It sets the foreign key of the dependents to null",
      "It deletes the dependent entities automatically",
      "It throws a `DbUpdateConcurrencyException`",
      "It detaches the dependent entities from the context"
    ],
    "answer": "It sets the foreign key of the dependents to null",
    "explanation": "By default, if a relationship is optional (nullable FK), deleting the principal will sever the relationship by setting the dependent's foreign key to null. If the relationship is required (non-nullable), EF Core would issue a DELETE for the dependents (cascade delete).",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "Which LINQ operator is necessary in an EF Core query to project the results into an anonymous type or DTO while preventing 'Client Evaluation' warnings in EF Core 3.0+?",
    "options": [
      "`Select()`",
      "`Include()`",
      "`Where()`",
      "`AsEnumerable()`"
    ],
    "answer": "`Select()`",
    "explanation": "In EF Core 3.0+, client evaluation is disabled by default. You must use `Select` to project data directly in the SQL query. Using `AsEnumerable` switches to client-side evaluation immediately, which is often inefficient.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the purpose of the `IExecutionStrategy` interface in EF Core?",
    "options": [
      "To handle connection pooling and multiplexing",
      "To define a retry policy for transient database failures",
      "To intercept and modify generated SQL commands",
      "To manage database schema migrations"
    ],
    "answer": "To define a retry policy for transient database failures",
    "explanation": "`IExecutionStrategy` defines a mechanism to execute a database command with retry logic (e.g., `EnableRetryOnFailure`), ensuring the app can recover from temporary network blips or database deadlocks.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the default behavior of EF Core when a navigation property is modified on a tracked entity without explicitly calling `Update` or modifying the foreign key property?",
    "options": [
      "The relationship is not persisted",
      "The change is detected and persisted during `SaveChanges`",
      "An `InvalidOperationException` is thrown",
      "The context must reload the entity to see the change"
    ],
    "answer": "The change is detected and persisted during `SaveChanges`",
    "explanation": "The change tracker automatically detects changes to navigation properties (relationships) and fixes the foreign keys during `DetectChanges`, which runs before `SaveChanges`.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Which method is used to configure an Entity to map to a specific database view instead of a table using Fluent API?",
    "options": [
      "`ToTable(\"ViewName\")`",
      "`ToView(\"ViewName\")`",
      "`HasDatabaseFunction(\"ViewName\")`",
      "`MapToView(\"ViewName\")`"
    ],
    "answer": "`ToView(\"ViewName\")`",
    "explanation": "`ToView` is the Fluent API method specifically designed to map an entity to a database view. Using `ToTable` works for tables, but `ToView` is semantically clearer and prevents EF Core from trying to create migration scripts for updates on that object.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "In EF Core, what is a 'Shadow Property'?",
    "options": [
      "A property that exists in the database but is hidden from the entity class",
      "A property defined in `OnModelCreating` that does not exist as a property in the .NET entity class",
      "A private field marked with the `[NotMapped]` attribute",
      "A property that is excluded from SQL SELECT statements"
    ],
    "answer": "A property defined in `OnModelCreating` that does not exist as a property in the .NET entity class",
    "explanation": "Shadow properties are defined only in the EF Core model (via Fluent API or Data Annotations) but are not declared in the C# entity class. They are often used for Foreign Keys or audit columns (e.g., `UpdatedDate`).",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What happens when you use `Attach` on an entity graph where a related child entity does not exist in the database but has a primary key set?",
    "options": [
      "The child is added to the context as `Added`",
      "The child is attached as `Unchanged`",
      "A `DbUpdateException` is thrown on `SaveChanges`",
      "The entire graph is ignored"
    ],
    "answer": "The child is attached as `Unchanged`",
    "explanation": "`Attach` attaches everything in the graph as `Unchanged` by default. If the child actually doesn't exist in the DB (even though it has a key), `SaveChanges` will fail because it tries to update (or do nothing to) a non-existent record.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which interface must be implemented to create a custom EF Core Core Type (Scalar) mapping for a provider?",
    "options": [
      "`IEntityTypeConfiguration`",
      "`IValueConverter`",
      "`ITypeMappingSource`",
      "`IMaterializationInterceptor`"
    ],
    "answer": "`ITypeMappingSource`",
    "explanation": "`ITypeMappingSource` is used by database providers to map .NET types to database types. `IValueConverter` is used to convert values, but `ITypeMappingSource` determines the *type* mapping (e.g., string to varchar vs text).",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the effect of setting `PropertyAccessMode.PreferFieldDuringConstruction`?",
    "options": [
      "EF Core will ignore property setters and access the backing field directly",
      "EF Core will only use fields when instantiating entities, but use properties for tracking changes",
      "It forces the use of the `IProperty` interface instead of reflection",
      "It disables lazy loading"
    ],
    "answer": "EF Core will only use fields when instantiating entities, but use properties for tracking changes",
    "explanation": "This mode optimizes performance by using fields to populate the entity object (bypassing logic in property setters), while still using properties for change tracking.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "When scaffolding a `DbContext` from an existing database (Database First), which CLI command is used?",
    "options": [
      "`dotnet ef dbcontext scaffold`",
      "`dotnet ef migrations add`",
      "`dotnet ef database update`",
      "`dotnet ef script generate`"
    ],
    "answer": "`dotnet ef dbcontext scaffold`",
    "explanation": "`dotnet ef dbcontext scaffold` is the command to reverse-engineer entity classes and a `DbContext` from an existing database schema.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is 'Table Per Hierarchy' (TPH) mapping in Entity Framework?",
    "options": [
      "Mapping each derived entity to its own distinct table with a foreign key",
      "Mapping all derived types to a single table with a discriminator column",
      "Mapping abstract base classes to a view and concrete classes to tables",
      "Splitting a single entity across multiple tables vertically"
    ],
    "answer": "Mapping all derived types to a single table with a discriminator column",
    "explanation": "TPH is the default inheritance strategy in EF Core where a single database table stores all types in the hierarchy, using a discriminator column to identify the specific type for each row.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which method ensures that a specific relationship is required (i.e., the foreign key is non-nullable) using Fluent API?",
    "options": [
      "`IsRequired()`",
      "`HasPrincipalKey()`",
      "`WithOne()`",
      "`HasForeignKey()`"
    ],
    "answer": "`IsRequired()`",
    "explanation": "The `IsRequired()` method is called on a relationship navigation to configure the dependency such that the foreign key property must have a value (non-nullable).",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In the context of EF Core Migrations, what is the purpose of the `__EFMigrationsHistory` table?",
    "options": [
      "To store a history of all data changes made by users",
      "To track which migrations have been applied to the specific database",
      "To store the source code of the migration classes",
      "To log the duration of each migration execution"
    ],
    "answer": "To track which migrations have been applied to the specific database",
    "explanation": "This table is created by EF Core to maintain the state of the database, ensuring that each migration script is run only once and in the correct order.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What does the `FromSqlRaw` method allow you to do?",
    "options": [
      "Execute a stored procedure or raw SQL query returning entities",
      "Execute a non-query SQL command (e.g., DELETE) without tracking",
      "Switch the database connection to a raw TCP socket",
      "Generate SQL scripts for migrations"
    ],
    "answer": "Execute a stored procedure or raw SQL query returning entities",
    "explanation": "`FromSqlRaw` is used on `DbSet` to execute a SQL query that returns entity instances. The results are still tracked by the context by default. For non-queries, `ExecuteSqlRaw` is used.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "Which feature in EF Core 7.0+ allows performing bulk updates (UPDATE) without loading entities into memory?",
    "options": [
      "`ExecuteUpdate`",
      "`UpdateRange`",
      "`BulkUpdate` (from EFCore.BulkExtensions)",
      "`Attach` followed by `SaveChanges`"
    ],
    "answer": "`ExecuteUpdate`",
    "explanation": "`ExecuteUpdate` (and `ExecuteDelete`) are built-in methods in EF Core 7+ that translate directly to SQL UPDATE/DELETE statements, operating directly on the database without fetching entities into the Change Tracker.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the 'N+1 Query Problem' in the context of ORM usage?",
    "options": [
      "Executing 1 query for the parent and N separate queries for related children",
      "Executing N queries for the parent and 1 query for the children",
      "Retrieving N times more data than needed from the database",
      "Using `Select` projections N times on the same entity"
    ],
    "answer": "Executing 1 query for the parent and N separate queries for related children",
    "explanation": "The N+1 problem occurs when iterating over a list of items and triggering a separate database query for every single item to fetch a related entity, instead of fetching all related data in a single join.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does `DbContextServiceLifetime.Transient` differ from `Scoped` when registering `DbContext` in Dependency Injection?",
    "options": [
      "Transient creates a new instance for every component injection, causing potential `DbContext` disposal issues",
      "Transient creates a new instance per HTTP request",
      "Scoped instances are faster but not thread-safe",
      "Transient allows cross-database transactions automatically"
    ],
    "answer": "Transient creates a new instance for every component injection, causing potential `DbContext` disposal issues",
    "explanation": "While `Scoped` (the default) creates one instance per request scope, `Transient` creates a new instance every time it is injected. This can lead to `ObjectDisposedException` if an injected context is disposed while another part of the request is still trying to use it.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the purpose of the `HasDefaultValueSql` method in Fluent API?",
    "options": [
      "To set the default value for a property in the C# class",
      "To specify a SQL expression (e.g., `GETDATE()`) used as the column's default value in the database",
      "To validate data before it is sent to the database",
      "To create a default check constraint for the entity"
    ],
    "answer": "To specify a SQL expression (e.g., `GETDATE()`) used as the column's default value in the database",
    "explanation": "`HasDefaultValueSql` is used in migrations to set the database-side default constraint for a column, allowing for SQL functions like `NEWID()` or `GETDATE()`.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Which method is used to explicitly load a navigation property that was not included in the original query (Explicit Loading)?",
    "options": [
      "`context.Entry(entity).Reference(e => e.Nav).Load()`",
      "`context.Collection().Include(e => e.Nav)`",
      "`context.Attach(entity)`",
      "`context.Find()`"
    ],
    "answer": "`context.Entry(entity).Reference(e => e.Nav).Load()`",
    "explanation": "Explicit loading is performed by retrieving the entity entry and calling `Load()` on the `Reference` (for single navigation) or `Collection` (for collection navigation) property.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "In EF Core, what does the `ValueGeneratedOnAdd` annotation or configuration indicate?",
    "options": [
      "The property value must be manually set before saving",
      "The database generates the value only when the entity is added",
      "The value is generated by the client application",
      "The value is generated on both Add and Update"
    ],
    "answer": "The database generates the value only when the entity is added",
    "explanation": "This configuration indicates that the value for this property is generated by the database (e.g., Identity columns or Sequences) only during the insert operation.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the difference between `UseSqlite` and `UseInMemoryDatabase` for testing?",
    "options": [
      "UseInMemoryDatabase supports relational behavior while UseSqlite does not",
      "UseSqlite provides behavior closer to a real relational database (e.g., constraints) than InMemory",
      "UseInMemoryDatabase requires a server to be running",
      "UseSqlite is async by default"
    ],
    "answer": "UseSqlite provides behavior closer to a real relational database (e.g., constraints) than InMemory",
    "explanation": "The In-Memory provider is not a relational database and ignores many constraints (Foreign Keys, Unique), whereas SQLite is a real engine that enforces relational integrity, making it a better choice for integration testing.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "When using `IDesignTimeDbContextFactory`, what is the specific use case?",
    "options": [
      "To create a context for runtime usage in ASP.NET Core",
      "To enable design-time tools (like migrations) to create a context when the Startup configuration is unavailable",
      "To replace the standard `DbContext` constructor",
      "To implement a custom connection pooling strategy"
    ],
    "answer": "To enable design-time tools (like migrations) to create a context when the Startup configuration is unavailable",
    "explanation": "When running EF Core CLI tools in a Console Class Library or a project with complex startup logic (e.g., Blazor), the tools may fail to construct the `DbContext`. `IDesignTimeDbContextFactory` provides a specific way to build the context solely for design-time operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Which mechanism helps prevent the 'Cartesian Explosion' problem when querying multiple `Include` statements on collections in EF Core?",
    "options": [
      "Using `AsSplitQuery()`",
      "Using `AsNoTracking()`",
      "Using `Distinct()`",
      "Using `GroupBy()`"
    ],
    "answer": "Using `AsSplitQuery()`",
    "explanation": "`AsSplitQuery()` translates a single LINQ query with multiple `Include` collections into separate SQL queries for each collection. This prevents the database from returning a massive multiplication of rows (Cartesian product) to join all collections.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the primary consequence of setting `context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking`?",
    "options": [
      "It prevents any `WHERE` clauses from being applied",
      "It makes all queries read-only (entities are not tracked for updates)",
      "It disables the generation of SQL parameters",
      "It forces all queries to be executed synchronously"
    ],
    "answer": "It makes all queries read-only (entities are not tracked for updates)",
    "explanation": "Setting this behavior to `NoTracking` globally ensures that every query executed by this context does not track the returned entities, making updates impossible without re-attaching, but significantly improving read performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What does the `HasIndex` method in Fluent API allow you to define?",
    "options": [
      "Primary keys only",
      "Foreign key constraints",
      "Indexes on columns to improve query performance or enforce uniqueness",
      "The data type of a column"
    ],
    "answer": "Indexes on columns to improve query performance or enforce uniqueness",
    "explanation": "`HasIndex` is used to configure database indexes on specific properties. It can be chained with `.IsUnique()` to create unique indexes.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is 'Owned Entity Type' configuration primarily used for in EF Core?",
    "options": [
      "Mapping inheritance hierarchies",
      "Mapping value objects (DDD) where the entity does not have its own identity and is owned by a parent",
      "Defining many-to-many relationships",
      "Configuring database views"
    ],
    "answer": "Mapping value objects (DDD) where the entity does not have its own identity and is owned by a parent",
    "explanation": "Owned types map CLR classes to the same table as the owner (by default) and represent concepts like Addresses or Money, where the identity of the object is solely dependent on the parent entity.",
    "difficulty": "Advanced"
  }
]