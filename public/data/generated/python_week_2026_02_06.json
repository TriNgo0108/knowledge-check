[
  {
    "id": 1,
    "question": "What is the primary function of the Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "To allow multiple threads to execute Python bytecodes simultaneously on multi-core CPUs",
      "To prevent memory leaks by locking objects during garbage collection",
      "To ensure only one thread executes Python bytecode at a time, simplifying memory management",
      "To compile Python code into machine code for faster execution"
    ],
    "answer": "To ensure only one thread executes Python bytecode at a time, simplifying memory management",
    "explanation": "The GIL is a mutex that prevents multiple native threads from executing Python bytecodes simultaneously, which simplifies CPython's memory management by making object access thread-safe. It limits CPU-bound parallelism but effectively handles I/O-bound tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which of the following data types is immutable in Python?",
    "options": [
      "List",
      "Dictionary",
      "Set",
      "Tuple"
    ],
    "answer": "Tuple",
    "explanation": "Tuples are immutable sequences, meaning their contents cannot be changed after creation. Lists, dictionaries, and sets are mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "How does Python primarily manage memory allocation and deallocation?",
    "options": [
      "Manual memory management using malloc and free",
      "Automatic garbage collection without reference counting",
      "Reference counting augmented by a cyclic garbage collector",
      "A single generational garbage collector without reference counting"
    ],
    "answer": "Reference counting augmented by a cyclic garbage collector",
    "explanation": "Python primarily uses reference counting, where objects are deallocated immediately when their reference count reaches zero. A generational garbage collector handles reference cycles (circular references) that reference counting cannot resolve.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the output of the following code: print(type(1) is int)?",
    "options": [
      "True",
      "False",
      "TypeError",
      "SyntaxError"
    ],
    "answer": "True",
    "explanation": "In Python, types are objects. type(1) returns the class int, and the is operator confirms that int is indeed the int class.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which keyword is used to define a function in Python?",
    "options": [
      "function",
      "func",
      "def",
      "define"
    ],
    "answer": "def",
    "explanation": "The def keyword introduces a function definition in Python, followed by the function name and parentheses.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What character is used to denote a comment in a Python script?",
    "options": [
      "//",
      "#",
      "/*",
      "--"
    ],
    "answer": "#",
    "explanation": "The hash symbol (#) is used for single-line comments in Python. Everything following # on that line is ignored by the interpreter.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which of the following is a correct syntax to create a list in Python?",
    "options": [
      "list = (1, 2, 3)",
      "list = [1, 2, 3]",
      "list = {1, 2, 3}",
      "list = <1, 2, 3>"
    ],
    "answer": "list = [1, 2, 3]",
    "explanation": "Square brackets [] are used to define lists in Python. Parentheses () denote tuples, and curly braces {} denote dictionaries or sets.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What happens when you attempt to access a key in a dictionary that does not exist?",
    "options": [
      "It returns None",
      "It returns 0",
      "It raises a KeyError",
      "It raises an IndexError"
    ],
    "answer": "It raises a KeyError",
    "explanation": "Accessing a non-existent key directly (e.g., my_dict['key']) raises a KeyError. The .get() method can be used to return a default value (None) instead.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which operator is used for floor division in Python?",
    "options": [
      "/",
      "//",
      "%",
      "%%"
    ],
    "answer": "//",
    "explanation": "The // operator performs floor division, which divides the operands and returns the largest integer less than or equal to the result. / performs standard (true) division.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the result of bool([]) (checking the boolean value of an empty list)?",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "answer": "False",
    "explanation": "In Python, empty sequences (lists, tuples, strings) and collections (dictionaries, sets) evaluate to False in a boolean context.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which statement is used to exit a loop prematurely in Python?",
    "options": [
      "stop",
      "exit",
      "break",
      "return"
    ],
    "answer": "break",
    "explanation": "The break statement terminates the current loop immediately. return exits a function, and stop/exit are not Python keywords for loop control.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the purpose of the self parameter in a class method definition?",
    "options": [
      "To refer to the class itself",
      "To refer to the instance of the class calling the method",
      "To create a static variable",
      "To import external libraries"
    ],
    "answer": "To refer to the instance of the class calling the method",
    "explanation": "self represents the instance of the object. By convention, it is passed as the first argument to instance methods to access instance attributes and methods.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which of the following correctly imports a module named os?",
    "options": [
      "#include os",
      "import os",
      "require os",
      "using os"
    ],
    "answer": "import os",
    "explanation": "Python uses the import keyword to make modules available in the current namespace.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the output of the string operation: 'Py' * 3?",
    "options": [
      "Py3",
      "PyPyPy",
      "3Py",
      "Error"
    ],
    "answer": "PyPyPy",
    "explanation": "Multiplying a sequence (like a string or list) by an integer n repeats the sequence n times.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which built-in function returns the length of an object?",
    "options": [
      "length()",
      "size()",
      "len()",
      "count()"
    ],
    "answer": "len()",
    "explanation": "len() is the built-in function used to return the number of items in a container (list, tuple, string, dict, etc.).",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "How do you create an inheritance relationship where ClassB inherits from ClassA?",
    "options": [
      "class ClassB inherits ClassA:",
      "class ClassB(ClassA):",
      "class ClassB extends ClassA:",
      "class ClassB -> ClassA:"
    ],
    "answer": "class ClassB(ClassA):",
    "explanation": "Python uses a class definition syntax where the parent class is passed in parentheses immediately after the child class name.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What does the finally block in a try-except-finally structure do?",
    "options": [
      "Executes only if no exception occurs",
      "Executes only if an exception occurs",
      "Executes regardless of whether an exception occurred or not",
      "Stops the program execution"
    ],
    "answer": "Executes regardless of whether an exception occurred or not",
    "explanation": "The finally block is always executed, providing a clean-up mechanism that runs even if an unhandled exception causes the program to crash.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which data type uses a Key-Value pair structure?",
    "options": [
      "List",
      "Tuple",
      "Dictionary",
      "Set"
    ],
    "answer": "Dictionary",
    "explanation": "Dictionaries (dict) store data in key-value pairs, allowing for efficient retrieval of values based on their unique keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the correct syntax for an f-string (formatted string literal) in Python 3?",
    "options": [
      "format('Value: {x}')",
      "'Value: %s' % x",
      "f'Value: {x}'",
      "'Value: {x}'.format(x)"
    ],
    "answer": "f'Value: {x}'",
    "explanation": "Introduced in Python 3.6, f-strings prefix the string literal with 'f' and allow expressions to be embedded directly within curly braces.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which concept describes a situation where two objects reference each other, preventing reference counting from reclaiming their memory?",
    "options": [
      "Memory fragmentation",
      "Circular reference",
      "Race condition",
      "Memory leak"
    ],
    "answer": "Circular reference",
    "explanation": "A circular (or cyclic) reference occurs when object A references object B, and object B references object A. Their reference counts never reach zero, requiring the cyclic garbage collector to clean them up.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the default behavior of a function that does not have a return statement?",
    "options": [
      "It returns 0",
      "It returns an empty string",
      "It returns None",
      "It raises a SyntaxError"
    ],
    "answer": "It returns None",
    "explanation": "If a function finishes executing without hitting a return statement, it implicitly returns the None object.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which method is called automatically when an object is created?",
    "options": [
      "__init__",
      "__new__",
      "__str__",
      "__create__"
    ],
    "answer": "__init__",
    "explanation": "__init__ is the class constructor method that initializes the object's attributes after it has been created (__new__).",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is the output of range(3)?",
    "options": [
      "[1, 2, 3]",
      "[0, 1, 2, 3]",
      "[0, 1, 2]",
      "(0, 1, 2)"
    ],
    "answer": "[0, 1, 2]",
    "explanation": "range(stop) generates numbers from 0 up to (but not including) stop. It returns a range object (which acts like a sequence) containing 0, 1, 2.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which comparison operator checks if two variables point to the same object in memory?",
    "options": [
      "==",
      "===",
      "is",
      "equals"
    ],
    "answer": "is",
    "explanation": "The is operator checks for identity (same memory location), whereas == checks for equality (same value).",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "How do you start a function definition that accepts any number of positional arguments?",
    "options": [
      "def func(*args):",
      "def func(**kwargs):",
      "def func(&args):",
      "def func(args...):"
    ],
    "answer": "def func(*args):",
    "explanation": "The * syntax in a function definition collects variable positional arguments into a tuple.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the result of set([1, 1, 2, 2, 3])?",
    "options": [
      "{1, 2, 2, 3}",
      "{1, 1, 2, 3}",
      "{1, 2, 3}",
      "[1, 2, 3]"
    ],
    "answer": "{1, 2, 3}",
    "explanation": "A set is an unordered collection of unique elements. Duplicate values are automatically removed.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which keyword is used to define a generator function?",
    "options": [
      "yield",
      "return",
      "generator",
      "async"
    ],
    "answer": "yield",
    "explanation": "Using yield inside a function makes it a generator function, which returns an iterator that yields values one at a time.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the correct file extension for Python source code files?",
    "options": [
      ".python",
      ".py",
      ".pt",
      ".pyt"
    ],
    "answer": ".py",
    "explanation": "The standard file extension for Python source code is .py.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which built-in function reads a line from standard input?",
    "options": [
      "scan()",
      "input()",
      "read()",
      "get()"
    ],
    "answer": "input()",
    "explanation": "The input() function pauses program execution to wait for user input from the console.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What happens if you modify a list while iterating over it with a for loop?",
    "options": [
      "Python automatically creates a copy of the list",
      "The loop runs infinitely",
      "Items may be skipped or processed incorrectly",
      "It raises a TypeError"
    ],
    "answer": "Items may be skipped or processed incorrectly",
    "explanation": "Modifying a mutable sequence (like a list) while iterating over it changes the indices and size, often leading to unexpected behavior like skipping elements.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which statement regarding the GIL and I/O operations is correct?",
    "options": [
      "The GIL prevents I/O operations from running in parallel.",
      "The GIL is released during I/O operations, allowing other threads to run.",
      "I/O operations must run in separate processes to function.",
      "The GIL only locks I/O bound tasks."
    ],
    "answer": "The GIL is released during I/O operations, allowing other threads to run.",
    "explanation": "The GIL is released when performing I/O operations (like reading a file or network request), allowing other Python threads to execute code while waiting for the I/O to complete.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What does the `pass` keyword do in Python?",
    "options": [
      "It skips the next iteration of a loop",
      "It acts as a placeholder for a function or class body that does nothing",
      "It exits the program immediately",
      "It raises an exception to be caught later"
    ],
    "answer": "It acts as a placeholder for a function or class body that does nothing",
    "explanation": "pass is a null operation; when executed, nothing happens. It is required when a statement is needed syntactically but no code is to be executed.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which Python feature allows code to iterate over a sequence of elements one by one without needing to know the underlying index?",
    "options": [
      "Recursion",
      "Generators",
      "Iteration Protocol",
      "Slice notation"
    ],
    "answer": "Iteration Protocol",
    "explanation": "The Iteration Protocol (using __iter__ and __next__) allows objects to be iterable. This enables the for loop to traverse items regardless of their underlying implementation.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the result of `10 // 3`?",
    "options": [
      "3.33",
      "3",
      "4",
      "1"
    ],
    "answer": "3",
    "explanation": "The // operator performs floor division. 10 divided by 3 is 3.33, and the floor of that is 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which variable scope is searched first when looking up a name in a function?",
    "options": [
      "Global scope",
      "Built-in scope",
      "Local scope",
      "Enclosing scope"
    ],
    "answer": "Local scope",
    "explanation": "Python follows the LEGB rule: Local, Enclosing, Global, Built-in. The interpreter checks the local scope first.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Why does the Global Interpreter Lock (GIL) in CPython inhibit parallelism for CPU-bound multi-threaded programs?",
    "options": [
      "The GIL prevents multiple threads from acquiring memory simultaneously.",
      "The GIL ensures only one thread executes Python bytecode at a time, regardless of CPU cores.",
      "The GIL serializes I/O operations, forcing threads to wait for disk access.",
      "The GIL requires all threads to run on the same CPU core."
    ],
    "answer": "The GIL ensures only one thread executes Python bytecode at a time, regardless of CPU cores.",
    "explanation": "The GIL is a mutex that prevents multiple native threads from executing Python bytecodes at once. While I/O-bound threads release it, CPU-bound threads contend for it, serializing execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which mechanism is primarily used in CPython to manage memory allocation immediately when an object's reference count drops to zero?",
    "options": [
      "Mark-and-Sweep Garbage Collection",
      "Reference Counting",
      "Stop-the-world Pauses",
      "Biased Reference Counting"
    ],
    "answer": "Reference Counting",
    "explanation": "CPython primarily uses reference counting; memory is deallocated immediately when `ob_refcnt` hits zero. The cyclic garbage collector is a secondary mechanism to handle reference cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary limitation of CPython's standard reference counting mechanism that necessitates a cyclic garbage collector?",
    "options": [
      "It cannot handle memory leaks caused by unlinked nodes.",
      "It fails to deallocate objects involved in circular reference cycles.",
      "It is too slow for high-throughput network applications.",
      "It requires manual memory management for large objects."
    ],
    "answer": "It fails to deallocate objects involved in circular reference cycles.",
    "explanation": "If object A references object B, and B references A, their reference counts never reach zero despite being inaccessible from the root. The cyclic GC detects and breaks these cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of PEP 703 and the 'nogil' build, what is the specific function of 'Biased Reference Counting'?",
    "options": [
      "To completely remove the need for a garbage collector.",
      "To allow reference counts to be modified without atomic operations by assuming a 'owning' thread.",
      "To force all threads to share a single reference counter for every object.",
      "To prioritize I/O bound threads over CPU-bound threads."
    ],
    "answer": "To allow reference counts to be modified without atomic operations by assuming a 'owning' thread.",
    "explanation": "Biased reference counting optimizes performance by allowing a thread to modify refcounts non-atomically if it 'owns' the object, reducing the synchronization overhead required in a thread-safe environment.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which types of objects are tracked by the CPython cyclic garbage collector by default?",
    "options": [
      "Only user-defined class instances.",
      "Container objects (lists, dicts, classes) that can contain references to other objects.",
      "All objects allocated on the heap.",
      "Primitive types like integers and strings."
    ],
    "answer": "Container objects (lists, dicts, classes) that can contain references to other objects.",
    "explanation": "Only container objects capable of creating reference cycles are tracked. Simple types like integers or strings (which cannot reference other objects) are not tracked.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the 'nogil' CPython implementation change the behavior of the Garbage Collector regarding world-pausing?",
    "options": [
      "It removes the need for garbage collection entirely.",
      "It introduces 'stop-the-world' pauses where no other threads can run during the GC cycle.",
      "It runs the GC in a separate process without pausing the main application.",
      "It makes the GC concurrent, allowing it to run simultaneously with application threads."
    ],
    "answer": "It introduces 'stop-the-world' pauses where no other threads can run during the GC cycle.",
    "explanation": "Without the GIL to freeze object states, the nogil GC must use 'stop-the-world' pauses to ensure stable object graphs while scanning for cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the primary architectural change proposed in PEP 703 regarding the Generational GC in a 'nogil' CPython?",
    "options": [
      "The GC becomes strictly generational to improve performance.",
      "The GC implementation becomes non-generational, scanning all objects in every cycle.",
      "The GC is replaced by a mark-and-sweep algorithm.",
      "The GC only runs when the application explicitly calls it."
    ],
    "answer": "The GC implementation becomes non-generational, scanning all objects in every cycle.",
    "explanation": "The context states the new NOGIL GC implementation is non-generational, meaning it scans the entire object graph every cycle rather than segregating objects by generation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In CPython's memory management, what is the specific role of the `mimalloc` allocator in the 'nogil' effort?",
    "options": [
      "It replaces the Python memory manager entirely.",
      "It allows finding all Python objects without maintaining a linked list.",
      "It provides a faster implementation of the dictionary data structure.",
      "It automatically detects reference cycles."
    ],
    "answer": "It allows finding all Python objects without maintaining a linked list.",
    "explanation": "Mimalloc's internal structures can be traversed to locate objects, eliminating the overhead of maintaining a separate linked list of all Python objects for the garbage collector.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What happens when a Python thread encounters an I/O operation (like `time.sleep` or a socket read) under the standard GIL?",
    "options": [
      "The GIL is released, allowing other threads to run.",
      "The thread terminates and releases its resources.",
      "The GIL remains locked, blocking all other threads.",
      "The thread switches to a new process."
    ],
    "answer": "The GIL is released, allowing other threads to run.",
    "explanation": "The GIL is released during I/O operations to prevent blocking the entire interpreter while waiting for external resources, enabling concurrency for I/O-bound tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "Which method is invoked when an object is about to be created, responsible for allocating memory and returning the instance?",
    "options": [
      "`__init__`",
      "`__new__`",
      "`__create__`",
      "`__del__`"
    ],
    "answer": "`__new__`",
    "explanation": "`__new__` is a static method responsible for creating the instance (allocating memory). `__init__` is called after `__new__` to initialize the created object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the consequence of using a mutable object (like a list) as a default argument in a function definition?",
    "options": [
      "The function raises a SyntaxError.",
      "The default argument is evaluated once at function definition time and shared across calls.",
      "The argument is deep-copied on every function call.",
      "The argument is immutable and cannot be changed."
    ],
    "answer": "The default argument is evaluated once at function definition time and shared across calls.",
    "explanation": "Default values are evaluated only once when the function is defined. Mutating the default object in one call persists that change for subsequent calls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the resolution order for attribute access on a class in Python 3 (C3 Linearization)?",
    "options": [
      "Depth-first, left-to-right (DFLR).",
      "Breadth-first search (BFS).",
      "Monotonic C3 Linearization (MRO).",
      "Random order based on hash values."
    ],
    "answer": "Monotonic C3 Linearization (MRO).",
    "explanation": "Python 3 uses the C3 Linearization algorithm to determine the Method Resolution Order, which preserves local precedence ordering and monotonicity, unlike the old DFS method.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "In Python's `asyncio` library, what is the function of `await`?",
    "options": [
      "To block the thread until a result is ready.",
      "To pause the execution of the coroutine, yielding control back to the event loop.",
      "To start a new thread.",
      "To convert a function into a coroutine."
    ],
    "answer": "To pause the execution of the coroutine, yielding control back to the event loop.",
    "explanation": "`await` suspends the coroutine's execution, allowing the event loop to run other tasks. It does not block the thread; it waits asynchronously.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What distinguishes a `list` from a `tuple` in Python regarding memory usage and mutability?",
    "options": [
      "Lists are immutable and use less memory; tuples are mutable and use more memory.",
      "Tuples are immutable and generally consume less memory than lists.",
      "Lists and tuples are identical in memory usage and mutability.",
      "Tuples are mutable and stored on the stack."
    ],
    "answer": "Tuples are immutable and generally consume less memory than lists.",
    "explanation": "Tuples are immutable (cannot be changed after creation) and have a smaller memory footprint than lists because they lack the overhead required for dynamic resizing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How does Python handle integer caching, specifically for small integers?",
    "options": [
      "Every integer creates a new object.",
      "Integers between -5 and 256 are cached and reused.",
      "Only positive integers are cached.",
      "Integers are never cached."
    ],
    "answer": "Integers between -5 and 256 are cached and reused.",
    "explanation": "CPython pre-allocates an array of integer objects for the range -5 to 256. References to these values point to the same singleton object rather than creating new ones.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the result of comparing two different objects with the same value using the `is` operator?",
    "options": [
      "True, if their values are equal.",
      "False, because `is` checks identity (memory address), not equality.",
      "True, because Python optimizes storage.",
      "None, because `is` cannot be used on objects."
    ],
    "answer": "False, because `is` checks identity (memory address), not equality.",
    "explanation": "The `is` operator checks if two variables point to the exact same object in memory. The `==` operator checks for value equality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which built-in function allows you to inspect the attributes and methods of an object dynamically?",
    "options": [
      "`inspect()`",
      "`dir()`",
      "`attributes()`",
      "`help()`"
    ],
    "answer": "`dir()`",
    "explanation": "`dir()` attempts to return a list of valid attributes and methods of an object. `help()` provides documentation, but `dir()` provides the programmatic list of names.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the correct way to define a property in a class that allows computed access while keeping the interface attribute-like?",
    "options": [
      "Using the `@property` decorator on a getter method.",
      "Defining a method with the same name as the attribute.",
      "Using the `__getattr__` magic method.",
      "Using a public variable."
    ],
    "answer": "Using the `@property` decorator on a getter method.",
    "explanation": "The `@property` decorator transforms a method into a 'getter' for a read-only attribute accessed like `obj.attr`. It allows logic to execute during attribute access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Why are dictionary lookups generally faster than list lookups in Python?",
    "options": [
      "Dictionaries use a hash table for O(1) average access time.",
      "Lists are stored on disk.",
      "Dictionaries use binary search for O(log n) access.",
      "Lists must scan every element sequentially."
    ],
    "answer": "Dictionaries use a hash table for O(1) average access time.",
    "explanation": "Dicts implement hash tables where keys are hashed to specific memory locations, allowing for constant-time retrieval. Lists require O(n) time to find an element by value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the purpose of the `__slots__` declaration in a class?",
    "options": [
      "To define the allowed method names.",
      "To save memory by preventing the creation of a dynamic `__dict__` and restricting attribute creation.",
      "To make the class iterable.",
      "To enable multiple inheritance."
    ],
    "answer": "To save memory by preventing the creation of a dynamic `__dict__` and restricting attribute creation.",
    "explanation": "`__slots__` reserves space for a fixed set of attributes, eliminating the per-instance `__dict__` which significantly reduces memory usage for classes with many instances.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In the context of Python's `multiprocessing` module, how is data shared between processes?",
    "options": [
      "Through the shared heap (standard objects).",
      "Via explicit inter-process communication mechanisms like Queues or Pipes.",
      "Processes share all global variables automatically.",
      "Data is copied only once at the start of the program."
    ],
    "answer": "Via explicit inter-process communication mechanisms like Queues or Pipes.",
    "explanation": "Processes have separate memory spaces. Standard objects are not shared; data must be pickled (serialized) and sent via IPC mechanisms (Queue, Pipe) or shared memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What does the `Global` keyword actually do inside a function?",
    "options": [
      "It creates a new global variable.",
      "It declares that the variable refers to the global scope, not a local variable.",
      "It imports a variable from another module.",
      "It locks the variable for thread safety."
    ],
    "answer": "It declares that the variable refers to the global scope, not a local variable.",
    "explanation": "Without `global`, assignment to a variable inside a function creates a local variable. With `global`, assignment modifies the variable in the enclosing module scope.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which protocol must an object implement to be iterable in a `for` loop?",
    "options": [
      "It must have an `__iter__` method that returns an iterator.",
      "It must have a `next` method.",
      "It must be a collection (like list or tuple).",
      "It must implement the `__len__` method."
    ],
    "answer": "It must have an `__iter__` method that returns an iterator.",
    "explanation": "The iterator protocol requires the object to have `__iter__` (returning self) and `__next__` (returning the next item). For `for` loops, `__iter__` is sufficient if it returns an iterator.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the behavior of the `super()` function in Python 3?",
    "options": [
      "It calls the method of the parent class directly.",
      "It returns a proxy object that delegates method calls to the parent or sibling class according to the MRO.",
      "It creates a new instance of the parent class.",
      "It bypasses the MRO and calls the grandparent class."
    ],
    "answer": "It returns a proxy object that delegates method calls to the parent or sibling class according to the MRO.",
    "explanation": "`super()` provides a way to access cooperative methods in the MRO chain, ensuring that all classes in a multiple-inheritance hierarchy are properly initialized.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is 'String Interning' in CPython?",
    "options": [
      "Converting all strings to UTF-8.",
      "Storing only one copy of distinct string values in memory to save space and speed up comparisons.",
      "Encrypting strings for security.",
      "Splitting strings into smaller chunks."
    ],
    "answer": "Storing only one copy of distinct string values in memory to save space and speed up comparisons.",
    "explanation": "Interning ensures that two strings with the same value point to the same memory address. It happens automatically for strings that look like identifiers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does the GIL affect C-extension modules?",
    "options": [
      "C-extensions cannot be used with Python.",
      "C-extensions must manually release the GIL to perform parallel CPU-heavy operations.",
      "C-extensions are immune to the GIL and run freely.",
      "The GIL prevents C-extensions from accessing Python objects."
    ],
    "answer": "C-extensions must manually release the GIL to perform parallel CPU-heavy operations.",
    "explanation": "The GIL affects C-extensions too. However, C code can explicitly release the GIL (using macros like `Py_BEGIN_ALLOW_THREADS`) to perform heavy calculations in parallel.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the role of `__del__` magic method?",
    "options": [
      "It is called when an object is deleted from memory.",
      "It is called when an object's reference count reaches zero (finalizer).",
      "It is used to delete items from a list.",
      "It is called when a variable goes out of scope."
    ],
    "answer": "It is called when an object's reference count reaches zero (finalizer).",
    "explanation": "`__del__` is a finalizer called when the garbage collector determines an object is to be destroyed. It is not a deterministic destructor like in C++.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What mechanism allows Python dictionaries to maintain insertion order (as of Python 3.7+)?",
    "options": [
      "They convert to lists internally.",
      "They use a linked list or array of indices tracking the insertion order of keys.",
      "They sort keys alphabetically.",
      "They rely on the GIL to order writes."
    ],
    "answer": "They use a linked list or array of indices tracking the insertion order of keys.",
    "explanation": "Since Python 3.7 (dict preservation is a language feature in 3.7+), dicts maintain insertion order by storing an array of keys in insertion sequence alongside the hash table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Why might you use a `WeakValueDictionary`?",
    "options": [
      "To prevent keys from being garbage collected.",
      "To create a cache where entries are removed automatically when they are no longer referenced elsewhere.",
      "To store only strings as values.",
      "To make dictionary access thread-safe."
    ],
    "answer": "To create a cache where entries are removed automatically when they are no longer referenced elsewhere.",
    "explanation": "Weak references do not increase the reference count. When the last strong reference to a value is gone, the GC can reclaim it, and it is automatically removed from the WeakValueDictionary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "Which of the following correctly describes the behavior of `list.sort()` vs `sorted(list)`?",
    "options": [
      "`list.sort()` returns a new list; `sorted(list)` modifies in-place.",
      "`list.sort()` modifies the list in-place and returns None; `sorted(list)` returns a new sorted list.",
      "Both modify the list in-place.",
      "Both return a new list."
    ],
    "answer": "`list.sort()` modifies the list in-place and returns None; `sorted(list)` returns a new sorted list.",
    "explanation": "`.sort()` is a method of the list object that sorts in place (returning `None`). `sorted()` is a built-in function that creates and returns a new sorted list from the iterable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the result of `True + True` in Python?",
    "options": [
      "`True`",
      "`2`",
      "SyntaxError",
      "`'TrueTrue'`"
    ],
    "answer": "`2`",
    "explanation": "`bool` is a subclass of `int` where `True` is 1 and `False` is 0. Arithmetic operations on booleans treat them as integers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the `Ellipsis` object used for in Python (accessed via `...`)?",
    "options": [
      "To denote the end of a file.",
      "To pass as a placeholder for code not yet written.",
      "To represent a slice across all dimensions in NumPy.",
      "Both B and C are common use cases."
    ],
    "answer": "Both B and C are common use cases.",
    "explanation": "The `Ellipsis` singleton is valid syntax. It is often used as a pass-stub in code and is crucial in libraries like NumPy for slicing multidimensional arrays.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "In Python, what happens when you unpack a dictionary using `**kwargs` in a function call?",
    "options": [
      "The keys are passed as a list.",
      "The key-value pairs are passed as named arguments.",
      "The values are passed as positional arguments.",
      "The dictionary is converted to a JSON string."
    ],
    "answer": "The key-value pairs are passed as named arguments.",
    "explanation": "The `**` operator unpacks a dictionary into keyword arguments (e.g., `func(**{'a': 1})` becomes `func(a=1)`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the technical limitation of the `pickle` module regarding security?",
    "options": [
      "It cannot handle user-defined classes.",
      "It is slow and compresses data poorly.",
      "It is insecure because unpickling can execute arbitrary code.",
      "It only works with JSON data."
    ],
    "answer": "It is insecure because unpickling can execute arbitrary code.",
    "explanation": "`pickle` allows objects to define how they are serialized/restored (`__reduce__`), which can be exploited to run commands. Never unpickle data from an untrusted source.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of the `nogil` branch of CPython, why is the removal of the linked list of all GC objects significant?",
    "options": [
      "It increases the memory overhead.",
      "It requires the Garbage Collector to be run in a separate process.",
      "It allows the use of mimalloc which can traverse memory to find objects, removing the need to manually track them in a list.",
      "It forces all objects to be stored on the stack."
    ],
    "answer": "It allows the use of mimalloc which can traverse memory to find objects, removing the need to manually track them in a list.",
    "explanation": "Mimalloc enables the GC to find objects by traversing the heap structures. This removes the need for CPython to maintain a separate doubly-linked list of all GC-tracked objects.",
    "difficulty": "Intermediate"
  }
]