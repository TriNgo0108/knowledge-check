[
  {
    "id": 1,
    "question": "What is the primary architectural difference between Pulumi and Terraform?",
    "options": [
      "Pulumi uses a proprietary GUI while Terraform is CLI-only",
      "Pulumi uses general-purpose programming languages while Terraform uses HCL (HashiCorp Configuration Language)",
      "Pulumi manages state locally while Terraform requires a remote backend",
      "Terraform supports multi-cloud deployments while Pulumi does not"
    ],
    "answer": "Pulumi uses general-purpose programming languages while Terraform uses HCL (HashiCorp Configuration Language)",
    "explanation": "Pulumi allows defining infrastructure using standard languages like TypeScript, Python, or Go, rather than a domain-specific language like HCL. This enables familiar programming constructs like classes, functions, and loops.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In the Pulumi model, what is the specific term for an isolated instance of infrastructure configuration?",
    "options": [
      "Project",
      "Workspace",
      "Stack",
      "Environment"
    ],
    "answer": "Stack",
    "explanation": "A Stack is an independent instantiation of a project, often corresponding to a deployment environment like 'dev', 'staging', or 'production'.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which Pulumi CLI command is used to preview the changes that will be made to infrastructure without actually applying them?",
    "options": [
      "pulumi plan",
      "pulumi up",
      "pulumi preview",
      "pulumi diff"
    ],
    "answer": "pulumi preview",
    "explanation": "The `pulumi preview` command calculates the planned resource changes (create, update, delete) compared to the current state, but does not perform the actual deployment.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What represents the top-level container for your Pulumi infrastructure code?",
    "options": [
      "Stack",
      "Project",
      "Provider",
      "Component"
    ],
    "answer": "Project",
    "explanation": "A Project is the folder containing your Pulumi.yaml file and infrastructure code. It serves as the parent container for one or more Stacks.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "How does Pulumi manage state by default compared to Terraform?",
    "options": [
      "State is stored locally in a 'terraform.tfstate' file",
      "State is managed automatically by the Pulumi Service (or self-hosted backend) without manual file handling",
      "State is pushed directly to the git repository",
      "State is entirely ephemeral and recreated on every run"
    ],
    "answer": "State is managed automatically by the Pulumi Service (or self-hosted backend) without manual file handling",
    "explanation": "Pulumi abstracts state management away from the user. While Terraform often requires manual backend configuration, Pulumi automatically handles state file storage and locking via the logged-in backend.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What type of resource in Pulumi acts as a wrapper for one or more other resources to create an abstraction?",
    "options": [
      "Provider Resource",
      "Component Resource",
      "Custom Resource",
      "Virtual Resource"
    ],
    "answer": "Component Resource",
    "explanation": "Component Resources are logical abstractions that contain other resources, similar to modules in Terraform. They allow you to bundle and reuse infrastructure patterns.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which of the following is NOT a supported language for writing Pulumi programs?",
    "options": [
      "Go",
      "TypeScript",
      "Ruby",
      "Python"
    ],
    "answer": "Ruby",
    "explanation": "Pulumi natively supports TypeScript, JavaScript, Python, Go, C#, Java, and YAML (common language). Ruby is not currently a supported SDK for Pulumi infrastructure definitions.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "In the context of Pulumi configuration, what is the purpose of a 'Secret'?",
    "options": [
      "To encrypt the entire state file",
      "To store sensitive configuration values that are encrypted in the state file",
      "To hide the source code from the Pulumi Console",
      "To manage passwords for the Pulumi login only"
    ],
    "answer": "To store sensitive configuration values that are encrypted in the state file",
    "explanation": "Pulumi Secrets encrypt configuration values (like API keys or passwords) so they are stored safely and never appear in plaintext in the state file or stack outputs.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What happens when you run `pulumi up`?",
    "options": [
      "The CLI calculates the plan and immediately executes the deployment to reach the desired state",
      "The code is compiled but no infrastructure changes occur",
      "The state file is deleted and recreated",
      "It creates a new Stack regardless of the current configuration"
    ],
    "answer": "The CLI calculates the plan and immediately executes the deployment to reach the desired state",
    "explanation": "`pulumi up` performs the full deployment lifecycle: it calculates the diff (plan) and then performs the necessary create, update, or delete operations against the cloud provider.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which command is used to reconcile the state file with the actual resources existing in the cloud provider?",
    "options": [
      "pulumi fix",
      "pulumi refresh",
      "pulumi repair",
      "pulumi sync"
    ],
    "answer": "pulumi refresh",
    "explanation": "`pulumi refresh` compares the actual resources in the cloud against the Pulumi state file and updates the state to match reality, correcting for drift.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the role of a 'Provider' in Pulumi?",
    "options": [
      "The text editor used to write Pulumi code",
      "The package manager for installing dependencies",
      "The plugin that manages the lifecycle of resources for a specific cloud or service",
      "The authentication mechanism for the Pulumi Console"
    ],
    "answer": "The plugin that manages the lifecycle of resources for a specific cloud or service",
    "explanation": "Providers (e.g., AWS, Azure, Kubernetes) are plugins that understand how to create, read, update, and delete resources for specific cloud platforms.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "How are outputs typically defined and exported in a Pulumi stack?",
    "options": [
      "Using a 'outputs.tf' file",
      "By exporting an object in the entrypoint file (e.g., index.ts) containing values tagged with 'pulumi.Output'",
      "By setting environment variables",
      "By modifying the Pulumi.yaml file"
    ],
    "answer": "By exporting an object in the entrypoint file (e.g., index.ts) containing values tagged with 'pulumi.Output'",
    "explanation": "In languages like TypeScript or Python, you export an object from your program. Properties of this object are returned as Stack outputs after the deployment completes.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What command is used to log in to the Pulumi backend?",
    "options": [
      "pulumi auth",
      "pulumi login",
      "pulumi init",
      "pulumi connect"
    ],
    "answer": "pulumi login",
    "explanation": "The `pulumi login` command authenticates the CLI to a backend, such as the Pulumi Cloud, an S3 bucket, or Azure Blob Storage.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What mechanism does Pulumi use to determine which resources need to be created, updated, or deleted?",
    "options": [
      "Diffing the current State against the physical infrastructure and the new Code (Desired State)",
      "Reading only the git commit history",
      "Manual user input for every resource",
      "Comparing the code directly to the cloud provider without state"
    ],
    "answer": "Diffing the current State against the physical infrastructure and the new Code (Desired State)",
    "explanation": "Pulumi performs a diff involving three inputs: the code (desired state), the state file (known state), and the actual cloud resources (reality via refresh).",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which of the following is a valid self-managed backend option for Pulumi state?",
    "options": [
      "Amazon S3",
      "PostgreSQL Database",
      "Local file system only",
      "HashiCorp Vault"
    ],
    "answer": "Amazon S3",
    "explanation": "Pulumi supports self-hosted backends such as Amazon S3, Azure Blob Storage, Google Cloud Storage, and local filesystems.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the result of running `pulumi destroy`?",
    "options": [
      "It deletes the Pulumi project folder",
      "It removes the Pulumi CLI from your machine",
      "It deletes all resources defined in the active Stack",
      "It deletes the configuration but leaves the resources running"
    ],
    "answer": "It deletes all resources defined in the active Stack",
    "explanation": "The `pulumi destroy` command tears down all resources currently managed by the selected stack. It does not delete the stack history or the project files.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "In Pulumi, what is a 'URN' (Unique Resource Name)?",
    "options": [
      "The user's login name",
      "A unique identifier for a resource consisting of type, project, and stack",
      "The Uniform Resource Name of the state file",
      "The username used for cloud provider authentication"
    ],
    "answer": "A unique identifier for a resource consisting of type, project, and stack",
    "explanation": "A URN is a stable, globally unique identifier assigned to every resource managed by Pulumi, combining the resource type, project name, stack name, and resource name.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which file defines the metadata and configuration settings for a Pulumi project?",
    "options": [
      "package.json",
      "main.py",
      "Pulumi.yaml",
      "requirements.txt"
    ],
    "answer": "Pulumi.yaml",
    "explanation": "The `Pulumi.yaml` file is the heart of a Pulumi project, containing metadata such as the project name, runtime (language), and description.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How does Pulumi handle dependencies between resources implicitly?",
    "options": [
      "By the order they appear in the code file",
      "By creating a separate 'dependencies.txt' file",
      "By passing the output of one resource as an input to another",
      "It does not; all resources are created in parallel"
    ],
    "answer": "By passing the output of one resource as an input to another",
    "explanation": "Pulumi automatically tracks dependencies. If Resource B uses an Output from Resource A, Pulumi knows it must create Resource A first.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the function of `pulumi.Config` in Pulumi SDKs?",
    "options": [
      "To configure the Pulumi CLI settings",
      "To read configuration values defined for the stack",
      "To set up cloud provider credentials",
      "To generate random passwords"
    ],
    "answer": "To read configuration values defined for the stack",
    "explanation": "`pulumi.Config` (or similar constructs in other languages) is the API used within a program to access configuration values set via `pulumi config set`.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which command allows you to view the current stack's outputs on the command line?",
    "options": [
      "pulumi show",
      "pulumi stack output",
      "pulumi state list",
      "pulumi info"
    ],
    "answer": "pulumi stack output",
    "explanation": "The `pulumi stack output` command lists all the exported outputs for the currently selected stack and their values.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "When using Pulumi with YAML, what is the primary use case?",
    "options": [
      "Complex logic and looping",
      "Low-level infrastructure coding",
      "Declarative configuration for users who prefer configuration over code",
      "High-performance networking applications"
    ],
    "answer": "Declarative configuration for users who prefer configuration over code",
    "explanation": "Pulumi YAML allows users to define infrastructure declaratively without writing a general-purpose language, serving as an alternative to HCL users.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What happens if you remove a resource from your Pulumi code and run `pulumi up`?",
    "options": [
      "The resource is ignored but remains in the cloud",
      "The resource is deleted from the cloud provider",
      "The code will fail to compile",
      "The state file becomes corrupted"
    ],
    "answer": "The resource is deleted from the cloud provider",
    "explanation": "Pulumi's desired state model ensures that the real infrastructure matches the code. If a resource is removed from the code, Pulumi plans to delete it from the cloud.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the purpose of the 'Protect' resource option in Pulumi?",
    "options": [
      "To encrypt the resource data",
      "To prevent accidental deletion of the resource",
      "To ensure the resource is always created first",
      "To hide the resource from the Pulumi Console"
    ],
    "answer": "To prevent accidental deletion of the resource",
    "explanation": "Enabling the 'protect' option on a resource ensures that Pulumi will not allow it to be destroyed unless the protection is explicitly removed.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "How do you select a specific stack when running CLI commands?",
    "options": [
      "By setting the `STACK_NAME` environment variable",
      "By using the `--stack` flag or running `pulumi stack select`",
      "By renaming the project folder",
      "By editing the `Pulumi.yaml` file before every command"
    ],
    "answer": "By using the `--stack` flag or running `pulumi stack select`",
    "explanation": "You can explicitly target a stack using the `--stack` flag, or persistently select one using the `pulumi stack select <name>` command.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In Pulumi, what is 'drift'?",
    "options": [
      "The delay in time between writing code and deployment",
      "A discrepancy between the actual cloud resources and the Pulumi state file",
      "A feature that allows resources to move between regions",
      "The logging output during a deployment"
    ],
    "answer": "A discrepancy between the actual cloud resources and the Pulumi state file",
    "explanation": "Drift occurs when changes are made to infrastructure outside of Pulumi (e.g., manually in the console), causing the state file to become outdated.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the Automation API used for?",
    "options": [
      "Automating the installation of Pulumi",
      "Programmatically driving Pulumi workflows (up, down, refresh) from within an application",
      "Automating cloud provider authentication",
      "Converting HCL to Pulumi"
    ],
    "answer": "Programmatically driving Pulumi workflows (up, down, refresh) from within an application",
    "explanation": "The Automation API allows developers to embed Pulumi as a library in their own software (e.g., internal SaaS platforms, CI systems) rather than using the CLI.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which language feature is specifically leveraged by Pulumi TypeScript to strictly type cloud resources?",
    "options": [
      "Dynamic typing",
      "Interfaces and static typing",
      "Interpreting code at runtime",
      "Macros"
    ],
    "answer": "Interfaces and static typing",
    "explanation": "Pulumi TypeScript definitions utilize strict static typing to provide autocomplete and type checking for resource properties, reducing errors.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What does the `pulumi stack init` command do?",
    "options": [
      "Creates a new Pulumi project",
      "Initializes an empty stack for an existing project",
      "Installs the Pulumi providers",
      "Resets the state file to empty"
    ],
    "answer": "Initializes an empty stack for an existing project",
    "explanation": "This command creates a new stack configuration, allowing you to manage an isolated environment (like dev or prod) within a project.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the function of `pulumi.Output` in TypeScript/Python?",
    "options": [
      "To print text to the console",
      "To handle values that will be available only after the infrastructure is provisioned",
      "To export data to CSV",
      "To define environment variables"
    ],
    "answer": "To handle values that will be available only after the infrastructure is provisioned",
    "explanation": "Outputs are a special type that wrap a value that may not be known until the cloud provider finishes the operation. You must use `.apply` (TS) or `.apply` (Python) to access them.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "How can you prevent a specific stack from being deleted accidentally?",
    "options": [
      "By renaming the stack to 'do-not-delete'",
      "By marking the stack with a retention policy in the Pulumi Console",
      "By running `pulumi lock`",
      "By removing the stack from the project"
    ],
    "answer": "By marking the stack with a retention policy in the Pulumi Console",
    "explanation": "The Pulumi Service allows administrators to set retention policies on stacks to prevent accidental deletion and ensure compliance.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which command updates the configuration value for a specific key in the current stack?",
    "options": [
      "pulumi config set <key> <value>",
      "pulumi set <key> <value>",
      "pulumi update config <key>",
      "pulumi env <key> <value>"
    ],
    "answer": "pulumi config set <key> <value>",
    "explanation": "The `pulumi config set` CLI command is the standard way to store configuration values for the stack, which can then be read by the program.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the relationship between a Component Resource and a Custom Resource?",
    "options": [
      "They are synonyms for the same concept",
      "A Component Resource is a logical grouping, while a Custom Resource manages a physical cloud entity",
      "A Custom Resource is a language extension, while a Component Resource is a cloud entity",
      "A Custom Resource creates Component Resources"
    ],
    "answer": "A Component Resource is a logical grouping, while a Custom Resource manages a physical cloud entity",
    "explanation": "Custom Resources are the smallest unit of abstraction, mapping 1:1 with cloud provider entities. Component Resources are abstractions that group other resources.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "When deploying, Pulumi creates a 'Plan'. What information does this plan contain?",
    "options": [
      "The estimated cost in USD",
      "A list of resource changes (create, update, delete) and detailed steps",
      "A list of all team members who approved the deployment",
      "The compiled binary of the infrastructure code"
    ],
    "answer": "A list of resource changes (create, update, delete) and detailed steps",
    "explanation": "The plan details the specific operations Pulumi will perform, including which resources will be created, updated, or replaced.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the function of `pulumi.Config.require()` in Pulumi programs?",
    "options": [
      "To require that a specific version of Pulumi is installed",
      "To throw an error if a configuration value is not set",
      "To require internet connectivity for the deployment",
      "To ensure a resource is created before another"
    ],
    "answer": "To throw an error if a configuration value is not set",
    "explanation": "Using `require` (e.g., `config.require('apiKey')`) enforces that a configuration value must be provided by the user; otherwise, the program will fail during preview or update.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which command reconciles the state file with the actual resources existing in the cloud provider to detect drift?",
    "options": [
      "pulumi import",
      "pulumi refresh",
      "pulumi state update",
      "pulumi preview --sync"
    ],
    "answer": "pulumi refresh",
    "explanation": "The `pulumi refresh` command updates the Pulumi state file to match the actual infrastructure deployed in the cloud, identifying any configuration drift. It does not modify the actual cloud resources, only the state file.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary purpose of `pulumi.StackReference` in Pulumi?",
    "options": [
      "To create a dependency between resources within the same stack",
      "To read outputs exported from a different stack",
      "To reference a parent directory in the project structure",
      "To define a custom rollback target"
    ],
    "answer": "To read outputs exported from a different stack",
    "explanation": "A `StackReference` allows a stack to access outputs from another stack, enabling configuration sharing and multi-stack deployment patterns (e.g., separating networking and compute).",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How are component resources different from custom resources in Pulumi?",
    "options": [
      "Custom resources manage physical infrastructure; component resources are logical groupings of other resources",
      "Component resources are managed by the cloud provider; custom resources are managed by Pulumi",
      "Custom resources require a plugin; component resources run in the browser",
      "Component resources cannot have children"
    ],
    "answer": "Custom resources manage physical infrastructure; component resources are logical groupings of other resources",
    "explanation": "Component resources (like `awsx.ec2.Vpc`) are helper classes that organize multiple child resources into a single abstraction, whereas custom resources directly interface with a provider to manage a specific cloud entity.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In TypeScript, why is the `.apply()` method used on an `Output<T>`?",
    "options": [
      "To immediately resolve the value into a string",
      "To transform the value once it is known during deployment",
      "To apply the resource creation to the cloud provider",
      "To encrypt the output value in the state file"
    ],
    "answer": "To transform the value once it is known during deployment",
    "explanation": "Outputs are promises of values that will only be known after the infrastructure is provisioned. `.apply()` takes a callback function to transform or use that value once it becomes available.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which command is used to manually import an existing cloud resource into Pulumi state management without destroying it?",
    "options": [
      "pulumi up --import",
      "pulumi state import",
      "pulumi import",
      "pulumi stack add"
    ],
    "answer": "pulumi import",
    "explanation": "The `pulumi import` command generates the code definition for an existing cloud resource and inserts it into the current stack's state, ensuring Pulumimatches reality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the `pulumi.Config` object handle secrets?",
    "options": [
      "It requires a separate encryption key file",
      "It uses the `getSecret` method to retrieve encrypted values",
      "It automatically assumes all configuration values are secrets",
      "It cannot read secrets; only environment variables can store secrets"
    ],
    "answer": "It uses the `getSecret` method to retrieve encrypted values",
    "explanation": "While `config.get` retrieves standard configuration, `config.getSecret` retrieves values marked as secrets. These are encrypted in the state file and are only visible as plaintext to the engine performing the deployment.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the function of a 'Provider' resource in Pulumi?",
    "options": [
      "To define the region where the stack will be deployed",
      "To authenticate and configure the connection to a specific cloud service",
      "To package the Pulumi project for distribution",
      "To act as a wrapper for Component Resources"
    ],
    "answer": "To authenticate and configure the connection to a specific cloud service",
    "explanation": "A Provider resource (e.g., `aws.Provider`) encapsulates the configuration and credentials required to communicate with a cloud API, allowing for multi-region or multi-account deployments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which mechanism allows you to modify the properties of a child resource within a Component Resource without manually defining it?",
    "options": [
      "Resource Aliases",
      "Component Transformations",
      "Stack References",
      "Remote State"
    ],
    "answer": "Component Transformations",
    "explanation": "Component transformations are functions applied to a component resource that allow you to intercept and modify the properties of any child resources before they are registered with the engine.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the purpose of `deleteBeforeReplace` in resource options?",
    "options": [
      "To ensure the stack is deleted before a replacement occurs",
      "To force Pulumi to destroy an existing resource before creating its replacement",
      "To prevent recreation of resources if the update fails",
      "To reduce the cost of the deployment"
    ],
    "answer": "To force Pulumi to destroy an existing resource before creating its replacement",
    "explanation": "By default, Pulumi creates the replacement before destroying the old one to minimize downtime. `deleteBeforeReplace` reverses this behavior, which is necessary for resources with naming conflicts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "When using a self-managed backend (e.g., S3), what does the `pulumi login` command require?",
    "options": [
      "The name of the stack you wish to deploy",
      "The path or URL to the backend storage endpoint",
      "The AWS Access Key ID directly",
      "A local directory path where state should be stored"
    ],
    "answer": "The path or URL to the backend storage endpoint",
    "explanation": "The `pulumi login` command directs the Pulumi CLI to use a specific backend for storing state files, such as `s3://my-bucket` or a file path. If omitted, it defaults to the Pulumi Cloud Service.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the difference between `pulumi destroy` and `pulumi stack rm`?",
    "options": [
      "`pulumi destroy` deletes state; `pulumi stack rm` deletes cloud resources",
      "`pulumi destroy` removes cloud resources; `pulumi stack rm` removes the stack configuration and state file",
      "`pulumi stack rm` is for removing resources only; `pulumi destroy` removes everything",
      "There is no difference; they are aliases"
    ],
    "answer": "`pulumi destroy` removes cloud resources; `pulumi stack rm` removes the stack configuration and state file",
    "explanation": "`pulumi destroy` tears down the infrastructure provisioned by the stack. `pulumi stack rm` removes the stack entirely from the backend (including history and secrets), usually after a destroy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What functionality does the Pulumi Automation API provide?",
    "options": [
      "Automatic remediation of cloud security violations",
      "Programmatic control of Pulumi operations (up/destroy/refresh) embedded in an application",
      "Automatic conversion of Terraform HCL to Pulumi code",
      "Enhanced logging for CLI operations"
    ],
    "answer": "Programmatic control of Pulumi operations (up/destroy/refresh) embedded in an application",
    "explanation": "The Automation API exposes Pulumi's engine as a library (for Go, Node.js, Python, etc.), allowing developers to embed infrastructure provisioning directly into custom software tools.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the role of a `pulumi.yaml` file in a project?",
    "options": [
      "To define the runtime language and stack settings",
      "To store the encrypted secrets for the project",
      "To list all providers used in the stack",
      "To configure the CI/CD pipeline triggers"
    ],
    "answer": "To define the runtime language and stack settings",
    "explanation": "The `pulumi.yaml` file acts as the project manifest, defining the name, runtime (e.g., python, nodejs), and description. It is distinct from `Pulumi.yaml` (stack settings) or code files.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which flag must be set on a configuration value to ensure it is stored as an encrypted secret in the Pulumi state?",
    "options": [
      "--private",
      "--sensitive",
      "--secret",
      "--masked"
    ],
    "answer": "--secret",
    "explanation": "Using `pulumi config set --secret <key> <value>` ensures the value is encrypted by the state backend before storage and is handled securely in logs and outputs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How does Pulumi handle implicit dependencies between resources?",
    "options": [
      "By analyzing the order in which resources are defined in the code file",
      "By detecting when the output of one resource is used as an input to another",
      "By requiring the user to define `dependsOn` for every resource pair",
      "By alphabetical sorting of resource names"
    ],
    "answer": "By detecting when the output of one resource is used as an input to another",
    "explanation": "Pulumi builds a dependency graph based on data flow. If Resource B passes an Output from Resource A to one of its properties, Pulumi automatically knows it must create A before B.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the result of using the `ignoreChanges` resource option?",
    "options": [
      "Pulumi will skip creating the resource if it exists in the cloud",
      "Pulumi will stop tracking the specified properties in the state file",
      "Pulumi will not update the resource if it differs from the code definition",
      "Pulumi will suppress all outputs from the resource"
    ],
    "answer": "Pulumi will not update the resource if it differs from the code definition",
    "explanation": "This option tells Pulumi to ignore changes to specific properties (or the whole resource) during updates. It is useful for resources managed partially outside of Pulumi.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In the context of Pulumi stacks, what is a 'Drift'?",
    "options": [
      "The difference between the code in Git and the local files",
      "The difference between the actual state of cloud resources and the Pulumi state file",
      "The latency between running `pulumi up` and completion",
      "The version difference between Pulumi CLI and the language plugin"
    ],
    "answer": "The difference between the actual state of cloud resources and the Pulumi state file",
    "explanation": "Drift occurs when infrastructure is modified manually (via console or CLI) or by external processes, causing the actual cloud environment to no longer match the state recorded by Pulumi.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which resource option allows you to create a replacement for a resource alongside the existing one, and only switch over traffic once the new one is ready?",
    "options": [
      "createBeforeDelete",
      "deleteBeforeReplace",
      "replaceOnChanges",
      "preventUpdate"
    ],
    "answer": "createBeforeDelete",
    "explanation": "`createBeforeDelete` is the default behavior for many resources but can be explicitly configured. It ensures minimal downtime by creating the new instance before removing the old one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the `pulumi about` command used for?",
    "options": [
      "To display the version of Pulumi and installed providers",
      "To show the history of the current stack",
      "To list all resources in the current project",
      "To provide a detailed cost analysis of the stack"
    ],
    "answer": "To display the version of Pulumi and installed providers",
    "explanation": "This command outputs environment details such as the CLI version, language versions, and currently installed backend providers, which is crucial for debugging environment issues.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How do you specify a custom timeout for a resource creation operation in Pulumi?",
    "options": [
      "By setting the `--timeout` flag in the CLI",
      "By setting the `customTimeouts` option in the ResourceOptions",
      "By modifying the global `pulumi.yaml` configuration",
      "By adding a `sleep` statement in the code"
    ],
    "answer": "By setting the `customTimeouts` option in the ResourceOptions",
    "explanation": "The `customTimeouts` object allows developers to override default create, update, and delete timeouts for specific resources that may take longer to provision.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is a `urn` in Pulumi's state model?",
    "options": [
      "The physical name of the cloud resource",
      "The unique identifier for the resource in the stack",
      "The user-friendly alias for the resource",
      "The URL to access the resource"
    ],
    "answer": "The unique identifier for the resource in the stack",
    "explanation": "The URN (Uniform Resource Name) is a stable, canonical identifier for a resource within a stack, combining the type and name, independent of the physical ID assigned by the cloud provider.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "When should you use `pulumi state unmount`?",
    "options": [
      "When you want to delete a resource from the cloud and the state",
      "When you want to stop managing a resource with Pulumi but keep it in the cloud",
      "When you want to rename a stack",
      "When you want to revert to a previous deployment"
    ],
    "answer": "When you want to stop managing a resource with Pulumi but keep it in the cloud",
    "explanation": "Unmounting removes a resource from the Pulumi state file without destroying the actual cloud resource. It effectively hands over management to manual control or another tool.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which feature enables using `pulumi` commands from within a CI/CD pipeline without an interactive login?",
    "options": [
      "Using `pulumi login --local`",
      "Setting the `PULUMI_ACCESS_TOKEN` environment variable",
      "Passing `--non-interactive` flag",
      "Storing `Pulumi.yaml` in a public repository"
    ],
    "answer": "Setting the `PULUMI_ACCESS_TOKEN` environment variable",
    "explanation": "The access token authenticates the CLI against the Pulumi Service. In CI/CD, this token is injected as an environment variable to bypass the interactive browser login.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "How do `resource transformations` differ from `aliases` in Pulumi?",
    "options": [
      "Aliases rename resources; transformations modify properties",
      "Transformations are for encryption; aliases are for access control",
      "Aliases apply only to stacks; transformations apply only to providers",
      "There is no functional difference"
    ],
    "answer": "Aliases rename resources; transformations modify properties",
    "explanation": "An `alias` tells Pulumi that a new resource in code is actually the same as an old resource in the state (preventing replacement). A `transformation` intercepts the creation of a resource to change its properties.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What happens to resources that are defined in code but omitted from the state file when `pulumi up` is run?",
    "options": [
      "Pulumi ignores them",
      "Pulumi deletes them from the cloud provider",
      "Pulumi throws a syntax error",
      "Pulumi automatically imports them"
    ],
    "answer": "Pulumi deletes them from the cloud provider",
    "explanation": "Pulumi's goal is to make the cloud match the code. If a resource is removed from the code, it is removed from the state, and consequently, Pulumi will delete the physical resource.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does Pulumi determine the order of resource operations during an update?",
    "options": [
      "Alphabetical order of resource names",
      "The dependency graph derived from resource inputs and explicit dependencies",
      "The order resources appear in the source code file",
      "A random distribution to optimize parallelism"
    ],
    "answer": "The dependency graph derived from resource inputs and explicit dependencies",
    "explanation": "Pulumi constructs a Directed Acyclic Graph (DAG) based on how resources reference each other (and explicit `dependsOn` calls) to determine the valid parallelization and sequence of operations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the function of the `pulumi stack output` command?",
    "options": [
      "To list all resources currently deployed",
      "To display the exported stack outputs from the state file",
      "To print the full JSON representation of the state",
      "To remove sensitive outputs from the view"
    ],
    "answer": "To display the exported stack outputs from the state file",
    "explanation": "This command specifically retrieves and displays the Output values defined by the program and stored in the state, such as IP addresses or DNS names, facilitating integration with other tools.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which mechanism allows a Pulumi component to manage resources dynamically based on a list of items (e.g., creating a bucket per user)?",
    "options": [
      "Stack References",
      "Dynamic Resource Providers",
      "Loops within the general-purpose language (for/foreach)",
      "Resource Aliasing"
    ],
    "answer": "Loops within the general-purpose language (for/foreach)",
    "explanation": "Because Pulumi uses real programming languages, developers use standard control flow (loops, maps) to instantiate resources dynamically, rather than HLC-specific copy/paste mechanisms.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is a specific use case for a Policy Pack in Pulumi?",
    "options": [
      "Provisioning resources across multiple cloud regions",
      "Validating that resources comply with organizational standards (e.g., no public S3 buckets)",
      "Encrypting the state file for a specific stack",
      "Managing the lifecycle of the `pulumi` CLI binary"
    ],
    "answer": "Validating that resources comply with organizational standards (e.g., no public S3 buckets)",
    "explanation": "Policy Packs are written in code (using rego or Python/TS) and run during deployments to validate, audit, or enforce security and compliance rules on infrastructure before it is provisioned.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "How does Pulumi handle JSON inputs that are marked as sensitive in the configuration?",
    "options": [
      "It displays them as plain text but hides them in the state file",
      "It returns a Promise or Output that is marked as secret",
      "It automatically masks the entire stack output",
      "It converts them to base64"
    ],
    "answer": "It returns a Promise or Output that is marked as secret",
    "explanation": "When you call `requireSecret` (Python) or `getSecret` (TS), the value is wrapped in an Output marked as secret. Pulumi ensures this data is encrypted in the state and suppressed from logs/UI.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "In the context of Pulumi Architecture, what represents the 'Provider Binary'?",
    "options": [
      "The CLI tool used to run deployments",
      "The executable code written by the user (e.g., TypeScript)",
      "The plugin written in Go that communicates with the Cloud Provider API",
      "The Pulumi Service dashboard"
    ],
    "answer": "The plugin written in Go that communicates with the Cloud Provider API",
    "explanation": "The provider binary is the underlying engine (like `pulumi-resource-aws`) that implements the CRUD logic for specific cloud resources. It is distinct from the language host and the CLI.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the primary benefit of using 'Targeted Deployments' via the `--target` flag?",
    "options": [
      "To deploy the stack to a specific cloud region",
      "To skip dependencies and only update specific resources",
      "To reduce the cost of the deployment",
      "To increase the parallelism of the operation"
    ],
    "answer": "To skip dependencies and only update specific resources",
    "explanation": "The `--target` flag limits the operation to specific URNs. This allows for faster updates or debugging of specific resources without waiting for the full graph validation, though it risks violating dependency logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "When using the Automation API, what is the meaning of `Workspace`?",
    "options": [
      "The directory on the local machine where Pulumi is installed",
      "The context containing the Pulumi project, settings, and environment",
      "The backend storage location for the state file",
      "The UI dashboard for managing stacks"
    ],
    "answer": "The context containing the Pulumi project, settings, and environment",
    "explanation": "A Workspace is the execution environment for a stack. It encapsulates the project directory, environment variables, and Pulumi settings required to run deployment operations programmatically.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which of these options is NOT a valid backend storage option for Pulumi state?",
    "options": [
      "Pulumi Cloud Service",
      "Local file system",
      "Amazon S3",
      "GitHub Repository"
    ],
    "answer": "GitHub Repository",
    "explanation": "While code is stored in Git, Pulumi State cannot be stored directly on GitHub. It must be stored in a backend like the Pulumi Service, S3, Azure Blob, or the local filesystem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of the Pulumi architecture, how does the Pulumi CLI communicate with the language-specific runtime (e.g., Node.js, Python) to execute the infrastructure program?",
    "options": [
      "By directly compiling the source code into a binary executable using the host platform's toolchain",
      "By spawning a subprocess and attaching a standard input/output stream for JSON-RPC messaging",
      "By utilizing the gRPC protocol to interface with a long-running Language Host process",
      "By converting the source code into an intermediate HCL representation and passing it to the Terraform Core engine"
    ],
    "answer": "By utilizing the gRPC protocol to interface with a long-running Language Host process",
    "explanation": "The Pulumi CLI launches an executable 'language host' specific to the runtime (e.g., `pulumi-language-nodejs`) and communicates with it via gRPC. This host executes the user's program and returns resource dependencies and properties back to the CLI engine.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the specific effect of running `pulumi refresh` on a stack that has drifted from its actual cloud state?",
    "options": [
      "It updates the cloud resources to match the code defined in the Pulumi program",
      "It reconciles the Pulumi state file with the actual infrastructure found in the cloud provider",
      "It re-applies the configuration values from `Pulumi.yaml` to the cloud provider",
      "It forces a replacement of all resources that have a configuration drift"
    ],
    "answer": "It reconciles the Pulumi state file with the actual infrastructure found in the cloud provider",
    "explanation": "The `refresh` command queries the live cloud environment to retrieve the actual properties and statuses of resources, then updates the Pulumi state file (checkpoint) to match reality. It does not modify the actual cloud infrastructure or the source code.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "When using `StackReference` to retrieve outputs from a different stack, what prerequisite must be met for the referenced stack to be accessible?",
    "options": [
      "The referenced stack must be in the same Pulumi project and currently deployed",
      "The backend storing the state must be shared and accessible to the current stack's environment",
      "The referenced stack must export its configuration secrets as public outputs",
      "The stacks must be managed by the same cloud provider (e.g., both AWS)"
    ],
    "answer": "The backend storing the state must be shared and accessible to the current stack's environment",
    "explanation": "`StackReference` reads the state file of the target stack. Therefore, the current environment (CLI or Automation API) must have credentials and access permissions to the backend (S3, Pulumi Service, etc.) where the referenced stack's state is stored.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the primary technical use case for `pulumi.ResourceTransformation` within the Pulumi SDK?",
    "options": [
      "To modify the properties or options of a child resource dynamically before it is registered",
      "To convert a Terraform state file into a Pulumi stack definition",
      "To change the runtime behavior of the Pulumi CLI during the `pulumi up` operation",
      "To automatically upgrade the Pulumi dependencies and provider plugins"
    ],
    "answer": "To modify the properties or options of a child resource dynamically before it is registered",
    "explanation": "Transformations are callbacks invoked during resource construction that allow developers to mutate properties, add tags, or modify options (like `protect`) across a hierarchy of resources, typically used within Components or Stack-level transformations.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which flag is required when using `pulumi import` to bring an existing cloud resource under Pulumi management if the resource type is ambiguous?",
    "options": [
      "`--name`",
      "`--parent`",
      "`--type`",
      "`--provider"
    ],
    "answer": "`--type`",
    "explanation": "While `pulumi import` attempts to infer the type, ambiguity often exists (e.g., `aws:ec2/vpc:Vpc` vs custom providers). Explicitly specifying `--type` ensures Pulumi maps the cloud resource correctly to the specific SDK class definition.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What distinguishes the behavior of `pulumi.ResourceOptions.dependsOn` from creating an implicit dependency via an Output property reference?",
    "options": [
      "`dependsOn` creates a hard dependency that waits for creation, while implicit references only wait for availability",
      "`dependsOn` creates a dependency edge in the DAG even when no property value is actually exchanged",
      "Implicit dependencies are ignored during `pulumi destroy`, while `dependsOn` is respected",
      "`dependsOn` is used exclusively for cross-project stack references"
    ],
    "answer": "`dependsOn` creates a dependency edge in the DAG even when no property value is actually exchanged",
    "explanation": "Implicit dependencies are formed when Resource A uses an Output from Resource B. `dependsOn` allows you to explicitly declare that Resource A must wait for Resource B to complete (even if A does not consume B's outputs), often used to force specific sequencing.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "In the context of Component Resources, how does Pulumi handle the deletion of a Component instance?",
    "options": [
      "It only deletes the Component Resource object from state, leaving all child resources intact",
      "It deletes all child resources that are part of the Component's construction tree",
      "It requires explicit deletion of every child resource before the parent Component can be removed",
      "It converts the Component into a stand-alone Custom Resource"
    ],
    "answer": "It deletes all child resources that are part of the Component's construction tree",
    "explanation": "Component Resources are logical groupings. Deleting a Component Resource signals to the Pulumi engine that it should also delete the children belonging to that component's hierarchy, cascading the deletion operation.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What mechanism does the `pulumi.Output` type use to ensure that dependent resources are created in the correct order?",
    "options": [
      "It blocks the main thread until the value is available from the cloud provider",
      "It uses an `apply` method to register callbacks that run lazily after the dependency is resolved",
      "It serializes the entire graph into a JSON file before execution",
      "It automatically converts the value into a string and stores it in the state file immediately"
    ],
    "answer": "It uses an `apply` method to register callbacks that run lazily after the dependency is resolved",
    "explanation": "Outputs are promises or futures. Accessing them usually requires chaining a function (like `apply` in TypeScript or `apply` in Python) that captures the dependency, ensuring the engine knows that the consuming resource depends on the output value of the source resource.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the significance of the URN (Uniform Resource Name) in Pulumi's state management?",
    "options": [
      "It acts as the unique, immutable identifier for a resource within a stack, used to track state across updates",
      "It is a temporary identifier assigned during `pulumi preview` and discarded after `pulumi up`",
      "It stores the JSON representation of the resource's properties",
      "It is the connection string used to authenticate with the cloud provider"
    ],
    "answer": "It acts as the unique, immutable identifier for a resource within a stack, used to track state across updates",
    "explanation": "The URN uniquely identifies a resource by combining the type, project, stack, and name. It allows Pulumi to track a specific resource instance even if its logical name or properties change during a refactor or replacement.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "How does the `pulumi.Config` object handle values loaded from secrets (e.g., `pulumi config set --secret mypwd`)?",
    "options": [
      "It decrypts them transparently within the language runtime but marks the Output as secret to prevent logging",
      "It returns the ciphertext directly, requiring the developer to manually decrypt it",
      "It stores the secret in the environment variables instead of the state file",
      "It refuses to load the value unless the PULUMI_CONFIG_PASSPHRASE environment variable is set"
    ],
    "answer": "It decrypts them transparently within the language runtime but marks the Output as secret to prevent logging",
    "explanation": "The Pulumi encryption provider (keyring or cloud KMS) decrypts the secret value. The resulting value is wrapped in a special `Output` object marked as secret, ensuring the raw value is never printed to the console or plain-text logs.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the purpose of the `protect: true` resource option in Pulumi?",
    "options": [
      "To enable deletion protection on the underlying cloud resource (e.g., AWS S3 bucket versioning)",
      "To prevent Pulumi from deleting the resource during a `pulumi destroy` or resource removal operation",
      "To encrypt the resource's state data at rest using AES-256",
      "To ensure the resource is only updated manually and ignored by the pulumi up diff"
    ],
    "answer": "To prevent Pulumi from deleting the resource during a `pulumi destroy` or resource removal operation",
    "explanation": "Setting `protect: true` safeguards a resource from accidental deletion. Even if the code is removed or `pulumi destroy` is run, the Pulumi engine will refuse to delete the resource, requiring explicit unprotection to proceed.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "When using the Pulumi Automation API, what is the primary distinction compared to using the CLI?",
    "options": [
      "Automation API does not require a backend configuration",
      "Automation API exposes the engine's functionality directly as a programmable SDK for embedding in applications",
      "Automation API runs entirely in the browser without a Pulumi CLI installation",
      "Automation API uses a separate, non-compatible state file format"
    ],
    "answer": "Automation API exposes the engine's functionality directly as a programmable SDK for embedding in applications",
    "explanation": "The Automation API is a layer atop the Pulumi Engine (driven via gRPC/Exec), allowing developers to drive infrastructure operations (up, down, preview) programmatically within Go, Node.js, Python, or .NET applications, rather than invoking the CLI via subprocess.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What happens when a Policy Pack enforcement level is set to `mandatory`?",
    "options": [
      "The policy runs only during `pulumi preview` and produces warnings",
      "The policy violation is logged, but the deployment proceeds regardless",
      "The deployment fails before any resources are provisioned if a policy violation is detected",
      "The policy is ignored if the resource is protected"
    ],
    "answer": "The deployment fails before any resources are provisioned if a policy violation is detected",
    "explanation": "Policy Packs validate resources. `mandatory` enforcement acts as a gate: if the policy validation logic returns a violation, the Pulumi engine blocks the `up` operation and fails the deployment immediately.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "For a Dynamic Provider implementation, what are the four required methods that must be exported?",
    "options": [
      "check, diff, create, update",
      "create, read, update, delete",
      "diff, create, delete, check",
      "configure, plan, apply, destroy"
    ],
    "answer": "create, read, update, delete",
    "explanation": "Dynamic Providers must implement the CRUD interface. Pulumi calls `check` for validation/inputs and `diff` to check changes, but the core lifecycle hooks that handle the actual API interactions with the external service are `create`, `read`, `update`, and `delete`.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the function of the `retainOnDelete` resource option?",
    "options": [
      "It ensures the resource is not updated if the change would cause downtime",
      "It keeps the physical resource in the cloud when it is removed from the Pulumi program or stack is destroyed",
      "It retains the old version of the resource in the state file for rollback purposes",
      "It prevents the Pulumi state file from being deleted"
    ],
    "answer": "It keeps the physical resource in the cloud when it is removed from the Pulumi program or stack is destroyed",
    "explanation": "When `retainOnDelete` is true, removing the resource code or running `pulumi destroy` will remove the resource from Pulumi's state management but will leave the actual resource running in the cloud provider.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How does the `replaceOnChanges` option differ from standard Pulumi diff behavior?",
    "options": [
      "It ignores the calculated diff and forces an update of the resource in-place",
      "It treats any change in the specified properties as a reason to destroy and recreate the resource",
      "It blocks the update if the properties match the regular expression provided",
      "It automatically rolls back the resource to the previous version if the change fails"
    ],
    "answer": "It treats any change in the specified properties as a reason to destroy and recreate the resource",
    "explanation": "Normally, Pulumi updates properties in-place. `replaceOnChanges` allows the user to specify a list of properties; if any of these properties change between old and new state, Pulumi forces a replacement (delete + create) instead of an update.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What does the `ignoreChanges` resource option allow the user to do?",
    "options": [
      "Skip the creation of the resource if it already exists in the cloud",
      "Prevent Pulumi from updating specific properties that are managed outside of Pulumi",
      "Disable the execution of `pulumi refresh` for that specific resource",
      "Exclude the resource from the dependency graph entirely"
    ],
    "answer": "Prevent Pulumi from updating specific properties that are managed outside of Pulumi",
    "explanation": "If a resource's properties are being mutated by an external process or manual intervention, Pulumi would normally try to revert them. `ignoreChanges` tells the engine to ignore drift on specific properties, preventing Pulumi from 'fixing' them.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the primary risk associated with using `deleteBeforeReplace: true` for a critical resource?",
    "options": [
      "It causes the state file to become corrupted if the delete fails",
      "It results in downtime or data loss if the resource is destroyed before the replacement is fully functional",
      "It prevents the new resource from being created in the same region as the old one",
      "It forces the resource to be created in a failed state"
    ],
    "answer": "It results in downtime or data loss if the resource is destroyed before the replacement is fully functional",
    "explanation": "Pulumi defaults to creating the replacement before destroying the old resource to minimize downtime. Enabling `deleteBeforeReplace` inverts this order, which is dangerous for stateful resources (like databases) as it destroys the existing asset before the new one is ready.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the role of the `pulumi.Input` type in statically typed languages like TypeScript?",
    "options": [
      "It represents a raw JSON string passed directly to the cloud provider API",
      "It accepts plain values, Promises, or Outputs to handle asynchronous dependency resolution",
      "It restricts the user from passing sensitive data like passwords",
      "It acts as a wrapper for environment variables only"
    ],
    "answer": "It accepts plain values, Promises, or Outputs to handle asynchronous dependency resolution",
    "explanation": "Properties in Pulumi resources often define inputs as `Input<T>`. This union type allows the developer to pass static values (`T`), asynchronous promises (`Promise<T>`), or Pulumi Outputs (`Output<T>`), simplifying the handling of dependency chains.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What distinguishes a Native Provider from a Bridged Provider in the Pulumi ecosystem?",
    "options": [
      "Native providers use Terraform, while Bridged providers use CloudFormation",
      "Native providers are written in a specific SDK language (Go/Node), while Bridged providers are automatically generated from Terraform modules",
      "Native providers only support AWS, Azure, and GCP",
      "Bridged providers require a paid license, while Native providers are always free"
    ],
    "answer": "Native providers are written in a specific SDK language (Go/Node), while Bridged providers are automatically generated from Terraform modules",
    "explanation": "Native providers (e.g., AWS Classic, AWSx) are hand-coded for better ergonomics and control. Bridged providers (e.g., most on the Pulumi Registry) are generated automatically from existing Terraform Provider schemas using the `pulumi-terraform-bridge` tool.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "When configuring a provider for a specific resource (e.g., a specific AWS region), how is this passed to the resource?",
    "options": [
      "By setting the `PULUMI_BACKEND_URL` environment variable",
      "By passing an instance of the Provider to the `provider` option in the Resource constructor",
      "By defining the provider configuration globally in `Pulumi.yaml` without instantiation",
      "By using the `pulumi config set aws:region` command before running `pulumi up`"
    ],
    "answer": "By passing an instance of the Provider to the `provider` option in the Resource constructor",
    "explanation": "While global config sets defaults, specific provider instances (created via `new aws.Provider(...)`) allow for multi-region/multi-cloud setups. These instances are passed to resources via the `provider: myProvider` option.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the purpose of the `pulumi.runtime.setStack` function in dynamic testing or Automation API contexts?",
    "options": [
      "To select which cloud provider to use for the deployment",
      "To mock the stack name and configuration for unit testing without a real backend",
      "To change the active stack in the Pulumi Service",
      "To delete the current stack and create a new one"
    ],
    "answer": "To mock the stack name and configuration for unit testing without a real backend",
    "explanation": "In unit tests (e.g., using `pulumi/testing` or `mocha`), `setStack` allows the developer to simulate a stack environment (name, project, config) so that resource logic can be tested in isolation without needing a full Pulumi deployment engine.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "How does Pulumi handle the `--target` and `--target-replace` flags during an update operation?",
    "options": [
      "`--target` creates a new resource, while `--target-replace` deletes the specified resource",
      "`--target` limits the update to dependencies of the specified URN, while `--target-replace` forces a replacement of the specified URN",
      "`--target` skips all dependency checks, while `--target-replace` runs a full refresh",
      "`--target` is used for importing, while `--target-replace` is used for exporting"
    ],
    "answer": "`--target` limits the update to dependencies of the specified URN, while `--target-replace` forces a replacement of the specified URN",
    "explanation": "Both flags limit the scope of the operation to the specified resource URN and its dependencies. `--target` attempts a standard update, whereas `--target-replace` explicitly forces the resource to be replaced (deleted and recreated) regardless of property diff logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the correct interpretation of 'Drift' in Pulumi operations?",
    "options": [
      "The difference between the source code and the Pulumi state file",
      "The divergence between the actual cloud infrastructure and the Pulumi state file",
      "The latency introduced by the gRPC communication between CLI and the language host",
      "The automatic renaming of a resource when it is moved to a new stack"
    ],
    "answer": "The divergence between the actual cloud infrastructure and the Pulumi state file",
    "explanation": "Drift occurs when infrastructure is modified manually (via console or CLI) outside of Pulumi. This causes the actual cloud state to no longer match the last known state recorded by Pulumi.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the function of `pulumi.Alias` when creating a new resource?",
    "options": [
      "To map the new resource to a pre-existing URN from a previous deployment, preventing replacement",
      "To create a DNS CNAME record for the resource",
      "To give the resource multiple names in the cloud provider",
      "To hide the resource in the Pulumi Console"
    ],
    "answer": "To map the new resource to a pre-existing URN from a previous deployment, preventing replacement",
    "explanation": "If you refactor code to change a resource's name or parent, Pulumi usually sees it as a new resource (old delete, new create). Using `aliases` with the old URN/Name tells Pulumi that the new resource is actually the same as the old one, preserving its state.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In the context of Pulumi Secrets, which command rotates the encryption key for a stack?",
    "options": [
      "`pulumi config rotate`",
      "`pulumi stack key`",
      "`pulumi encrypt --rotate`",
      "`pulumi state rotate-key`"
    ],
    "answer": "`pulumi stack key`",
    "explanation": "The command `pulumi stack key` (often used with `--rotate` in specific contexts or managed via the Pulumi Service interface) handles the rotation of the stack's encryption key. It re-encrypts all secrets in the state file with the new key.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Which of the following best describes `pulumi.ConstructResult` in the context of Dynamic Providers?",
    "options": [
      "A method to compute the cost of the resource before creation",
      "A structure containing the ID and outputs of a resource after a Create or Update operation",
      "A function that validates the inputs against a JSON schema",
      "The final state of the stack after `pulumi up` completes"
    ],
    "answer": "A structure containing the ID and outputs of a resource after a Create or Update operation",
    "explanation": "For dynamic providers, the `create` and `update` functions must return a `ConstructResult`. This object bundles the unique ID of the created resource and its computed outputs, which Pulumi then merges into the state.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "When using `pulumi state move`, what operation is being performed?",
    "options": [
      "Physically moving a cloud resource from one region to another",
      "Changing the logical parent or name of a resource within the Pulumi state file",
      "Migrating the stack from the Pulumi Service to a self-managed S3 bucket",
      "Deleting the resource from the state file"
    ],
    "answer": "Changing the logical parent or name of a resource within the Pulumi state file",
    "explanation": "`pulumi state move` is a refactoring tool. It allows you to restructure your code (e.g., moving a resource into a Component Resource or renaming it) and update the state to match, preventing Pulumi from deleting and recreating the resource.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is a limitation of the `pulumi.com/pulumi-auto` (Automation API) workspace?",
    "options": [
      "It cannot access secure environment variables",
      "It does not support multi-stack deployments in a single process",
      "It requires the underlying Pulumi CLI to be installed on the system",
      "It only works with JavaScript/TypeScript programs"
    ],
    "answer": "It requires the underlying Pulumi CLI to be installed on the system",
    "explanation": "The Automation API acts as a wrapper around the Pulumi CLI and engine. It requires the `pulumi` binary to be present in the system's PATH to function, as it relies on it for backend operations and plugin management.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "How does the `customTimeouts` option affect a resource operation?",
    "options": [
      "It creates a schedule for when the resource can be updated (e.g., maintenance window)",
      "It overrides the default provider-specific timeouts for Create, Update, and Delete operations",
      "It sets the maximum time a `pulumi preview` is allowed to run",
      "It defines how long Pulumi waits before retrying a failed API call"
    ],
    "answer": "It overrides the default provider-specific timeouts for Create, Update, and Delete operations",
    "explanation": "Cloud providers have default timeouts for API operations. The `customTimeouts` option allows developers to extend or reduce these durations for specific resources (e.g., increasing create time for a large RDS instance) to prevent Pulumi from failing the operation prematurely.",
    "difficulty": "Advanced"
  }
]