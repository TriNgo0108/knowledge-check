[
  {
    "id": 1,
    "question": "Which utility type makes all properties of a Type optional?",
    "options": [
      "Required<Type>",
      "Partial<Type>",
      "Readonly<Type>",
      "Omit<Type>"
    ],
    "answer": "Partial<Type>",
    "explanation": "Partial<Type> constructs a type with all properties of Type set to optional. Required makes them mandatory, Readonly makes them immutable, and Omit removes keys entirely.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the result of the type `Omit<{ a: string; b: number; }, 'a'>`?",
    "options": [
      "{ a: string; }",
      "{ b: number; }",
      "{ a: string; b: number; }",
      "never"
    ],
    "answer": "{ b: number; }",
    "explanation": "Omit creates a new type by picking all properties from the first type and then removing the specified keys ('a').",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which TypeScript feature allows you to extract the return type of a function?",
    "options": [
      "Parameters",
      "ReturnType",
      "Infer",
      "typeof"
    ],
    "answer": "ReturnType",
    "explanation": "ReturnType<T> extracts the type returned by a function type T. Parameters extracts argument types, while 'typeof' extracts the type of a value.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In TypeScript, what is the primary difference between `interface` and `type`?",
    "options": [
      "Interfaces cannot use generics",
      "Types support declaration merging",
      "Interfaces support declaration merging",
      "Types are strictly for objects"
    ],
    "answer": "Interfaces support declaration merging",
    "explanation": "Interfaces can be declared multiple times and their definitions will be merged, whereas type aliases create a single, rigid definition and cannot be re-opened.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which type represents the absence of any value at the bottom of the type hierarchy?",
    "options": [
      "null",
      "undefined",
      "void",
      "never"
    ],
    "answer": "never",
    "explanation": "never represents the type of values that never occur, such as the return type of a function that throws an error or loops infinitely.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "How do you define a variable that can hold a string or a number in TypeScript?",
    "options": [
      "let val: string & number",
      "let val: string | number",
      "let val: (string, number)",
      "let val: string + number"
    ],
    "answer": "let val: string | number",
    "explanation": "The pipe operator (|) denotes a Union type, allowing the variable to be one of several types. The ampersand (&) denotes an Intersection type.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does the `Readonly` utility type do?",
    "options": [
      "Prevents a variable from being reassigned",
      "Makes all properties of an object immutable",
      "Hides properties from external access",
      "Allows read access only at compile time"
    ],
    "answer": "Makes all properties of an object immutable",
    "explanation": "Readonly maps all properties of an object type to be readonly, meaning they cannot be reassigned once initialized.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which operator is used to access the type of a variable or property?",
    "options": [
      "typeof",
      "instanceof",
      "type",
      ":type"
    ],
    "answer": "typeof",
    "explanation": "The typeof query operator returns the type of a variable or property, allowing you to capture it in a type alias.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the output type of `Pick<{ a: number; b: string; }, 'a'>`?",
    "options": [
      "string",
      "number",
      "{ a: number; }",
      "{ b: string; }"
    ],
    "answer": "{ a: number; }",
    "explanation": "Pick constructs a type by selecting the set of properties (in this case 'a') from the source type, preserving their types.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What does the NonNullabe utility type do?",
    "options": [
      "Removes null and undefined from Type",
      "Ensures a variable is not null at runtime",
      "Changes a type to strictly not null",
      "Adds a runtime check for null"
    ],
    "answer": "Removes null and undefined from Type",
    "explanation": "NonNullable constructs a type by excluding null and undefined from the given Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which utility type constructs a type with all properties of Type set to required?",
    "options": [
      "Partial<Type>",
      "Required<Type>",
      "Confirm<Type>",
      "Assert<Type>"
    ],
    "answer": "Required<Type>",
    "explanation": "Required<Type> makes all optional properties required, essentially removing the optional modifiers (?) from the keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "How do you specify an array of strings in TypeScript?",
    "options": [
      "Array(string)",
      "string[]",
      "Strings[]",
      "[string]"
    ],
    "answer": "string[]",
    "explanation": "string[] or Array<string> denotes an array containing elements of type string.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is a Tuple in TypeScript?",
    "options": [
      "An array with mixed types",
      "An array with a fixed number of elements of specific types",
      "A key-value pair data structure",
      "A type that cannot be changed"
    ],
    "answer": "An array with a fixed number of elements of specific types",
    "explanation": "Tuples allow you to express an array where the type of a fixed number of elements is known, e.g., [string, number].",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which keyword is used to assert that a value is not null or undefined despite TypeScript's analysis?",
    "options": [
      "!",
      "?",
      "??",
      "--"
    ],
    "answer": "!",
    "explanation": "The non-null assertion operator (!) asserts to the compiler that the operand is not null or undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the `unknown` type used for?",
    "options": [
      "To represent any type without type checking",
      "To represent a value that is not known yet but requires type checking before use",
      "To represent a variable that cannot be typed",
      "To represent void or empty values"
    ],
    "answer": "To represent a value that is not known yet but requires type checking before use",
    "explanation": "unknown is a type-safe counterpart of any; you must perform some form of checking or assertion before using values of type unknown.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which utility type extracts the types of a function's parameters into a tuple?",
    "options": [
      "Arguments",
      "Params",
      "Parameters",
      "Args"
    ],
    "answer": "Parameters",
    "explanation": "Parameters<T> extracts the parameter types from a function type T and returns them as a tuple type.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the result of `Extract<'a' | 'b', 'a'>`?",
    "options": [
      "'b'",
      "never",
      "'a'",
      "'a' | 'b'"
    ],
    "answer": "'a'",
    "explanation": "Extract constructs a type by extracting from Type all union members that are assignable to Union.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What does the `keyof` operator do?",
    "options": [
      "Gets the value of an object key",
      "Returns a union of all property names of a type",
      "Checks if a key exists",
      "Creates a new object type"
    ],
    "answer": "Returns a union of all property names of a type",
    "explanation": "The keyof operator produces a string or numeric literal union of the keys of the input type.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "How do you define an optional property in an interface?",
    "options": [
      "Using the pipe operator |",
      "Using the question mark ?",
      "Using the optional keyword",
      "Using the undefined keyword"
    ],
    "answer": "Using the question mark ?",
    "explanation": "Appending a question mark (?) to a property name in an interface or type alias marks that property as optional.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which type constructs an object type whose property keys are of a specific type and values are another type?",
    "options": [
      "Map",
      "Dictionary",
      "Record<Keys, Type>",
      "Object<Keys, Type>"
    ],
    "answer": "Record<Keys, Type>",
    "explanation": "Record<Keys, Type> constructs an object type with property keys of type Keys and values of type Type.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the `void` type used for?",
    "options": [
      "To represent variables with no value",
      "To represent the return type of functions that do not return a value",
      "To represent null or undefined",
      "To represent empty objects"
    ],
    "answer": "To represent the return type of functions that do not return a value",
    "explanation": "void is the absence of having any type at all and is commonly used as the return type for functions that do not return anything.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which operator allows you to provide a default value if a variable is null or undefined?",
    "options": [
      "||",
      "&&",
      "??",
      "?:"
    ],
    "answer": "??",
    "explanation": "The nullish coalescing operator (??) returns the right-hand operand only when the left-hand operand is null or undefined.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What is a Type Guard in TypeScript?",
    "options": [
      "A function that checks types at runtime",
      "A keyword that locks a variable type",
      "A compiler directive",
      "A utility type to restrict types"
    ],
    "answer": "A function that checks types at runtime",
    "explanation": "Type guards are expressions that perform a runtime check guaranteeing the type in a specific scope, often using `typeof`, `instanceof`, or custom predicates.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What does `Exclude<UnionType, ExcludedMembers>` do?",
    "options": [
      "Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers",
      "Removes properties from an object",
      "Filters null values",
      "Intersects two types"
    ],
    "answer": "Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers",
    "explanation": "Exclude removes specific types from a union.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "How do you declare a generic function?",
    "options": [
      "function func<T>(arg: T)",
      "function func(arg: T)",
      "function func(arg: <T>)",
      "function func(T): any"
    ],
    "answer": "function func<T>(arg: T)",
    "explanation": "Generic functions declare a type parameter (e.g., <T>) before the parameter list to capture the type provided by the caller.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the behavior of the `as const` assertion?",
    "options": [
      "It converts a variable to a constant at runtime",
      "It infers the most specific literal type possible and makes the object readonly",
      "It prevents the variable from being overwritten",
      "It creates a new class"
    ],
    "answer": "It infers the most specific literal type possible and makes the object readonly",
    "explanation": "as const creates a readonly tuple or object with literal types (e.g., 'hello' instead of string) rather than generic primitives.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which access modifier makes a class member accessible only within the class it is defined in?",
    "options": [
      "public",
      "private",
      "protected",
      "internal"
    ],
    "answer": "private",
    "explanation": "private restricts access strictly to the defining class, whereas protected allows access in subclasses.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the `infer` keyword used for?",
    "options": [
      "Inferring the type of a variable",
      "Conditional type logic to extract a type part",
      "Creating a new class instance",
      "Checking types at runtime"
    ],
    "answer": "Conditional type logic to extract a type part",
    "explanation": "infer is used within conditional types to declare a type variable that TypeScript will attempt to infer from the type being checked.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which symbol denotes a mapped type transformation?",
    "options": [
      "[K in keyof T]",
      "[K of T]",
      "T[K]",
      "keyof T"
    ],
    "answer": "[K in keyof T]",
    "explanation": "The syntax `[P in keyof T]: T[P]` iterates over all keys in T to create a new type, defining a mapped type.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "How do you define an index signature for an object with string keys and number values?",
    "options": [
      "[string]: number",
      "{ [key: string]: number }",
      "key string: number",
      "Map<string, number>"
    ],
    "answer": "{ [key: string]: number }",
    "explanation": "Index signatures use the syntax [key: KeyType]: ValueType to define dynamic property keys on an object.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What does the `any` type signify?",
    "options": [
      "A variable that can be anything",
      "A type that represents the absence of type checking",
      "A type for non-nullable values",
      "A strict type for mixed content"
    ],
    "answer": "A type that represents the absence of type checking",
    "explanation": "any effectively turns off TypeScript type checking for that variable, allowing any operation.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the output of `typeof` on a class instance?",
    "options": [
      "The class name as a string",
      "The class constructor type",
      "'object'",
      "'instance'"
    ],
    "answer": "'object'",
    "explanation": "typeof returns the JavaScript type string; for class instances (which are objects), this is 'object'.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which utility type maps keys of Type to another type?",
    "options": [
      "MapType",
      "Record",
      "KeyMapper",
      "InferType"
    ],
    "answer": "Record",
    "explanation": "While mapped types do this generally, Record<Keys, Type> is the specific utility for creating an object type with keys of type Keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the purpose of the `tsconfig.json` file?",
    "options": [
      "To list project dependencies",
      "To configure the TypeScript compiler options and root files",
      "To run the application",
      "To define runtime environments"
    ],
    "answer": "To configure the TypeScript compiler options and root files",
    "explanation": "tsconfig.json defines the root files and the compiler options required to compile the project.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which utility type constructs a type by picking the set of keys `K` from type `T`?",
    "options": [
      "Pick<T, K>",
      "Select<T, K>",
      "Partial<T, K>",
      "Extract<T, K>"
    ],
    "answer": "Pick<T, K>",
    "explanation": "`Pick<T, K>` creates a new type by extracting the specified properties `K` from `T`. `Select` does not exist, while `Partial` makes all properties optional and `Extract` selects types from a union.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the result of using the `Exclude<UnionType, ExcludedMembers>` utility type?",
    "options": [
      "It removes all types from `UnionType` that are assignable to `ExcludedMembers`",
      "It removes all types from `ExcludedMembers` that are assignable to `UnionType`",
      "It intersects `UnionType` with `ExcludedMembers`",
      "It filters an object's properties based on the keys in `ExcludedMembers`"
    ],
    "answer": "It removes all types from `UnionType` that are assignable to `ExcludedMembers`",
    "explanation": "`Exclude` filters a union type by removing members that match the excluded type. It operates on type unions, not object property keys (which is the purpose of `Omit`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which utility type allows you to extract the return type of a function type `T`?",
    "options": [
      "ReturnType<T>",
      "ExtractReturnType<T>",
      "GetReturn<T>",
      "ValueOf<T>"
    ],
    "answer": "ReturnType<T>",
    "explanation": "`ReturnType<T>` specifically infers the return type of a function passed to it. `ValueOf` gets the union of values in an object, and the others are not standard TypeScript utilities.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How does the `Partial<T>` utility type transform the properties of `T`?",
    "options": [
      "It sets all properties to optional (`?`)",
      "It sets all properties to required",
      "It makes all properties read-only",
      "It removes null and undefined from all properties"
    ],
    "answer": "It sets all properties to optional (`?`)",
    "explanation": "`Partial<T>` maps over all properties of `T` and adds the optional modifier (`?`) to each key. `Required` does the opposite, and `Readonly` prevents modification.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the primary difference between the `satisfies` operator and standard type annotations (`:`)?",
    "options": [
      "`satisfies` checks compatibility but retains the specific inferred type of the expression",
      "`satisfies` allows implicit any checks, while type annotations throw errors",
      "`satisfies` is used only for interfaces, while `:` is used for types",
      "There is no difference; they are interchangeable syntaxes"
    ],
    "answer": "`satisfies` checks compatibility but retains the specific inferred type of the expression",
    "explanation": "The `satisfies` operator ensures a value matches a type but preserves the more specific literal type for better subsequent usage. Standard type annotations (`:`) often widen the type to the base annotation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which standard utility type is equivalent to `Pick<T, Exclude<keyof T, K>>`?",
    "options": [
      "Omit<T, K>",
      "Remove<T, K>",
      "Diff<T, K>",
      "Without<T, K>"
    ],
    "answer": "Omit<T, K>",
    "explanation": "`Omit` constructs a type by picking all properties from `T` and then removing `K`. This is functionally implemented as `Pick<T, Exclude<keyof T, K>>`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the output of the `Parameters<T>` utility type when `T` is a function type?",
    "options": [
      "A tuple type of the function's parameter types",
      "An array type of the function's parameter types",
      "A union of the function's parameter types",
      "An object type containing the function's parameter names"
    ],
    "answer": "A tuple type of the function's parameter types",
    "explanation": "`Parameters<T>` returns a tuple type representing the types of the function's arguments in order. It captures the specific signature, unlike a generic array.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "When using conditional types, what happens if `T` is a union type (e.g., `A | B`) in `T extends U ? X : Y`?",
    "options": [
      "The conditional type distributes automatically over the union",
      "The conditional type evaluates the union as a single whole",
      "It throws a syntax error regarding unions in conditionals",
      "Only the first member of the union is evaluated"
    ],
    "answer": "The conditional type distributes automatically over the union",
    "explanation": "This is called a Distributive Conditional Type. TypeScript instantiates the conditional type automatically for each member of the union `T` (e.g., `(A extends U ? X : Y) | (B extends U ? X : Y)`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the purpose of the `keyof` operator?",
    "options": [
      "It retrieves a union of all known property keys (names) of a type",
      "It retrieves the type of a specific property in an object",
      "It validates that a key exists in an object at runtime",
      "It converts a value into a property key"
    ],
    "answer": "It retrieves a union of all known property keys (names) of a type",
    "explanation": "`keyof T` produces a string or numeric literal union of the property names of `T`. To retrieve the type of a specific property, you would use indexed access `T['key']`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which keyword is used within a conditional type to infer a type variable for subsequent use?",
    "options": [
      "infer",
      "derive",
      "typeof",
      "generic"
    ],
    "answer": "infer",
    "explanation": "The `infer` keyword introduces a type variable that TypeScript will infer from the structure being checked (e.g., `T extends Array<infer U> ? U : never`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "How does `Readonly<T>` affect the properties of `T`?",
    "options": [
      "It sets the `readonly` modifier on all properties",
      "It prevents the object reference from being reassigned",
      "It deep freezes the object structure entirely",
      "It converts the type into a tuple"
    ],
    "answer": "It sets the `readonly` modifier on all properties",
    "explanation": "`Readonly<T>` is a mapped type that adds the `readonly` modifier to every property of `T`, preventing reassignment of those properties. It is shallow (does not affect nested properties).",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the result of `Record<Keys, Type>`?",
    "options": [
      "An object type with property keys of `Keys` and values of type `Type`",
      "A Map object where keys are mapped to Types",
      "A dictionary type where keys are always strings",
      "A union of all Types associated with Keys"
    ],
    "answer": "An object type with property keys of `Keys` and values of type `Type`",
    "explanation": "`Record` constructs an object type whose property keys are `Keys` (often a union of string/number literals) and whose property values are `Type`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which utility type creates a new type with all properties of `T` set to required, removing optional modifiers?",
    "options": [
      "Required<T>",
      "Strict<T>",
      "Defined<T>",
      "NonNullable<T>"
    ],
    "answer": "Required<T>",
    "explanation": "`Required<T>` removes the `?` modifier from all properties in `T`, making them mandatory. `NonNullable` only removes `null` and `undefined` from the type itself.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What does the `NonNullable<T>` utility type do?",
    "options": [
      "It removes `null` and `undefined` from `T`",
      "It removes all optional properties from `T`",
      "It ensures `T` is not the `any` type",
      "It enforces that `T` is a primitive type"
    ],
    "answer": "It removes `null` and `undefined` from `T`",
    "explanation": "`NonNullable<T>` constructs a type by excluding `null` and `undefined` from `T`. It does not affect the optionality of object properties (which is handled by `Required`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In mapped types, what is the function of the `as` clause?",
    "options": [
      "It allows remapping of keys to a new type",
      "It asserts the type of the value",
      "It casts the resulting object to an interface",
      "It prevents the mapping of certain properties"
    ],
    "answer": "It allows remapping of keys to a new type",
    "explanation": "Key remapping via `as` (e.g., `[P in keyof T as NewKeyType]: T[P]`) allows you to transform the property names during the creation of a mapped type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the definition of `ThisType<T>`?",
    "options": [
      "It does not transform a type but acts as a marker for contextual `this` typing",
      "It transforms a method to bind `this` to a specific class instance",
      "It asserts that a function is a valid constructor",
      "It creates a type alias for the global `this` object"
    ],
    "answer": "It does not transform a type but acts as a marker for contextual `this` typing",
    "explanation": "`ThisType<T>` is a utility marker that signals to the compiler that `this` within the object literal should be typed as `T` inside methods.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the difference between `unknown` and `any`?",
    "options": [
      "`unknown` is type-safe (requires narrowing), while `any` allows anything without checking",
      "`any` is type-safe, while `unknown` allows anything without checking",
      "`unknown` is the top type of the type system, while `any` is the bottom type",
      "There is no difference; they are aliases"
    ],
    "answer": "`unknown` is type-safe (requires narrowing), while `any` allows anything without checking",
    "explanation": "`unknown` forces you to perform type checks before using the value, whereas `any` effectively disables type checking, allowing any operation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which utility type extracts the type of the `this` parameter of a function type?",
    "options": [
      "ThisParameterType<T>",
      "ExtractThis<T>",
      "TypeOfThis<T>",
      "InstanceType<T>"
    ],
    "answer": "ThisParameterType<T>",
    "explanation": "`ThisParameterType<T>` extracts the type of the `this` parameter for a function type. `InstanceType` extracts the instance type of a constructor.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What does the `OmitThisParameter<T>` utility type do?",
    "options": [
      "Removes the `this` parameter from a function type `T`",
      "Removes the `this` keyword from the body of the function",
      "Converts `this` into the global scope",
      "Makes the `this` parameter optional"
    ],
    "answer": "Removes the `this` parameter from a function type `T`",
    "explanation": "`OmitThisParameter<T>` constructs a new function type by stripping out the explicit `this` parameter from `T`, allowing the function to be used where `this` is not typed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which assertion operator creates an immutable literal type expression?",
    "options": [
      "as const",
      "readonly",
      "as final",
      "const"
    ],
    "answer": "as const",
    "explanation": "The `as const` assertion creates a read-only, non-widening literal type (e.g., converting `'red'` to the type `'red'` rather than `string`). `readonly` is a type modifier, not an assertion operator.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "How does TypeScript treat excess property checks in object literals?",
    "options": [
      "They occur only when the object literal is assigned directly to a variable with a specific type",
      "They occur for all object assignments regardless of context",
      "They are disabled when using the `any` type",
      "They are a runtime feature of JavaScript"
    ],
    "answer": "They occur only when the object literal is assigned directly to a variable with a specific type",
    "explanation": "Excess property checking strictly applies when assigning a fresh object literal to a variable. If the object is assigned to a variable first, TypeScript allows extra properties due to structural typing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the output of `ReturnType<() => Promise<string>>`?",
    "options": [
      "Promise<string>",
      "string",
      "Async<string>",
      "unknown"
    ],
    "answer": "Promise<string>",
    "explanation": "`ReturnType` extracts the type returned by the function. Since the function returns a `Promise`, the result is `Promise<string>`. To get `string`, you would need to use `Awaited`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "Which utility type would you use to unwrap Promise types recursively?",
    "options": [
      "Awaited<T>",
      "UnwrapPromise<T>",
      "DeepPromise<T>",
      "ResolveType<T>"
    ],
    "answer": "Awaited<T>",
    "explanation": "`Awaited<T>` recursively unwraps Promises to get the final resolution type. `ReturnType` does not perform this recursive unwrapping.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is the behavior of `Extract<T, U>`?",
    "options": [
      "It selects all types from `T` that are assignable to `U`",
      "It removes all types from `T` that are assignable to `U`",
      "It intersects `T` with `U`",
      "It creates a union of `T` and `U`"
    ],
    "answer": "It selects all types from `T` that are assignable to `U`",
    "explanation": "`Extract` is the opposite of `Exclude`; it pulls out members of the union `T` that match the constraint `U`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "When defining a Generic, how do you constrain a type parameter `T` to be a subtype of `Base`?",
    "options": [
      "<T extends Base>",
      "<T : Base>",
      "<T implements Base>",
      "<T super Base>"
    ],
    "answer": "<T extends Base>",
    "explanation": "The `extends` keyword in a generic declaration (`<T extends Base>`) constrains `T` to be a subtype of `Base`. This syntax is specific to type constraints.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is a Type Predicate in TypeScript?",
    "options": [
      "A function return type annotation `arg is Type` that narrows the type in conditionals",
      "A type that only accepts boolean values",
      "A utility that checks if a property exists",
      "A class method that returns the type name"
    ],
    "answer": "A function return type annotation `arg is Type` that narrows the type in conditionals",
    "explanation": "A type predicate (e.g., `function isString(val: unknown): val is string`) informs the compiler that if the function returns true, the argument is of the specified type.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How do Template Literal Types function?",
    "options": [
      "They build string literal types via concatenation",
      "They allow runtime string interpolation in types",
      "They convert any type to a string representation",
      "They enforce specific character casing"
    ],
    "answer": "They build string literal types via concatenation",
    "explanation": "Template literal types (e.g., `${Key & string}: ${Value}`) allow for the creation of string literal union types based on the structure of other types.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which utility returns the instance type of a constructor function `C`?",
    "options": [
      "InstanceType<C>",
      "New<C>",
      "ConstructType<C>",
      "ReturnType<C>"
    ],
    "answer": "InstanceType<C>",
    "explanation": "`InstanceType<C>` extracts the type returned by the `new` operator of a class or constructor function. `ReturnType` would extract the constructor function itself.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the `Uppercase<StringType>` utility used for?",
    "options": [
      "To transform a string literal type to its uppercased version",
      "To cast a string value to uppercase at runtime",
      "To enforce that a string only contains uppercase characters",
      "To create a generic object wrapper"
    ],
    "answer": "To transform a string literal type to its uppercased version",
    "explanation": "It is a type-level manipulation that converts string literal types (e.g., 'hello') to uppercase ('HELLO'). It has no runtime effect.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What does the `NoInfer<T>` utility type prevent?",
    "options": [
      "Type inference of a generic type argument from a specific usage site",
      "Usage of the `infer` keyword in conditional types",
      "Explicit type annotations",
      "Type narrowing in control flow analysis"
    ],
    "answer": "Type inference of a generic type argument from a specific usage site",
    "explanation": "`NoInfer` blocks a type parameter from being inferred by a specific call site, forcing it to be specified explicitly or inferred from other parameters.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "In a mapped type, how do you make a property optional only if a condition is met?",
    "options": [
      "Use a conditional type with `?` (e.g., `keyof T extends Key ? T[P] : never`)",
      "Use the `Optional` utility",
      "Add a `?` after the property key automatically",
      "Use the `Partial` utility on the specific property"
    ],
    "answer": "Use a conditional type with `?` (e.g., `keyof T extends Key ? T[P] : never`)",
    "explanation": "Advanced mapped types combine `+?` or `-?` modifiers with conditional types (e.g., `[P in keyof T as T[P] extends Condition ? P : never]?: ...`) to selectively add optionality.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the primary limitation of the `Partial<T>` utility regarding nested objects?",
    "options": [
      "It is shallow; it does not make properties of nested objects optional",
      "It cannot be used with interfaces",
      "It removes type information from nested objects",
      "It converts nested objects into arrays"
    ],
    "answer": "It is shallow; it does not make properties of nested objects optional",
    "explanation": "Standard `Partial` only adds `?` to the top-level properties. To make nested objects optional, you must implement a recursive mapped type (e.g., `DeepPartial`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "Which declaration merging scenario is NOT supported in TypeScript?",
    "options": [
      "Merging a class with an interface",
      "Merging an interface with an interface",
      "Merging a namespace with a class",
      "Merging a namespace with a function"
    ],
    "answer": "Merging a class with an interface",
    "explanation": "Classes cannot merge with interfaces. Interfaces can merge with other interfaces, and namespaces/functions/classes can merge with namespaces, but a class cannot adopt an interface's members via declaration merging.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the result of `keyof any`?",
    "options": [
      "string | number",
      "any",
      "never",
      "object"
    ],
    "answer": "string | number",
    "explanation": "`keyof any` represents the set of all possible keys for a generic object, which can be either strings or symbols (and implicitly numbers, as they are string-coerced in keys). The result simplifies to `string | number`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "How do you enforce that a generic type parameter has a specific property?",
    "options": [
      "Use a constraint `extends { property: Type }`",
      "Use a type guard in the generic definition",
      "Use the `require` keyword",
      "Use `implements` in the generic list"
    ],
    "answer": "Use a constraint `extends { property: Type }`",
    "explanation": "Generics are constrained using `extends`. To check for a property, you extend a structural type: `<T extends { id: string }>`. `implements` is used in class declarations.",
    "difficulty": "Intermediate"
  }
]