[
  {
    "id": 1,
    "question": "Which of the following is NOT a valid way to start a comment in Python?",
    "options": [
      "# This is a comment",
      "/* This is a comment */",
      "docstrings can serve as comments",
      "Inline comments follow a code statement"
    ],
    "answer": "/* This is a comment */",
    "explanation": "Python uses the hash symbol (#) for single-line comments. It does not support block comments using /* */ syntax, which is found in languages like C or Java.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the output of the expression: `3 * 'abc'`?",
    "options": [
      "9",
      "'abcabcabc'",
      "'3abc'",
      "TypeError"
    ],
    "answer": "'abcabcabc'",
    "explanation": "In Python, multiplying a sequence (like a string) by an integer `n` concatenates `n` copies of that sequence. Therefore, 'abc' repeated 3 times results in 'abcabcabc'.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which keyword is used to define a function in Python?",
    "options": [
      "func",
      "function",
      "def",
      "define"
    ],
    "answer": "def",
    "explanation": "The `def` keyword is the standard statement in Python used to define a function, followed by the function name and parentheses.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the result of `bool(0)` in Python?",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "answer": "False",
    "explanation": "In Python, the integer 0 is considered False in a boolean context. Any non-zero number is evaluated as True.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which data type is immutable?",
    "options": [
      "List",
      "Dictionary",
      "Tuple",
      "Set"
    ],
    "answer": "Tuple",
    "explanation": "Tuples are immutable, meaning their elements cannot be changed after creation. Lists, dictionaries, and sets are mutable data structures.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "How do you create a variable with a floating-point number value?",
    "options": [
      "x = int(3.14)",
      "x = 3.14",
      "x = '3.14'",
      "x = float(3)"
    ],
    "answer": "x = 3.14",
    "explanation": "Python automatically infers the type based on the assigned value. Writing `x = 3.14` assigns a float, while `int(3.14)` would truncate to 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the correct way to create a function that accepts an arbitrary number of positional arguments?",
    "options": [
      "def my_func(*args):",
      "def my_func(**args):",
      "def my_func(args...):",
      "def my_func(&args):"
    ],
    "answer": "def my_func(*args):",
    "explanation": "The `*args` syntax allows a function to accept any number of positional arguments, which are then accessible as a tuple within the function.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which of the following correctly accesses the value associated with the key 'name' in a dictionary `person`?",
    "options": [
      "person['name']",
      "person{name}",
      "person.get('name')",
      "person(name)"
    ],
    "answer": "person['name']",
    "explanation": "Dictionary values are accessed using square brackets and the key (e.g., `person['name']`). While `get()` is also valid, it is a method, not the primary accessor syntax shown in the option set.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the output of `print(type([]))`?",
    "options": [
      "<class 'list'>",
      "<class 'array'>",
      "list",
      "<type 'list'>"
    ],
    "answer": "<class 'list'>",
    "explanation": "In Python 3, the `type()` function returns the type of the object. An empty literal `[]` creates a list, represented as `<class 'list'>`.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which operator checks for identity rather than equality?",
    "options": [
      "==",
      "=",
      "is",
      "eq"
    ],
    "answer": "is",
    "explanation": "The `is` operator checks if two variables point to the same object in memory (identity), whereas `==` checks if their values are equal.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the result of `10 % 3`?",
    "options": [
      "3",
      "1",
      "3.33",
      "0"
    ],
    "answer": "1",
    "explanation": "The `%` operator is the modulo operator, which returns the remainder of the division of 10 by 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which statement is used to prevent a block of code from doing anything (acting as a placeholder)?",
    "options": [
      "continue",
      "break",
      "pass",
      "return"
    ],
    "answer": "pass",
    "explanation": "The `pass` statement is a null operation; it allows code to be syntactically correct where a statement is required but no action is needed.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "How do you start a `for` loop that iterates over the items in a list `my_list`?",
    "options": [
      "for (i = 0; i < len(my_list); i++)",
      "for item in my_list:",
      "foreach item in my_list:",
      "for i in range(my_list):"
    ],
    "answer": "for item in my_list:",
    "explanation": "Python uses `for item in iterable:` syntax to iterate directly over elements. C-style loops are not used in Python.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which built-in function is used to get the length of a list or string?",
    "options": [
      "length()",
      "len()",
      "size()",
      "count()"
    ],
    "answer": "len()",
    "explanation": "The `len()` function returns the number of items in a container or the number of characters in a string.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What happens when you try to add a string and an integer in Python 3 (e.g., `'2' + 2)`?",
    "options": [
      "The result is '22'",
      "The result is 4",
      "A TypeError is raised",
      "The integer is converted to a string automatically"
    ],
    "answer": "A TypeError is raised",
    "explanation": "Python 3 does not perform implicit type coercion between different types for the `+` operator; you must explicitly convert types.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which of the following methods adds an element to the end of a list?",
    "options": [
      "add()",
      "append()",
      "push()",
      "insert()"
    ],
    "answer": "append()",
    "explanation": "The `append()` method adds a single item to the end of the list. `insert()` is used for specific indices, while `push` is not a standard list method.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the output of `print('Python'[1:4])`?",
    "options": [
      "Pyt",
      "yth",
      "ytho",
      "on"
    ],
    "answer": "yth",
    "explanation": "String slicing includes the start index but excludes the end index. Index 1 is 'y', and index 4 is 'h', so it takes indices 1, 2, and 3.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which keyword is used to import a module?",
    "options": [
      "include",
      "import",
      "require",
      "using"
    ],
    "answer": "import",
    "explanation": "The `import` keyword is used to make modules (external Python files) and their contents available in the current namespace.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the primary purpose of the `__init__` method in a class?",
    "options": [
      "To destroy the object",
      "To initialize the object's attributes",
      "To compare two objects",
      "To convert the object to a string"
    ],
    "answer": "To initialize the object's attributes",
    "explanation": "`__init__` is a constructor method that runs automatically when a new instance of a class is created, used to set up initial attributes.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which of the following is a valid dictionary key in Python?",
    "options": [
      "A list",
      "Another dictionary",
      "A tuple containing integers",
      "A set"
    ],
    "answer": "A tuple containing integers",
    "explanation": "Dictionary keys must be immutable (hashable). Tuples are immutable, whereas lists, sets, and other dictionaries are mutable and cannot be used as keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What does the `raise` keyword do?",
    "options": [
      "It catches an exception",
      "It creates a new class",
      "It triggers an exception manually",
      "It increases a variable's value"
    ],
    "answer": "It triggers an exception manually",
    "explanation": "The `raise` keyword allows a developer to force a specific exception to occur, interrupting the normal flow of the program.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the result of the expression `set([1, 1, 2, 3])`?",
    "options": [
      "{1, 2, 3}",
      "[1, 1, 2, 3]",
      "{1, 1, 2, 3}",
      "Error"
    ],
    "answer": "{1, 1, 2, 3}",
    "explanation": "Sets are unordered collections of unique elements. However, converting a list with duplicates to a set results in a set containing only unique elements, usually represented as {1, 2, 3}. Wait, looking at the options, {1, 2, 3} is the conceptual result, but options usually contain distractor formatting. If the option `{1, 1, 2, 3}` is there as a distractor, the correct valid set representation is `{1, 2, 3}`.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which function reads a single line from standard input?",
    "options": [
      "input()",
      "raw_input()",
      "read()",
      "scan()"
    ],
    "answer": "input()",
    "explanation": "In Python 3, `input()` reads a line from input, converts it to a string (stripping the newline), and returns it. `raw_input()` was used in Python 2.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the default return value of a function that executes without encountering a `return` statement?",
    "options": [
      "0",
      "None",
      "Null",
      "False"
    ],
    "answer": "None",
    "explanation": "If a function finishes execution without hitting a `return` statement, it implicitly returns `None`.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "How do you create a list comprehension that generates squares of numbers from 0 to 4?",
    "options": [
      "[x**2 for x in range(5)]",
      "{x**2 for x in range(5)}",
      "map(x**2, range(5))",
      "[square(x) for x in range(4)]"
    ],
    "answer": "[x**2 for x in range(5)]",
    "explanation": "List comprehensions use brackets `[ ]` and iterate with a `for` clause. `range(5)` produces 0, 1, 2, 3, 4.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which file mode opens a file for writing and truncates the file if it already exists?",
    "options": [
      "'r'",
      "'a'",
      "'w'",
      "'x'"
    ],
    "answer": "'w'",
    "explanation": "The 'w' mode opens the file for writing; if the file exists, its contents are truncated (overwritten). 'a' appends, and 'r' is read-only.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is the `self` parameter in a class method?",
    "options": [
      "A reference to the class itself",
      "A reference to the current instance of the class",
      "A reserved keyword for static methods",
      "A reference to the parent class"
    ],
    "answer": "A reference to the current instance of the class",
    "explanation": "`self` represents the instance of the class, allowing access to its attributes and methods. It must be the first parameter of instance methods.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which operator is used for floor division?",
    "options": [
      "/",
      "//",
      "%",
      "**"
    ],
    "answer": "//",
    "explanation": "The `//` operator performs floor division, which divides the operands and returns the largest integer less than or equal to the result.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the correct way to handle multiple exception types in a single `except` block?",
    "options": [
      "except (ValueError, TypeError):",
      "except ValueError, TypeError:",
      "except ValueError or TypeError:",
      "except [ValueError, TypeError]:"
    ],
    "answer": "except (ValueError, TypeError):",
    "explanation": "To catch multiple specific exceptions, they must be placed in a tuple. The parentheses are required.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the Global Interpreter Lock (GIL)?",
    "options": [
      "A lock that prevents multiple threads from executing Python bytecodes at once",
      "A lock that prevents multiple processes from accessing shared memory",
      "A mechanism to secure Python scripts from reverse engineering",
      "A tool that checks for syntax errors before execution"
    ],
    "answer": "A lock that prevents multiple threads from executing Python bytecodes at once",
    "explanation": "The GIL is a mutex that protects access to Python objects, ensuring only one thread executes bytecode at a time. This simplifies memory management but limits CPU-bound parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which built-in function converts an object to an integer?",
    "options": [
      "int()",
      "integer()",
      "str()",
      "double()"
    ],
    "answer": "int()",
    "explanation": "The `int()` function converts a string or number to an integer. `str()` converts to a string, and `double()` does not exist in Python.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which keyword is used to define a class in Python?",
    "options": [
      "class",
      "Class",
      "def",
      "struct"
    ],
    "answer": "class",
    "explanation": "The `class` keyword is used to create a new class. Python is case-sensitive, so `Class` would be a different name.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the output of `True and False`?",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "answer": "False",
    "explanation": "The `and` operator returns True only if both operands are true. Since one operand is False, the result is False.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which module is commonly used for generating random numbers?",
    "options": [
      "random",
      "math",
      "statistics",
      "numpy"
    ],
    "answer": "random",
    "explanation": "The `random` module is part of the standard library and provides functions for generating random numbers and selections. While `numpy` has random capabilities, `random` is the standard library answer.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What does `sys.exit()` do?",
    "options": [
      "Exits the current loop",
      "Exits the current function",
      "Terminates the Python script",
      "Closes the current file"
    ],
    "answer": "Terminates the Python script",
    "explanation": "`sys.exit()` raises the SystemExit exception, which, if not caught, causes the Python interpreter to exit.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary reason CPython uses the Global Interpreter Lock (GIL)?",
    "options": [
      "To prevent race conditions during reference counting operations",
      "To enforce strict type checking at compile time",
      "To simplify the parsing of Python bytecode into machine code",
      "To allow multiple threads to write to the same file handle simultaneously"
    ],
    "answer": "To prevent race conditions during reference counting operations",
    "explanation": "CPython manages memory using reference counting, which is not thread-safe. The GIL ensures that only one thread executes Python bytecode at a time, protecting the object reference counters from concurrent modification corruption.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which mechanism handles circular references in CPython, given that reference counting alone cannot resolve them?",
    "options": [
      "The Garbage Collector (cyclic GC)",
      "The Reference Counter overflow handler",
      "The System Memory Manager (malloc)",
      "The Global Interpreter Lock (GIL)"
    ],
    "answer": "The Garbage Collector (cyclic GC)",
    "explanation": "Reference counting fails when objects reference each other (cycles) because their counts never reach zero. The cyclic garbage collector periodically identifies and collects these isolated groups of objects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In Python's `with` statement context management, which method is called if an exception occurs within the block?",
    "options": [
      "__init__",
      "__enter__",
      "__exit__",
      "__del__"
    ],
    "answer": "__exit__",
    "explanation": "The `__exit__` method is responsible for cleaning up resources. It receives exception details (type, value, traceback) if an error occurs, allowing it to suppress the exception or handle cleanup before propagation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the output of `print(isinstance(True, int))` in Python?",
    "options": [
      "False",
      "True",
      "TypeError",
      "AttributeError"
    ],
    "answer": "True",
    "explanation": "In Python, `bool` is a subclass of `int`. `True` behaves like the integer 1 and `False` like 0, so `True` is an instance of `int`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which Python feature allows a function to modify its own behavior based on the arguments passed to it, specifically using the `*args` and `**kwargs` syntax?",
    "options": [
      "Function overloading",
      "Variable positional and keyword arguments",
      "Operator overloading",
      "Metaprogramming"
    ],
    "answer": "Variable positional and keyword arguments",
    "explanation": "`*args` collects any number of extra positional arguments into a tuple, and `**kwargs` collects extra keyword arguments into a dictionary. This enables flexible function interfaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the purpose of the `__slots__` declaration in a class?",
    "options": [
      "To define abstract methods that must be implemented by subclasses",
      "To explicitly list allowed attributes and save memory by preventing `__dict__` creation",
      "To enable operator overloading for custom objects",
      "To synchronize method access between threads"
    ],
    "answer": "To explicitly list allowed attributes and save memory by preventing `__dict__` creation",
    "explanation": "Using `__slots__` replaces the default dynamic `__dict__` with a fixed-size structure for attributes, significantly reducing memory usage per instance and preventing the addition of undefined attributes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "How does the `await` keyword differ from `yield` in an asynchronous function?",
    "options": [
      "`await` yields control to the event loop while waiting for a Future; `yield` produces a value to the caller",
      "`await` is used for thread synchronization; `yield` is for memory management",
      "`await` executes a function synchronously; `yield` executes it asynchronously",
      "There is no difference; they are aliases for the same operation"
    ],
    "answer": "`await` yields control to the event loop while waiting for a Future; `yield` produces a value to the caller",
    "explanation": "`await` suspends the execution of a coroutine until an awaitable (like a Task or Future) completes, yielding control back to the event loop. `yield` is used in generators to produce data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the resolution order utilized by Python to determine attribute access in multiple inheritance?",
    "options": [
      "Depth-first search (DFS)",
      "Breadth-first search (BFS)",
      "C3 Linearization",
      "Random selection"
    ],
    "answer": "C3 Linearization",
    "explanation": "Python uses C3 Linearization (or MRO - Method Resolution Order) to create a consistent monotonic order for class inheritance, ensuring that a parent class is always searched before its children and respecting local precedence orders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Why might you choose `multiprocessing` over `threading` for a CPU-bound task in CPython?",
    "options": [
      "Threads share memory, while processes do not",
      "The GIL prevents threads from achieving true parallelism for CPU-bound code",
      "Processes are lighter to create than threads",
      "Threads cannot access the CPU core"
    ],
    "answer": "The GIL prevents threads from achieving true parallelism for CPU-bound code",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time. Multiprocessing creates separate memory spaces and interpreter states (each with its own GIL), allowing true parallel execution on multiple cores.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is 'Biased Reference Counting' in the context of the CPython 'nogil' (PEP 703) effort?",
    "options": [
      "A garbage collection algorithm that prioritizes older objects",
      "A mechanism to optimize reference counting by assuming a single 'owner' thread for atomic updates",
      "A security feature to prevent buffer overflows",
      "A type hinting system for integer variables"
    ],
    "answer": "A mechanism to optimize reference counting by assuming a single 'owner' thread for atomic updates",
    "explanation": "To remove the GIL, biased reference counting treats the thread creating an object as its 'owner'. This thread can modify the reference count cheaply without atomic operations, while other threads use atomic ops.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the behavior of a generator expression when consumed?",
    "options": [
      "It generates the entire sequence in memory immediately",
      "It produces items one at a time as they are requested (lazy evaluation)",
      "It can only be iterated over once before being permanently deleted",
      "It automatically runs in a separate thread"
    ],
    "answer": "It produces items one at a time as they are requested (lazy evaluation)",
    "explanation": "Generator expressions yield items lazily. They do not store the full sequence in memory, calculating the next value only when iteration advances, which improves memory efficiency for large datasets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "In the context of PEP 703 (Making the GIL Optional), what happens to the Garbage Collector (GC) implementation?",
    "options": [
      "It switches to a non-generational collector that pauses the world (stop-the-world)",
      "It becomes fully concurrent without ever pausing application threads",
      "It relies entirely on reference counting and disables cycle detection",
      "It moves to a tracing collector that runs in a background thread only"
    ],
    "answer": "It switches to a non-generational collector that pauses the world (stop-the-world)",
    "explanation": "Without the GIL to guarantee object stability during collection, the new GC implementation uses 'stop-the-world' pauses where all threads are halted, and it often switches to non-generational scanning to manage thread safety.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the primary function of `sys.intern()` in CPython?",
    "options": [
      "To interrupt the currently running thread",
      "To convert a floating-point number to an integer",
      "To store a string in the 'interned' table to reuse memory and speed up comparisons",
      "To interpret a Python string as raw bytes"
    ],
    "answer": "To store a string in the 'interned' table to reuse memory and speed up comparisons",
    "explanation": "Interning strings stores them in a global table, ensuring that equal strings share the same memory object. This speeds up equality comparisons (pointer comparison) and reduces memory usage for duplicates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "Which method is called when an attribute lookup fails on an object?",
    "options": [
      "__getattr__",
      "__getattribute__",
      "__setattr__",
      "__missing__"
    ],
    "answer": "__getattr__",
    "explanation": "`__getattr__` is invoked as a fallback only when an attribute is not found through the usual mechanism (instance dict, class dict). `__getattribute__` is called for *every* attribute access attempt.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is a potential side effect of defining a `__del__` method (finalizer) in a class?",
    "options": [
      "The class cannot be inherited from",
      "It can prevent objects from being garbage collected if they are involved in a reference cycle",
      "It forces the object to be stored in the stack instead of the heap",
      "It automatically makes the class thread-safe"
    ],
    "answer": "It can prevent objects from being garbage collected if they are involved in a reference cycle",
    "explanation": "Objects with `__del__` methods are stored in a special set by the garbage collector. If they participate in a reference cycle, the GC cannot safely determine the order to delete them, causing a memory leak.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "Why are default mutable arguments considered a 'gotcha' in Python?",
    "options": [
      "They cause a SyntaxError when the function is defined",
      "They are evaluated only once at function definition time, not at call time",
      "They cannot be serialized by the pickle module",
      "They are converted to immutable tuples at runtime"
    ],
    "answer": "They are evaluated only once at function definition time, not at call time",
    "explanation": "Default argument values are evaluated when the function is defined. If the default is a mutable object (like a list), modifications to it persist across function calls, leading to unintended shared state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "What distinguishes a `descriptor` from a standard class attribute?",
    "options": [
      "A descriptor is a class attribute with at least one of `__get__`, `__set__`, or `__delete__` methods",
      "A descriptor can only be used inside abstract base classes",
      "A descriptor is an attribute that cannot be accessed via dot notation",
      "A descriptor is a C-optimized type that cannot be written in pure Python"
    ],
    "answer": "A descriptor is a class attribute with at least one of `__get__`, `__set__`, or `__delete__` methods",
    "explanation": "Descriptors define how attribute access is handled. By implementing these protocol methods, a descriptor class can customize behavior (like computing a value or enforcing type checks) when accessed, set, or deleted.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is the result of the `super()` function in a class method?",
    "options": [
      "It returns the parent class object as an unbound proxy",
      "It returns a delegate object to the parent or sibling class of the type, respecting the MRO",
      "It returns the instance of the class currently being defined",
      "It returns the metaclass of the current class"
    ],
    "answer": "It returns a delegate object to the parent or sibling class of the type, respecting the MRO",
    "explanation": "`super()` returns a proxy object that routes method calls to the appropriate class in the Method Resolution Order (MRO), enabling cooperative multiple inheritance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Which protocol allows an object to be iterated over in a `for` loop?",
    "options": [
      "The Iterator Protocol (`__iter__` and `__next__`)",
      "The Sequence Protocol (`__len__` and `__getitem__`)",
      "The Context Protocol (`__enter__` and `__exit__`)",
      "The Comparison Protocol (`__eq__` and `__lt__`)"
    ],
    "answer": "The Iterator Protocol (`__iter__` and `__next__`)",
    "explanation": "An iterable implements `__iter__` which returns an iterator. An iterator implements `__next__` (returning the next item) and `__iter__` (returning itself). The `for` loop uses this protocol to fetch items.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What does the `nonlocal` statement do inside a nested function?",
    "options": [
      "It allows the function to access global variables",
      "It indicates that the variable refers to a variable in the enclosing scope (not global or local)",
      "It imports a variable from a different module",
      "It prevents the variable from being garbage collected"
    ],
    "answer": "It indicates that the variable refers to a variable in the enclosing scope (not global or local)",
    "explanation": "`nonlocal` is used in nested functions to assign a value to a variable defined in the enclosing (non-global) scope. Without it, assignment would create a new local variable instead of modifying the outer one.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the consequence of `os.fork()` in a Python program using threads?",
    "options": [
      "All threads are safely duplicated in the new process",
      "Only the thread calling `fork()` is duplicated; other threads vanish in the child process",
      "The Python interpreter immediately crashes to prevent deadlocks",
      "The Global Interpreter Lock is automatically released"
    ],
    "answer": "Only the thread calling `fork()` is duplicated; other threads vanish in the child process",
    "explanation": "`os.fork()` copies the memory space of the process. However, only the calling thread continues execution in the child process; locks held by other threads in the parent remain locked forever in the child, often causing deadlocks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "How does the `functools.lru_cache` decorator improve performance?",
    "options": [
      "By converting Python code into C extensions",
      "By storing the results of expensive function calls with specific arguments and returning the cached result on subsequent calls",
      "By pre-loading libraries into the operating system's page cache",
      "By detecting infinite loops and breaking out of them"
    ],
    "answer": "By storing the results of expensive function calls with specific arguments and returning the cached result on subsequent calls",
    "explanation": "LRU (Least Recently Used) cache memoizes function results. If the function is called again with the same arguments, the cached result is returned immediately, skipping the computation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "In CPython, what is ` PyObject `?",
    "options": [
      "The root structure for all Python objects containing reference count and type pointer",
      "A specific data type used for representing text strings",
      "The name of the Python bytecode compiler",
      "A reserved keyword used for type hinting generic objects"
    ],
    "answer": "The root structure for all Python objects containing reference count and type pointer",
    "explanation": "Every object in CPython begins with a `PyObject` (or similar) header, which stores `ob_refcnt` (reference count) and `ob_type` (pointer to the type object). This enables Python's dynamic typing and memory management.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What characterizes the 'Stop-the-World' phase in the context of the No-GIL garbage collector?",
    "options": [
      "The application runs faster than the GC",
      "All application threads are paused so the GC can traverse the heap safely without race conditions",
      "The GC leaks memory intentionally to avoid crashes",
      "The GC moves objects from the heap to the stack"
    ],
    "answer": "All application threads are paused so the GC can traverse the heap safely without race conditions",
    "explanation": "Without a GIL, concurrent threads could modify object links while the GC is traversing them. Stop-the-world pauses all mutator threads to ensure the heap remains consistent during the collection cycle.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the primary difference between `is` and `==` in Python?",
    "options": [
      "`is` checks for value equality, while `==` checks for memory address",
      "`is` checks for identity (memory address), while `==` checks for value equality",
      "`is` is used for integer comparison, `==` for string comparison",
      "There is no difference; they are completely interchangeable"
    ],
    "answer": "`is` checks for identity (memory address), while `==` checks for value equality",
    "explanation": "`is` (identity operator) returns `True` if two variables point to the exact same object in memory. `==` (equality operator) returns `True` if the objects have the same value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Why is using `__del__` discouraged for resource cleanup (like closing files) in favor of context managers?",
    "options": [
      "`__del__` is called immediately when the variable goes out of scope",
      "The time at which `__del__` is called is non-deterministic and it is not guaranteed to be called on interpreter exit",
      "`__del__` requires the file to be opened in binary mode only",
      "Context managers use more memory"
    ],
    "answer": "The time at which `__del__` is called is non-deterministic and it is not guaranteed to be called on interpreter exit",
    "explanation": "Finalizers (`__del__`) rely on garbage collection timing, which is non-deterministic. Context managers (`with` statements) ensure deterministic acquisition and release of resources immediately after the block.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the purpose of the `else` clause in a `for` or `while` loop?",
    "options": [
      "It executes when the loop is skipped entirely",
      "It executes when the loop completes normally (i.e., not via a `break` statement)",
      "It executes when the loop encounters an exception",
      "It executes after every iteration of the loop"
    ],
    "answer": "It executes when the loop completes normally (i.e., not via a `break` statement)",
    "explanation": "The loop `else` block runs if the loop iterates to exhaustion. If a `break` statement terminates the loop, the `else` block is skipped.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What does the `mmap` module provide?",
    "options": [
      "A way to map hardware memory addresses to Python objects",
      "Memory-mapped file access, allowing files to be treated as mutable byte strings",
      "A profiler for memory usage analysis",
      "A garbage collector tuning interface"
    ],
    "answer": "Memory-mapped file access, allowing files to be treated as mutable byte strings",
    "explanation": "`mmap` creates a memory-mapped object that maps a file or device into the virtual memory space. This allows accessing file content as if it were a byte array, often used for random access to large files.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In Python 3, what does `dataclass` automatically generate compared to a standard class?",
    "options": [
      "Thread-safety locks and serialization methods",
      "`__init__`, `__repr__`, `__eq__`, and other dunder methods based on type annotations",
      "Bytecode compilation optimization and JIT hooks",
      "Database connection pooling and cursor management"
    ],
    "answer": "`__init__`, `__repr__`, `__eq__`, and other dunder methods based on type annotations",
    "explanation": "The `@dataclass` decorator inspects type annotations to auto-generate boilerplate methods like `__init__`, `__repr__`, and `__eq__`, reducing boilerplate code for classes primarily storing data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the specific behavior of `finally` in a `try...finally` block when an exception is raised?",
    "options": [
      "It suppresses the exception if no `except` block is present",
      "It executes regardless of whether an exception occurred or not, before propagating the exception",
      "It executes only if the exception matches a specific type in the `except` block",
      "It halts the program immediately"
    ],
    "answer": "It executes regardless of whether an exception occurred or not, before propagating the exception",
    "explanation": "The `finally` block is guaranteed to execute. If an unhandled exception occurs in the `try` block, `finally` runs first, and then the exception continues to propagate up the stack.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which type hint indicates that a parameter can accept any type?",
    "options": [
      "Any",
      "Object",
      "Universal",
      "AnyType"
    ],
    "answer": "Any",
    "explanation": "`Any` from the `typing` module indicates that a value can be of any type and is compatible with all types. It effectively disables type checking for that variable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What occurs when you modify a collection while iterating over it in Python?",
    "options": [
      "The iterator automatically updates to reflect changes",
      "A `RuntimeError` is raised (e.g., 'list changed size during iteration')",
      "The iteration stops silently at the current element",
      "The changes are queued and applied after the loop finishes"
    ],
    "answer": "A `RuntimeError` is raised (e.g., 'list changed size during iteration')",
    "explanation": "Modifying a sequence (like adding/removing items) while iterating over it can cause unpredictable behavior. Python iterators detect this and raise a `RuntimeError` to prevent logic errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the `__name__` attribute of a module equal to when the script is run directly versus when it is imported?",
    "options": [
      "It is the filename in both cases",
      "It is `'__main__'` when run directly, and the module name when imported",
      "It is `None` when run directly, and `'__main__'` when imported",
      "It is `'main'` when run directly, and `None` when imported"
    ],
    "answer": "It is `'__main__'` when run directly, and the module name when imported",
    "explanation": "Python sets the global variable `__name__` to `'__main__'` for the top-level script being executed. If imported, `__name__` is set to the module's actual name.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which of the following correctly describes a 'read-write lock'?",
    "options": [
      "A mechanism used by the GIL to prevent memory leaks",
      "A lock that allows multiple concurrent readers or a single writer, but not both simultaneously",
      "A type of lock that permanently locks a variable after it is read",
      "A Python keyword used to enforce immutability on variables"
    ],
    "answer": "A lock that allows multiple concurrent readers or a single writer, but not both simultaneously",
    "explanation": "Read-write locks optimize concurrency by allowing multiple threads to read data simultaneously, provided no thread is writing. Writers require exclusive access.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What is the `gc.disable()` function used for?",
    "options": [
      "To prevent the import of the `gc` module",
      "To turn off the automatic cyclic garbage collector",
      "To stop the Python interpreter entirely",
      "To disable the Global Interpreter Lock"
    ],
    "answer": "To turn off the automatic cyclic garbage collector",
    "explanation": "Calling `gc.disable()` stops the automatic garbage collector from running. Reference counting still occurs, but the cyclic GC will not scan for and collect reference cycles until re-enabled.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the context of PEP 703 and the 'nogil' build of CPython, what is the primary purpose of introducing Biased Reference Counting?",
    "options": [
      "To eliminate the need for a garbage collector entirely",
      "To allow reference count modifications to occur without expensive atomic operations or locks when an object is owned by a single thread",
      "To enable automatic garbage collection of C-based pointers without cyclic reference detection",
      "To implement a copy-on-write mechanism for all mutable objects in the standard library"
    ],
    "answer": "To allow reference count modifications to occur without expensive atomic operations or locks when an object is owned by a single thread",
    "explanation": "Biased reference counting assumes ownership by a single thread, allowing non-atomic increments/decrements. It only falls back to atomic operations (or shared ownership) when the object is passed between threads.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Why does the experimental 'nogil' Garbage Collector implementation in CPython 3.13 utilize 'stop-the-world' pauses?",
    "options": [
      "To allow the operating system to defragment the physical RAM",
      "To ensure that no other threads modify the object graph while the garbage collector is traversing it for cycle detection",
      "To force all running Python threads to release their acquired locks before deadlocks occur",
      "To provide a window for the JIT compiler to optimize bytecode into machine code"
    ],
    "answer": "To ensure that no other threads modify the object graph while the garbage collector is traversing it for cycle detection",
    "explanation": "Without the GIL to pause other threads, the GC must explicitly stop all other threads (stop-the-world) to safely traverse the object graph and detect cycles without race conditions.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "How does the Garbage Collection strategy change in the CPython 'nogil' branch regarding generations?",
    "options": [
      "It transitions from a generational collector (Gen 0/1/2) to a non-generational collector that scans all objects in every cycle",
      "It introduces a fourth generation specifically for handling very large tensors",
      "It implements a concurrent tri-color marker that runs entirely in the background without pauses",
      "It switches to a purely reference-counted system and removes the cycle detector entirely"
    ],
    "answer": "It transitions from a generational collector (Gen 0/1/2) to a non-generational collector that scans all objects in every cycle",
    "explanation": "The nogil implementation simplifies the GC by removing generations. While this increases scan frequency, it simplifies thread synchronization and maintains safety without the GIL.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the specific role of the `mimalloc` allocator in the CPython 'nogil' integration?",
    "options": [
      "It replaces the Python memory manager entirely to automatically serialize all multi-threaded operations",
      "It enables the garbage collector to find all Python objects by traversing its internal structures, removing the need for a linked list of objects",
      "It forces all threads to execute sequentially on a single CPU core to emulate the GIL behavior",
      "It serves as a drop-in replacement for the C standard library `malloc` but provides no specific functionality for garbage collection"
    ],
    "answer": "It enables the garbage collector to find all Python objects by traversing its internal structures, removing the need for a linked list of objects",
    "explanation": "Mimalloc's internal metadata can be traversed to find objects, allowing CPython to remove the overhead of maintaining a separate linked list (`gc_prev`/`gc_next`) purely for the GC's benefit.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "In standard CPython (with GIL), what is the fundamental limitation of reference counting that necessitates a separate cyclic Garbage Collector?",
    "options": [
      "Reference counting is too slow for real-time applications and requires background optimization",
      "Reference counting cannot reclaim memory for objects involved in reference cycles where the count never reaches zero",
      "Reference counting is not thread-safe and requires the GIL to prevent segfaults during deallocation",
      "Reference counting causes heap fragmentation that can only be resolved by a stop-the-world pass"
    ],
    "answer": "Reference counting cannot reclaim memory for objects involved in reference cycles where the count never reaches zero",
    "explanation": "If object A references object B, and B references A, but neither is reachable from the root, their reference counts remain non-zero. The cyclic GC is required to detect and break these cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the primary mechanism by which the CPython Global Interpreter Lock (GIL) is released to allow I/O-bound operations to run concurrently?",
    "options": [
      "The operating system scheduler forcibly preempts the Python thread",
      "The bytecode interpreter explicitly releases the GIL before blocking I/O calls and reacquires it upon completion",
      "The JIT compiler compiles I/O operations into native code that bypasses the interpreter lock",
      "A separate kernel thread handles I/O, signaling the main thread only when data is ready"
    ],
    "answer": "The bytecode interpreter explicitly releases the GIL before blocking I/O calls and reacquires it upon completion",
    "explanation": "CPython I/O operations (like `read` or `write`) are implemented to drop the GIL while waiting on the OS, allowing other threads to run Python bytecode during the wait.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which algorithm is used by CPython's default Garbage Collector to determine the set of objects to traverse, starting from the roots?",
    "options": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Shortest Path",
      "Topological Sort"
    ],
    "answer": "Depth-First Search (DFS)",
    "explanation": "The Python GC uses a depth-first search (specifically a variation of the trial deletion algorithm) to traverse from root objects (containers) to identify which objects are reachable and which are in cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In the context of the CPython C API, what is the danger of directly accessing the `ob_refcnt` member of a `PyObject` without using the `Py_INCREF` and `Py_DECREF` macros?",
    "options": [
      "It bypasses the type checking system, allowing integers to be added to strings",
      "It causes a segmentation fault because the member is marked as private and protected by the OS",
      "It may break thread safety assumptions or fail to trigger debugging checks (like `Py_TRACE_REFS`) wrapped by the macros",
      "It prevents the object from being garbage collected by the cyclic GC"
    ],
    "answer": "It may break thread safety assumptions or fail to trigger debugging checks (like `Py_TRACE_REFS`) wrapped by the macros",
    "explanation": "The macros handle platform-specific atomic operations (especially in free-threaded builds) and debug instrumentation. Direct manipulation is unsafe and non-portable.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the specific behavior of the `__slots__` declaration in a Python class regarding memory usage?",
    "options": [
      "It moves all instance variables from the heap to the stack to reduce Garbage Collection pressure",
      "It prevents the creation of the instance dictionary (`__dict__`), reducing memory overhead by pre-allocating fixed space for attributes",
      "It forces the interpreter to cache the class bytecode in CPU L1 cache for faster access",
      "It converts the class into a C-struct equivalent, enabling zero-copy serialization via pickle"
    ],
    "answer": "It prevents the creation of the instance dictionary (`__dict__`), reducing memory overhead by pre-allocating fixed space for attributes",
    "explanation": "`__slots__` replaces the dynamic `__dict__` with a static descriptor. This saves memory (no hash table overhead per instance) and improves attribute access speed.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Why is CPython's Global Interpreter Lock (GIL) considered a bottleneck for CPU-bound multi-threaded programs but not for I/O-bound ones?",
    "options": [
      "CPU-bound tasks execute bytecode faster than the lock can be switched, while I/O tasks spend most of their time waiting for external events",
      "I/O-bound tasks use the `select` system call which bypasses the networking stack lock",
      "CPU-bound tasks require hardware-specific instructions that the GIL cannot execute, whereas I/O tasks are standard library calls",
      "The GIL is only active during the compilation phase of the Python script, which affects calculation loops but not file handling"
    ],
    "answer": "CPU-bound tasks execute bytecode faster than the lock can be switched, while I/O tasks spend most of their time waiting for external events",
    "explanation": "The GIL prevents parallel execution of bytecode. CPU-bound threads fight for the lock, serializing execution. I/O-bound threads release the lock while waiting, allowing concurrency.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which Method Resolution Order (MRO) algorithm is adopted by Python since version 2.3 to resolve attribute lookups in multiple inheritance?",
    "options": [
      "Depth-First Left-to-Right (DFLR)",
      "Breadth-First Search (BFS)",
      "C3 Linearization",
      "Monotonic Sequence Ordering"
    ],
    "answer": "C3 Linearization",
    "explanation": "Python uses C3 Linearization (also known as C3 superclass linearization) to compute the MRO. This algorithm preserves local precedence ordering and monotonicity, fixing issues with the old DFLR approach.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "In CPython's memory management, what is the function of the `PyMem_Malloc` allocator compared to the system `malloc`?",
    "options": [
      "`PyMem_Malloc` allocates memory exclusively in the CPU cache to speed up access",
      "It wraps the system `malloc` but adds debugging hooks and ensures the allocation is tracked by Python's memory profiling tools",
      "It bypasses the system `malloc` entirely to implement a garbage-collected memory pool",
      "It is used only for allocating the interpreter stack, not object instances"
    ],
    "answer": "It wraps the system `malloc` but adds debugging hooks and ensures the allocation is tracked by Python's memory profiling tools",
    "explanation": "`PyMem_Malloc` is part of the Python memory allocator family. It generally wraps the system malloc (or pymalloc) and ensures that the allocation behavior is consistent and hookable for debuggers like `tracemalloc`.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What occurs when a Python object's reference count reaches zero within the CPython interpreter?",
    "options": [
      "The object is moved to the 'Generation 2' pool for delayed deletion",
      "The object's memory is immediately deallocated and the `__dealloc__` slot (if present) is called",
      "The object is marked as 'zombie' and remains in memory until the cyclic GC runs its next cycle",
      "The interpreter triggers a segmentation fault to notify the user of an invalid access"
    ],
    "answer": "The object's memory is immediately deallocated and the `__dealloc__` slot (if present) is called",
    "explanation": "Unlike Java or C#, CPython uses reference counting as its primary mechanism. When `ob_refcnt` hits 0, the teardown is immediate; no waiting for a separate GC pass is required.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the specific purpose of the `__call__` method in a Python class definition?",
    "options": [
      "To define the behavior of the class when it is used as a decorator",
      "To allow instances of the class to be called like a function",
      "To initialize the class attributes before the `__init__` method is called",
      "To override the default behavior of the `super()` builtin"
    ],
    "answer": "To allow instances of the class to be called like a function",
    "explanation": "Defining `__call__` makes an instance callable. It intercepts the parentheses operator (`instance()`), enabling the object to act as a functor.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "How does the `__prepare__` method in a metaclass differ from `__new__` during class creation?",
    "options": [
      "`__prepare__` returns the dictionary to be used as the namespace for the class body, whereas `__new__` constructs the class object itself",
      "`__prepare__` is called after `__new__` to optimize the memory layout of the class",
      "`__prepare__` is a deprecated alias for `__init__` in older Python versions",
      "`__prepare__` creates the bytecode for the class, while `__new__` executes it"
    ],
    "answer": "`__prepare__` returns the dictionary to be used as the namespace for the class body, whereas `__new__` constructs the class object itself",
    "explanation": "`__prepare__` is executed first to create the mapping (namespace) where attributes are collected during the class definition. `__new__` receives that mapping to actually create the class type.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the technical implication of `isinstance()` returning `True` for a class that implements `__instancecheck__`?",
    "options": [
      "The class is a virtual subclass (ABC) or has customized the isinstance check, regardless of inheritance hierarchy",
      "The object has been dynamically modified to include the methods of the class at runtime",
      "The class uses the `slots` mechanism and the instance matches the memory layout",
      "The `__class__` attribute of the object points directly to the metaclass"
    ],
    "answer": "The class is a virtual subclass (ABC) or has customized the isinstance check, regardless of inheritance hierarchy",
    "explanation": "By implementing `__instancecheck__` (often seen in Abstract Base Classes or `typing` protocols), a class can make `isinstance(obj, MyClass)` return True even if `obj` does not actually inherit from `MyClass`.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "Why is String Interning (`sys.intern()`) useful for memory optimization in Python applications?",
    "options": [
      "It compresses strings using the LZ77 algorithm to reduce the footprint of string literals",
      "It ensures that identical string values share a single memory address, reducing the size of dictionaries or sets using them as keys",
      "It moves string objects from the heap to the static data segment of the binary",
      "It converts mutable strings into immutable byte arrays to prevent buffer overflows"
    ],
    "answer": "It ensures that identical string values share a single memory address, reducing the size of dictionaries or sets using them as keys",
    "explanation": "Interning de-duplicates strings. If two strings have the same value and are interned, they point to the same object. This saves memory and speeds up comparisons (pointer equality vs content comparison).",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the functional difference between `asyncio.run()` and `loop.run_until_complete()` in modern Python versions?",
    "options": [
      "`asyncio.run()` creates a new event loop and closes it automatically, while `loop.run_until_complete()` requires explicit loop management",
      "`loop.run_until_complete()` is multi-threaded, while `asyncio.run()` is strictly single-threaded",
      "`asyncio.run()` can only run synchronous functions, while `loop.run_until_complete()` is required for coroutines",
      "There is no difference; `asyncio.run()` is strictly an alias for `loop.run_until_complete()`"
    ],
    "answer": "`asyncio.run()` creates a new event loop and closes it automatically, while `loop.run_until_complete()` requires explicit loop management",
    "explanation": "`asyncio.run()` is the high-level entry point introduced in Python 3.7 to handle the boilerplate of getting, running, and closing a loop. The lower-level API requires manual loop creation and cleanup.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "In the Python Data Model, what differentiates a 'descriptor' from a simple class attribute?",
    "options": [
      "A descriptor is any object that implements at least one of `__get__`, `__set__`, or `__delete__` methods to control bind behavior",
      "A descriptor is a special type of dictionary that can only contain keys of type `str`",
      "A descriptor is strictly a property created using the `@property` decorator and cannot be created manually",
      "A descriptor is an attribute that has been marked as private using a leading underscore"
    ],
    "answer": "A descriptor is any object that implements at least one of `__get__`, `__set__`, or `__delete__` methods to control bind behavior",
    "explanation": "The descriptor protocol defines how attribute access is intercepted. If a class attribute has a `__get__` method (and optionally `__set__`/`__delete__`), it binds the lookup to that method.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the behavior of the `super()` function in Python 3 regarding Method Resolution Order (MRO)?",
    "options": [
      "It returns a proxy object that delegates method calls to the next class in the MRO chain of the current type",
      "It immediately calls the method of the parent class, bypassing the MRO of the current instance",
      "It creates a shallow copy of the current instance to avoid state mutation in parent methods",
      "It uses C++-style multiple inheritance to resolve the diamond problem statically"
    ],
    "answer": "It returns a proxy object that delegates method calls to the next class in the MRO chain of the current type",
    "explanation": "`super()` returns a delegate object. When you access an attribute on it, Python looks for that attribute not in the direct parent, but in the class next in the MRO order of the instance.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "When using the `multiprocessing` module in Python, why must objects passed between processes be picklable?",
    "options": [
      "Because processes share the same memory space and serialization prevents race conditions",
      "Because data must be serialized to be sent over inter-process communication (IPC) channels like pipes or queues",
      "Because the operating system kernel enforces type checking on shared memory blocks",
      "Because `multiprocessing` uses JSON for data transfer and JSON only supports specific primitive types"
    ],
    "answer": "Because data must be serialized to be sent over inter-process communication (IPC) channels like pipes or queues",
    "explanation": "Processes do not share memory (unlike threads). To exchange data, Python uses `pickle` to serialize the object into a byte stream, transmits it, and deserializes it in the target process.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the primary consequence of setting `__slots__ = ('foo', 'bar')` on a class?",
    "options": [
      "The class prevents the creation of any new attributes other than 'foo' and 'bar', and instances no longer have a `__dict__`",
      "The class becomes immutable, meaning the values of 'foo' and 'bar' cannot be changed after initialization",
      "The class automatically converts the attributes 'foo' and 'bar' into class-level static variables",
      "The class enables fast thread-safety locking for the specific attributes listed"
    ],
    "answer": "The class prevents the creation of any new attributes other than 'foo' and 'bar', and instances no longer have a `__dict__`",
    "explanation": "`__slots__` explicitly lists allowed instance attributes. This prevents the addition of arbitrary attributes (saving memory) but removes the flexibility of `__dict__`.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "How does the Python GIL handle the execution of C-extension code?",
    "options": [
      "C-extensions always run in parallel with Python bytecode, ignoring the GIL",
      "C-extensions must manually acquire the GIL before interacting with Python objects, but can release it during long calculations",
      "C-extensions are automatically compiled by Cython to be GIL-free",
      "The GIL prevents any C-extension code from executing unless the main thread is idle"
    ],
    "answer": "C-extensions must manually acquire the GIL before interacting with Python objects, but can release it during long calculations",
    "explanation": "The C-API allows extensions to release the GIL (e.g., via `Py_BEGIN_ALLOW_THREADS`). This enables heavy computations in C (like NumPy) to run in parallel while other Python threads run.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What is the 'Cooperative Multitasking' model utilized by Python's `asyncio` library?",
    "options": [
      "The operating system preempts tasks at arbitrary intervals to ensure fair CPU usage",
      "Tasks voluntarily yield control back to the event loop (typically via `await`) when waiting for I/O",
      "The interpreter spawns a new OS thread for every concurrent task",
      "The JIT compiler automatically reorders bytecode instructions to run in parallel"
    ],
    "answer": "Tasks voluntarily yield control back to the event loop (typically via `await`) when waiting for I/O",
    "explanation": "Asyncio is single-threaded. Concurrency is achieved because tasks yield control when blocked (await), allowing the event loop to switch to another ready task in the same thread.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is a potential consequence of using a `__del__` finalizer method in a Python class?",
    "options": [
      "It increases the execution speed of the class by invoking the compiler optimizer",
      "It can lead to uncollectable garbage (reference cycles) if the `__del__` method involves resurrecting the object",
      "It causes the object to be immediately allocated on the stack instead of the heap",
      "It prevents the class from being pickled because the serialization format is incompatible"
    ],
    "answer": "It can lead to uncollectable garbage (reference cycles) if the `__del__` method involves resurrecting the object",
    "explanation": "If an object with `__del__` is part of a reference cycle, the Cyclic GC historically could not break it because it didn't know if it was safe to delete the object. (Though `__del__` has complex interactions with GC).",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the function of the 'mro' attribute on a Python class?",
    "options": [
      "It stores the method resolution order tuple, which is the sequence of classes searched for method calls",
      "It is a dictionary of all read-only methods defined in the class",
      "It monitors the reference count of the class object for deallocation",
      "It serves as a lock mutex for concurrent method access in the free-threaded build"
    ],
    "answer": "It stores the method resolution order tuple, which is the sequence of classes searched for method calls",
    "explanation": "The `__mro__` attribute is a tuple containing the class and its superclasses in the order they are checked by the interpreter during attribute lookup.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "How does the `__contains__` method affect the behavior of the `in` operator?",
    "options": [
      "It allows the class to override the boolean logic of the `and` and `or` operators",
      "It defines custom membership testing logic, enabling `item in instance` to work for custom containers",
      "It converts the instance into an iterator for use in `for` loops",
      "It is used to validate function arguments during type checking"
    ],
    "answer": "It defines custom membership testing logic, enabling `item in instance` to work for custom containers",
    "explanation": "When Python evaluates `x in y`, it calls `type(y).__contains__(y, x)`. Implementing this allows objects to define how membership checks are performed.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "In the context of CPython's memory allocators (pymalloc), what is an 'Arena'?",
    "options": [
      "A single byte in memory used for reference counting",
      "A large contiguous chunk of memory (usually 256KB or 1MB) subdivided into 'pools' which are further subdivided into 'blocks'",
      "The virtual address space used exclusively by the JIT compiler",
      "A synchronization primitive used to replace the GIL in multi-core environments"
    ],
    "answer": "A large contiguous chunk of memory (usually 256KB or 1MB) subdivided into 'pools' which are further subdivided into 'blocks'",
    "explanation": "pymalloc optimizes small object allocation. It manages memory in Arenas (large chunks). Arenas are split into Pools, and Pools are split into Blocks of specific size classes.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Why is `None` in Python often implemented as a singleton?",
    "options": [
      "To allow it to be used as a default argument without creating memory leaks",
      "To enable pointer comparison (`is`) instead of value comparison (`==`) for efficiency and uniqueness",
      "Because `None` is a keyword and cannot be instantiated as a standard object",
      "To ensure that `None` is always garbage collected immediately at the end of a script"
    ],
    "answer": "To enable pointer comparison (`is`) instead of value comparison (`==`) for efficiency and uniqueness",
    "explanation": "There is only one instance of `None`. This means `x is None` is a fast pointer check (identity) rather than a value equality check, and guarantees that 'falseness' is consistent.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the specific utility of 'Argument Clinic' in the CPython C-API?",
    "options": [
      "It automatically generates the parsing code for function arguments (`PyArg_ParseTuple`), reducing boilerplate and errors",
      "It acts as a linter for Python code to ensure type hint compliance",
      "It is a diagnostic tool that detects memory leaks in C-extensions at runtime",
      "It converts Python bytecode into C code for compilation"
    ],
    "answer": "It automatically generates the parsing code for function arguments (`PyArg_ParseTuple`), reducing boilerplate and errors",
    "explanation": "Argument Clinic is a preprocessor tool that allows C-API developers to define function signatures in a DSL, automatically generating the complex C code required to parse arguments and build docstrings.",
    "difficulty": "Advanced"
  }
]