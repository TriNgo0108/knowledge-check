[
  {
    "id": 1,
    "question": "Which clause is used to filter the results of a GROUP BY query after aggregation has occurred?",
    "options": [
      "WHERE",
      "HAVING",
      "ORDER BY",
      "LIMIT"
    ],
    "answer": "HAVING",
    "explanation": "HAVING is specifically designed to filter groups based on aggregate values. WHERE filters individual rows before grouping.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the result of a standard SQL query selecting a column containing NULL values using the equality operator (e.g., `WHERE col = NULL`)?",
    "options": [
      "All rows with NULL values",
      "An error is thrown",
      "No rows are returned",
      "All rows in the table"
    ],
    "answer": "No rows are returned",
    "explanation": "NULL represents unknown data; comparing an unknown value to anything (including another NULL) using `=` yields FALSE (or UNKNOWN). One must use `IS NULL`.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which join type returns all rows from the left table, and matching rows from the right table, or NULL if there is no match?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "CROSS JOIN"
    ],
    "answer": "LEFT JOIN",
    "explanation": "LEFT JOIN prioritizes the left table (first table listed), ensuring all its rows appear. RIGHT JOIN prioritizes the right, and INNER JOIN only returns matches.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In SQL, what is the primary difference between WHERE and HAVING clauses?",
    "options": [
      "WHERE sorts rows; HAVING groups them.",
      "WHERE filters before aggregation; HAVING filters after.",
      "HAVING is for text columns; WHERE is for numbers.",
      "There is no difference; they are interchangeable."
    ],
    "answer": "WHERE filters before aggregation; HAVING filters after.",
    "explanation": "The WHERE clause evaluates row-level data prior to the GROUP BY operation. The HAVING clause evaluates the aggregated results of the GROUP BY operation.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which aggregate function counts the number of non-NULL values in a specific column?",
    "options": [
      "COUNT(*)",
      "COUNT(column_name)",
      "SUM(column_name)",
      "AVG(column_name)"
    ],
    "answer": "COUNT(column_name)",
    "explanation": "COUNT(column) specifically ignores NULL values. COUNT(*) counts total rows regardless of NULL content in specific columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the logical order of execution for the following SQL clauses: SELECT, FROM, WHERE, GROUP BY, HAVING?",
    "options": [
      "SELECT -> FROM -> WHERE -> GROUP BY -> HAVING",
      "FROM -> WHERE -> GROUP BY -> HAVING -> SELECT",
      "FROM -> SELECT -> WHERE -> GROUP BY -> HAVING",
      "WHERE -> FROM -> SELECT -> GROUP BY -> HAVING"
    ],
    "answer": "FROM -> WHERE -> GROUP BY -> HAVING -> SELECT",
    "explanation": "Data is retrieved (FROM), filtered (WHERE), grouped (GROUP BY), group-filtered (HAVING), and finally the projection (SELECT) is determined.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which operator is used to pattern match a single character in a LIKE statement?",
    "options": [
      "%",
      "_",
      "*",
      "?"
    ],
    "answer": "_",
    "explanation": "The underscore (_) represents exactly one character. The percent sign (%) represents zero or more characters.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What distinguishes UNION from UNION ALL when combining two result sets?",
    "options": [
      "UNION ALL sorts the results.",
      "UNION removes duplicate rows; UNION ALL includes them.",
      "UNION ALL requires matching data types; UNION does not.",
      "UNION is faster than UNION ALL."
    ],
    "answer": "UNION removes duplicate rows; UNION ALL includes them.",
    "explanation": "UNION incurs the overhead of sorting and removing duplicates. UNION ALL simply concatenates results, making it generally faster.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which constraint ensures that a column cannot contain NULL values?",
    "options": [
      "UNIQUE",
      "PRIMARY KEY",
      "NOT NULL",
      "CHECK"
    ],
    "answer": "NOT NULL",
    "explanation": "The NOT NULL constraint enforces that a column must have a value. PRIMARY KEY implies NOT NULL but also implies UNIQUE.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "In a SELECT statement, which clause is mandatory?",
    "options": [
      "WHERE",
      "FROM",
      "ORDER BY",
      "GROUP BY"
    ],
    "answer": "FROM",
    "explanation": "Every query must draw data from a source (table or subquery). While SELECT is technically required in syntax, FROM is required to specify the data source context.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What does the acronym ACID stand for in the context of SQL database transactions?",
    "options": [
      "Atomicity, Consistency, Isolation, Durability",
      "Atomicity, Concurrency, Integrity, Durability",
      "Automatic, Consistency, Indexing, Distribution",
      "Attributes, Columns, Indices, Data"
    ],
    "answer": "Atomicity, Consistency, Isolation, Durability",
    "explanation": "These are the four properties that guarantee that database transactions are processed reliably.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which data type is most appropriate for storing fixed-length character strings, such as a country code (e.g., 'US')?",
    "options": [
      "VARCHAR",
      "TEXT",
      "CHAR",
      "BLOB"
    ],
    "answer": "CHAR",
    "explanation": "CHAR is a fixed-length string type, padding remaining space with spaces. VARCHAR is variable-length and better for unpredictable data length.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the result of the BETWEEN operator when used as `WHERE age BETWEEN 10 AND 20`?",
    "options": [
      "Ages 11 through 19",
      "Ages 10 through 20 inclusive",
      "Ages 10 through 20 exclusive",
      "Ages greater than 10 and less than 20"
    ],
    "answer": "Ages 10 through 20 inclusive",
    "explanation": "The BETWEEN operator is an inclusive range operator, meaning both the start and end values are included in the result.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "Which command is used to remove a stored table from a database completely, including its data and structure?",
    "options": [
      "DELETE",
      "TRUNCATE",
      "DROP",
      "REMOVE"
    ],
    "answer": "DROP",
    "explanation": "DROP deletes the table definition and data. DELETE removes data only, and TRUNCATE removes data only and resets the table.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the main purpose of a Primary Key in a database table?",
    "options": [
      "To speed up text searches",
      "To uniquely identify each row in the table",
      "To link to another table",
      "To allow NULL values in a column"
    ],
    "answer": "To uniquely identify each row in the table",
    "explanation": "A Primary Key enforces entity integrity by ensuring each record is unique and non-NULL. Foreign Keys handle linking to other tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which clause is used to sort the result set of a query?",
    "options": [
      "GROUP BY",
      "SORT BY",
      "ORDER BY",
      "ARRANGE BY"
    ],
    "answer": "ORDER BY",
    "explanation": "ORDER BY is the standard SQL clause for sorting results. GROUP BY is for aggregation, and SORT BY is non-standard syntax.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is a Cartesian product (or Cross Join) in SQL?",
    "options": [
      "The result of joining two tables without a WHERE clause",
      "The result of joining two tables with an INNER JOIN",
      "A filtered list of unique rows",
      "The intersection of two tables"
    ],
    "answer": "The result of joining two tables without a WHERE clause",
    "explanation": "A Cartesian product combines every row of the first table with every row of the second table, occurring if joins are specified without filters.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which function returns the first non-null value in a list of arguments?",
    "options": [
      "NULLIF",
      "ISNULL",
      "COALESCE",
      "IFNULL"
    ],
    "answer": "COALESCE",
    "explanation": "COALESCE is standard SQL that evaluates arguments in order and returns the first non-null value. ISNULL and IFNULL are often vendor-specific variants.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which normalization form ensures that all non-key attributes are fully dependent on the primary key (eliminating partial dependencies)?",
    "options": [
      "First Normal Form (1NF)",
      "Second Normal Form (2NF)",
      "Third Normal Form (3NF)",
      "Boyce-Codd Normal Form (BCNF)"
    ],
    "answer": "Second Normal Form (2NF)",
    "explanation": "2NF requires 1NF and that all non-key attributes are fully functionally dependent on the whole primary key.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "In the context of SQL, what does DML stand for?",
    "options": [
      "Data Definition Language",
      "Data Manipulation Language",
      "Data Metadata Language",
      "Dynamic Management Language"
    ],
    "answer": "Data Manipulation Language",
    "explanation": "DML (Data Manipulation Language) encompasses commands used to manipulate data (SELECT, INSERT, UPDATE, DELETE). DDL defines structure (CREATE, ALTER).",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which statement is used to grant specific permissions to a user on a database object?",
    "options": [
      "ALLOW",
      "PERMIT",
      "GRANT",
      "GIVE"
    ],
    "answer": "GRANT",
    "explanation": "GRANT is the standard SQL command to assign specific privileges (like SELECT or UPDATE) to a user. REVOKE removes them.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the default sort order of the ORDER BY clause if no direction is specified?",
    "options": [
      "Descending",
      "Ascending",
      "Random",
      "Hash"
    ],
    "answer": "Ascending",
    "explanation": "SQL defaults to ASC (Ascending) if the sort direction is omitted. To reverse it, one must explicitly specify DESC.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which keyword is used to eliminate duplicate rows from the result set of a SELECT statement?",
    "options": [
      "UNIQUE",
      "SINGLE",
      "DISTINCT",
      "REDUCE"
    ],
    "answer": "DISTINCT",
    "explanation": "DISTINCT suppresses duplicate rows in the SELECT output, ensuring only unique combinations of the selected columns are returned.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which constraint ensures that values in a column exist in another table's column?",
    "options": [
      "PRIMARY KEY",
      "FOREIGN KEY",
      "UNIQUE",
      "CHECK"
    ],
    "answer": "FOREIGN KEY",
    "explanation": "A FOREIGN KEY constraint enforces referential integrity by ensuring a value matches an existing value in the parent (referenced) table.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the result of an INNER JOIN between Table A and Table B?",
    "options": [
      "All records from Table A and Table B",
      "Only records that match in both Table A and Table B",
      "All records from Table A and matching from Table B",
      "All records from Table B and matching from Table A"
    ],
    "answer": "Only records that match in both Table A and Table B",
    "explanation": "An INNER JOIN returns the intersection of the two tables, excluding rows that do not satisfy the join condition in either table.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which keyword is used to rename a column or table in the output of a query?",
    "options": [
      "RENAME",
      "AS",
      "DEFINE",
      "ALIAS"
    ],
    "answer": "AS",
    "explanation": "AS is used to assign a temporary alias to a column or table. While optional in some databases, it is standard practice for readability.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which clause limits the number of rows returned by a query after the result set is generated?",
    "options": [
      "Reducing the dataset size via pagination",
      "Filtering rows via WHERE",
      "Grouping rows",
      "Aggregating data"
    ],
    "answer": "Reducing the dataset size via pagination",
    "explanation": "Pagination clauses (like LIMIT) restrict the number of rows returned to the client.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which operator combines the results of two queries, excluding duplicates?",
    "options": [
      "JOIN",
      "UNION",
      "INTERSECT",
      "EXCEPT"
    ],
    "answer": "UNION",
    "explanation": "UNION combines the result sets of two or more SELECT statements and removes duplicate rows. INTERSECT finds common rows.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is the primary function of the CHECK constraint?",
    "options": [
      "Ensure a column is unique",
      "Validate data values against a boolean condition",
      "Link two tables together",
      "Prevent NULL values"
    ],
    "answer": "Validate data values against a boolean condition",
    "explanation": "A CHECK constraint enforces domain integrity by limiting the values that can be placed in a column (e.g., `Age > 18`).",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "In a SQL transaction, which command saves all changes made since the last COMMIT or ROLLBACK?",
    "options": [
      "SAVE",
      "COMMIT",
      "TRANSACTION",
      "KEEP"
    ],
    "answer": "COMMIT",
    "explanation": "COMMIT permanently writes transactional changes to the database. ROLLBACK undoes them.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which of the following is NOT a valid SQL aggregate function?",
    "options": [
      "SUM",
      "AVG",
      "MAX",
      "LENGTH"
    ],
    "answer": "LENGTH",
    "explanation": "LENGTH (or LEN) is a scalar function operating on a single string value. SUM, AVG, and MAX are aggregate functions operating on groups of rows.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which statement is used to create a new, empty table based on the structure of an existing table without copying the data?",
    "options": [
      "CREATE TABLE new_tbl SELECT * FROM old_tbl",
      "SELECT * INTO new_tbl FROM old_tbl",
      "CREATE TABLE new_tbl AS SELECT * FROM old_tbl WHERE FALSE",
      "COPY STRUCTURE old_tbl TO new_tbl"
    ],
    "answer": "CREATE TABLE new_tbl AS SELECT * FROM old_tbl WHERE FALSE",
    "explanation": "Using a false condition (like 1=0 or FALSE) in the `CREATE TABLE AS` statement copies the schema (columns/types) but creates an empty result set.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What does the keyword 'DEFAULT' do when defining a table column?",
    "options": [
      "It sets the column to be the Primary Key",
      "It provides a value if no value is supplied during an INSERT",
      "It encrypts the column data",
      "It creates an index on the column"
    ],
    "answer": "It provides a value if no value is supplied during an INSERT",
    "explanation": "The DEFAULT constraint ensures a column has a specific value if the INSERT statement omits a value for that column.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which command removes all rows from a table without logging individual row deletions, making it faster than DELETE?",
    "options": [
      "DROP",
      "REMOVE",
      "TRUNCATE",
      "CLEAR"
    ],
    "answer": "TRUNCATE",
    "explanation": "TRUNCATE is a DDL operation that deallocates data pages rather than deleting rows one by one. It is faster but cannot be rolled back in some databases.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which of the following describes a View in SQL?",
    "options": [
      "A physical copy of a table",
      "A stored procedure that returns data",
      "A virtual table based on the result-set of an SQL statement",
      "A temporary table that expires at session end"
    ],
    "answer": "A virtual table based on the result-set of an SQL statement",
    "explanation": "A View is a saved query that behaves like a table but does not store data physically (unless materialized). Temporary tables are physical transient tables.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary distinction between the RANK() and DENSE_RANK() window functions in SQL when identical values are present?",
    "options": [
      "RANK() assigns unique sequential integers; DENSE_RANK() skips numbers after ties.",
      "RANK() includes a default partition; DENSE_RANK() requires explicit partitioning.",
      "RANK() skips rank numbers after ties; DENSE_RANK() does not skip numbers.",
      "RANK() assigns 0 to tied values; DENSE_RANK() assigns 1."
    ],
    "answer": "RANK() skips rank numbers after ties; DENSE_RANK() does not skip numbers.",
    "explanation": "RANK() leaves gaps in the sequence when there are ties (e.g., 1, 2, 2, 4), whereas DENSE_RANK() assigns consecutive integers (e.g., 1, 2, 2, 3). Both functions assign the same rank to tied values within the partition.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "In the context of indexing, what defines a 'Covering Index'?",
    "options": [
      "An index that includes all columns of the table to facilitate full table scans.",
      "An index containing all columns required by a specific query, avoiding table lookups.",
      "A composite index used to enforce a UNIQUE constraint across multiple columns.",
      "An index that spans multiple tables in a clustered environment."
    ],
    "answer": "An index containing all columns required by a specific query, avoiding table lookups.",
    "explanation": "A covering index includes all columns appearing in the SELECT, JOIN, and WHERE clauses. This allows the engine to satisfy the query purely from the index structure (Index Only Scan), significantly improving performance by accessing the base table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which clause is mandatory to define the 'window' or set of rows a window function operates on, separate from the current row?",
    "options": [
      "GROUP BY",
      "HAVING",
      "OVER",
      "PARTITION BY"
    ],
    "answer": "OVER",
    "explanation": "The OVER clause is required to define the window for a window function. While PARTITION BY and ORDER BY are optional components *within* the OVER clause to refine the window, the OVER clause itself is the mandatory syntax that distinguishes window functions from standard aggregate functions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the result set characteristic of a SQL Left Anti-Semi Join?",
    "options": [
      "Returns all rows from the left table and matched rows from the right table.",
      "Returns only rows that exist in both the left and right tables.",
      "Returns rows from the left table that do not have a corresponding match in the right table.",
      "Returns the Cartesian product of rows from both tables."
    ],
    "answer": "Returns rows from the left table that do not have a corresponding match in the right table.",
    "explanation": "A Left Anti-Semi Join filters the left table to retain only rows where no match is found in the right table. This is commonly implemented using `WHERE NOT EXISTS` or `LEFT JOIN ... WHERE right.key IS NULL`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Consider a composite index defined on columns (A, B, C). Which query scenario is most likely to perform an Index Seek rather than an Index Scan?",
    "options": [
      "WHERE B = 1 AND C = 2",
      "WHERE C = 1",
      "WHERE A = 1 AND C = 1",
      "WHERE A > 10 AND B = 5"
    ],
    "answer": "WHERE A = 1 AND C = 1",
    "explanation": "B-Tree indexes rely on the leftmost column (A) for seeking. Scenario 3 allows seeking on A, whereas Scenario 1 and 2 ignore the leading column. Scenario 4 can seek on A but may not efficiently use B due to the range operator on A before the equality on B, depending on the optimizer.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "How does the execution of a correlated subquery differ from a non-correlated (nested) subquery?",
    "options": [
      "A correlated subquery executes once for the entire query; a nested subquery executes once per row.",
      "A correlated subquery executes once per row processed by the outer query; a nested subquery executes once independently.",
      "A correlated subquery cannot contain aggregate functions; a nested subquery must.",
      "There is no performance difference; they are logically identical."
    ],
    "answer": "A correlated subquery executes once per row processed by the outer query; a nested subquery executes once independently.",
    "explanation": "A correlated subquery references a column from the outer query, forcing the database to evaluate it repeatedly for every candidate row. A non-correlated subquery is self-contained and runs independently, usually evaluated once.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the effect of the 'REPEATABLE READ' isolation level regarding specific concurrency phenomena?",
    "options": [
      "It prevents Non-Repeatable Reads but allows Phantom Reads.",
      "It prevents Phantom Reads but allows Non-Repeatable Reads.",
      "It prevents both Non-Repeatable Reads and Phantom Reads.",
      "It prevents Dirty Reads but allows Non-Repeatable Reads."
    ],
    "answer": "It prevents Non-Repeatable Reads but allows Phantom Reads.",
    "explanation": "REPEATABLE READ guarantees that if a row is read twice, the values remain the same (locks on read data). However, it does not prevent Phantom Reads, where new rows appear in a subsequent read within the same transaction if a WHERE clause range is queried.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "In window function syntax, what is the default frame clause if an ORDER BY is specified but no explicit frame (ROWS BETWEEN) is defined?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING",
      "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"
    ],
    "answer": "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "When ORDER BY is used, the default window frame is from the start of the partition (UNBOUNDED PRECEDING) up to the current row. Note that while often thought of as 'ROWS', the standard default is actually 'RANGE', which handles peers (tied values) differently than specific row offsets.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which join algorithm is generally most efficient when joining two large datasets that are not sorted and lack indexes on the join columns?",
    "options": [
      "Nested Loop Join",
      "Hash Join",
      "Merge Join",
      "Cartesian Join"
    ],
    "answer": "Hash Join",
    "explanation": "Hash Joins are typically optimal for large, unsorted inputs without indexes. The database builds a hash table in memory for the smaller input and probes it with the larger input, avoiding the expensive O(N*M) cost of Nested Loops or the sorting cost of Merge Joins.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the primary technical reason to use `UNION ALL` instead of `UNION`?",
    "options": [
      "`UNION ALL` sorts the result set, whereas `UNION` does not.",
      "`UNION ALL` removes duplicates from the result set more efficiently than `UNION`.",
      "`UNION ALL` does not incur the overhead of duplicate elimination and sorting.",
      "`UNION ALL` allows combining tables with different data types."
    ],
    "answer": "`UNION ALL` does not incur the overhead of duplicate elimination and sorting.",
    "explanation": "`UNION` implicitly performs a sort operation (or distinct check) to remove duplicates, which is computationally expensive. `UNION ALL` simply concatenates results, making it significantly faster when duplicates are not a concern.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In a Recursive Common Table Expression (CTE), what is the function of the 'anchor member'?",
    "options": [
      "It defines the termination condition for the recursion.",
      "It is the initial result set that the recursive member builds upon.",
      "It limits the maximum recursion depth (MAXRECURSION).",
      "It defines the JOIN condition between the CTE and the outer query."
    ],
    "answer": "It is the initial result set that the recursive member builds upon.",
    "explanation": "The anchor member is the first part of the recursive CTE (defined before UNION ALL). It returns the initial rows, which serve as the base input for the recursive member in the first iteration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which SQL clause ensures that a query only updates rows where a specific column value has actually changed, preventing unnecessary writes and trigger firings?",
    "options": [
      "WHERE EXISTS",
      "WHERE CURRENT OF",
      "WHERE ... != (Old Value)",
      "No standard clause exists; logic must check column values in the WHERE clause."
    ],
    "answer": "No standard clause exists; logic must check column values in the WHERE clause.",
    "explanation": "SQL does not have an 'IF CHANGED' clause. To prevent unnecessary writes (and side effects like trigger execution), the UPDATE statement must explicitly include a predicate in the WHERE clause checking `ColumnA <> ColumnB` (or IS DISTINCT FROM) alongside the ID filter.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What distinguishes a Clustered Index from a Non-Clustered Index regarding data storage?",
    "options": [
      "A Clustered Index stores data pages at the leaf level; a Non-Clustered Index stores pointers or clustering keys.",
      "A Clustered Index contains only the indexed columns; a Non-Clustered Index contains all columns.",
      "A Clustered Index is always unique; a Non-Clustered Index allows duplicates.",
      "A Clustered Index is stored in a separate file; a Non-Clustered Index is in memory."
    ],
    "answer": "A Clustered Index stores data pages at the leaf level; a Non-Clustered Index stores pointers or clustering keys.",
    "explanation": "The leaf level of a Clustered Index is the actual data row of the table. The leaf level of a Non-Clustered Index contains the indexed column values and a pointer (either a Row ID or the Clustered Key) to the actual data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "When using the `LEAD()` window function, what is the return value if the offset goes beyond the boundary of the partition?",
    "options": [
      "0",
      "The value of the first row in the partition",
      "NULL",
      "An error is thrown"
    ],
    "answer": "NULL",
    "explanation": "Like `LAG()`, if the `LEAD()` offset (e.g., looking 1 row ahead) extends past the last row of the partition, the function returns NULL (or the default value specified in the `default` argument, if provided).",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Why is applying a function to an indexed column in a WHERE clause (e.g., `WHERE YEAR(date_col) = 2023`) generally considered bad practice?",
    "options": [
      "It causes a syntax error in most SQL dialects.",
      "It forces the database to ignore the index and perform a Table Scan (SARGability issue).",
      "It converts the data type to a string, which is slower.",
      "It automatically converts the query to a Correlated Subquery."
    ],
    "answer": "It forces the database to ignore the index and perform a Table Scan (SARGability issue).",
    "explanation": "Applying a function to the column (`YEAR(date_col)`) prevents the optimizer from using the index on that column because the index stores the raw value, not the result of the function. This violates 'Search ARGument ABILITY' (SARGable).",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the difference between `WHERE` and `HAVING` clauses regarding SQL logical execution order?",
    "options": [
      "`WHERE` filters grouped data; `HAVING` filters individual rows.",
      "`WHERE` is evaluated before row aggregation; `HAVING` is evaluated after row aggregation.",
      "`WHERE` allows aggregate functions; `HAVING` does not.",
      "There is no logical difference; they are interchangeable."
    ],
    "answer": "`WHERE` is evaluated before row aggregation; `HAVING` is evaluated after row aggregation.",
    "explanation": "`WHERE` filters rows *before* the `GROUP BY` aggregation occurs. `HAVING` filters the *aggregated* result set *after* the `GROUP BY` has been applied. You cannot use aggregates in WHERE.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In SQL, what is the 'Phantom Read' anomaly?",
    "options": [
      "Reading data that has been modified but not committed by another transaction.",
      "Reading the same row twice and getting different values.",
      "Executing the same query twice within a transaction and retrieving a different set of rows because a new row was inserted.",
      "Data disappearing due to disk corruption."
    ],
    "answer": "Executing the same query twice within a transaction and retrieving a different set of rows because a new row was inserted.",
    "explanation": "A Phantom Read occurs when a transaction reads a set of rows matching a condition, and another transaction inserts (or deletes) a row that matches that condition. When the first transaction re-runs the query, it sees the new (or missing) 'phantom' row.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Which index maintenance operation reorganizes the leaf level of an index physically without rebuilding the entire index?",
    "options": [
      "DROP INDEX",
      "REBUILD",
      "REORGANIZE",
      "STATISTICS UPDATE"
    ],
    "answer": "REORGANIZE",
    "explanation": "`REORGANIZE` (or similar depending on dialect, like `OPTIMIZE TABLE` or `INDEX REORGANIZE`) defragments the leaf level of an index online. It is lighter weight than `REBUILD`, which drops and recreates the index entirely.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What determines the outcome of the `COALESCE(column1, column2)` function?",
    "options": [
      "It returns the first non-NULL argument in the list.",
      "It returns the last non-NULL argument in the list.",
      "It returns a random value if both arguments are NULL.",
      "It returns the sum of the arguments if both are non-NULL."
    ],
    "answer": "It returns the first non-NULL argument in the list.",
    "explanation": "`COALESCE` takes a list of arguments and evaluates them in order. It returns the value of the first argument that is not NULL. If all arguments are NULL, it returns NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "When using `GROUP BY ROLLUP(A, B)`, how many aggregation levels are generated in the result set?",
    "options": [
      "1 level (only A and B)",
      "2 levels (A and B)",
      "3 levels ((A,B), A, Grand Total)",
      "4 levels ((A,B), A, B, Grand Total)"
    ],
    "answer": "3 levels ((A,B), A, Grand Total)",
    "explanation": "`ROLLUP` generates hierarchical subtotals. For `ROLLUP(A, B)`, it creates: 1. The base grouping (A, B); 2. Subtotals for A; 3. The Grand Total. It does not create subtotals for B alone.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "In a `SELECT` statement, at which logical stage are column aliases defined in the `SELECT` list available to other clauses?",
    "options": [
      "They are available in the WHERE clause.",
      "They are available in the GROUP BY clause.",
      "They are available only in the ORDER BY clause.",
      "They are available immediately in the HAVING clause."
    ],
    "answer": "They are available only in the ORDER BY clause.",
    "explanation": "Logically, the `SELECT` list (where aliases are created) is processed after `WHERE`, `GROUP BY`, and `HAVING`. Therefore, aliases cannot be used in those clauses. `ORDER BY` is processed after `SELECT`, so aliases are valid there.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the specific technical benefit of using a 'Sparse Column' in column-store or wide-table scenarios?",
    "options": [
      "It enforces NOT NULL constraints more strictly.",
      "It reduces storage space for columns containing many NULL values.",
      "It automatically creates a covering index.",
      "It increases the speed of JOIN operations."
    ],
    "answer": "It reduces storage space for columns containing many NULL values.",
    "explanation": "Sparse columns are optimized for storage of NULL values. Instead of taking up the full data type space (e.g., 4 bytes for INT), a NULL in a sparse column consumes almost zero space, which is highly efficient for wide tables with many empty values.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Which CTE feature allows a query to reference itself, typically used for hierarchical data structures like organizational charts?",
    "options": [
      "Common CTE",
      "Recursive CTE",
      "Correlated CTE",
      "Hierarchical CTE"
    ],
    "answer": "Recursive CTE",
    "explanation": "A Recursive CTE is defined by referencing itself within the CTE definition (usually using `UNION ALL`). It repeatedly executes the recursive member until the result set is empty or the max recursion is hit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is the impact of specifying `MAXDOP 1` in a query hint?",
    "options": [
      "The query will utilize all available CPU cores.",
      "The query will be restricted to a single processor core (serial execution).",
      "The query will fail if it takes longer than 1 second.",
      "The query will use exactly 1GB of memory."
    ],
    "answer": "The query will be restricted to a single processor core (serial execution).",
    "explanation": "`MAXDOP` (Maximum Degree of Parallelism) controls the number of CPUs used. `MAXDOP 1` forces the query optimizer to generate a serial plan, using only one CPU, which is sometimes useful to troubleshoot concurrency issues or for very fast queries where parallel overhead is wasteful.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Regarding the `TRUNCATE TABLE` command, which statement is technically accurate compared to `DELETE`?",
    "options": [
      "`TRUNCATE` can be rolled back, whereas `DELETE` cannot.",
      "`TRUNCATE` scans every row to log individual row deletions.",
      "`TRUNCATE` deallocates data pages rather than logging individual row deletions.",
      "`TRUNCATE` activates triggers defined on the table."
    ],
    "answer": "`TRUNCATE` deallocates data pages rather than logging individual row deletions.",
    "explanation": "`TRUNCATE` is a minimally logged operation that marks the data pages as empty/deallocated rather than deleting rows one by one. It is faster but cannot be used on tables referenced by foreign keys or with `WHERE` clauses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What does the `NULLIF(expression1, expression2)` function return?",
    "options": [
      "Returns expression1 if expression2 is NULL.",
      "Returns NULL if the two expressions are equal, otherwise returns expression1.",
      "Returns TRUE if the expressions are different.",
      "Returns the first non-NULL expression found."
    ],
    "answer": "Returns NULL if the two expressions are equal, otherwise returns expression1.",
    "explanation": "`NULLIF` compares the two arguments. If they are equivalent, it returns NULL; otherwise, it returns the first argument. It is effectively a shorthand for `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "In the context of a Full-Text Search index, what does a 'Thesaurus' configuration enable?",
    "options": [
      "It maps abbreviations to their full meanings.",
      "It maps synonyms to search terms, expanding the query to include related words.",
      "It corrects spelling mistakes automatically.",
      "It ranks results by page authority."
    ],
    "answer": "It maps synonyms to search terms, expanding the query to include related words.",
    "explanation": "A thesaurus in Full-Text Search defines a list of synonyms for a term. When a user searches for a word, the engine expands the search to include the synonyms defined in the thesaurus XML file, improving recall.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "Which `UPDATE` join syntax updates a table based on values from another table without needing a subquery?",
    "options": [
      "UPDATE table1 FROM table2",
      "MERGE",
      "UPDATE ... SET ... FROM ... JOIN ... (or equivalent correlated update)",
      "INSERT ... ON DUPLICATE KEY UPDATE"
    ],
    "answer": "UPDATE ... SET ... FROM ... JOIN ... (or equivalent correlated update)",
    "explanation": "In dialects like SQL Server or PostgreSQL (using `FROM`), you can join the target table to a source table directly in the `UPDATE` statement to set values based on the joined data. This is often preferred over correlated subqueries for readability and performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What is the definition of 'Cardinality' in the context of database indexes?",
    "options": [
      "The total number of rows in the table.",
      "The number of distinct values in an indexed column.",
      "The number of columns in an index.",
      "The physical size of the index on disk."
    ],
    "answer": "The number of distinct values in an indexed column.",
    "explanation": "Cardinality refers to the uniqueness of data values in a column. High cardinality means many distinct values (good for indexes), while low cardinality means few distinct values (e.g., Booleans), where indexes might be less selective/efficient.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "How does the `CROSS APPLY` operator differ from `INNER JOIN`?",
    "options": [
      "`CROSS APPLY` allows correlation between the left table and the table-valued function on the right.",
      "`INNER JOIN` allows table-valued functions, while `CROSS APPLY` does not.",
      "`CROSS APPLY` returns all rows from the left table regardless of a match.",
      "There is no functional difference; they are synonyms."
    ],
    "answer": "`CROSS APPLY` allows correlation between the left table and the table-valued function on the right.",
    "explanation": "`CROSS APPLY` is specifically designed to join a table with a Table-Valued Function (TVF) or derived table where the right side needs to accept a parameter *from* the left side (correlation). `INNER JOIN` generally does not support passing a column from the left side as an argument to a function on the right side in this manner.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the primary purpose of the `FOR XML` (SQL Server) or `FOR JSON` clause?",
    "options": [
      "To format the query results as XML or JSON text.",
      "To store XML or JSON data in specific columns.",
      "To validate XML or JSON input against a schema.",
      "To join XML and JSON tables together."
    ],
    "answer": "To format the query results as XML or JSON text.",
    "explanation": "These clauses transform the relational result set of a query into a single string or stream representing a hierarchical XML or JSON document. It is used for data export or API integration.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In a database transaction, if a session holds an update lock on a resource, what type of lock can other sessions acquire on the same resource simultaneously?",
    "options": [
      "Exclusive Lock (X)",
      "Shared Lock (S)",
      "Update Lock (U)",
      "Intent Exclusive (IX)"
    ],
    "answer": "Shared Lock (S)",
    "explanation": "Update (U) locks are compatible with Shared (S) locks. This allows multiple reads to happen while a specific process is looking at a row with the intent to update it, preventing a common deadlock scenario known as the 'conversion deadlock'.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the result of `SELECT COUNT(NULL)` in most SQL dialects?",
    "options": [
      "0",
      "1",
      "NULL",
      "Error"
    ],
    "answer": "0",
    "explanation": "The `COUNT` function counts the number of non-NULL values. Since the input is explicitly `NULL`, the count of non-null values is 0.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "Which pattern allows finding rows that have a 'gap' in a sequence (e.g., missing dates or IDs)?",
    "options": [
      "Using `GROUP BY` with `HAVING`.",
      "Using a Self-Join or `LEAD/LAG` to compare current row values with the next row's value.",
      "Using `DISTINCT`.",
      "Using `ORDER BY DESC`."
    ],
    "answer": "Using a Self-Join or `LEAD/LAG` to compare current row values with the next row's value.",
    "explanation": "To find gaps, you must compare a row to its immediate neighbor (e.g., `WHERE t2.ID = t1.ID + 1`). If the join returns no match, there is a gap. `LEAD` or `LAG` window functions provide a cleaner way to calculate the difference (`current_val - prev_val`) to detect deviations from 1.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "What does the `TRY_CONVERT` function do differently from standard `CONVERT`?",
    "options": [
      "`TRY_CONVERT` converts data to a different file format.",
      "`TRY_CONVERT` returns NULL if the cast fails, instead of throwing an error.",
      "`TRY_CONVERT` automatically encrypts the converted data.",
      "`TRY_CONVERT` works faster on large datasets."
    ],
    "answer": "`TRY_CONVERT` returns NULL if the cast fails, instead of throwing an error.",
    "explanation": "`TRY_CAST` and `TRY_CONVERT` are defensive programming tools. If you attempt to convert the string 'hello' to an integer, `CONVERT` crashes the batch. `TRY_CONVERT` returns NULL, allowing the query to proceed and handle bad data gracefully.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "Which of the following statements is TRUE regarding the order of execution in a SQL query involving aggregation, window functions, and the `HAVING` clause?",
    "options": [
      "The `WHERE` clause is evaluated after window functions to filter the calculated results.",
      "Window functions are evaluated after the `HAVING` clause but before the `ORDER BY` clause.",
      "The `HAVING` clause filters rows before the window function's window frame is calculated.",
      "Window functions are logically evaluated before the `GROUP BY` clause aggregates the data."
    ],
    "answer": "Window functions are evaluated after the `HAVING` clause but before the `ORDER BY` clause.",
    "explanation": "Logically, window functions operate on the result set *after* the `GROUP BY` and `HAVING` clauses have been applied (the post-aggregation data), but conceptually before the final `ORDER BY` for presentation. This distinction is crucial because you cannot use a window function in a `WHERE` or `HAVING` clause without a subquery.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In the context of a database using MVCC (Multi-Version Concurrency Control) like PostgreSQL, what occurs when a row is updated and a new transaction attempts to read that row?",
    "options": [
      "The reading transaction is blocked until the update transaction commits.",
      "The reading transaction reads the old version of the row (the tuple) from the undo log or table heap.",
      "The reading transaction immediately fails with a serialization error.",
      "The reading transaction waits for a shared lock to be released by the updater."
    ],
    "answer": "The reading transaction reads the old version of the row (the tuple) from the undo log or table heap.",
    "explanation": "Under MVCC, readers do not block writers and writers do not block readers. The update creates a new row version (tuple) with a new transaction ID. The reader sees the old version because its snapshot was taken before the update committed.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Why does a `NOT IN` subquery return an empty result set if the subquery contains even a single `NULL` value, whereas `NOT EXISTS` does not?",
    "options": [
      "`NOT IN` implicitly applies an `IS NOT NULL` check to the outer query.",
      "`NOT IN` performs a three-valued logic comparison where `NULL = value` is unknown (not true), causing rows to be filtered out.",
      "`NOT EXISTS` converts `NULL`s to empty strings automatically to facilitate the join.",
      "`NOT IN` uses a Hash Join which cannot handle `NULL` keys effectively."
    ],
    "answer": "`NOT IN` performs a three-valued logic comparison where `NULL = value` is unknown (not true), causing rows to be filtered out.",
    "explanation": "SQL uses three-valued logic (TRUE, FALSE, UNKNOWN). If the subquery returns a `NULL`, the comparison `col != NULL` evaluates to `UNKNOWN` (not TRUE). Since `WHERE` clauses only accept TRUE, all rows are filtered out. `NOT EXISTS` checks for the presence of a row, not the specific value, avoiding this pitfall.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "When defining a composite index on columns `(A, B, C)`, which of the following queries will NOT be able to perform an Index Seek (efficient traversal) using this index?",
    "options": [
      "`WHERE A = 1 AND B = 2`",
      "`WHERE B = 2 AND C = 3`",
      "`WHERE A = 1 ORDER BY B`",
      "`WHERE A = 1 AND B = 2 AND C = 3`"
    ],
    "answer": "`WHERE B = 2 AND C = 3`",
    "explanation": "B-Tree indexes follow the left-to-right prefix property. To use the index efficiently (seek), the query must filter on the leading column (A). If the query filters on B and C but skips A, the engine must perform an Index Scan (reading all rows) rather than a Seek.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the primary distinction between `RANGE` and `ROWS` window frame bounds in SQL window functions?",
    "options": [
      "`RANGE` considers duplicates as a single group, while `ROWS` treats duplicates as distinct physical rows.",
      "`RANGE` cannot be used with `ORDER BY`, whereas `ROWS` requires it.",
      "`ROWS` calculates the frame based on value offsets, while `RANGE` calculates based on physical row position.",
      "`RANGE` is a logical offset that respects peer rows (ties), while `ROWS` is a physical offset."
    ],
    "answer": "`RANGE` is a logical offset that respects peer rows (ties), while `ROWS` is a physical offset.",
    "explanation": "`ROWS` operates on physical row numbers (e.g., the 1 row preceding the current row). `RANGE` operates on the logical value of the `ORDER BY` column; if there are ties (peers) in the ordering, `RANGE` includes them all in the frame boundaries, whereas `ROWS` may cut them off arbitrarily.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the specific effect of adding the column `Status` to a Covering Index that already includes `ID` and `Date` for a query `SELECT ID, Date FROM Table WHERE Status = 'Active'`?",
    "options": [
      "It eliminates the need for the Key Lookup (or Bookmark Lookup) to retrieve the `Status` column to evaluate the `WHERE` clause.",
      "It forces the query optimizer to use a Clustered Index Scan instead of a Non-Clustered Index Seek.",
      "It decreases the size of the index pages, allowing more rows to fit in memory.",
      "It enables the index to be used for the `SELECT` projection, but not for the filtering."
    ],
    "answer": "It eliminates the need for the Key Lookup (or Bookmark Lookup) to retrieve the `Status` column to evaluate the `WHERE` clause.",
    "explanation": "A covering index includes all columns required by the query (SELECT, JOIN, WHERE). By including `Status`, the engine satisfies the `WHERE` filter directly from the non-clustered index without accessing the base table (heap/clustered index), significantly reducing I/O.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of the SQL `SELECT` statement evaluation order, at which stage are column aliases defined in the `SELECT` list available to subsequent clauses?",
    "options": [
      "They are available immediately for the `WHERE` clause.",
      "They are available for the `GROUP BY` and `HAVING` clauses only.",
      "They are strictly available only for the `ORDER BY` clause.",
      "They are available for the `JOIN` condition."
    ],
    "answer": "They are strictly available only for the `ORDER BY` clause.",
    "explanation": "Logically, the `SELECT` list (where aliases are created) is evaluated *after* the `WHERE`, `GROUP BY`, and `HAVING` clauses. Therefore, aliases cannot be used in those clauses. `ORDER BY` is evaluated *after* the `SELECT` list, making it the only standard clause that can use these aliases.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "Consider a Recursive Common Table Expression (CTE). What is the mechanism that prevents an infinite loop if the recursive member does not eventually return an empty result set?",
    "options": [
      "The `MAXRECURSION` hint or limit setting.",
      "Automatic detection of cycles via the `CYCLE` clause.",
      "The query optimizer automatically terminates recursion after 100 iterations.",
      "Recursive CTEs are inherently finite; the syntax guarantees a stop condition."
    ],
    "answer": "The `MAXRECURSION` hint or limit setting.",
    "explanation": "Without a specific `CYCLE` clause or a `WHERE` condition that filters out subsequent iterations, a recursive CTE can loop infinitely. Database systems (like SQL Server) provide a `MAXRECURSION` option (defaulting often to 100) to abort the query if the limit is exceeded, preventing runaway server resource consumption.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which SQL isolation level allows 'Non-Repeatable Reads' but prevents 'Dirty Reads'?",
    "options": [
      "Read Uncommitted",
      "Read Committed",
      "Repeatable Read",
      "Serializable"
    ],
    "answer": "Read Committed",
    "explanation": "`Read Committed` guarantees that you only see data committed by other transactions (preventing Dirty Reads). However, because it takes a new snapshot for every statement within the transaction, data can change between statements, leading to Non-Repeatable Reads.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "When analyzing an execution plan, what is the primary indicator that the 'Table Scan' (or 'Seq Scan') operator is more efficient than an 'Index Seek' (or 'Index Scan' + Lookup)?",
    "options": [
      "The table has fewer than 100 rows.",
      "The query returns a large percentage of the total rows in the table (low selectivity).",
      "The index is fragmented.",
      "The query uses an `OR` operator in the `WHERE` clause."
    ],
    "answer": "The query returns a large percentage of the total rows in the table (low selectivity).",
    "explanation": "If a query retrieves a significant portion of the table (e.g., >5-10%), the cost of random I/O lookups via a non-clustered index exceeds the cost of reading the table sequentially. In such high-selectivity scenarios, the optimizer correctly chooses a Table Scan.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the fundamental difference between `UNION` and `UNION ALL` regarding performance and result set?",
    "options": [
      "`UNION` includes duplicate rows, while `UNION ALL` removes them.",
      "`UNION` sorts the data to remove duplicates, incurring overhead, whereas `UNION ALL` simply concatenates results.",
      "`UNION ALL` requires the inputs to have identical data types, while `UNION` performs implicit casting.",
      "`UNION` is faster because it stops processing as soon as it finds a duplicate."
    ],
    "answer": "`UNION` sorts the data to remove duplicates, incurring overhead, whereas `UNION ALL` simply concatenates results.",
    "explanation": "`UNION` performs a distinct sort operation (or hash aggregation) to eliminate duplicates, which is computationally expensive. `UNION ALL` appends the result sets without checking for duplicates, making it significantly faster.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which join algorithm is generally most efficient when joining two large datasets that are not sorted and have no useful indexes on the join columns?",
    "options": [
      "Nested Loop Join",
      "Hash Join",
      "Merge Join",
      "Lookup Join"
    ],
    "answer": "Hash Join",
    "explanation": "For large, unsorted datasets, a Hash Join is typically optimal. It builds a hash table in memory from the smaller input and probes it with the larger input. Merge Joins require sorted inputs (incurring sort cost), and Nested Loops are inefficient for large row sets due to O(N*M) complexity.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "In a B-Tree index, what is the definition of a 'Clustered Index' regarding the physical storage of data?",
    "options": [
      "The leaf level nodes contain the actual data pages of the table.",
      "The index is stored in a separate file from the table data.",
      "The index allows duplicate values but does not allow NULLs.",
      "The data is sorted across multiple disks based on the index key."
    ],
    "answer": "The leaf level nodes contain the actual data pages of the table.",
    "explanation": "A Clustered Index dictates the physical order of data on disk. The leaf nodes of a Clustered Index are the actual data rows of the table. In contrast, a Non-Clustered Index contains a pointer (or clustering key) to the data at the leaf level.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the purpose of the `LATERAL` keyword in a SQL `JOIN` or subquery?",
    "options": [
      "To allow the subquery to reference columns from tables that appear to the left of it in the `FROM` clause.",
      "To perform a cross join between two tables.",
      "To force the query to execute in parallel across multiple CPU cores.",
      "To optimize the query by creating a temporary table for the subquery."
    ],
    "answer": "To allow the subquery to reference columns from tables that appear to the left of it in the `FROM` clause.",
    "explanation": "Standard subqueries are self-contained. `LATERAL` enables correlated subqueries that can access values from the preceding table(s) in the query, effectively acting like a row-by-row function application or a correlated join.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the specific risk of using random UUIDs (e.g., `uuid_generate_v4`) as the primary key in a high-throughput B-Tree index?",
    "options": [
      "They consume too much disk space.",
      "Their randomness causes high index fragmentation and frequent page splits during inserts.",
      "They cannot be used in Foreign Key constraints.",
      "They are slower to hash than integer keys."
    ],
    "answer": "Their randomness causes high index fragmentation and frequent page splits during inserts.",
    "explanation": "B-Trees rely on inserting new data at the 'end' of the index to maintain density. Random UUIDs can insert anywhere in the index structure, forcing the database to split pages constantly to fit them, leading to sparse, fragmented indexes and degraded I/O performance.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "How does the `ISNULL()` function (SQL Server) differ from the `COALESCE()` function in terms of standard SQL behavior and data type precedence?",
    "options": [
      "`COALESCE` can take only two arguments, while `ISNULL` takes a list.",
      "`ISNULL` uses the data type of the first parameter, while `COALESCE` uses the data type of the highest precedence parameter.",
      "`ISNULL` returns 0 for integers, while `COALESCE` returns NULL.",
      "`COALESCE` evaluates all arguments before returning a value, whereas `ISNULL` short-circuits."
    ],
    "answer": "`ISNULL` uses the data type of the first parameter, while `COALESCE` uses the data type of the highest precedence parameter.",
    "explanation": "A critical difference lies in type resolution. `ISNULL(col, val)` converts `val` to the type of `col`. `COALESCE(col1, col2...)` returns the type of the highest precedence argument among the inputs, which can lead to truncation errors if not handled carefully.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the 'Parameter Sniffing' problem in SQL Server execution plans?",
    "options": [
      "The query optimizer incorrectly identifies parameters as variables and scans the table.",
      "The optimizer generates a plan based on the parameter values of the first execution, which may be suboptimal for subsequent executions with different values.",
      "Parameters are 'sniffed' by hackers to inject SQL code.",
      "The optimizer caches the parameter values but recompiles the query every time."
    ],
    "answer": "The optimizer generates a plan based on the parameter values of the first execution, which may be suboptimal for subsequent executions with different values.",
    "explanation": "Parameter sniffing is when the optimizer uses the specific parameter values passed during the initial compilation (the 'sniffed' values) to estimate row counts and determine the plan. If subsequent calls use atypical values (e.g., finding 1 row vs 1 million rows), the cached 'universal' plan may perform terribly.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "Which normal form addresses 'Multivalued Dependencies' (e.g., a course having multiple textbooks and multiple instructors independent of each other)?",
    "options": [
      "Third Normal Form (3NF)",
      "Boyce-Codd Normal Form (BCNF)",
      "Fourth Normal Form (4NF)",
      "Fifth Normal Form (5NF)"
    ],
    "answer": "Fourth Normal Form (4NF)",
    "explanation": "4NF deals with independent multivalued dependencies. It states that no table should contain two or more independent multivalued facts about an entity. 3NF removes transitive dependencies, while 4NF specifically separates these independent 1:N sets.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "When using `EXCEPT` (set difference), how does NULL handling differ from using `LEFT JOIN / WHERE IS NULL`?",
    "options": [
      "`EXCEPT` treats two NULL values as distinct, whereas `LEFT JOIN` treats them as equal.",
      "`EXCEPT` treats two NULL values as equal, whereas standard equality checks in `LEFT JOIN` treat them as unknown.",
      "`EXCEPT` cannot compare NULL values and throws an error.",
      "`LEFT JOIN` is automatically optimized to behave identically to `EXCEPT`."
    ],
    "answer": "`EXCEPT` treats two NULL values as equal, whereas standard equality checks in `LEFT JOIN` treat them as unknown.",
    "explanation": "`EXCEPT` (set operation) compares values by the 'distinct' concept where `NULL` equals `NULL`. In a `LEFT JOIN` condition `ON a.ID = b.ID`, if both sides are NULL, the result is UNKNOWN, so the row does not match. `EXCEPT` will filter them out if they match, `JOIN` will not.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What is the consequence of defining a `FOREIGN KEY` constraint with `ON DELETE SET DEFAULT`?",
    "options": [
      "The child row is deleted if the parent is deleted.",
      "The child row's foreign key column is set to the column's default value; the default value must exist in the parent table.",
      "The child row's foreign key column is set to NULL regardless of column constraints.",
      "The delete operation on the parent is blocked if child rows exist."
    ],
    "answer": "The child row's foreign key column is set to the column's default value; the default value must exist in the parent table.",
    "explanation": "Unlike `SET NULL`, `SET DEFAULT` updates the child rows to the default value defined for that column. Crucially, for the constraint to be valid, that default value *must* exist in the referenced parent table, otherwise, the update would violate referential integrity.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "In a `ROW_NUMBER()` window function, how are ties (rows with equal ordering values) handled?",
    "options": [
      "Ties receive the same rank, but the sequence skips subsequent numbers.",
      "Ties are ordered arbitrarily based on physical storage order (non-deterministic).",
      "Ties receive the same rank and do not skip numbers.",
      "Ties cause the function to return an error."
    ],
    "answer": "Ties are ordered arbitrarily based on physical storage order (non-deterministic).",
    "explanation": "Unlike `RANK` or `DENSE_RANK`, `ROW_NUMBER()` must produce a unique integer for every row. If the `ORDER BY` clause does not fully distinguish rows (ties exist), the database engine arbitrarily decides the order, which can vary between executions.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "Why are Insert-Heavy workloads generally slower on tables with many non-clustered indexes?",
    "options": [
      "The engine must read the non-clustered indexes to determine where to insert the row.",
      "For every row inserted, the database must update the clustered index AND every non-clustered index to include the new key.",
      "Non-clustered indexes lock the table during the update.",
      "The transaction log fills up faster due to index logging."
    ],
    "answer": "For every row inserted, the database must update the clustered index AND every non-clustered index to include the new key.",
    "explanation": "Non-clustered indexes store a copy of the indexed key (and often the clustering key). When a new row is added, it must be inserted into the main table (Clustered/Heap) *and* registered in every single non-clustered index. This multiplicative I/O cost significantly slows down inserts.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the 'Write Amplification' factor in columnar storage formats (like Parquet or ORC) compared to row-based formats (like Avro or CSV)?",
    "options": [
      "Write amplification is lower because only changed columns are rewritten.",
      "Write amplification is higher because updating a single value often requires rewriting the entire file (row group) to maintain columnar compression.",
      "Write amplification is zero because columnar formats are immutable.",
      "Write amplification is negligible because columnar stores are only used for read-only data."
    ],
    "answer": "Write amplification is higher because updating a single value often requires rewriting the entire file (row group) to maintain columnar compression.",
    "explanation": "Columnar formats rely on compression and encoding across batches of rows (like row groups). They are immutable. Modifying data technically requires rewriting the entire file/partition. In contrast, row-based OLTP databases often modify pages in-place.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "What does the term 'Sargable' (Search ARGument ABLE) refer to in SQL optimization?",
    "options": [
      "A query that is able to be run in parallel.",
      "A predicate in a `WHERE` clause that can leverage an index seek rather than a table scan.",
      "A query that uses valid SQL syntax.",
      "A stored procedure that accepts arguments."
    ],
    "answer": "A predicate in a `WHERE` clause that can leverage an index seek rather than a table scan.",
    "explanation": "Sargable queries allow the engine to isolate the search argument to use an index B-Tree. Operations like wrapping a column in a function (e.g., `WHERE YEAR(date) = 2023`) render the predicate non-sargable, forcing a scan because the modified column value cannot be looked up directly in the index.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In a 'Write-Ahead Logging' (WAL) architecture, when is the data actually written to the main data files on disk?",
    "options": [
      "Immediately when the transaction executes.",
      "Only when the `CHECKPOINT` operation occurs.",
      "When the database is shut down.",
      "When the log file reaches 50% capacity."
    ],
    "answer": "Only when the `CHECKPOINT` operation occurs.",
    "explanation": "In WAL systems, changes are written to the log file first (for durability). The dirty pages in the buffer pool (memory) are written to the actual data files on disk later, during a Checkpoint operation. This ensures that if a crash occurs, the log can replay changes to restore the state.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the result of subtracting two `DATE` columns in standard SQL (e.g., `SELECT date1 - date2`)?",
    "options": [
      "An INTEGER representing the number of days.",
      "An INTERVAL representing the duration.",
      "A FLOAT representing seconds.",
      "An ERROR because dates cannot be subtracted."
    ],
    "answer": "An INTERVAL representing the duration.",
    "explanation": "Standard SQL specifies that subtracting two dates yields an `INTERVAL`. While specific implementations (like PostgreSQL) return an `INTERVAL`, others (like MySQL) might return an integer (days), but the rigorous SQL standard definition is `INTERVAL`.\n    ",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "Which of the following accurately describes the `CUBE` grouping operation compared to `ROLLUP`?",
    "options": [
      "`ROLLUP` creates subtotals for all combinations of dimensions, while `CUBE` only creates hierarchies.",
      "`CUBE` generates subtotals for all possible combinations of the specified grouping columns, while `ROLLUP` assumes a hierarchy.",
      "`CUBE` is faster than `ROLLUP` because it uses less memory.",
      "`ROLLUP` calculates the Grand Total only, whereas `CUBE` calculates only the lowest level."
    ],
    "answer": "`CUBE` generates subtotals for all possible combinations of the specified grouping columns, while `ROLLUP` assumes a hierarchy.",
    "explanation": "`ROLLUP((A, B))` assumes A > B hierarchy and calculates (A,B), (A), and (). `CUBE((A, B))` calculates all permutations: (A,B), (A), (B), and (). Cube creates an n-dimensional hypercube of aggregations.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "How does the `GROUPING_ID()` function assist in filtering the results of a `GROUPING SETS` query?",
    "options": [
      "It returns the total count of rows in each group.",
      "It returns a bitmap indicating which grouping columns are NULL (because they are grouped) versus actual NULL data.",
      "It uniquely identifies the specific Grouping Set combination used for the current row.",
      "It filters out rows where the aggregate value is zero."
    ],
    "answer": "It uniquely identifies the specific Grouping Set combination used for the current row.",
    "explanation": "`GROUPING_ID` (or `GROUPING`) returns a number representing the bitmask of the group. This allows you to distinguish between a `NULL` resulting from grouping (super-aggregate row) and a `NULL` that is actual data, and to filter specific hierarchy levels in the `HAVING` clause.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is a 'Hash Bucket' in the context of a Hash Join execution?",
    "options": [
      "The amount of memory allocated to the join operation.",
      "A specific slot in the hash table where a row is placed based on the hash value of its join key.",
      "The input dataset that is smaller and used to build the hash table.",
      "The file on disk used to spill data if memory runs out."
    ],
    "answer": "A specific slot in the hash table where a row is placed based on the hash value of its join key.",
    "explanation": "The database builds an in-memory hash table. The 'Build' input rows are hashed and placed into specific slots (buckets) based on that hash. The 'Probe' input rows are then hashed to check the corresponding bucket for matches.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "In the context of database statistics, what does 'Histogram' information capture that simple density (average number of duplicates) cannot?",
    "options": [
      "The total number of rows in the table.",
      "The distribution of data values within a column (frequency of specific ranges or steps).",
      "The number of distinct values in an index.",
      "The fragmentation level of the index."
    ],
    "answer": "The distribution of data values within a column (frequency of specific ranges or steps).",
    "explanation": "Density assumes an even distribution of data. Histograms track the actual frequency of values or ranges of values, allowing the optimizer to estimate row counts more accurately for skewed data (e.g., a 'Status' column where 99% are 'Open' and 1% are 'Closed').",
    "difficulty": "Advanced"
  }
]