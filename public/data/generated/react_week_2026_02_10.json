[
  {
    "id": 1,
    "question": "What is the primary purpose of the `key` prop when rendering lists of elements in React?",
    "options": [
      "To enforce strict type checking on list items",
      "To uniquely identify items and assist React in updating the DOM efficiently",
      "To automatically sort the array elements before rendering",
      "To handle event listeners specifically for list items"
    ],
    "answer": "To uniquely identify items and assist React in updating the DOM efficiently",
    "explanation": "Keys help React identify which items have changed, are added, or are removed, allowing the reconciler to reuse existing DOM nodes. Without keys, React may resort to inefficient index-based diffing.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which term describes the algorithm React uses to diff one tree of elements against another to determine which parts need to be changed?",
    "options": [
      "Reconciliation",
      "Hoisting",
      "Virtualization",
      "Memoization"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation is the process React uses to compare the previous rendered tree with the new tree to calculate the minimal set of DOM mutations required.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In React, what is the returned value of a call to `useState`?",
    "options": [
      "An object containing the current state and a history of previous states",
      "The current state value and a function to update it",
      "A promise that resolves when the state update is complete",
      "A reference to the DOM node associated with the state"
    ],
    "answer": "The current state value and a function to update it",
    "explanation": "The `useState` hook returns an array where the first element is the current state value and the second element is a dispatcher function (setState) to update that value.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Why must state updates in React be treated as immutable?",
    "options": [
      "React uses Object.is comparison to detect changes, requiring a new reference to trigger a re-render",
      "JavaScript garbage collection requires objects to be copied before modification",
      "Immutable state is required for TypeScript type safety",
      "To ensure that the state can be serialized to JSON"
    ],
    "answer": "React uses Object.is comparison to detect changes, requiring a new reference to trigger a re-render",
    "explanation": "React triggers re-renders based on reference changes (shallow comparison). Mutating an object directly creates no new reference, so React cannot detect the change.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What happens if a component's `render` method (or function component body) returns `null` or `false`?",
    "options": [
      "The component throws a runtime error",
      "The component renders nothing, leaving the DOM empty for that node",
      "React renders an empty `<div>` placeholder element",
      "The component unmounts completely from the component tree"
    ],
    "answer": "The component renders nothing, leaving the DOM empty for that node",
    "explanation": "Returning `null` or `false` from a component tells React to render no DOM nodes for that component, effectively rendering nothing while keeping the component mounted in the tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the primary function of `React.memo`?",
    "options": [
      "To memoize the result of a function passed to a callback",
      "To prevent a functional component from re-rendering if its props have not changed",
      "To cache API responses in the browser's local storage",
      "To automatically optimize all components within a provider"
    ],
    "answer": "To prevent a functional component from re-rendering if its props have not changed",
    "explanation": "`React.memo` is a higher-order component that performs a shallow comparison of props; if they haven't changed, it skips re-rendering the component.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which hook allows you to perform side effects in function components, such as data fetching or manual DOM manipulation?",
    "options": [
      "useLayoutEffect",
      "useEffect",
      "useReducer",
      "useCallback"
    ],
    "answer": "useEffect",
    "explanation": "`useEffect` is the standard hook for side effects, running after the render is committed to the screen. `useLayoutEffect` fires synchronously before updates, while `useCallback` is for memoization.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is the behavior of passing an empty dependency array `[]` to `useEffect`?",
    "options": [
      "The effect runs after every render",
      "The effect runs only once when the component mounts",
      "The effect never runs",
      "The effect runs only when the component unmounts"
    ],
    "answer": "The effect runs only once when the component mounts",
    "explanation": "An empty dependency array signals to React that the effect does not depend on any props or state, so it never needs to re-run after the initial mount.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "In React, why is direct DOM manipulation generally discouraged?",
    "options": [
      "It violates the core principle of declarative UI programming and bypasses the Virtual DOM diffing",
      "Direct DOM manipulation is not supported in modern browsers",
      "It causes the application to run slower because JavaScript is faster than DOM APIs",
      "React creates a copy of the DOM that is immutable"
    ],
    "answer": "It violates the core principle of declarative UI programming and bypasses the Virtual DOM diffing",
    "explanation": "React abstracts DOM updates. Direct manipulation creates a state mismatch between React's Virtual DOM and the actual DOM, leading to bugs and loss of state synchronization.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What does the `useRef` hook return?",
    "options": [
      "A mutable object containing a `.current` property",
      "A reference to the component's internal state object",
      "A function to update the component's props",
      "A direct reference to the root DOM element of the application"
    ],
    "answer": "A mutable object containing a `.current` property",
    "explanation": "`useRef` returns a plain JavaScript object with a single property, `current`, which can hold a value that persists across renders without causing re-renders.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "Which event naming convention is used in JSX to attach event handlers?",
    "options": [
      " lowercase (e.g., onclick)",
      "UPPERCASE (e.g., ONCLICK)",
      "camelCase (e.g., onClick)",
      "kebab-case (e.g., on-click)"
    ],
    "answer": "camelCase (e.g., onClick)",
    "explanation": "JSX uses camelCase for event handler props to adhere to JavaScript naming standards, as `class` and `for` are reserved words in JS.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is the specific purpose of the `children` prop in React?",
    "options": [
      "To define the child components that will be rendered as a fallback",
      "To represent the content passed between the opening and closing tags of a component",
      "To list all the nested components for performance analysis",
      "To force the component to render only specific types of HTML elements"
    ],
    "answer": "To represent the content passed between the opening and closing tags of a component",
    "explanation": "`props.children` allows components to be composed and pass arbitrary elements (or other components) to their children for rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "How does React Fiber improve the rendering of large UI updates compared to the legacy Stack reconciler?",
    "options": [
      "It compiles JSX to machine code before execution",
      "It splits rendering work into units of work that can be paused, resumed, or prioritized",
      "It removes the need for the Virtual DOM entirely",
      "It forces all updates to run synchronously to prevent race conditions"
    ],
    "answer": "It splits rendering work into units of work that can be paused, resumed, or prioritized",
    "explanation": "Fiber implements incremental rendering, breaking work into chunks. This allows React to prioritize high-priority updates (like input) over low-priority ones.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the result of calling `setState` (or the state setter from `useState`) with the same value as the current state?",
    "options": [
      "React throws an error to prevent infinite loops",
      "The component re-renders anyway to ensure state consistency",
      "React bails out of the render and no re-render occurs",
      "The state is updated to `null`"
    ],
    "answer": "React bails out of the render and no re-render occurs",
    "explanation": "React performs a shallow comparison (Object.is) on the new state value. If it is identical to the current state, React skips rendering that component and its children.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which Phase of the React rendering lifecycle is interruptible in the Fiber architecture?",
    "options": [
      "The Commit Phase",
      "The Render Phase",
      "The Pre-commit Phase",
      "The Cleanup Phase"
    ],
    "answer": "The Render Phase",
    "explanation": "The Render Phase involves creating the Fiber tree and determining changes; this is interruptible in Fiber. The Commit Phase (applying changes to the DOM) is synchronous and not interruptible.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the 'Virtual DOM'?",
    "options": [
      "A browser feature provided by Chrome for performance",
      "An in-memory JavaScript representation of the actual DOM",
      "A backup copy of the database schema",
      "A way to write CSS in JavaScript files"
    ],
    "answer": "An in-memory JavaScript representation of the actual DOM",
    "explanation": "The Virtual DOM is a programming concept where a lightweight copy of the DOM is kept in memory and synced with the real DOM via reconciliation.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "Which syntax is used to embed JavaScript expressions within JSX?",
    "options": [
      "Double curly braces {{ }}",
      "Single quotes ' '",
      "Backticks ` `",
      "Curly braces { }"
    ],
    "answer": "Curly braces { }",
    "explanation": "Curly braces signal to JSX that the content within should be evaluated as a JavaScript expression.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is 'Lifting State Up' in React?",
    "options": [
      "Moving state to a higher global variable",
      "Moving the state to the nearest common ancestor of components that need it",
      "Deleting state from child components to force them to be pure",
      "Using `useEffect` to update state at the top of the file"
    ],
    "answer": "Moving the state to the nearest common ancestor of components that need it",
    "explanation": "When multiple components need to share the same state, the state should be lifted to their closest common parent, who passes it down via props.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is a 'Controlled Component' in React forms?",
    "options": [
      "A component wrapped in a Higher-Order Component",
      "An input element where the value is controlled by React state",
      "A component that manages its own state without parent interference",
      "A component that is rendered only if a specific condition is met"
    ],
    "answer": "An input element where the value is controlled by React state",
    "explanation": "In a controlled component, the form element's value is driven by React state, and updates are handled via event handlers, making React the 'single source of truth'.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "Which React hook is best suited for managing complex state logic involving multiple sub-values or dependent state?",
    "options": [
      "useState",
      "useContext",
      "useReducer",
      "useEffect"
    ],
    "answer": "useReducer",
    "explanation": "`useReducer` is preferable when state logic is complex or involves multiple sub-values, as it allows managing state via a reducer function and dispatch actions.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is the output of `console.log(<div />.type)` in React?",
    "options": [
      "'div'",
      "'DIV'",
      "undefined",
      "'React.element'"
    ],
    "answer": "'div'",
    "explanation": "When a JSX element is transpiled, the `type` property holds the string name of the HTML tag (lowercase for HTML elements).",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What does the `dangerouslySetInnerHTML` prop do?",
    "options": [
      "It disables React's XSS protection and inserts raw HTML",
      "It sanitizes HTML strings automatically",
      "It increases the rendering speed of inner HTML elements",
      "It allows rendering SVG components"
    ],
    "answer": "It disables React's XSS protection and inserts raw HTML",
    "explanation": "It is React's replacement for `innerHTML`. It is named 'dangerously' to warn developers that it opens up XSS vulnerabilities if the content is not sanitized.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "In the context of React reconciliation, why is the `index` of an array item often discouraged as a `key`?",
    "options": [
      "It causes a memory leak in the browser",
      "It can negatively impact performance and cause state issues if the list order changes",
      "React does not accept numbers as keys",
      "It makes the application run slower than using strings"
    ],
    "answer": "It can negatively impact performance and cause state issues if the list order changes",
    "explanation": "Using indices as keys can lead to bugs and component state mismatch when items are reordered, inserted, or removed, as React may confuse the identity of items.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the purpose of the `super(props)` call in the constructor of a React class component?",
    "options": [
      "To initialize the component's state",
      "To bind event handlers to the component instance",
      "To call the constructor of the parent React.Component class and make `this.props` accessible",
      "To register the component with the Redux store"
    ],
    "answer": "To call the constructor of the parent React.Component class and make `this.props` accessible",
    "explanation": "In ES6 class components, you must call `super(props)` before accessing `this.props`, otherwise `this.props` will be undefined in the constructor.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which term describes the mechanism in React that wraps native browser events to ensure cross-browser compatibility and provide a consistent interface?",
    "options": [
      "Native Event",
      "Synthetic Event",
      "Virtual Event",
      "Polyfill Event"
    ],
    "answer": "Synthetic Event",
    "explanation": "React uses SyntheticEvents to wrap native browser events, normalizing properties across browsers (e.g., `onChange` for `input`, `select`, and `textarea`).",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the main benefit of using React Fragments (`<>...</>` or `<React.Fragment>`)?",
    "options": [
      "They automatically apply CSS styles to child elements",
      "They allow grouping of children without adding extra nodes to the DOM",
      "They improve the performance of reconciliation by 50%",
      "They enforce strict typing on the children"
    ],
    "answer": "They allow grouping of children without adding extra nodes to the DOM",
    "explanation": "Fragments let you group a list of children without adding wrapping DOM nodes (like `div`s), keeping the DOM tree cleaner and often avoiding invalid HTML markup.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which hook is used to optimize performance by caching a function definition between renders?",
    "options": [
      "useMemo",
      "useCallback",
      "useRef",
      "useReducer"
    ],
    "answer": "useCallback",
    "explanation": "`useCallback` returns a memoized callback function that only changes if one of its dependencies changes, useful when passing callbacks to optimized child components.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is the `useContext` hook used for?",
    "options": [
      "To consume the value of a React Context without nesting",
      "To create a new Context Provider",
      "To manage the local component state",
      "To handle error boundaries"
    ],
    "answer": "To consume the value of a React Context without nesting",
    "explanation": "`useContext` accepts a context object (created by `createContext`) and returns the current context value for that context, allowing you to skip the `Context.Consumer` wrapper.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is 'prop drilling'?",
    "options": [
      "The process of validating PropTypes for a component",
      "Passing data through multiple layers of components to reach a deeply nested child",
      "Creating holes in the DOM using SVG filters",
      "Drilling down into the state object to find a specific property"
    ],
    "answer": "Passing data through multiple layers of components to reach a deeply nested child",
    "explanation": "Prop drilling refers to passing data through intermediate components that do not need the data themselves, just to get it to a child component further down the tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "Which lifecycle method is equivalent to running an effect on every dependency change in a function component?",
    "options": [
      "componentDidMount",
      "componentDidUpdate",
      "componentWillUnmount",
      "getSnapshotBeforeUpdate"
    ],
    "answer": "componentDidUpdate",
    "explanation": "If a `useEffect` dependency changes, the effect runs again, similar to logic placed in `componentDidUpdate`. An empty array `[]` mimics `componentDidMount`.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the behavior of `StrictMode` in React?",
    "options": [
      "It forces all console logs to be errors",
      "It performs additional checks and warnings, and invokes functions twice in development to detect side effects",
      "It compiles the application to WebAssembly",
      "It prevents the application from running in production"
    ],
    "answer": "It performs additional checks and warnings, and invokes functions twice in development to detect side effects",
    "explanation": "StrictMode is a development tool that intentionally double-invokes functions (like render, `useState`, etc.) to help detect impure side effects or unsafe lifecycles.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "How do you conditionally render a component in React?",
    "options": [
      "Using the `v-if` directive on the element",
      "Using JavaScript logical operators like `&&` or ternary operators within the JSX",
      "Using the `hidden` attribute in the HTML",
      "Wrapping the element in a `<Conditional>` tag"
    ],
    "answer": "Using JavaScript logical operators like `&&` or ternary operators within the JSX",
    "explanation": "Since JSX is just JavaScript, standard conditional logic (`condition && <Component />` or `condition ? A : B`) is used for conditional rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What happens when you pass a function to `setState`?",
    "options": [
      "The function is executed immediately to update the state",
      "The function is queued and will receive the previous state and props as arguments when the update is applied",
      "The function replaces the component entirely",
      "The state is updated asynchronously only if the component is focused"
    ],
    "answer": "The function is queued and will receive the previous state and props as arguments when the update is applied",
    "explanation": "Functional updates ensure that state updates are based on the most recent state, preventing race conditions when multiple updates are batched.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In React's Fiber architecture, what is a 'Lane'?",
    "options": [
      "A data structure used to store the component's local styles",
      "A priority unit used to define the urgency of an update",
      "A separate thread for rendering the UI",
      "A debugging tool used to track component mount times"
    ],
    "answer": "A priority unit used to define the urgency of an update",
    "explanation": "Lanes (introduced in React 18) represent the priority of updates. Higher priority lanes (like user input) take precedence over lower priority lanes (like data fetching).",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which hook should be used to read layout information synchronously after all DOM mutations?",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useInsertionEffect",
      "useImperativeHandle"
    ],
    "answer": "useLayoutEffect",
    "explanation": "`useLayoutEffect` fires synchronously after all DOM mutations but before the browser paints the screen, making it suitable for reading layout and synchronously re-rendering.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In React's Fiber architecture, what is the primary purpose of the 'return' pointer in a Fiber node?",
    "options": [
      "To store the return value of the component function",
      "To point to the parent Fiber node in the tree",
      "To link to the next sibling Fiber node for traversal",
      "To reference the DOM element associated with the Fiber"
    ],
    "answer": "To point to the parent Fiber node in the tree",
    "explanation": "The 'return' pointer in a Fiber node links back to the parent, allowing the reconciler to return to the parent after processing a child. The 'sibling' pointer links to siblings, and 'stateNode' typically holds the DOM reference.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which phase of the Fiber reconciliation process is interruptible and allows React to prioritize work based on 'lanes'?",
    "options": [
      "The Commit phase",
      "The Render phase",
      "The Hydration phase",
      "The Pre-commit phase"
    ],
    "answer": "The Render phase",
    "explanation": "The Render (Reconciliation) phase builds the Fiber tree and effects, and is interruptible to allow the browser to handle high-priority inputs. The Commit phase is always synchronous and cannot be interrupted.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is the primary difference between `useEffect` and `useLayoutEffect` regarding timing?",
    "options": [
      "`useEffect` runs synchronously during the render phase; `useLayoutEffect` runs asynchronously after paint",
      "`useLayoutEffect` runs synchronously after DOM mutations but before paint; `useEffect` runs asynchronously after paint",
      "`useEffect` runs before the component renders; `useLayoutEffect` runs after the component unmounts",
      "There is no difference; `useLayoutEffect` is simply an alias for `useEffect`."
    ],
    "answer": "`useLayoutEffect` runs synchronously after DOM mutations but before paint; `useEffect` runs asynchronously after paint",
    "explanation": "`useLayoutEffect` fires synchronously after all DOM mutations but before the browser paints the screen, blocking visual updates. `useEffect` defers execution until after the paint is committed to the screen, preventing blocking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Why does React recommend using a stable `key` prop when rendering lists of elements derived from dynamic data?",
    "options": [
      "To ensure the components can access the data object via the `key` prop",
      "To allow React to automatically re-order the DOM nodes for CSS transitions",
      "To enable the reconciler to identify which items have changed, been added, or been removed to preserve component state",
      "To prevent the 'Maximum update depth exceeded' error caused by infinite loops"
    ],
    "answer": "To enable the reconciler to identify which items have changed, been added, or been removed to preserve component state",
    "explanation": "Keys help React identify which items have changed, are added, or are removed, allowing it to update the DOM efficiently and preserve state in existing components. Without stable keys (like array indices), React may re-create components unnecessarily, destroying local state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "In React 18+, what is the behavior of state updates triggered asynchronously (e.g., in `setTimeout` or Promises) regarding batching?",
    "options": [
      "Automatic batching only occurs inside event handlers; async updates create separate renders",
      "Updates are never batched unless `unstable_batchedUpdates` is explicitly used",
      "Updates are automatically batched regardless of where they originate, provided Concurrent Mode is enabled",
      "Async updates are batched only if the component is a PureComponent"
    ],
    "answer": "Updates are automatically batched regardless of where they originate, provided Concurrent Mode is enabled",
    "explanation": "Prior to React 18, batching only happened in React event handlers. In React 18, Automatic Batching is enabled by default (via createRoot), batching state updates even in timeouts, promises, and native event handlers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the technical function of the `startTransition` API in React 18?",
    "options": [
      "To immediately abort the currently rendering component tree",
      "To mark specific state updates as non-urgent, allowing React to interrupt them for higher-priority renders",
      "To manually trigger the re-render of a child component regardless of props",
      "To transition a component from a 'mounted' to an 'unmounted' state asynchronously"
    ],
    "answer": "To mark specific state updates as non-urgent, allowing React to interrupt them for higher-priority renders",
    "explanation": "`startTransition` marks state updates inside its callback as 'transitions', giving them a lower priority. This keeps the interface responsive by allowing React to interrupt these updates if more urgent interactions (like typing) occur.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "When using React.memo() to optimize a component, how does React determine if the component should re-render?",
    "options": [
      "It performs a deep comparison of the component's state object",
      "It performs a shallow comparison of the component's props object",
      "It checks if the component's context has changed",
      "It compares the return value of the previous render with the current render"
    ],
    "answer": "It performs a shallow comparison of the component's props object",
    "explanation": "`React.memo` performs a shallow comparison of the current props with the previous props. If the props reference hasn't changed, React skips the re-render. It does not compare state or perform deep checks by default.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Which statement accurately describes the relationship between the `current` tree and the `workInProgress` tree in Fiber?",
    "options": [
      "The `current` tree is used for layout effects, while the `workInProgress` tree is used for side effects",
      "The `workInProgress` tree is a clone of the `current` tree that React updates during the render phase to apply changes",
      "The `current` tree is deleted after every commit and replaced entirely by the `workInProgress` tree",
      "Both trees are rendered to the DOM simultaneously to prevent UI flicker"
    ],
    "answer": "The `workInProgress` tree is a clone of the `current` tree that React updates during the render phase to apply changes",
    "explanation": "React maintains a 'current' tree (what is on screen) and a 'work-in-progress' tree (being built in memory). Updates are applied to the work-in-progress tree during the render phase, which then becomes the current tree upon commit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the purpose of the 'Lane' model in React's internal priority system?",
    "options": [
      "To track which components are currently in the 'loading' or 'error' state",
      "To represent the 32-bit integer mask used to prioritize and batch updates",
      "To map virtual DOM nodes to physical memory lanes on the GPU",
      "To define the horizontal layout direction (LTR/RTL) of the Fiber node"
    ],
    "answer": "To represent the 32-bit integer mask used to prioritize and batch updates",
    "explanation": "Lanes are a model used to represent priorities. They use bitmasks (32-bit integers) to efficiently check if an update includes higher-priority work or if it can be batched with other updates.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What occurs during the 'Commit' phase of the Fiber lifecycle?",
    "options": [
      "React calculates the diff between the new and old Virtual DOM trees",
      "React applies the calculated changes to the host environment (DOM) and executes lifecycle methods/effects",
      "React pauses rendering to allow the browser to handle user inputs",
      "React creates the Fiber nodes for the first time"
    ],
    "answer": "React applies the calculated changes to the host environment (DOM) and executes lifecycle methods/effects",
    "explanation": "The Commit phase is where React takes the finished work-in-progress tree and applies changes to the DOM (or other host environments). It runs layout effects and cleans up old effects synchronously.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does the `useDeferredValue` hook improve performance in list filtering scenarios?",
    "options": [
      "It caches the filtered list in `localStorage` to avoid re-computation",
      "It defers re-rendering the expensive list until the urgent input updates are completed",
      "It automatically debounces the input event to reduce the frequency of state updates",
      "It transforms the list into a virtualized window to reduce DOM nodes"
    ],
    "answer": "It defers re-rendering the expensive list until the urgent input updates are completed",
    "explanation": "`useDeferredValue` allows a value (like a search query) to lag behind the urgent state. React keeps the old value for a non-urgent render while the new value is being processed, keeping the interface responsive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the result of passing an impure function to the `calc` dependency array of `useMemo`?",
    "options": [
      "React will automatically memoize the function's result based on its return value",
      "The `useMemo` hook will fail to compile and throw a runtime error",
      "The memoization will likely fail or behave unpredictably as `useMemo` checks reference equality for dependencies",
      "React will force the component to re-render on every frame"
    ],
    "answer": "The memoization will likely fail or behave unpredictably as `useMemo` checks reference equality for dependencies",
    "explanation": "`useMemo` relies on referential equality of dependencies. If an impure function is created inline (new reference every render) or changes unexpectedly, the memoized value will be recalculated on every render, negating the performance benefit.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "In the context of Synthetic Events in React, what is 'Event Delegation'?",
    "options": [
      "Assigning a unique event listener to every DOM node in the component tree",
      "Attaching a single event listener at the root of the document to manage all child events",
      "Delegating event handling to the Web Worker pool to free up the main thread",
      "Passing event objects down to child components via props"
    ],
    "answer": "Attaching a single event listener at the root of the document to manage all child events",
    "explanation": "React attaches event listeners to the root (or document in legacy versions). When an event fires, React uses the event's `bubbling` phase to find the component and triggers the handler, normalizing cross-browser events.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What happens if a component throws an error during the 'Render' phase (while calculating a Virtual DOM)?",
    "options": [
      "The error is caught by the nearest Error Boundary, which can render a fallback UI",
      "The entire application crashes immediately (white screen of death)",
      "The component is automatically unmounted without logging the error",
      "The error is swallowed and the component simply fails to render"
    ],
    "answer": "The error is caught by the nearest Error Boundary, which can render a fallback UI",
    "explanation": "Errors during rendering (in lifecycle methods or constructors) are caught by the nearest Error Boundary component. If no Error Boundary exists, the entire app tree unmounts.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "Why is it generally discouraged to mutate the `state` property directly in a React component?",
    "options": [
      "Direct mutation is slower than creating a new object due to garbage collection overhead",
      "Direct mutation does not trigger a re-render, as `React.useState` relies on Object.is comparison for updates",
      "Direct mutation causes memory leaks in the Fiber tree",
      "State properties are marked as `readonly` by TypeScript and will cause a compilation error"
    ],
    "answer": "Direct mutation does not trigger a re-render, as `React.useState` relies on Object.is comparison for updates",
    "explanation": "React determines if a re-render is needed by checking if the state reference has changed. Mutating the existing object directly does not change the reference, so React assumes nothing changed and skips the render.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the specific use case for `useInsertionEffect` introduced in React 18?",
    "options": [
      "To fetch data before the component mounts",
      "To execute logic synchronously before React makes changes to the DOM, primarily for CSS-in-JS libraries",
      "To schedule a layout update after the paint",
      "To insert a node into the middle of the Fiber tree"
    ],
    "answer": "To execute logic synchronously before React makes changes to the DOM, primarily for CSS-in-JS libraries",
    "explanation": "`useInsertionEffect` fires before DOM mutations. It is designed specifically for CSS-in-JS libraries to inject styles before the browser paints, avoiding layout shifts/flickers, without having access to refs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which hook should be used to measure the DOM layout (e.g., width/height) immediately after React commits updates, but before the browser paints?",
    "options": [
      "`useEffect`",
      "`useLayoutEffect`",
      "`useRef`",
      "`useCallback`"
    ],
    "answer": "`useLayoutEffect`",
    "explanation": "`useLayoutEffect` runs synchronously after DOM mutations but before the browser paints. This is the ideal time to read layout from the DOM and synchronously re-render if needed to avoid visual flicker.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "How does `React.forwardRef` differ from standard ref passing?",
    "options": [
      "It automatically creates a ref for the parent component",
      "It allows a parent component to pass a ref through a child component directly to a DOM element or grandchild",
      "It is the only way to use refs in functional components",
      "It enforces strict type checking on the ref object"
    ],
    "answer": "It allows a parent component to pass a ref through a child component directly to a DOM element or grandchild",
    "explanation": "Standard ref passing does not work when the ref is attached to a custom component (the ref points to the component instance). `forwardRef` explicitly exposes a specific child DOM element to the parent.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "When using `StrictMode` in React 18, why do effects appear to run twice?",
    "options": [
      "It is a bug in the concurrency implementation",
      "StrictMode double-invokes effects (and render functions in dev) to help detect side effects that need cleanup",
      "StrictMode simulates a 'fast refresh' scenario to verify component resilience",
      "Effects run twice because the component is mounted and immediately updated with new props"
    ],
    "answer": "StrictMode double-invokes effects (and render functions in dev) to help detect side effects that need cleanup",
    "explanation": "In Development mode, StrictMode intentionally double-invokes functions like `useState`, `useReducer`, and `useEffect` to highlight cleanup issues or impure renders that might break in concurrent features.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the 'effect list' in the context of the Fiber commit phase?",
    "options": [
      "A list of all components currently mounted in the application",
      "A linked list of Fiber nodes that have side effects (DOM updates, refs, layout effects) to be processed",
      "The list of dependencies passed to the `useEffect` hook",
      "A log of all errors caught during the render phase"
    ],
    "answer": "A linked list of Fiber nodes that have side effects (DOM updates, refs, layout effects) to be processed",
    "explanation": "During the render phase, React marks fibers that have effects (insertion, updates, deletions). It links these together into a linear 'effect list' so the commit phase can iterate quickly over them without searching the whole tree.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the primary behavior difference between `createClass` (legacy) and functional components regarding `this`?",
    "options": [
      "`createClass` autobinds methods; functional components use `this` automatically",
      "Functional components do not have `this`; `createClass` instances do",
      "Both are identical but `createClass` is deprecated syntax",
      "Functional components use `this` to refer to the Fiber node"
    ],
    "answer": "Functional components do not have `this`; `createClass` instances do",
    "explanation": "Functional components are plain JavaScript functions and do not have a `this` context. Legacy `createClass` components created instances where `this` referred to the component, autobinding methods.",
    "difficulty": "Intermediate"
  }
]