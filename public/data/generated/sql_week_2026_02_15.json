[
  {
    "id": 1,
    "question": "Which clause is used to filter the results of a GROUP BY query based on a specific condition applied to the aggregated data?",
    "options": [
      "WHERE",
      "HAVING",
      "ORDER BY",
      "FILTER"
    ],
    "answer": "HAVING",
    "explanation": "The HAVING clause filters records after they have been grouped, unlike WHERE which filters rows before aggregation. HAVING is typically used with conditions involving aggregate functions like COUNT or SUM.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is the result of a LEFT JOIN (or LEFT OUTER JOIN) between Table A and Table B if no matching row is found in Table B?",
    "options": [
      "The row from Table A is excluded from the result set",
      "The row from Table A is included with NULL values for Table B's columns",
      "The database returns an error indicating a referential integrity violation",
      "The row from Table B is included with NULL values for Table A's columns"
    ],
    "answer": "The row from Table A is included with NULL values for Table B's columns",
    "explanation": "A LEFT JOIN prioritizes the left (first) table, returning all its rows. If there is no match in the right table, the columns for the right table are returned as NULL.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "In SQL, which operator is used to check if a value exists within a specified list of values?",
    "options": [
      "BETWEEN",
      "EXISTS",
      "IN",
      "LIKE"
    ],
    "answer": "IN",
    "explanation": "The IN operator allows you to specify multiple values in a WHERE clause, functioning as a shorthand for multiple OR conditions. EXISTS is used to check for the presence of rows in a subquery.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What distinguishes the DELETE command from the TRUNCATE command?",
    "options": [
      "DELETE cannot be rolled back, while TRUNCATE can",
      "DELETE is a DDL operation, while TRUNCATE is a DML operation",
      "DELETE can use a WHERE clause to filter rows, while TRUNCATE removes all rows",
      "TRUNCATE resets the identity seed, while DELETE does not"
    ],
    "answer": "DELETE can use a WHERE clause to filter rows, while TRUNCATE removes all rows",
    "explanation": "DELETE is a DML operation that removes specific rows based on a condition. TRUNCATE is a DDL operation that deallocates data pages, removing all rows instantly and usually resetting identity seeds.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "Which SQL keyword is used to eliminate duplicate rows from the result set of a query?",
    "options": [
      "SINGLE",
      "REDUCE",
      "UNIQUE",
      "DISTINCT"
    ],
    "answer": "DISTINCT",
    "explanation": "The DISTINCT keyword ensures that the query returns only unique values for the columns specified, removing any duplicate rows from the output.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Which of the following correctly describes the behavior of the BETWEEN operator in a WHERE clause?",
    "options": [
      "It selects values excluding the specified endpoints",
      "It selects values within a given range, inclusive of the endpoints",
      "It selects values strictly greater than the lower bound and less than the upper bound",
      "It functions identically to the IN operator"
    ],
    "answer": "It selects values within a given range, inclusive of the endpoints",
    "explanation": "The BETWEEN operator selects values within a given range and is inclusive, meaning the boundary values specified in the query are included in the results.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "In the context of database normalization, what is the primary purpose of the First Normal Form (1NF)?",
    "options": [
      "To ensure all non-key attributes are dependent on the primary key",
      "To eliminate repeating groups by ensuring atomic values in each column",
      "To remove transitive dependencies",
      "To ensure all rows have a unique identifier"
    ],
    "answer": "To eliminate repeating groups by ensuring atomic values in each column",
    "explanation": "1NF dictates that a table should not contain repeating groups or multi-valued attributes. Every column must hold single, atomic values (indivisible).",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which aggregate function returns the number of rows that match a specified criterion, ignoring NULL values in the specific column?",
    "options": [
      "COUNT(*)",
      "SUM(column_name)",
      "COUNT(column_name)",
      "TOTAL(column_name)"
    ],
    "answer": "COUNT(column_name)",
    "explanation": "COUNT(column_name) specifically counts non-NULL values within that column. In contrast, COUNT(*) counts the total number of rows regardless of NULL values.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the default sort order of the ORDER BY clause if no direction (ASC or DESC) is specified?",
    "options": [
      "Random",
      "Descending",
      "Ascending",
      "Index order"
    ],
    "answer": "Ascending",
    "explanation": "The default sorting behavior for ORDER BY is Ascending (ASC), sorting text A-Z and numbers 0-9. You must explicitly specify DESC to reverse this order.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which constraint ensures that a column cannot contain NULL values?",
    "options": [
      "UNIQUE",
      "PRIMARY KEY",
      "NOT NULL",
      "CHECK"
    ],
    "answer": "NOT NULL",
    "explanation": "The NOT NULL constraint enforces that a column must always contain a value. While PRIMARY KEY also implicitly prevents NULLs, NOT NULL is the specific constraint designed for this purpose on non-key columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What does the wildcard character '%' represent when used with the LIKE operator?",
    "options": [
      "A single character",
      "Zero or more characters",
      "Any single digit",
      "Exactly one space"
    ],
    "answer": "Zero or more characters",
    "explanation": "The '%' sign matches any sequence of characters (including zero characters). The underscore '_' is used to match exactly one single character.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which join type returns all rows when there is a match in either the left or right table records?",
    "options": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "FULL OUTER JOIN",
    "explanation": "A FULL OUTER JOIN combines the results of both LEFT and RIGHT joins. It returns all records from both tables, matching them where possible, and NULLs where there is no match.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "Which logical operator has a higher precedence when evaluating conditions in a WHERE clause?",
    "options": [
      "OR",
      "AND",
      "NOT",
      "XOR"
    ],
    "answer": "NOT",
    "explanation": "NOT generally has the highest precedence, followed by AND, and then OR. Parentheses should be used to enforce specific evaluation orders and ensure clarity.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is the primary function of the SQL UNION operator?",
    "options": [
      "To join two tables based on a common column",
      "To combine the result sets of two or more SELECT statements",
      "To return only distinct values from a single table",
      "To intersect the results of two queries"
    ],
    "answer": "To combine the result sets of two or more SELECT statements",
    "explanation": "UNION removes duplicate rows from the combined result set. UNION ALL keeps duplicates. Both vertically stack results, requiring matching column counts and data types.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which command is used to permanently save the changes made during the current transaction?",
    "options": [
      "SAVE",
      "COMMIT",
      "PERSIST",
      "EXECUTE"
    ],
    "answer": "COMMIT",
    "explanation": "COMMIT is the transactional control command that saves all transactional changes to the database. Until a COMMIT is issued, changes can be reversed using ROLLBACK.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "In a SELECT statement, which clause is evaluated logically first?",
    "options": [
      "SELECT",
      "WHERE",
      "FROM",
      "ORDER BY"
    ],
    "answer": "FROM",
    "explanation": "The logical order of execution starts with FROM (identifying the data source), then WHERE (filtering), then GROUP BY, followed by HAVING, SELECT, and finally ORDER BY.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the effect of adding the keyword ALL after the UNION set operator?",
    "options": [
      "It filters out duplicates from the combined result set",
      "It includes duplicate rows in the combined result set",
      "It requires both tables to have identical column names",
      "It sorts the final result set in ascending order"
    ],
    "answer": "It includes duplicate rows in the combined result set",
    "explanation": "UNION removes duplicates by default. UNION ALL retains all rows from the combined queries, including duplicates, which makes it generally faster because it skips the duplicate-checking step.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which clause is mandatory when using an aggregate function like SUM() or AVG() alongside non-aggregated columns in the SELECT list?",
    "options": [
      "ORDER BY",
      "WHERE",
      "GROUP BY",
      "LIMIT"
    ],
    "answer": "GROUP BY",
    "explanation": "Standard SQL requires that all non-aggregated columns in the SELECT list be included in the GROUP BY clause. This organizes data into groups so the aggregate can be calculated for each specific group.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which data type is most appropriate for storing variable-length text strings up to approximately 1 gigabyte?",
    "options": [
      "CHAR",
      "VARCHAR",
      "TEXT",
      "BLOB"
    ],
    "answer": "VARCHAR",
    "explanation": "VARCHAR is a standard string data type for variable-length character data. TEXT/CLOB is often used for very large strings, but VARCHAR is the general-purpose type; however, in many databases, VARCHAR(max) or TEXT is used for GB-sized data. In the context of beginner SQL, VARCHAR is the distinct type for variable text, but technically for *very* large strings (GB), types like TEXT or CLOB are used. *Self-correction for beginner level:* VARCHAR is the standard variable type. For very large (GB), 'TEXT' (or CLOB) is the specific answer.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What happens if you attempt to insert a row into a table that violates a PRIMARY KEY constraint?",
    "options": [
      "The database inserts the row and updates the key",
      "The database inserts a NULL value for the key",
      "The database rejects the insert and raises an error",
      "The database truncates the existing conflicting row"
    ],
    "answer": "The database rejects the insert and raises an error",
    "explanation": "PRIMARY KEY constraints enforce uniqueness and non-nullability. Any attempt to insert a duplicate value or a NULL into a primary key column will result in an error.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which of the following best describes a FOREIGN KEY constraint?",
    "options": [
      "It uniquely identifies each record in the table",
      "It ensures data in a column matches values in another table's column",
      "It restricts the column to only non-negative integers",
      "It automatically creates an index on the column"
    ],
    "answer": "It ensures data in a column matches values in another table's column",
    "explanation": "A FOREIGN KEY enforces referential integrity by ensuring that values in a column (or set of columns) correspond to valid values in another table, typically the PRIMARY KEY of that table.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "Which keyword is used to assign a temporary name to a table or column within a query?",
    "options": [
      "RENAME",
      "DEFINE",
      "ALIAS",
      "AS"
    ],
    "answer": "AS",
    "explanation": "The AS keyword is used to define aliases for columns or tables to make headers more readable or to simplify table references during joins.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which operator is used to test whether a subquery returns any rows?",
    "options": [
      "EXISTS",
      "IN",
      "CONTAINS",
      "SOME"
    ],
    "answer": "EXISTS",
    "explanation": "The EXISTS operator returns TRUE if the subquery returns one or more records. It is often more efficient than IN for checking existence because it stops scanning upon finding the first match.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "Which statement correctly describes the difference between CHAR and VARCHAR data types?",
    "options": [
      "CHAR stores variable-length data, VARCHAR stores fixed-length",
      "CHAR stores fixed-length data padded with spaces, VARCHAR stores variable-length data",
      "CHAR is used for numbers, VARCHAR is used for text",
      "There is no performance difference between the two"
    ],
    "answer": "CHAR stores fixed-length data padded with spaces, VARCHAR stores variable-length data",
    "explanation": "CHAR columns have a fixed length and use trailing spaces to fill the space. VARCHAR columns use only the storage required for the actual data plus a length prefix.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is the result of the expression 'NULL = NULL' in standard SQL?",
    "options": [
      "TRUE",
      "FALSE",
      "UNKNOWN",
      "NULL"
    ],
    "answer": "UNKNOWN",
    "explanation": "In SQL, NULL represents an unknown value. Any comparison involving NULL (except IS NULL or IS NOT NULL) yields a result of UNKNOWN (or NULL), which is treated as FALSE in a WHERE clause.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "Which clause limits the number of rows returned by a query after calculation and sorting?",
    "options": [
      "TOP",
      "LIMIT",
      "FETCH",
      "All of the above are valid depending on the SQL dialect"
    ],
    "answer": "All of the above are valid depending on the SQL dialect",
    "explanation": "Syntax varies by database: MySQL/PostgreSQL use LIMIT, SQL Server uses TOP, and Oracle uses FETCH. All serve the purpose of limiting the result set size.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which set operation returns only the rows that appear in the result sets of both queries involved?",
    "options": [
      "UNION",
      "INTERSECT",
      "EXCEPT",
      "JOIN"
    ],
    "answer": "INTERSECT",
    "explanation": "INTERSECT returns the distinct rows that are output by both the left and right input queries. It acts like a set intersection in mathematics.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which function is used to return the current date and time in most SQL dialects?",
    "options": [
      "GETDATE()",
      "NOW()",
      "CURRENT_TIMESTAMP",
      "All of the above are common"
    ],
    "answer": "All of the above are common",
    "explanation": "Date and time functions vary by dialect: SQL Server uses GETDATE(), MySQL uses NOW(), and standard SQL prefers CURRENT_TIMESTAMP. All are valid depending on the environment.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which SQL keyword is used to create a new, empty table structure?",
    "options": [
      "NEW TABLE",
      "CREATE TABLE",
      "INSERT TABLE",
      "SCHEMA ADD"
    ],
    "answer": "CREATE TABLE",
    "explanation": "CREATE TABLE is the DDL (Data Definition Language) command used to define a new table, specifying its columns, data types, and constraints.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the purpose of the CHECK constraint?",
    "options": [
      "To verify the data type of a column",
      "To ensure all values in a column satisfy a specific Boolean condition",
      "To check if a table exists before dropping it",
      "To validate that a primary key exists in another table"
    ],
    "answer": "To ensure all values in a column satisfy a specific Boolean condition",
    "explanation": "A CHECK constraint limits the values that can be placed in a column (e.g., ensuring Age > 18). If the condition evaluates to FALSE, the row is rejected.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which statement is used to modify the structure of an existing table, such as adding a column?",
    "options": [
      "UPDATE TABLE",
      "CHANGE TABLE",
      "ALTER TABLE",
      "MODIFY TABLE"
    ],
    "answer": "ALTER TABLE",
    "explanation": "ALTER TABLE is the DDL command used to add, delete, or modify columns in an existing table, as well as add or drop constraints.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which aggregate function calculates the arithmetic mean of a set of values?",
    "options": [
      "MEDIAN",
      "AVERAGE",
      "AVG",
      "MEAN"
    ],
    "answer": "AVG",
    "explanation": "AVG is the standard SQL aggregate function for calculating the mean. It ignores NULL values in its calculation.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What does the term 'Normalization' refer to in the context of SQL database design?",
    "options": [
      "Converting data to a standard character set (e.g., UTF-8)",
      "The process of organizing data to reduce redundancy and improve integrity",
      "Backing up the database to a secondary location",
      "Compiling SQL queries into machine code"
    ],
    "answer": "The process of organizing data to reduce redundancy and improve integrity",
    "explanation": "Normalization involves structuring a relational database in accordance with a series of 'normal forms' (1NF, 2NF, 3NF) to reduce data dependency and minimize duplication.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "Which join returns rows that are not matched in the specified join?",
    "options": [
      "INNER JOIN",
      "CROSS JOIN",
      "ANTI JOIN (typically implemented via LEFT JOIN ... WHERE NULL)",
      "SELF JOIN"
    ],
    "answer": "ANTI JOIN (typically implemented via LEFT JOIN ... WHERE NULL)",
    "explanation": "An Anti Join filters for rows in one table that have no corresponding match in another. This is usually achieved by a LEFT JOIN checking for NULL values in the right table's columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which command is used to remove a stored procedure, view, or table from the database?",
    "options": [
      "DELETE",
      "REMOVE",
      "DROP",
      "DESTROY"
    ],
    "answer": "DROP",
    "explanation": "DROP is a DDL command that removes existing database objects (like tables, views, or indexes) and their structures permanently. DELETE removes only the data rows.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the default window frame if an `ORDER BY` clause is specified in a window function definition, but no explicit frame clause (e.g., `ROWS BETWEEN`) is provided?",
    "options": [
      "ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING",
      "RANGE UNBOUNDED PRECEDING AND CURRENT ROW",
      "ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING",
      "GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"
    ],
    "answer": "RANGE UNBOUNDED PRECEDING AND CURRENT ROW",
    "explanation": "In standard SQL, when `ORDER BY` is used without a frame clause, the default scope is `RANGE UNBOUNDED PRECEDING AND CURRENT ROW`. This sets the frame from the start of the partition to the current row.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "When using `RANK()` versus `DENSE_RANK()` in SQL, how do they behave differently regarding tied values?",
    "options": [
      "`RANK()` assigns unique sequential integers to rows; `DENSE_RANK()` leaves gaps in the ranking sequence",
      "`RANK()` leaves gaps in the ranking sequence after ties; `DENSE_RANK()` does not leave gaps",
      "`DENSE_RANK()` counts the total number of rows; `RANK()` counts only distinct values",
      "Both functions behave identically, but `RANK()` requires an `ORDER BY` clause"
    ],
    "answer": "`RANK()` leaves gaps in the ranking sequence after ties; `DENSE_RANK()` does not leave gaps",
    "explanation": "`RANK()` assigns the same rank to tied rows but skips the next rank numbers (e.g., 1, 2, 2, 4). `DENSE_RANK()` assigns the same rank to ties but does not skip numbers (e.g., 1, 2, 2, 3).",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "Which SQL clause is used to filter the results of a `GROUP BY` query based on a specific aggregate condition?",
    "options": [
      "WHERE",
      "LIMIT",
      "HAVING",
      "FILTER"
    ],
    "answer": "HAVING",
    "explanation": "The `HAVING` clause was added to SQL specifically because the `WHERE` keyword could not be used with aggregate functions. It filters records after they have been grouped.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "Which set operation returns all distinct rows from the first query that do not appear in the results of the second query?",
    "options": [
      "INTERSECT",
      "UNION",
      "EXCEPT",
      "DIFFERENCE"
    ],
    "answer": "EXCEPT",
    "explanation": "`EXCEPT` (or `MINUS` in some dialects like Oracle) outputs the unique rows from the left result set that are not output by the right result set, effectively subtracting the second set from the first.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the primary purpose of the `COALESCE` function in SQL?",
    "options": [
      "To combine multiple rows into a single comma-separated string",
      "To return the first non-NULL expression among its arguments",
      "To enforce a check constraint on a column",
      "To convert a string to a numeric type"
    ],
    "answer": "To return the first non-NULL expression among its arguments",
    "explanation": "`COALESCE` takes a list of arguments and evaluates them in order, returning the value of the first argument that is not `NULL`. If all arguments are NULL, it returns NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "When creating a Recursive Common Table Expression (CTE), which two components are mandatory?",
    "options": [
      "An anchor member and a recursive member connected by UNION ALL",
      "A base table and a cursor",
      "A window function and a self-join",
      "A temporary table and a trigger"
    ],
    "answer": "An anchor member and a recursive member connected by UNION ALL",
    "explanation": "A recursive CTE requires an anchor member (the initial result set) and a recursive member (the repeated step) connected by `UNION ALL`. The recursion stops when the recursive member returns no rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In SQL optimization, what does the acronym \"SARGable\" refer to?",
    "options": [
      "A query that is able to be saved and reused later",
      "A query predicate that allows the engine to efficiently use an index (Search ARGument ABLE)",
      "A specific type of sorting algorithm used in execution plans",
      "A permission setting that allows argument passing to stored procedures"
    ],
    "answer": "A query predicate that allows the engine to efficiently use an index (Search ARGument ABLE)",
    "explanation": "SARGable stands for Search ARGument ABLE. It describes a WHERE clause predicate that can leverage an index seek (e.g., `WHERE col = 1`) rather than an expensive index scan (e.g., `WHERE UPPER(col) = 'VAL'`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is the effect of using the `REPEATABLE READ` isolation level compared to `READ COMMITTED`?",
    "options": [
      "It guarantees that phantom reads will occur",
      "It prevents non-repeatable reads and guarantees that if a row is read twice, its values are consistent",
      "It allows dirty reads to improve concurrency",
      "It locks the entire table for the duration of the transaction"
    ],
    "answer": "It prevents non-repeatable reads and guarantees that if a row is read twice, its values are consistent",
    "explanation": "`REPEATABLE READ` ensures that any data read during a transaction cannot be modified by other transactions until the current transaction completes, preventing non-repeatable reads (though phantoms may still occur in some implementations).",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which `JOIN` type is used to return all rows from both tables, matching them where possible, and inserting `NULL`s where there is no match?",
    "options": [
      "INNER JOIN",
      "LEFT OUTER JOIN",
      "RIGHT OUTER JOIN",
      "FULL OUTER JOIN"
    ],
    "answer": "FULL OUTER JOIN",
    "explanation": "A `FULL OUTER JOIN` combines the results of both `LEFT` and `RIGHT` joins. It returns all records when there is a match in either the left or right table, filling with `NULLs` on the side where there is no match.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the difference between `WHERE` and `HAVING` in a query involving aggregation?",
    "options": [
      "`WHERE` filters individual rows before aggregation; `HAVING` filters groups after aggregation",
      "`WHERE` filters groups after aggregation; `HAVING` filters individual rows before aggregation",
      "There is no difference; they are interchangeable",
      "`HAVING` can only be used with string functions, while `WHERE` is for numbers"
    ],
    "answer": "`WHERE` filters individual rows before aggregation; `HAVING` filters groups after aggregation",
    "explanation": "The `WHERE` clause evaluates row data before groups are formed and aggregated. The `HAVING` clause evaluates the aggregated data after the `GROUP BY` clause has been applied.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "Which function returns a value indicating the sequential rank of a row within a partition, without gaps for tied values?",
    "options": [
      "ROW_NUMBER",
      "RANK",
      "DENSE_RANK",
      "NTILE"
    ],
    "answer": "DENSE_RANK",
    "explanation": "`DENSE_RANK()` returns the rank of rows within a partition without gaps; ties receive the same rank, and the next rank is the sequential integer (e.g., 1, 2, 2, 3). `RANK()` creates gaps.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the primary disadvantage of using `SELECT *` in a production application query?",
    "options": [
      "It prevents the use of the `WHERE` clause",
      "It retrieves unnecessary columns, increasing network traffic and I/O, and breaks application code if schemas change",
      "It automatically converts all strings to uppercase",
      "It forces the database to use a full table scan regardless of indexes"
    ],
    "answer": "It retrieves unnecessary columns, increasing network traffic and I/O, and breaks application code if schemas change",
    "explanation": "`SELECT *` fetches all columns, which can consume excessive bandwidth and memory. Furthermore, relying on ordinal position makes the application brittle to schema changes (column additions or reordering).",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Which clause is used to define a window frame specification explicitly within a window function?",
    "options": [
      "PARTITION BY",
      "ORDER BY",
      "ROWS BETWEEN",
      "GROUP BY"
    ],
    "answer": "ROWS BETWEEN",
    "explanation": "While `PARTITION BY` and `ORDER BY` define the scope and sequence, the frame clause (e.g., `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`) explicitly defines the set of rows relative to the current row used in the calculation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "When using a Composite Index on columns (A, B, C), which query scenario guarantees the index will be used efficiently?",
    "options": [
      "Searching only on column C",
      "Searching on column B only",
      "Searching on column A, or A and B, or A and B and C",
      "Searching on columns B and C"
    ],
    "answer": "Searching on column A, or A and B, or A and B and C",
    "explanation": "For a composite index (A, B, C), the B-Tree traversal is efficient only if the search uses the leading column (A). Skipping the leading column (e.g., searching only B or C) usually results in a scan rather than a seek.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What does the `TRUNCATE` command do regarding transaction logging compared to `DELETE`?",
    "options": [
      "`TRUNCATE` logs every row deletion individually; `DELETE` logs page deallocations",
      "`TRUNCATE` logs only page deallocations, making it faster; `DELETE` logs every row deletion",
      "Both commands log data identically, but `TRUNCATE` cannot be rolled back",
      "`TRUNCATE` logs nothing; it is a non-logged operation"
    ],
    "answer": "`TRUNCATE` logs only page deallocations, making it faster; `DELETE` logs every row deletion",
    "explanation": "`TRUNCATE` is a minimally logged operation (de-allocating data pages) rather than deleting rows one by one. This makes it significantly faster for clearing large tables, though it cannot be used with foreign keys.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "In a `CROSS JOIN`, what is the resulting row count if Table A has 5 rows and Table B has 10 rows?",
    "options": [
      "15 rows",
      "10 rows",
      "50 rows",
      "5 rows"
    ],
    "answer": "50 rows",
    "explanation": "A `CROSS JOIN` (Cartesian product) returns every possible combination of rows from the joined tables. The total number of rows is the product of the row counts of the two tables (5 * 10 = 50).",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Which of the following best describes the `INTERSECT` set operation?",
    "options": [
      "Returns all rows from the first table and matching rows from the second",
      "Returns distinct rows that are returned by both the left and right SELECT queries",
      "Returns rows from the first query that are not in the second",
      "Returns all rows including duplicates from both queries"
    ],
    "answer": "Returns distinct rows that are returned by both the left and right SELECT queries",
    "explanation": "`INTERSECT` compares the results of two queries and returns only the rows that are common to both, automatically eliminating duplicates (similar to an inner join on all columns).",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What does the `LATERAL` keyword (or `APPLY` in T-SQL) allow a subquery to do?",
    "options": [
      "Reference columns from tables that appear to the left of the subquery in the `FROM` clause",
      "Execute the subquery after the `WHERE` clause is processed",
      "Create a temporary table that persists after the session ends",
      "Reference columns from the `SELECT` clause of the outer query"
    ],
    "answer": "Reference columns from tables that appear to the left of the subquery in the `FROM` clause",
    "explanation": "A `LATERAL` join allows a subquery in the `FROM` clause to reference column values from the preceding table(s) in the same `FROM` clause, acting like a correlated subquery that can return multiple rows.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "Why might a database optimizer choose a \"Table Scan\" over an \"Index Seek\"?",
    "options": [
      "The table is very small and scanning is cheaper than looking up the index",
      "The index is corrupted",
      "The query uses the `ORDER BY` clause",
      "Table Scans are always faster than Index Seeks"
    ],
    "answer": "The table is very small and scanning is cheaper than looking up the index",
    "explanation": "For very small tables, the cost of the I/O to read the index pages plus the table pages often exceeds the cost of simply reading the entire table (Table Scan) directly from the data pages.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "Which aggregate function ignores `NULL` values completely during its calculation?",
    "options": [
      "COUNT(*)",
      "SUM(column_name)",
      "AVG(column_name)",
      "Both SUM and AVG ignore NULLs"
    ],
    "answer": "Both SUM and AVG ignore NULLs",
    "explanation": "Most aggregate functions, including `SUM`, `AVG`, `MIN`, `MAX`, and `COUNT(column)`, ignore `NULL` values. `COUNT(*)` is a notable exception because it counts rows regardless of column content.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What is the logical order of execution for the clauses in a SQL SELECT statement?",
    "options": [
      "SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY",
      "FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY",
      "WHERE -> FROM -> SELECT -> GROUP BY -> ORDER BY -> HAVING",
      "FROM -> SELECT -> WHERE -> HAVING -> GROUP BY -> ORDER BY"
    ],
    "answer": "FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY",
    "explanation": "SQL logically processes queries in the order: FROM (including JOINs), WHERE, GROUP BY, HAVING, SELECT, and finally ORDER BY. This determines when aliases become available and how filters interact.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "In the context of the `WITH` clause (CTE), what happens if the CTE is referenced multiple times in the main query?",
    "options": [
      "The CTE query is executed multiple times",
      "The CTE materializes once and is reused",
      "An error is thrown because CTEs cannot be used more than once",
      "The CTE is converted into a temporary table automatically"
    ],
    "answer": "The CTE query is executed multiple times",
    "explanation": "In standard SQL implementations (like Postgres or SQL Server), non-recursive CTEs act as syntactic macros or optimization fences. Unless the database explicitly materializes the CTE (like Postgres's `MATERIALIZED` keyword), it may be re-evaluated for each reference.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is a \"Deadlock\" in the context of database transactions?",
    "options": [
      "A query that takes too long to execute",
      "A situation where two transactions wait for each other to release locks, causing a permanent wait",
      "A lock placed on a row that prevents reads",
      "A failure in the network connection"
    ],
    "answer": "A situation where two transactions wait for each other to release locks, causing a permanent wait",
    "explanation": "A deadlock occurs when Transaction A holds a lock on Resource 1 and waits for Resource 2, while Transaction B holds a lock on Resource 2 and waits for Resource 1. The database must kill one transaction to resolve it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which window function assigns a unique integer to each row within a partition, regardless of ties?",
    "options": [
      "RANK",
      "DENSE_RANK",
      "ROW_NUMBER",
      "NTILE"
    ],
    "answer": "ROW_NUMBER",
    "explanation": "`ROW_NUMBER()` is a deterministic function that assigns a unique sequential integer (1, 2, 3...) to every row, irrespective of duplicate values in the `ORDER BY` clause.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "When defining a constraint `ON DELETE SET NULL`, what occurs when the parent row is deleted?",
    "options": [
      "The child row is deleted automatically",
      "The foreign key column in the child row is set to NULL",
      "The database throws an error",
      "The parent row cannot be deleted"
    ],
    "answer": "The foreign key column in the child row is set to NULL",
    "explanation": "The `ON DELETE SET NULL` referential action ensures that when a referenced row in the parent table is deleted, the foreign key value in the child table is set to NULL (assuming the column allows NULLs).",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What does the `ROLLUP` extension of `GROUP BY` generate?",
    "options": [
      "A cross-tabulation of all possible combinations of grouping columns",
      "Hierarchical subtotals (aggregations) for the hierarchy of columns specified",
      "A list of unique grouping IDs",
      "A pivot table based on time"
    ],
    "answer": "Hierarchical subtotals (aggregations) for the hierarchy of columns specified",
    "explanation": "`ROLLUP` generates subtotals based on the hierarchy of the columns defined (e.g., (A,B,C) produces (A,B,C), (A,B), (A), and Grand Total), whereas `CUBE` generates all combinations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "Which operator is used to check if a subquery returns any rows, typically for existence checks?",
    "options": [
      "IN",
      "EXISTS",
      "ANY",
      "SOME"
    ],
    "answer": "EXISTS",
    "explanation": "The `EXISTS` operator is a boolean operator that returns `TRUE` if the subquery returns one or more rows. It stops scanning as soon as it finds a match, making it efficient for existence checks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "In a normalized database, what is the primary purpose of the Third Normal Form (3NF)?",
    "options": [
      "To ensure every column contains atomic values (1NF)",
      "To remove partial dependencies of non-prime attributes on candidate keys (2NF)",
      "To remove transitive dependencies of non-prime attributes on the primary key",
      "To allow duplication of data to improve read performance"
    ],
    "answer": "To remove transitive dependencies of non-prime attributes on the primary key",
    "explanation": "Third Normal Form (3NF) requires that a table be in 2NF and that there be no transitive dependenciesâ€”meaning non-key columns cannot depend on other non-key columns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "Which SQL feature allows you to pivot rows into columns dynamically based on unique values in a specific column?",
    "options": [
      "GROUP BY",
      "PIVOT",
      "UNION",
      "CROSS TAB"
    ],
    "answer": "PIVOT",
    "explanation": "The `PIVOT` operator (available in SQL Server, Oracle with syntax variations) allows you to rotate unique values from a single column into multiple columns in the output, effectively aggregating and pivoting data for reporting.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the key difference between a `UNIQUE` constraint and a `PRIMARY KEY` constraint?",
    "options": [
      "A `UNIQUE` constraint allows only one NULL value; a `PRIMARY KEY` does not allow NULLs",
      "A `UNIQUE` constraint creates an index automatically, but `PRIMARY KEY` does not",
      "A `PRIMARY KEY` allows multiple NULL values; `UNIQUE` does not",
      "There is no difference; they are synonyms"
    ],
    "answer": "A `UNIQUE` constraint allows only one NULL value; a `PRIMARY KEY` does not allow NULLs",
    "explanation": "Both enforce uniqueness. The main difference is that a table can have only one `PRIMARY KEY` (which enforces entity integrity and cannot be NULL), whereas a table can have multiple `UNIQUE` constraints (which typically allow one NULL, depending on the RDBMS).",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the purpose of the `ISNULL` function (SQL Server) or `IFNULL` (MySQL)?",
    "options": [
      "To check if a value is NULL and return 0",
      "To check if a value is NULL and return a specific replacement value",
      "To convert a NULL to a boolean TRUE",
      "To delete rows containing NULL values"
    ],
    "answer": "To check if a value is NULL and return a specific replacement value",
    "explanation": "These functions take two arguments: the expression to check and the replacement value to use if the expression evaluates to NULL. It is functionally similar to `COALESCE` with two arguments.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "In a Composite Index (ColA, ColB), why is searching by `WHERE ColB = 'value'` generally inefficient?",
    "options": [
      "The index stores data sorted by ColA first; skipping ColA prevents the B-Tree from efficiently narrowing down the search",
      "ColB is not included in the index definition",
      "The index is automatically disabled",
      "Databases do not support searching on the second column of an index"
    ],
    "answer": "The index stores data sorted by ColA first; skipping ColA prevents the B-Tree from efficiently narrowing down the search",
    "explanation": "B-Tree indexes are sorted lexicographically by the defined column order. Searching on the second column (`ColB`) without filtering on the first (`ColA`) generally requires a full index scan because the sorted order of `ColB` is scrambled within distinct values of `ColA`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What does the `NATURAL JOIN` syntax do implicitly?",
    "options": [
      "It performs a cross join and filters by row number",
      "It joins two tables based on all columns with the same name in both tables",
      "It joins two tables only if they have a primary key-foreign key relationship defined",
      "It performs a left join on the first matching column"
    ],
    "answer": "It joins two tables based on all columns with the same name in both tables",
    "explanation": "`NATURAL JOIN` automatically identifies columns with identical names in the joined tables and applies an equijoin on them. This is generally discouraged in production because schema changes can silently break queries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "When would you use the `MERGE` statement (also known as `UPSERT`)?",
    "options": [
      "To permanently delete data from two tables simultaneously",
      "To conditionally insert, update, or delete rows in a target table based on the results of a join with a source",
      "To combine the results of two queries into a single result set",
      "To optimize the storage of the database file"
    ],
    "answer": "To conditionally insert, update, or delete rows in a target table based on the results of a join with a source",
    "explanation": "The `MERGE` statement allows you to synchronize two tables by performing an `UPDATE` if a row exists and an `INSERT` if it does not (and optionally a `DELETE`), all in a single atomic operation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "In the context of Window Functions, what is the specific difference between the `RANK()` and `DENSE_RANK()` functions when identical values are present?",
    "options": [
      "`RANK()` assigns a unique number to every row, while `DENSE_RANK()` skips numbers for ties.",
      "`RANK()` leaves gaps in the ranking sequence after ties, while `DENSE_RANK()` does not leave gaps.",
      "`RANK()` sorts the partition randomly for ties, while `DENSE_RANK()` preserves input order.",
      "`RANK()` returns 0 for the first row, while `DENSE_RANK()` returns 1."
    ],
    "answer": "`RANK()` leaves gaps in the ranking sequence after ties, while `DENSE_RANK()` does not leave gaps.",
    "explanation": "If two rows tie for rank 1, `RANK()` assigns the next row rank 3 (creating a gap), whereas `DENSE_RANK()` assigns the next row rank 2 (no gap).",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "When optimizing a composite B-Tree index on columns (A, B, C), which query scenario is guaranteed to utilize the index for seeking data?",
    "options": [
      "WHERE A = 1 OR B = 2",
      "WHERE B = 2 AND C = 3",
      "WHERE C = 3 ORDER BY A",
      "WHERE A = 1 AND B > 2 ORDER BY C"
    ],
    "answer": "WHERE A = 1 AND B > 2 ORDER BY C",
    "explanation": "B-Tree indexes require the leftmost columns (leading columns) to be used for equality or range constraints to perform an index seek. Options lacking 'A' cannot effectively use the index structure for traversal.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "What is the primary purpose of the `WITH (HOLDLOCK)` table hint in SQL Server (equivalent to `SERIALIZABLE` in standard SQL)?",
    "options": [
      "It prevents shared locks from being taken, forcing exclusive locks immediately.",
      "It holds a shared lock until the transaction completes, preventing phantom reads.",
      "It tells the optimizer to ignore the index and use a table scan.",
      "It allows dirty reads to improve performance."
    ],
    "answer": "It holds a shared lock until the transaction completes, preventing phantom reads.",
    "explanation": "`HOLDLOCK` ensures that the locked range cannot be modified by other transactions until the transaction finishes, effectively enforcing serializable isolation and preventing phantoms.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In a Recursive Common Table Expression (CTE), what clause is strictly required to terminate the recursion and prevent infinite loops?",
    "options": [
      "The `UNION` operator",
      "The `UNION ALL` operator with a termination condition in the WHERE clause",
      "The `LIMIT` clause",
      "The `CYCLE` clause"
    ],
    "answer": "The `UNION ALL` operator with a termination condition in the WHERE clause",
    "explanation": "The recursive member must reference the CTE itself and include a `WHERE` clause (or explicit `CYCLE` syntax) that eventually evaluates to false; otherwise, the recursion continues indefinitely.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which join algorithm is generally most efficient when joining two large, unsorted datasets with no available indexes on the join columns?",
    "options": [
      "Nested Loop Join",
      "Hash Join",
      "Merge Join",
      "Adaptive Join"
    ],
    "answer": "Hash Join",
    "explanation": "The Hash Join builds a hash table in memory for the smaller input and probes it with the larger input, which is typically faster than sorting both inputs (Merge Join) or performing row-by-row lookups (Nested Loop) for large unsorted data.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is the 'Write Skew' anomaly, and at which isolation level is it strictly prevented?",
    "options": [
      "Two transactions update the same row, leading to a deadlock; prevented by Read Committed.",
      "Two transactions read overlapping data sets and make disjoint updates that, when combined, violate a constraint; prevented by Serializable.",
      "A transaction reads uncommitted data from another transaction; prevented by Repeatable Read.",
      "Data is modified within a read-only transaction; prevented by Snapshot Isolation."
    ],
    "answer": "Two transactions read overlapping data sets and make disjoint updates that, when combined, violate a constraint; prevented by Serializable.",
    "explanation": "Write Skew occurs in Snapshot Isolation (and lower levels) where two transactions operate on disjoint sets of data based on a shared predicate; Serializable isolation is required to detect and prevent this.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "When analyzing an execution plan, what does the 'Key Lookup' operator indicate?",
    "options": [
      "The query is performing a Clustered Index Seek to retrieve columns not present in the Non-Clustered Index.",
      "The query is searching for a foreign key constraint violation.",
      "The query is using a brute-force search through the entire table.",
      "The database engine is looking up statistics to determine the cardinality."
    ],
    "answer": "The query is performing a Clustered Index Seek to retrieve columns not present in the Non-Clustered Index.",
    "explanation": "A Key Lookup (or RID Lookup in heaps) occurs when a non-clustered index covers the search criteria but not the selected columns, requiring a round-trip to the base table to fetch the missing data.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the specific behavior of the `REPEATABLE READ` isolation level regarding 'Phantom Reads'?",
    "options": [
      "It prevents Phantom Reads by placing range locks.",
      "It allows Phantom Reads because it only locks the rows currently read, not the range.",
      "It prevents Phantom Reads using Multiversion Concurrency Control (MVCC) only.",
      "It prevents Phantom Reads by escalating all locks to the table level immediately."
    ],
    "answer": "It allows Phantom Reads because it only locks the rows currently read, not the range.",
    "explanation": "`REPEATABLE READ` guarantees that if you re-read a row you retrieved, the data hasn't changed, but it does not prevent new rows (phantoms) from appearing in the range on a subsequent read.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "In PostgreSQL, what is the main distinction between the `EXPLAIN` and `EXPLAIN ANALYZE` commands?",
    "options": [
      "`EXPLAIN` shows the logical plan, while `EXPLAIN ANALYZE` shows the physical plan.",
      "`EXPLAIN` estimates costs based on statistics, while `EXPLAIN ANALYZE` actually executes the query and returns actual timing.",
      "`EXPLAIN` requires Superuser privileges, while `EXPLAIN ANALYZE` does not.",
      "`EXPLAIN` works for DML statements, while `EXPLAIN ANALYZE` only works for SELECT."
    ],
    "answer": "`EXPLAIN` estimates costs based on statistics, while `EXPLAIN ANALYZE` actually executes the query and returns actual timing.",
    "explanation": "`EXPLAIN ANALYZE` runs the statement (so be careful with INSERT/UPDATE) and records real-time performance metrics, whereas `EXPLAIN` only predicts planner estimates.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which of the following SQL techniques effectively addresses the 'N+1 select problem' in an application context?",
    "options": [
      "Using a subquery in the SELECT clause",
      "Using a `LEFT JOIN` to fetch related data in a single query",
      "Adding `OPTION (RECOMPILE)` to the inner query",
      "Increasing the `SET NOCOUNT` setting"
    ],
    "answer": "Using a `LEFT JOIN` to fetch related data in a single query",
    "explanation": "The N+1 problem occurs when executing one query to fetch a list of N items and then N separate queries to fetch details for each. A `JOIN` retrieves all necessary data in a single round-trip.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the computational complexity of searching for a record in a standard B-Tree index?",
    "options": [
      "O(1)",
      "O(N)",
      "O(log N)",
      "O(N log N)"
    ],
    "answer": "O(log N)",
    "explanation": "B-Trees are balanced tree structures; each step down the tree halves the remaining search space, resulting in logarithmic time complexity relative to the number of rows.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "In the context of columnstore indexing, what is a primary benefit of the 'Segment elimination' optimization?",
    "options": [
      "It eliminates duplicate rows within the column store.",
      "It skips reading entire row groups (segments) if the `min/max` metadata values do not match the query predicate.",
      "It removes columns from the select list that are not accessed.",
      "It eliminates the need for a Clustered Index."
    ],
    "answer": "It skips reading entire row groups (segments) if the `min/max` metadata values do not match the query predicate.",
    "explanation": "Columnstores store metadata about the minimum and maximum values in each segment. If a filter predicate falls outside this range, the entire segment is skipped from I/O.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does the `CUBE()` grouping set extension differ from the `ROLLUP()` extension?",
    "options": [
      "`CUBE()` generates subtotals for all combinations of the specified columns, while `ROLLUP()` only generates hierarchical subtotals.",
      "`ROLLUP()` generates all combinations, while `CUBE()` only generates hierarchical totals.",
      "`CUBE()` requires an `ORDER BY` clause, while `ROLLUP()` does not.",
      "There is no difference; they are synonyms in the SQL standard."
    ],
    "answer": "`CUBE()` generates subtotals for all combinations of the specified columns, while `ROLLUP()` only generates hierarchical subtotals.",
    "explanation": "`ROLLUP` assumes a hierarchy (e.g., Year -> Month -> Day) and creates subtotals for that specific path. `CUBE` creates subtotals for every permutation of dimensions (e.g., Year/Month, Year/Day, Month/Day).",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the function of a 'Covering Index'?",
    "options": [
      "It includes all columns of the table in the index structure.",
      "It contains all columns referenced by a specific query (SELECT, JOIN, WHERE) in its leaf nodes, avoiding table lookups.",
      "It covers multiple tables in a single index structure.",
      "It encrypts the index data for security purposes."
    ],
    "answer": "It contains all columns referenced by a specific query (SELECT, JOIN, WHERE) in its leaf nodes, avoiding table lookups.",
    "explanation": "A covering index allows the query processor to satisfy the request purely from the index structure (Index Only Scan), which is much faster than accessing the data pages (Heap/Clustered Index).",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "In the context of SQL constraints, what does 'ON DELETE SET NULL' imply?",
    "options": [
      "The delete operation is blocked if child rows exist.",
      "The foreign key columns in the child table are set to NULL when the parent row is deleted.",
      "The parent row is set to NULL and the child row is deleted.",
      "The child rows are automatically deleted."
    ],
    "answer": "The foreign key columns in the child table are set to NULL when the parent row is deleted.",
    "explanation": "This referential action ensures that if a referenced parent row is deleted, the foreign key field in the child records is updated to NULL, preserving the child records while breaking the link.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is a 'Partial Index' (or Filtered Index)?",
    "options": [
      "An index that has not yet finished building.",
      "An index that contains only a subset of rows based on a predicate (e.g., WHERE status = 'active').",
      "An index that only indexes the first N characters of a text column.",
      "An index that is unique but allows multiple NULL values."
    ],
    "answer": "An index that contains only a subset of rows based on a predicate (e.g., WHERE status = 'active').",
    "explanation": "Partial indexes are smaller and faster because they ignore rows that are never queried (e.g., inactive users), reducing index maintenance and storage costs.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which of the following describes 'Parameter Sniffing'?",
    "options": [
      "The database detects a SQL injection attempt.",
      "The optimizer uses the specific parameter values of the first execution to generate a plan, which might be suboptimal for other values.",
      "The query engine sniffs the network packets to intercept parameters.",
      "The optimizer creates a generic plan that ignores all parameter histograms."
    ],
    "answer": "The optimizer uses the specific parameter values of the first execution to generate a plan, which might be suboptimal for other values.",
    "explanation": "Parameter sniffing boosts performance by tailoring the plan to the initial inputs, but it can backfire if subsequent calls have data distributions (skew) that differ significantly from the first run.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In a `SELECT` query, why is `SELECT *` generally discouraged in production SQL code?",
    "options": [
      "It retrieves columns in alphabetical order, breaking application logic.",
      "It increases network traffic and breaks application code if the table schema changes (column order/addition).",
      "It prevents the use of the `WHERE` clause.",
      "It forces the database to use a Table Scan even if an index exists."
    ],
    "answer": "It increases network traffic and breaks application code if the table schema changes (column order/addition).",
    "explanation": "Fetching unnecessary columns consumes I/O and memory. Furthermore, hard-coded application logic relying on `SELECT *` often breaks if new columns are added or column order is altered.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What is the result of `NULLIF(1, 1)`?",
    "options": [
      "1",
      "0",
      "NULL",
      "TRUE"
    ],
    "answer": "NULL",
    "explanation": "The `NULLIF` function returns NULL if the two arguments are equal; otherwise, it returns the first argument. Since 1 equals 1, the result is NULL.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What statistical concept is represented by 'Cardinality' in SQL indexing?",
    "options": [
      "The total number of bytes occupied by the index.",
      "The uniqueness of data in a column, calculated as the percentage of unique values relative to total rows.",
      "The relationship between two tables.",
      "The number of pages required to store the index."
    ],
    "answer": "The uniqueness of data in a column, calculated as the percentage of unique values relative to total rows.",
    "explanation": "High cardinality (many unique values like UUIDs) makes an index very selective and efficient; low cardinality (few unique values like 'Gender') often renders an index inefficient.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How does a 'Unique Index' differ from a 'Unique Constraint' (at the physical level)?",
    "options": [
      "A Unique Constraint allows NULLs, while a Unique Index does not.",
      "Functionally, they are nearly identical; a Unique Constraint is implemented by creating a Unique Index behind the scenes.",
      "A Unique Constraint is enforced by the application, while a Unique Index is enforced by the database.",
      "A Unique Constraint can be dropped without dropping the column, but a Unique Index cannot."
    ],
    "answer": "Functionally, they are nearly identical; a Unique Constraint is implemented by creating a Unique Index behind the scenes.",
    "explanation": "While they have logical differences (Constraints are logical objects, Indexes are physical storage structures), the engine enforces constraints by creating the corresponding index.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the primary danger of using 'NOCHECK' to disable a constraint during a bulk data load?",
    "options": [
      "The database will drop the constraint permanently.",
      "The load will fail if the data is already sorted.",
      "The constraint remains untrusted, allowing the optimizer to ignore it, and invalid data may enter the table.",
      "The database file size will grow indefinitely."
    ],
    "answer": "The constraint remains untrusted, allowing the optimizer to ignore it, and invalid data may enter the table.",
    "explanation": "When `NOCHECK` is used, the constraint is marked 'not trusted'. The query optimizer may skip using the index for filtering or joins. Furthermore, the database may now contain violations of that constraint.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "In Window Functions, what is the default frame if no frame clause (`ROWS` or `RANGE`) is specified?",
    "options": [
      "`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`",
      "`ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`",
      "`RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`",
      "`ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING`"
    ],
    "answer": "`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`",
    "explanation": "According to the SQL standard, the default window frame is from the start of the partition (`UNBOUNDED PRECEDING`) up to and including the current row (`CURRENT ROW`).",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What does the 'Lag' in database replication typically refer to?",
    "options": [
      "The time delay between a transaction committing on the primary node and being applied on the replica node.",
      "The time taken to write a query.",
      "The latency caused by indexing.",
      "The time difference between the oldest and newest transaction in the log."
    ],
    "answer": "The time delay between a transaction committing on the primary node and being applied on the replica node.",
    "explanation": "Replication lag measures how far 'behind' the secondary copy of the data is compared to the primary source, usually measured in time or bytes/transactions.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Which isolation level allows 'Non-Repeatable Reads' but prevents 'Dirty Reads'?",
    "options": [
      "Read Uncommitted",
      "Read Committed",
      "Repeatable Read",
      "Serializable"
    ],
    "answer": "Read Committed",
    "explanation": "`Read Committed` guarantees you only see committed data (no Dirty Reads). However, because it releases locks immediately after a read, data can change if you query again (Non-Repeatable Reads).",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the difference between `TRUNCATE TABLE` and `DELETE FROM Table`?",
    "options": [
      "`TRUNCATE` can be rolled back, but `DELETE` cannot.",
      "`TRUNCATE` cannot use a `WHERE` clause and logs page deallocations rather than row deletions.",
      "`DELETE` resets identity seeds, while `TRUNCATE` does not.",
      "`TRUNCATE` fires triggers, while `DELETE` does not."
    ],
    "answer": "`TRUNCATE` cannot use a `WHERE` clause and logs page deallocations rather than row deletions.",
    "explanation": "`TRUNCATE` is a DDL operation that removes all rows by deallocating data pages, making it faster and logging less than DML `DELETE`, which logs every row deletion.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "In the context of `GROUP BY`, what does the SQL extension `GROUPING SETS` allow you to do?",
    "options": [
      "Filter groups after aggregation.",
      "Define multiple groupings in a single query pass, calculating totals for different dimensions simultaneously.",
      "Sort the groups in ascending order.",
      "Combine groups from different tables."
    ],
    "answer": "Define multiple groupings in a single query pass, calculating totals for different dimensions simultaneously.",
    "explanation": "`GROUPING SETS` is an extension that allows you to compute aggregates for different sets of dimensions in one query, equivalent to the `UNION ALL` of multiple `GROUP BY` queries.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is a 'Sparse Column'?",
    "options": [
      "A column that only contains 0s.",
      "A column optimized for storing NULL values, taking zero storage space when NULL.",
      "A column that is distributed across multiple servers.",
      "A column that is encrypted."
    ],
    "answer": "A column optimized for storing NULL values, taking zero storage space when NULL.",
    "explanation": "Sparse columns are a feature in some SQL databases (like SQL Server) designed to optimize storage for columns that have a high percentage of NULL values.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Which of the following scenarios describes a 'Deadlock' rather than a 'Lock Wait'?",
    "options": [
      "Transaction A holds a lock on Row 1 and waits for Row 2; Transaction B holds Row 2 and waits for Row 1.",
      "Transaction A attempts to update a row locked by Transaction B, and waits for B to finish.",
      "Transaction A is blocked by Transaction B, which is blocked by Transaction C.",
      "A query takes 10 seconds to run because of high concurrency."
    ],
    "answer": "Transaction A holds a lock on Row 1 and waits for Row 2; Transaction B holds Row 2 and waits for Row 1.",
    "explanation": "A deadlock is a cyclic dependency where resources are held by processes waiting on each other. A lock wait is a simple blockage (A waits for B) which resolves when B finishes.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the primary function of the `OVER` clause in SQL window functions?",
    "options": [
      "To filter the results after aggregation.",
      "To define the window (partition and ordering) of rows that the function operates over relative to the current row.",
      "To override the transaction isolation level.",
      "To specify the output format."
    ],
    "answer": "To define the window (partition and ordering) of rows that the function operates over relative to the current row.",
    "explanation": "The `OVER` clause determines which rows belong to the partition (`PARTITION BY`), how they are ordered (`ORDER BY`), and the frame scope, enabling calculations without collapsing rows.",
    "difficulty": "Advanced"
  }
]