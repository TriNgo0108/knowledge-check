[
  {
    "id": 1,
    "question": "What is the primary purpose of the Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "To manage memory allocation on the heap",
      "To prevent multiple native threads from executing Python bytecodes simultaneously",
      "To ensure garbage collection runs in a separate thread",
      "To compile Python code into machine code"
    ],
    "answer": "To prevent multiple native threads from executing Python bytecodes simultaneously",
    "explanation": "The GIL is a mutex that protects access to Python objects, ensuring only one thread executes bytecode at a time. It simplifies memory management (specifically reference counting) but limits parallelism in CPU-bound multi-threaded programs.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which mechanism does Python primarily use to manage memory immediately when an object is no longer referenced?",
    "options": [
      "Generational garbage collection",
      "Reference counting",
      "Manual memory management via `free()`",
      "Mark-and-sweep algorithm"
    ],
    "answer": "Reference counting",
    "explanation": "Python uses reference counting as its primary memory management technique; objects are deallocated immediately when their reference count reaches zero. Generational GC is a secondary mechanism used specifically to clean up circular reference cycles.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "When using `sys.getrefcount(obj)`, why is the returned count often higher than expected (e.g., 2 instead of 1)?",
    "options": [
      "The object is referenced by the `sys` module.",
      "The `sys.getrefcount()` function temporarily adds a reference to the object.",
      "Python creates a backup copy of the object for safety.",
      "The interpreter stores a reference in the `__main__` scope."
    ],
    "answer": "The `sys.getrefcount()` function temporarily adds a reference to the object.",
    "explanation": "When you pass an object to `sys.getrefcount()`, the argument itself creates a new temporary reference to that object. This artificial reference is included in the count returned by the function.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "Which statement accurately describes the behavior of the `del` keyword in Python?",
    "options": [
      "It immediately frees the memory occupied by the object.",
      "It deletes the object from the computer's RAM.",
      "It removes the binding between a variable name and the object, decrementing the reference count.",
      "It calls the garbage collector to force a collection cycle."
    ],
    "answer": "It removes the binding between a variable name and the object, decrementing the reference count.",
    "explanation": "`del` deletes the reference (the name), not the object itself. The actual object is only deallocated by the memory manager if its reference count drops to zero as a result of the deletion.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "In the context of CPython's Garbage Collector (GC), what specific problem does the generational approach solve?",
    "options": [
      "Memory fragmentation due to large object allocations",
      "Performance overhead of scanning long-lived objects repeatedly",
      "Race conditions caused by the GIL",
      "Inefficient reference counting of integers"
    ],
    "answer": "Performance overhead of scanning long-lived objects repeatedly",
    "explanation": "The generational hypothesis assumes that most objects die young. By segregating objects into generations (0, 1, 2), the GC scans the young generation (where garbage is frequent) more often and the old generation (where garbage is rare) less often, optimizing performance.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the result of attempting to perform CPU-bound operations in multiple threads within a standard CPython application?",
    "options": [
      "Performance scales linearly with the number of CPU cores.",
      "The GIL causes threads to run sequentially, offering no performance benefit for CPU-bound tasks.",
      "The program crashes due to concurrent memory access violations.",
      "The operating system automatically switches to multiprocessing."
    ],
    "answer": "The GIL causes threads to run sequentially, offering no performance benefit for CPU-bound tasks.",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time. For CPU-bound tasks, threads compete for the GIL and effectively run sequentially (or with heavy context switching overhead), preventing true parallelism.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which scenario is best suited for using Python's `threading` module rather than `multiprocessing`?",
    "options": [
      "Tasks requiring heavy matrix computations",
      "Waiting for multiple network I/O operations to complete",
      "Rendering 3D graphics",
      "Parsing large JSON files from disk"
    ],
    "answer": "Waiting for multiple network I/O operations to complete",
    "explanation": "The `threading` module is efficient for I/O-bound tasks because the GIL is released while waiting for I/O operations (like network requests), allowing other threads to run. It is inefficient for CPU-bound tasks.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Why is it technically risky to use a mutable object (like an empty list `[]`) as a default argument value in a function definition?",
    "options": [
      "The list cannot be accessed inside the function.",
      "Mutable default arguments are evaluated only once at definition time, causing state persistence across calls.",
      "It causes a `TypeError` when the function is called without arguments.",
      "Python's garbage collector will immediately delete the list."
    ],
    "answer": "Mutable default arguments are evaluated only once at definition time, causing state persistence across calls.",
    "explanation": "Default argument values are evaluated only once when the function is defined. If the value is mutable and modified within the function, the modification persists to subsequent calls, leading to unintended shared state.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What happens when `gc.disable()` is called in a Python script?",
    "options": [
      "Reference counting is disabled, causing memory leaks immediately.",
      "The interpreter stops executing bytecode.",
      "The automatic cyclic garbage collector is disabled, but reference counting remains active.",
      "All existing objects are immediately deallocated."
    ],
    "answer": "The automatic cyclic garbage collector is disabled, but reference counting remains active.",
    "explanation": "Disabling the GC stops the automatic detection and cleanup of *circular references*. Standard memory management via reference counting continues to function normally, handling non-circular references.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which data type is immutable and does not support item assignment?",
    "options": [
      "list",
      "dict",
      "tuple",
      "set"
    ],
    "answer": "tuple",
    "explanation": "Tuples are immutable sequences. Once created, their elements cannot be changed, added, or removed, unlike lists, dictionaries, or sets which are mutable.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the correct syntax for defining a function that accepts an arbitrary number of positional arguments?",
    "options": [
      "def func(*args):",
      "def func(args...):",
      "def func(**args):",
      "def func(&args):"
    ],
    "answer": "def func(*args):",
    "explanation": "The `*args` syntax allows a function to accept any number of extra positional arguments, which are then accessible as a tuple within the function. `**kwargs` is used for keyword arguments.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which operator is used to check if two variables reference the exact same object in memory?",
    "options": [
      "==",
      "=",
      "is",
      "eq()"
    ],
    "answer": "is",
    "explanation": "The `is` operator checks for identity (same memory address), whereas `==` checks for equality (same value). `a is b` returns `True` only if `id(a) == id(b)`.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the behavior of a dictionary key if the key is a mutable type like a list?",
    "options": [
      "The list is automatically converted to a tuple.",
      "It functions as a key but cannot be retrieved later.",
      "A `TypeError` is raised because dictionary keys must be hashable (immutable).",
      "The list is stored by reference, changing the key changes the dictionary."
    ],
    "answer": "A `TypeError` is raised because dictionary keys must be hashable (immutable).",
    "explanation": "Dictionary keys must be hashable. Since mutable objects like lists can change value, their hash would change, violating hash invariants. Therefore, Python raises a `TypeError` when using a list as a key.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "In Python string slicing, what is the result of `'hello'[1:4]`?",
    "options": [
      "'hel'",
      "'ell'",
      "'llo'",
      "'h'"
    ],
    "answer": "'ell'",
    "explanation": "Slicing uses the syntax `[start:stop]`. It includes the start index (1, which is 'e') and excludes the stop index (4, which is 'o'). Thus, characters at indices 1, 2, and 3 are returned.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Which keyword is used as a placeholder inside a compound statement (like a function or loop) to prevent syntax errors when no action is required?",
    "options": [
      "wait",
      "skip",
      "pass",
      "continue"
    ],
    "answer": "pass",
    "explanation": "The `pass` keyword is a null operation; it is syntactically required to indicate 'do nothing'. `continue` is specific to loops to skip to the next iteration.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is the value of the expression `10 % 3` in Python?",
    "options": [
      "3",
      "1",
      "0.33",
      "3.33"
    ],
    "answer": "1",
    "explanation": "The `%` operator is the modulo operator, which returns the remainder of the division. 10 divided by 3 is 3 with a remainder of 1.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "How does the `with` statement (context manager) improve file handling compared to opening a file manually?",
    "options": [
      "It makes the file reading process faster.",
      "It automatically closes the file, even if exceptions occur during processing.",
      "It allows multiple programs to read the file at once.",
      "It converts the file content to JSON automatically."
    ],
    "answer": "It automatically closes the file, even if exceptions occur during processing.",
    "explanation": "The `with` statement guarantees that the file's `__exit__` method is called, ensuring the file is properly closed. This handles resource cleanup automatically, preventing memory leaks or file locks.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "Which exception is raised when an indentation is incorrect in Python?",
    "options": [
      "SyntaxError",
      "IndentationError",
      "TabError",
      "AlignmentError"
    ],
    "answer": "IndentationError",
    "explanation": "Python uses whitespace for structuring. Incorrect mixing of tabs and spaces or inconsistent levels raises an `IndentationError`, which is a subclass of `SyntaxError`.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What distinguishes a `set` from a `list` in Python?",
    "options": [
      "Sets are ordered and allow duplicates.",
      "Sets are unordered and do not allow duplicate elements.",
      "Sets can only contain strings.",
      "Sets are immutable."
    ],
    "answer": "Sets are unordered and do not allow duplicate elements.",
    "explanation": "Sets are unordered collections of unique hashable elements. Lists are ordered sequences that allow duplicates and are defined with square brackets.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the scope of a variable defined inside a function without the `global` keyword?",
    "options": [
      "Global scope",
      "Local scope",
      "Built-in scope",
      "Module scope"
    ],
    "answer": "Local scope",
    "explanation": "Variables assigned inside a function are local to that function by default. They cease to exist when the function returns unless declared `global` or `nonlocal`.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "Which built-in function returns the type of an object?",
    "options": [
      "type()",
      "class()",
      "typeof()",
      "instance()"
    ],
    "answer": "type()",
    "explanation": "The `type()` function returns the class type of the object passed to it. This is distinct from `isinstance()`, which checks for inheritance.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "In a `try...except` block, what ensures that a specific piece of code executes regardless of whether an exception occurred?",
    "options": [
      "else",
      "finally",
      "raise",
      "ensure"
    ],
    "answer": "finally",
    "explanation": "The `finally` block is always executed after the `try` (and any `except`) blocks complete, ensuring cleanup code runs even if an error is raised or the function returns.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which module is used to create shallow or deep copies of objects?",
    "options": [
      "copy",
      "duplicate",
      "clone",
      "memcopy"
    ],
    "answer": "copy",
    "explanation": "The `copy` module provides `copy()` for shallow copies and `deepcopy()` for deep copies. Simple assignment (`=`) in Python creates a reference, not a copy.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the output of `bool([])`?",
    "options": [
      "True",
      "False",
      "None",
      "[]"
    ],
    "answer": "False",
    "explanation": "In Python, empty sequences (lists, tuples, strings) and collections (dictionaries, sets) evaluate to `False` in a boolean context. Non-empty containers evaluate to `True`.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "Which syntax is used to unpack elements from a list directly into function arguments?",
    "options": [
      "func(*my_list)",
      "func(&my_list)",
      "func(@my_list)",
      "func(my_list...)"
    ],
    "answer": "func(*my_list)",
    "explanation": "The `*` operator unpacks an iterable into positional arguments. If `my_list = [1, 2]`, then `func(*my_list)` is equivalent to `func(1, 2)`.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is the purpose of the `__init__` method in a Python class?",
    "options": [
      "To initialize the class instance attributes immediately after the object is created.",
      "To construct the object instance in memory.",
      "To destroy the object when it is deleted.",
      "To define string representation for print()."
    ],
    "answer": "To initialize the class instance attributes immediately after the object is created.",
    "explanation": "`__init__` is the initializer (often incorrectly called the constructor). It receives the newly created object (`self`) and sets up its initial state. `__new__` is the actual constructor.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "Which keyword is used to define a generator function instead of a standard function?",
    "options": [
      "return",
      "yield",
      "generate",
      "stream"
    ],
    "answer": "yield",
    "explanation": "Using `yield` inside a function turns it into a generator. When called, it returns an iterator that produces values one at a time using `yield`, pausing state between each value.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "How do you define a docstring for a function?",
    "options": [
      "Using the `#` comment syntax on the first line",
      "Using a string literal as the first statement in the function body",
      "Using the `__doc__` attribute assignment outside the function",
      "Using the `/* */` syntax"
    ],
    "answer": "Using a string literal as the first statement in the function body",
    "explanation": "A docstring is a string literal (triple-quoted usually) that occurs as the first statement in a module, function, class, or method definition. It becomes the `__doc__` attribute.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which statement allows you to import a module `math` and access it using a specific alias `m`?",
    "options": [
      "import math as m",
      "include math as m",
      "import math = m",
      "module math as m"
    ],
    "answer": "import math as m",
    "explanation": "The `import ... as ...` syntax allows you to bind the imported module to a different identifier (alias) in the local scope.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the result of `['a', 'b', 'c'][::-1]`?",
    "options": [
      "['a', 'b', 'c']",
      "['c', 'b', 'a']",
      "['c']",
      "[]"
    ],
    "answer": "['c', 'b', 'a']",
    "explanation": "The slice notation `[start:stop:step]` with a step of `-1` reverses the sequence. This is a common Python idiom for creating a reversed copy of a list.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "Which exception is raised when accessing a dictionary key that does not exist?",
    "options": [
      "ValueError",
      "IndexError",
      "KeyError",
      "LookupError"
    ],
    "answer": "KeyError",
    "explanation": "Attempting to access a non-existent key via `d[key]` raises a `KeyError`. `IndexError` applies to lists/tuples, while `ValueError` applies to incorrect type values. Using `d.get(key)` avoids this.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the concept of 'Duck Typing' in Python?",
    "options": [
      "Enforcing strict type checking at compile time.",
      "Checking if an object is an instance of a specific class before method execution.",
      "Ignoring an object's actual type and focusing on whether it can perform the required behavior.",
      "Using type hints for all function arguments."
    ],
    "answer": "Ignoring an object's actual type and focusing on whether it can perform the required behavior.",
    "explanation": "Duck typing means: 'If it walks like a duck and quacks like a duck, it's a duck.' Python cares about methods/properties available on the object, not its specific class hierarchy.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "Which comparison operator checks if a value is contained within a sequence?",
    "options": [
      "in",
      "contains",
      "has",
      "inside"
    ],
    "answer": "in",
    "explanation": "The `in` operator is a membership test that returns `True` if the specified value is found in the sequence (list, string, tuple, set, etc.).",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is the function of the `super()` keyword in a class?",
    "options": [
      "To call the parent class's method",
      "To initialize the child class",
      "To convert an object to a superclass type",
      "To access the global scope"
    ],
    "answer": "To call the parent class's method",
    "explanation": "`super()` returns a proxy object that delegates method calls to a parent or sibling class. It is commonly used in `__init__` to ensure the parent is initialized correctly.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "Which command line flag is used with the Python interpreter to run a single command string?",
    "options": [
      "-c",
      "-r",
      "-e",
      "-x"
    ],
    "answer": "-c",
    "explanation": "The `-c` option (`python -c \"print('hi')\"`) executes the Python code passed as a string. This is distinct from running a script file (`python script.py`).",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is the primary reason the CPython interpreter uses the Global Interpreter Lock (GIL)?",
    "options": [
      "To prevent race conditions within the CPython memory management code",
      "To ensure that Python bytecode executes on multiple CPU cores simultaneously",
      "To enforce strict thread priority ordering in the operating system scheduler",
      "To prevent deadlocks in user-level application code"
    ],
    "answer": "To prevent race conditions within the CPython memory management code",
    "explanation": "CPython's memory management relies on reference counting, which is not thread-safe. The GIL acts as a mutex to ensure only one thread executes Python bytecode at a time, protecting internal object state. It effectively prevents parallelism on multi-core systems for CPU-bound tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "Which specific scenario causes Python's reference counting mechanism to fail, necessitating the cyclic garbage collector?",
    "options": [
      "When an object is referenced by multiple threads simultaneously",
      "When a reference count reaches zero but the object is still in use",
      "When a circular reference exists between container objects containing `__del__` methods",
      "When objects are allocated in a fixed-size memory block (arena)"
    ],
    "answer": "When a circular reference exists between container objects containing `__del__` methods",
    "explanation": "Reference counting fails to reclaim memory if objects reference each other (forming a cycle), as their reference counts never drop to zero. The generational garbage collector is required to detect and break these reference cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When examining reference counts using `sys.getrefcount(obj)`, why is the returned value often higher than expected?",
    "options": [
      "The function creates a temporary copy of the object",
      "The object is passed as an argument to the function, creating a temporary reference",
      "The function includes references from the garbage collector's internal tracking",
      "The object is automatically interned by the interpreter"
    ],
    "answer": "The object is passed as an argument to the function, creating a temporary reference",
    "explanation": "When `obj` is passed to `sys.getrefcount`, the function call itself creates a new reference to the object on the stack. Consequently, the returned count is always one higher than the count existing at the call site.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is the function of the `gc.set_threshold(threshold0, threshold1, threshold2)` method?",
    "options": [
      "It sets the maximum memory limit in bytes before a MemoryError is raised",
      "It configures the frequency of garbage collection based on object allocation counts across generations",
      "It defines the number of worker threads used for parallel garbage collection",
      "It adjusts the reference counting trigger for immediate object deallocation"
    ],
    "answer": "It configures the frequency of garbage collection based on object allocation counts across generations",
    "explanation": "The thresholds determine how often the generational collector runs. Collection triggers when the number of new allocations exceeds `threshold0` (Gen 0) or based on cumulative counts for older generations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "How does defining `__slots__` in a class improve memory usage?",
    "options": [
      "It replaces the instance dictionary with a fixed-size structure, preventing the creation of `__dict__`",
      "It moves all instance variables to stack memory instead of heap memory",
      "It automatically enables weak references for all instance attributes",
      "It compresses the object's bytecode to reduce disk footprint"
    ],
    "answer": "It replaces the instance dictionary with a fixed-size structure, preventing the creation of `__dict__`",
    "explanation": "By default, instances store attributes in a dynamic `__dict__`, which consumes significant memory. `__slots__` reserves a fixed amount of space for specific attributes, eliminating the overhead of the per-instance dictionary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In the context of Python's Generational Garbage Collection, what happens to an object during a collection cycle if it survives?",
    "options": [
      "It is immediately moved to a 'permanent' generation that is never collected",
      "It is promoted to an older generation (e.g., from Gen 0 to Gen 1)",
      "Its reference count is permanently decremented to speed up future deletion",
      "It is deep-copied to a new memory location to optimize cache locality"
    ],
    "answer": "It is promoted to an older generation (e.g., from Gen 0 to Gen 1)",
    "explanation": "Python assumes that older objects live longer. Surviving collection in the young generation (Gen 0) promotes the object to an older generation (Gen 1, then Gen 2), which is scanned less frequently to optimize performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the primary use case for `weakref` modules in Python?",
    "options": [
      "To create shallow copies of complex nested objects",
      "To maintain a reference to an object without preventing its garbage collection",
      "To enforce type checking at runtime for function arguments",
      "To allow a function to modify variables in an enclosing scope"
    ],
    "answer": "To maintain a reference to an object without preventing its garbage collection",
    "explanation": "A weak reference allows a program to access an object but does not increase its reference count. If all strong references are removed, the garbage collector can reclaim the object, and the weak reference returns None or becomes dead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "Why is CPU-bound task performance often worse with multithreading in CPython compared to multiprocessing?",
    "options": [
      "Processes have lower overhead than threads when sharing memory",
      "The GIL prevents multiple threads from executing Python bytecode in parallel on multiple cores",
      "Threads cannot access the CPU cache, whereas processes can",
      "The operating system scheduler does not support Python threads"
    ],
    "answer": "The GIL prevents multiple threads from executing Python bytecode in parallel on multiple cores",
    "explanation": "The GIL ensures only one thread runs Python bytecode at a time. In CPU-bound tasks, threads compete for the GIL and effectively run serially, incurring context switching overhead without parallelism. Multiprocessing bypasses the GIL by using separate memory spaces.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which of the following statements is true regarding the `__del__` special method?",
    "options": [
      "It is called immediately when the reference count of an object reaches zero",
      "It is guaranteed to be called when the interpreter exits, preventing object leaks",
      "It is called when an object is about to be destroyed, but timing is not guaranteed for circular references",
      "It is used to define the behavior of the `del` keyword on module-level variables"
    ],
    "answer": "It is called when an object is about to be destroyed, but timing is not guaranteed for circular references",
    "explanation": "`__del__` is a finalizer. While called upon reclamation, objects involved in reference cycles may not have `__del__` called if the garbage collector cannot safely break the cycles.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the effect of using `with` statements (Context Managers) on resource management?",
    "options": [
      "They automatically increase the priority of the thread to prevent preemption",
      "They ensure that acquisition and release methods are called even if an exception occurs",
      "They convert synchronous I/O operations into asynchronous operations",
      "They disable the garbage collector temporarily to improve speed"
    ],
    "answer": "They ensure that acquisition and release methods are called even if an exception occurs",
    "explanation": "Context Managers utilize `__enter__` and `__exit__` methods. The `__exit__` method is guaranteed to run after the block, even if errors are raised, ensuring resources (like file handles or locks) are properly cleaned up.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "How does `super()` function in Python's Method Resolution Order (MRO) under multiple inheritance?",
    "options": [
      "It calls the method in the first parent class listed in the class definition",
      "It delegates to the next class in the C3 linearization MRO chain, not just the parent",
      "It searches the entire class hierarchy for the first matching method regardless of depth",
      "It bypasses the current class and calls the method on `object` directly"
    ],
    "answer": "It delegates to the next class in the C3 linearization MRO chain, not just the parent",
    "explanation": "In MRO, `super()` does not simply look at the immediate parent. It looks at the computed MRO list (C3 linearization) and finds the class next in line, ensuring a consistent and monotonic method lookup path in complex inheritance graphs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the purpose of the `__new__` method compared to `__init__`?",
    "options": [
      "`__new__` initializes the object's attributes after creation",
      "`__new__` is a static method responsible for creating and returning the instance, while `__init__` initializes it",
      "`__init__` creates the object, while `__new__` destroys it",
      "`__new__` is called automatically every time an attribute is accessed"
    ],
    "answer": "`__new__` is a static method responsible for creating and returning the instance, while `__init__` initializes it",
    "explanation": "`__new__` controls the actual creation of the object (memory allocation) and returns the instance. `__init__` receives the created instance to set initial attribute values. `__new__` is used for immutable types or singletons.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "Why are mutable default arguments (e.g., `def foo(l=[]):`) considered a dangerous practice in Python?",
    "options": [
      "They cause a syntax error in Python 3.x interpreters",
      "The default list is evaluated once at definition time, so subsequent calls share the same mutable object",
      "They prevent the function from being imported into other modules",
      "Mutable objects cannot be passed as keyword arguments"
    ],
    "answer": "The default list is evaluated once at definition time, so subsequent calls share the same mutable object",
    "explanation": "Default argument values are evaluated only once when the function is defined. If the default is mutable and modified inside the function, the modification persists across future calls to the same function.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "In Python's implementation of garbage collection, what are 'container objects'?",
    "options": [
      "Objects that strictly contain primitive types like integers and floats",
      "Objects that can hold references to other objects (like lists, dicts, custom class instances)",
      "Objects allocated within the stack frame of the main thread",
      "Objects managed by the operating system rather than the interpreter"
    ],
    "answer": "Objects that can hold references to other objects (like lists, dicts, custom class instances)",
    "explanation": "The cyclic garbage collector specifically tracks container objects (tuples, lists, dicts, classes) because only they can participate in reference cycles. Simple types like integers or strings (which cannot reference other objects) are ignored by the cycle detector.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What happens during the 'Mark' phase of Python's mark-and-sweep garbage collection algorithm?",
    "options": [
      "All objects in generation 0 are immediately deallocated",
      "The interpreter traverses reachable objects from roots, tagging them as live",
      "The memory is defragmented to improve allocation speed",
      "The reference counts of all objects are reset to zero"
    ],
    "answer": "The interpreter traverses reachable objects from roots, tagging them as live",
    "explanation": "The Mark phase identifies live objects by starting from 'root' objects (like global variables and stack frames) and following references. Any object not reached (tagged) during this phase is considered garbage in the subsequent Sweep phase.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the difference between `is` and `==` in Python?",
    "options": [
      "`is` checks for value equality, `==` checks for memory address",
      "`is` checks for object identity (memory address), `==` checks for value equality",
      "`is` is used for integers, `==` is used for strings",
      "There is no difference; they are aliases for the same operation"
    ],
    "answer": "`is` checks for object identity (memory address), `==` checks for value equality",
    "explanation": "`is` operator compares the `id()` of two objects to see if they are the exact same object in memory. `==` calls the object's `__eq__` method to compare the logical content or value.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "Why does the GIL usually release the lock during I/O operations?",
    "options": [
      "To allow other threads to perform CPU-intensive calculations while waiting for I/O",
      "To force the operating system to flush the disk buffers",
      "To prevent network packets from being corrupted",
      "To allow the garbage collector to run exclusively"
    ],
    "answer": "To allow other threads to perform CPU-intensive calculations while waiting for I/O",
    "explanation": "Since threads cannot run in parallel due to the GIL, releasing the lock during I/O (waiting for disk/network) is crucial. This allows other threads to acquire the GIL and execute bytecode, improving concurrency for I/O-bound tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "How does `copy.deepcopy()` differ from `copy.copy()` (shallow copy)?",
    "options": [
      "Shallow copy creates a new object but inserts references to the original nested objects; deep copy creates recursive copies",
      "Deep copy only works on primitive data types like integers",
      "Shallow copy performs a memory dump of the entire process",
      "Deep copy modifies the original object to increase reference counts"
    ],
    "answer": "Shallow copy creates a new object but inserts references to the original nested objects; deep copy creates recursive copies",
    "explanation": "A shallow copy constructs a new compound object and then inserts references into it to the objects found in the original. A deep copy constructs a new compound object and then recursively inserts copies into it of the objects found in the original.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What is the purpose of the `DISCARD` opcode in the Python bytecode execution model?",
    "options": [
      "To remove the top item from the evaluation stack",
      "To delete a variable from the global namespace",
      "To stop the execution of the current frame",
      "To clear the garbage collector's cache"
    ],
    "answer": "To remove the top item from the evaluation stack",
    "explanation": "Python is a stack-based virtual machine. `DISCARD` pops the top value off the stack (often the result of an expression or function call that isn't being assigned) and discards it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "In the context of `asyncio`, what must a coroutine do to allow other tasks to run?",
    "options": [
      "It must explicitly call `time.sleep()`",
      "It must contain an `await` expression that yields control back to the event loop",
      "It must be decorated with `@thread_safe`",
      "It must be defined using the `async def` syntax only, without any internal calls"
    ],
    "answer": "It must contain an `await` expression that yields control back to the event loop",
    "explanation": "The asyncio event loop is cooperative. A coroutine runs until it hits an `await` keyword on an awaitable object (like an I/O operation), at which point it yields control, allowing the event loop to schedule other pending tasks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "What mechanism does CPython use to optimize memory allocation for small integers and strings?",
    "options": [
      "Reference counting only",
      "Interning (caching) frequently used immutable objects",
      "Direct memory access bypassing the OS heap",
      "Automated swapping to disk when memory is full"
    ],
    "answer": "Interning (caching) frequently used immutable objects",
    "explanation": "CPython interns (caches) small integers (-5 to 256) and short strings. This ensures that references to these values point to the same pre-allocated object in memory, saving memory and speeding up comparisons.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is name mangling in Python classes, and how does it work?",
    "options": [
      "It converts public methods to private methods automatically",
      "It prefixes identifiers starting with `__` (but not ending with `__`) with `_ClassName` to make them unique to the class",
      "It obfuscates all class attributes to prevent reverse engineering",
      "It removes double underscores from variable names to save memory"
    ],
    "answer": "It prefixes identifiers starting with `__` (but not ending with `__`) with `_ClassName` to make them unique to the class",
    "explanation": "Name mangling is a mechanism to make class variables 'private'. Any identifier like `__var` is textually replaced with `_ClassName__var`, preventing accidental collision with names in superclasses or subclasses.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "What is a 'closure' in Python?",
    "options": [
      "A function that has no access to global variables",
      "A function object that remembers values in enclosing scopes even if they are not present in memory",
      "A method used to close open file handles",
      "A specific type of exception raised when a loop terminates"
    ],
    "answer": "A function object that remembers values in enclosing scopes even if they are not present in memory",
    "explanation": "A closure occurs when a nested function references a value from its enclosing scope. The function object retains a reference to the variables in the enclosing scope, allowing them to be accessed after the outer function has finished execution.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which of the following best describes the behavior of a generator expression?",
    "options": [
      "It computes all values immediately and stores them in a list",
      "It produces values lazily one at a time as they are requested",
      "It can only be iterated over once before being exhausted",
      "It automatically enables multithreading for the loop"
    ],
    "answer": "It produces values lazily one at a time as they are requested",
    "explanation": "Generator expressions use lazy evaluation. They yield items one by one only when the iteration requests them, rather than materializing the entire sequence in memory upfront like a list comprehension.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "What is the purpose of the `nonlocal` keyword?",
    "options": [
      "To declare a variable that is not local to the function, but resides in an enclosing (non-global) scope",
      "To import a module from a non-standard library path",
      "To delete a variable from the local namespace",
      "To prevent a variable from being modified by threads"
    ],
    "answer": "To declare a variable that is not local to the function, but resides in an enclosing (non-global) scope",
    "explanation": "`nonlocal` allows a nested function to assign a value to a variable defined in the scope of the enclosing function. Without it, Python would create a new local variable instead of modifying the outer variable.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "Why is it generally unsafe to mutate a dictionary while iterating over it?",
    "options": [
      "It causes the interpreter to hang indefinitely",
      "It can raise a `RuntimeError` because the internal size of the hash table may change, invalidating the iterator",
      "It converts the dictionary into a list automatically",
      "It triggers the garbage collector immediately"
    ],
    "answer": "It can raise a `RuntimeError` because the internal size of the hash table may change, invalidating the iterator",
    "explanation": "Modifying a collection (adding/deleting items) changes its internal structure or size. Iterators rely on this structure; if it changes during traversal, the iterator loses its place, causing Python to raise a `RuntimeError: dictionary changed size during iteration`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What does the `Global Interpreter Lock (GIL)` specifically prevent in CPython?",
    "options": [
      "Multiple threads from running at all",
      "Multiple native threads from executing Python bytecodes at once",
      "A single thread from utilizing multiple CPU cores",
      "Memory leaks in C-extension modules"
    ],
    "answer": "Multiple native threads from executing Python bytecodes at once",
    "explanation": "The GIL is a mutex that protects access to Python objects. It ensures that only one thread executes Python bytecode at a specific moment, preventing true parallelism of Python code on multi-core machines.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the role of the `sys.modules` dictionary?",
    "options": [
      "It lists all built-in functions available in the interpreter",
      "It acts as a cache for imported modules to prevent reloading",
      "It stores the configuration settings for the Python interpreter",
      "It contains the traceback of the last unhandled exception"
    ],
    "answer": "It acts as a cache for imported modules to prevent reloading",
    "explanation": "When you import a module, Python checks `sys.modules`. If the module is present there, it uses the cached module object instead of re-executing the module file. This ensures that imports are efficient and singletons.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In Python 3, how are function annotations used?",
    "options": [
      "To automatically enforce type checking at runtime",
      "To store metadata about argument and return types in the `__annotations__` attribute",
      "To optimize the bytecode generated by the compiler",
      "To convert the function into a static method"
    ],
    "answer": "To store metadata about argument and return types in the `__annotations__` attribute",
    "explanation": "Annotations (e.g., `def foo(x: int) -> int:`) are purely syntactic metadata stored in a dictionary. Python itself does not enforce them at runtime; they are intended for use by linters, type checkers (like mypy), or frameworks.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the output of `print(True + True + False)` in Python?",
    "options": [
      "True",
      "3",
      "2",
      "TypeError"
    ],
    "answer": "2",
    "explanation": "In Python, `bool` is a subclass of `int`. `True` has an integer value of 1, and `False` has a value of 0. Therefore, arithmetic operations treat them as 1s and 0s.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which data structure is most efficient for checking if an element exists in a large collection of unique items?",
    "options": [
      "list",
      "tuple",
      "set",
      "dict (storing items as keys)"
    ],
    "answer": "set",
    "explanation": "Sets and dictionaries use hash tables, providing average O(1) time complexity for membership testing. Lists and tuples require O(n) iteration to find an element.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What is the `PEP 8` style guide's recommendation for naming constants?",
    "options": [
      "camelCase",
      "snake_case",
      "UPPER_CASE_WITH_UNDERSCORES",
      "UpperCase"
    ],
    "answer": "UPPER_CASE_WITH_UNDERSCORES",
    "explanation": "PEP 8 recommends `UPPER_CASE_WITH_UNDERSCORES` for constants (global variables intended not to be rebound), and `snake_case` for variables and functions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What happens when you import a module inside a function?",
    "options": [
      "The module is imported every time the function is called",
      "The module is imported only on the first call, and subsequent calls use the cached version from `sys.modules`",
      "It raises a syntax error because imports are only allowed at the top level",
      "The module is imported in a separate private namespace"
    ],
    "answer": "The module is imported only on the first call, and subsequent calls use the cached version from `sys.modules`",
    "explanation": "Imports are executed when the statement is reached. The first time the function runs, the module loads and is cached in `sys.modules`. Subsequent calls to the function check the cache and skip the loading overhead.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the result of calling `hash((1, 2))` versus `hash([1, 2])`?",
    "options": [
      "Both return an integer hash value",
      "The tuple returns a hash; the list raises a `TypeError`",
      "The list returns a hash; the tuple raises a `TypeError`",
      "Neither returns a hash because both are mutable"
    ],
    "answer": "The tuple returns a hash; the list raises a `TypeError`",
    "explanation": "Tuples are immutable and hashable (if their contents are hashable). Lists are mutable and do not implement the `__hash__` method, so attempting to hash them raises a `TypeError: unhashable type: 'list'`.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "How does Python resolve attribute access for a class instance (e.g., `obj.attr`)?",
    "options": [
      "It checks the instance dict, then the class dict, then bases (MRO)",
      "It checks the class dict, then the instance dict, then global scope",
      "It checks the instance dict only",
      "It checks the most recently defined parent class first"
    ],
    "answer": "It checks the instance dict, then the class dict, then bases (MRO)",
    "explanation": "Python looks for `attr` in the instance's `__dict__`. If not found, it searches the class `__dict__`, and then follows the Method Resolution Order (MRO) through base classes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What is the specific mechanism protected by the Global Interpreter Lock (GIL) in CPython that ensures thread safety during memory management?",
    "options": [
      "The mark-and-sweep phase of the generational garbage collector",
      "The increment and decrement operations of object reference counts",
      "The allocation of memory blocks from the operating system via malloc",
      "The bytecode compilation pipeline from source to .pyc files"
    ],
    "answer": "The increment and decrement operations of object reference counts",
    "explanation": "Reference counting is not thread-safe by nature; the GIL prevents race conditions where multiple threads might simultaneously modify an object's reference count. The mark-and-sweep algorithm runs separately and is also synchronized by the GIL, but the primary ongoing need for the lock is reference counting updates.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "In the context of CPython's garbage collector, why are objects tracked in three different generations (0, 1, and 2)?",
    "options": [
      "To separate user-defined objects from built-in types for faster deallocation",
      "To optimize collection frequency based on the heuristic that most objects die young",
      "To implement different memory allocation strategies for integers, strings, and lists",
      "To prioritize the collection of objects with high memory usage regardless of age"
    ],
    "answer": "To optimize collection frequency based on the heuristic that most objects die young",
    "explanation": "This is the 'generational hypothesis.' Newer objects (Generation 0) are collected more frequently as they are more likely to become unreachable quickly, while surviving objects are moved to older generations which are scanned less often to save CPU cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "Which specific category of objects is excluded from CPython's cycle detection algorithm (generational GC)?",
    "options": [
      "Objects defined within a function scope",
      "Objects containing a `__del__` finalizer method",
      "Atomic types (e.g., integers, strings, tuples) containing only other atomic types",
      "Objects that are part of a reference cycle involving a class definition"
    ],
    "answer": "Atomic types (e.g., integers, strings, tuples) containing only other atomic types",
    "explanation": "The cycle detector only monitors container objects (like lists, dicts, classes) that can potentially reference other containers. Atomic types cannot hold references to other containers, therefore they cannot form reference cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the precise behavior of `sys.getrefcount(obj)` when passed a specific object `obj` held in a variable?",
    "options": [
      "It returns the count of references excluding the temporary reference created by the function call itself",
      "It returns the actual reference count plus one to account for the temporary reference passed as an argument",
      "It returns the number of times the object has been accessed since the Python interpreter started",
      "It returns the count of references only from the current scope, ignoring global references"
    ],
    "answer": "It returns the actual reference count plus one to account for the temporary reference passed as an argument",
    "explanation": "The function borrows a reference to the object to inspect it, temporarily incrementing the count. Consequently, the returned value is always exactly one higher than the count you would observe if the object were not passed to the function.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When using `gc.set_threshold(threshold0, threshold1, threshold2)`, what does the `threshold0` value specifically control?",
    "options": [
      "The number of manual collections required before triggering an automatic sweep",
      "The maximum number of objects allowed in Generation 0 before a collection is triggered",
      "The number of allocations of new objects since the last collection before triggering a collection of Generation 0",
      "The time in milliseconds that the GC is allowed to run before pausing"
    ],
    "answer": "The number of allocations of new objects since the last collection before triggering a collection of Generation 0",
    "explanation": "The GC triggers a collection of the youngest generation when the number of allocations exceeds the threshold value. The higher thresholds (1 and 2) control the frequency of collecting older generations based on the number of collections of the younger generation.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Why does `asyncio` run multi-threaded tasks effectively despite the presence of the GIL?",
    "options": [
      "`asyncio` disables the GIL when using the `async` and `await` keywords",
      "`asyncio` uses a single-threaded event loop model, relying on cooperative multitasking rather than OS threads",
      "`asyncio` tasks are actually separate processes managed by the operating system kernel",
      "`asyncio` automatically rewrites bytecode to bypass the GIL restrictions"
    ],
    "answer": "`asyncio` uses a single-threaded event loop model, relying on cooperative multitasking rather than OS threads",
    "explanation": "The GIL only restricts CPU-bound threads executing Python bytecode simultaneously. `asyncio` achieves concurrency on a single thread using an event loop and `yield` control, which is unaffected by the GIL because it never involves concurrent thread execution.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the primary technical risk associated with defining a `__del__` finalizer method on a custom class?",
    "options": [
      "It prevents the object from being pickled and serialized",
      "It creates an uncollectable reference cycle if the object participates in a cycle",
      "It forces the interpreter to use a mark-and-sweep algorithm instead of reference counting",
      "It causes the object to be immediately deallocated when it goes out of scope"
    ],
    "answer": "It creates an uncollectable reference cycle if the object participates in a cycle",
    "explanation": "Objects with `__del__` methods that are part of a reference cycle cannot be safely garbage collected because the GC cannot determine the safe order to call the finalizers. These objects are placed in `gc.garbage` and leak memory until the process exits.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "How does Python's `is` operator fundamentally differ from the `==` operator regarding object comparison?",
    "options": [
      "`is` checks for value equality while `==` checks for memory address identity",
      "`is` checks for memory address identity while `==` checks for value equality",
      "`is` invokes the object's `__eq__` method while `==` compares `id()` values",
      "`is` is used for integer comparison while `==` is used for string comparison"
    ],
    "answer": "`is` checks for memory address identity while `==` checks for value equality",
    "explanation": "The `is` operator evaluates to `True` only if two variables point to the exact same object in memory (i.e., `id(a) == id(b)`). The `==` operator invokes the `__eq__` method to determine if the contents of the objects are equivalent.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Which Python construct allows a class to intercept attribute access and modification on *another* class?",
    "options": [
      "Metaclasses",
      "Decorators",
      "Descriptors",
      "Context Managers"
    ],
    "answer": "Descriptors",
    "explanation": "Descriptors define `__get__`, `__set__`, or `__delete__` methods that allow a separate class (the descriptor) to control how an attribute is accessed, set, or deleted on a host class. This is the underlying mechanism for properties, methods, and class methods.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the function of C3 Linearization in the context of Python class inheritance?",
    "options": [
      "To calculate the Method Resolution Order (MRO) for multiple inheritance",
      "To optimize memory layout for class instances to reduce cache misses",
      "To convert Python source code into C-extensions for faster execution",
      "To linearize multi-dimensional lists into a single dimension for iteration"
    ],
    "answer": "To calculate the Method Resolution Order (MRO) for multiple inheritance",
    "explanation": "C3 Linearization is the algorithm used to determine the order in which base classes are searched when looking for a method. It ensures that a class is always checked before its parents and that the inheritance hierarchy remains monotonic.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "Which bytecode instruction is used to access a local variable in Python, and why is it faster than accessing a global variable?",
    "options": [
      "`LOAD_GLOBAL` accesses a fixed array slot while `LOAD_FAST` uses a hash map lookup",
      "`LOAD_FAST` uses a fixed array offset while `LOAD_GLOBAL` requires a dictionary lookup",
      "`LOAD_FAST` compiles to C code while `LOAD_GLOBAL` remains interpreted",
      "`LOAD_GLOBAL` uses the GIL while `LOAD_FAST` bypasses it"
    ],
    "answer": "`LOAD_FAST` uses a fixed array offset while `LOAD_GLOBAL` requires a dictionary lookup",
    "explanation": "Local variables are stored in a dedicated fixed-size array, and the compiler knows their offset, making `LOAD_FAST` an O(1) array index operation. Global variables are stored in a dictionary (`globals()`), making `LOAD_GLOBAL` a slower hash map lookup.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the purpose of the `__slots__` declaration in a class definition?",
    "options": [
      "To define the order in which methods are resolved in the MRO",
      "To prevent the creation of a `__dict__` and save memory by fixing the set of valid attributes",
      "To allow methods to run asynchronously without using the `async` keyword",
      "To reserve specific memory addresses for the object on the heap"
    ],
    "answer": "To prevent the creation of a `__dict__` and save memory by fixing the set of valid attributes",
    "explanation": "By default, Python stores instance attributes in a flexible dictionary (`__dict__`), which consumes significant memory. `__slots__` replaces this dictionary with a static set of descriptors, reducing memory overhead and preventing dynamic attribute assignment.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "When would you use `gc.disable()` in a production Python application?",
    "options": [
      "To ensure deterministic deallocation of all objects immediately when they leave scope",
      "During a short, performance-critical phase where allocation spikes but no circular references are created",
      "To force the interpreter to use reference counting exclusively for all object types",
      "To prevent multiple threads from accessing the garbage collector simultaneously"
    ],
    "answer": "During a short, performance-critical phase where allocation spikes but no circular references are created",
    "explanation": "The cyclic GC introduces overhead. If a section of code creates many temporary objects but arranges them in a tree structure (no cycles), disabling the GC temporarily can improve performance, provided it is re-enabled later to handle cycles.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What distinguishes a `weakref` from a standard reference in Python?",
    "options": [
      "A `weakref` does not increment the object's reference count, allowing the GC to destroy the object",
      "A `weakref` points to a copy of the object rather than the object itself",
      "A `weakref` is only valid within the scope where it was defined",
      "A `weakref` automatically converts the object to a C-pointer for speed"
    ],
    "answer": "A `weakref` does not increment the object's reference count, allowing the GC to destroy the object",
    "explanation": "Standard references increase `ob_refcnt`, preventing garbage collection. A `weakref` allows access to an object but does not prevent the garbage collector from reclaiming that object's memory if no strong references remain.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Why is CPython's GIL considered a bottleneck for CPU-bound multi-threaded programs?",
    "options": [
      "The GIL prevents multiple threads from acquiring network resources simultaneously",
      "The GIL serializes bytecode execution, preventing multiple threads from utilizing multiple CPU cores",
      "The GIL forces all threads to run on the same logical processor",
      "The GIL requires explicit locking from the programmer for every variable access"
    ],
    "answer": "The GIL serializes bytecode execution, preventing multiple threads from utilizing multiple CPU cores",
    "explanation": "The GIL ensures only one thread executes Python bytecode at a time. While threads can run concurrently during I/O waits, they cannot run in parallel on multiple cores for computation-intensive tasks, negating the benefits of multi-core processors.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "What is the specific behavior of the `intern()` function regarding strings?",
    "options": [
      "It compresses the string using a lossless algorithm to save memory",
      "It converts the string into a byte array to bypass the Unicode overhead",
      "It adds the string to the interned string table, ensuring that future equal strings share the same memory address",
      "It creates a copy of the string to ensure the original is immutable"
    ],
    "answer": "It adds the string to the interned string table, ensuring that future equal strings share the same memory address",
    "explanation": "String interning caches string objects in a global table. If a string `s` is interned, checking `s is t` becomes an O(1) pointer comparison if `t` is also interned, significantly speeding up dictionary lookups using those strings as keys.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "In Python's data model, what triggers the invocation of `__call__`?",
    "options": [
      "Calling an object as if it were a function (e.g., `obj()`)",
      "Accessing an attribute of an object (e.g., `obj.attr`)",
      "Creating a new instance of a class (e.g., `ClassName()`)",
      "Deleting an object reference (e.g., `del obj`)"
    ],
    "answer": "Calling an object as if it were a function (e.g., `obj()`)",
    "explanation": "The `__call__` method allows a class instance to be called like a standard function. When you use `instance(*args)`, Python invokes `type(instance).__call__(instance, *args)`.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What determines the 'check interval' in CPython, and how does it relate to thread switching?",
    "options": [
      "A timer set by the OS scheduler that forces the Python process to yield",
      "A counter of Python bytecode instructions executed by the current thread",
      "The amount of memory allocated before the interpreter forces a context switch",
      "The number of I/O operations performed by the thread"
    ],
    "answer": "A counter of Python bytecode instructions executed by the current thread",
    "explanation": "CPython periodically checks for signals and attempts to switch threads. This switch is triggered by a counter that increments as bytecode instructions are executed, ensuring threads get a fair slice of the interpreter time.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is a 'free list' in the context of CPython's memory allocator?",
    "options": [
      "A linked list of all currently active objects in memory",
      "A list of memory addresses that have been freed by the OS but not yet returned to Python",
      "A cache of recently deallocated objects of a specific type to speed up reallocation",
      "A list of all threads waiting to acquire the GIL"
    ],
    "answer": "A cache of recently deallocated objects of a specific type to speed up reallocation",
    "explanation": "For performance, CPython keeps single-type lists of freed objects (like integers or floats). Instead of returning memory to the system heap, it keeps this memory 'live' to quickly satisfy future allocation requests for the same type.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What happens when a `__del__` method raises an exception during object destruction?",
    "options": [
      "The exception propagates to the code that caused the object to be deallocated",
      "The exception is printed to `stderr` but does not terminate the program",
      "The object immediately becomes a zombie object and is never deallocated",
      "The garbage collector suspends the current collection cycle"
    ],
    "answer": "The exception is printed to `stderr` but does not terminate the program",
    "explanation": "Exceptions occurring in `__del__` are ignored by the interpreter in terms of control flow. They are printed to `sys.stderr` to warn the developer, but they do not propagate up the stack during garbage collection.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "Which argument in the `__exit__` method of a context manager indicates that the code block raised an exception?",
    "options": [
      "The second argument, which contains the exception instance",
      "The return value of `__exit__`",
      "The first argument, which is a boolean flag",
      "The third argument, which contains the traceback object"
    ],
    "answer": "The second argument, which contains the exception instance",
    "explanation": "The `__exit__` signature is `__exit__(self, exc_type, exc_value, traceback)`. If the block exited without exception, all three arguments are `None`. If an exception occurred, `exc_value` (the second argument) holds the exception instance.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "How does the `yield from` expression delegate to a sub-generator in Python?",
    "options": [
      "It pauses the main generator and executes the sub-generator in a new thread",
      "It transparently yields values from the sub-generator until it is exhausted",
      "It returns a list of all values produced by the sub-generator",
      "It merges the bytecode of the sub-generator into the main generator"
    ],
    "answer": "It transparently yields values from the sub-generator until it is exhausted",
    "explanation": "`yield from` creates a bidirectional channel between the caller and the sub-generator. It yields every value produced by the sub-generator and returns the final value of the sub-generator to the outer generator.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What is the correct interpretation of Python's LEGB rule regarding scope resolution?",
    "options": [
      "Names are resolved in the order: Local, Enclosing, Global, Built-in",
      "Names are resolved in the order: Local, External, Global, Bytecode",
      "Names are resolved by checking the heap, then the stack, then the registers",
      "Names are resolved by the Garbage Collector before execution"
    ],
    "answer": "Names are resolved in the order: Local, Enclosing, Global, Built-in",
    "explanation": "When accessing a variable, Python searches the Local scope, then Enclosing (nested functions), then Global (module), and finally Built-in namespaces. The first match found is used.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Why are default arguments evaluated only once at function definition time?",
    "options": [
      "To improve performance by avoiding the overhead of calling the constructor on every invocation",
      "To ensure that the default argument is shared across all threads",
      "Because the default value is stored in the function's `__defaults__` tuple attribute",
      "To allow mutable default arguments to act as static variables"
    ],
    "answer": "Because the default value is stored in the function's `__defaults__` tuple attribute",
    "explanation": "Default values are bound to the function object itself when it is created. The function object holds references to these objects; consequently, if the default is mutable (like a list), changes persist across calls.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "In the context of the `multiprocessing` module, how is data shared between processes?",
    "options": [
      "Data is shared automatically through the system's copy-on-write memory policy",
      "Data must be explicitly passed via pickling (serialization) when using Queues or Pipes",
      "Data is shared via a shared memory space managed by the GIL",
      "Data is shared directly via pointers without copying"
    ],
    "answer": "Data must be explicitly passed via pickling (serialization) when using Queues or Pipes",
    "explanation": "Processes have separate memory spaces. To communicate, objects must be serialized (pickled) and sent via IPC mechanisms like Queues or Pipes, or placed in shared memory using `Value` or `Array`.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "What is the specific role of `Py_INCREF` in CPython C API?",
    "options": [
      "To parse an integer argument from a Python object",
      "To increment the reference count of an object, preventing its deallocation",
      "To create a new reference to a Python object in a different thread",
      "To initialize the Python interpreter"
    ],
    "answer": "To increment the reference count of an object, preventing its deallocation",
    "explanation": "`Py_INCREF` is a macro that increases the `ob_refcnt` field of a PyObject. It is essential for maintaining the life of an object when a new reference to it is stored in C.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the result of `bool([]) == bool({})` in Python?",
    "options": [
      "False",
      "True",
      "It raises a TypeError",
      "It depends on the Python version"
    ],
    "answer": "True",
    "explanation": "Both empty lists `[]` and empty dictionaries `{}` are considered falsy. `bool([])` evaluates to `False` and `bool({})` evaluates to `False`, therefore `False == False` is `True`.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "Which module provides a way to run Python code without the Global Interpreter Lock (GIL) in CPython 3.13+?",
    "options": [
      "`threading`",
      "`multiprocessing`",
      "`asyncio`",
      "`subinterpreter` (via `_xxsubinterpreters`)"
    ],
    "answer": "`subinterpreter` (via `_xxsubinterpreters`)",
    "explanation": "Python 3.13 introduces experimental support for disabling the GIL and creating sub-interpreters that can run truly parallel Python code in the same process, distinct from the `multiprocessing` module which uses separate processes.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the primary consequence of modifying a list while iterating over it with a `for` loop?",
    "options": [
      "The loop restarts from the beginning",
      "The loop skips elements or leads to undefined behavior due to index shifts",
      "Python creates a copy of the list automatically",
      "It raises an `IteratorModifiedError`"
    ],
    "answer": "The loop skips elements or leads to undefined behavior due to index shifts",
    "explanation": "The `for` loop maintains an internal index. If items are added or removed from the list during iteration, the indices shift, causing the loop to skip items or process them multiple times.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What does the `__mro__` attribute on a class represent?",
    "options": [
      "A list of all methods defined in the class",
      "A tuple of classes representing the search order for method resolution",
      "A reference to the metaclass used to create the class",
      "A dictionary of module imports required by the class"
    ],
    "answer": "A tuple of classes representing the search order for method resolution",
    "explanation": "`__mro__` (Method Resolution Order) stores the linearization of the inheritance hierarchy. It is the sequence CPython follows when looking up attributes or methods on an instance of that class.",
    "difficulty": "Advanced"
  }
]