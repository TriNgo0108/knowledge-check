[
  {
    "id": 1,
    "question": "What is the primary purpose of React Fiber?",
    "options": [
      "To introduce a new syntax for writing JavaScript components",
      "To enable incremental rendering and improve scheduling of updates",
      "To replace the Virtual DOM with a more efficient real DOM system",
      "To automatically optimize CSS rendering performance"
    ],
    "answer": "To enable incremental rendering and improve scheduling of updates",
    "explanation": "Fiber is a reimplementation of the reconciler that breaks rendering work into units, allowing React to pause, resume, and prioritize updates. The previous stack reconciler was synchronous and blocking.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In React Fiber, what is the 'work-in-progress' tree?",
    "options": [
      "A persistent backup of the initial application state",
      "A draft tree constructed in memory during the render phase to calculate changes",
      "The visual DOM tree currently displayed to the user",
      "A deprecated concept replaced by Hooks"
    ],
    "answer": "A draft tree constructed in memory during the render phase to calculate changes",
    "explanation": "The work-in-progress tree is an off-screen buffer where React builds the next state of the UI. Once complete, it swaps this with the current tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Which phase of the Fiber reconciliation process is interruptible?",
    "options": [
      "Commit Phase",
      "Render (Reconciliation) Phase",
      "Mounting Phase",
      "Unmounting Phase"
    ],
    "answer": "Render (Reconciliation) Phase",
    "explanation": "The Render phase involves creating the work-in-progress tree and determining changes, which Fiber can pause and resume based on priority. The Commit phase is synchronous and atomic.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the specific role of the 'commit' phase in the Fiber architecture?",
    "options": [
      "To calculate the difference between the current and previous virtual DOM trees",
      "To apply the calculated changes to the host environment (e.g., DOM) and run layout effects",
      "To schedule high-priority updates before low-priority ones",
      "To clone the current fiber nodes"
    ],
    "answer": "To apply the calculated changes to the host environment (e.g., DOM) and run layout effects",
    "explanation": "The commit phase is the synchronous step where React writes to the DOM. It cannot be interrupted to ensure the UI remains consistent.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "How are sibling Fiber nodes linked in the Fiber tree structure?",
    "options": [
      "Via the 'parent' pointer",
      "Via the 'child' pointer",
      "Via the 'return' pointer",
      "Via the 'sibling' pointer"
    ],
    "answer": "Via the 'sibling' pointer",
    "explanation": "Fiber nodes use a specific 'sibling' pointer to link to the next node at the same hierarchy level. 'Child' points to the first offspring, while 'return' points to the parent.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "Why does React use the 'key' prop when rendering lists of elements?",
    "options": [
      "To enforce unique CSS class names for each element",
      "To help the reconciler identify which items have changed, been added, or been removed",
      "To automatically handle event listeners for list items",
      "To create a unique ID for the DOM element"
    ],
    "answer": "To help the reconciler identify which items have changed, been added, or been removed",
    "explanation": "Keys allow React to match elements in the old tree with elements in the new tree. Stable keys prevent unnecessary re-creation of DOM nodes.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "Which React Hook is primarily designed to manage side effects such as data fetching or subscriptions?",
    "options": [
      "useState",
      "useContext",
      "useEffect",
      "useReducer"
    ],
    "answer": "useEffect",
    "explanation": "useEffect allows performing side effects in functional components after the render is committed to the screen. It replaces lifecycle methods like componentDidMount.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What happens when a state update occurs during the render phase of a functional component?",
    "options": [
      "The component immediately re-renders and updates the DOM",
      "React queues the update and re-runs the component to calculate the new output",
      "The update is ignored until the next user interaction",
      "The browser throws a runtime error"
    ],
    "answer": "React queues the update and re-runs the component to calculate the new output",
    "explanation": "State updates trigger a re-render. React re-executes the component function to determine the new React element tree before committing changes.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "In the context of React reconciliation, what does 'double buffering' refer to?",
    "options": [
      "Storing two copies of every user input",
      "Maintaining a 'current' tree and a 'work-in-progress' tree to swap between",
      "Rendering components twice to ensure accuracy",
      "Using two different virtual DOM libraries simultaneously"
    ],
    "answer": "Maintaining a 'current' tree and a 'work-in-progress' tree to swap between",
    "explanation": "Double buffering allows React to prepare the next UI state in the background (work-in-progress) without blocking the current UI (current tree).",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Which property on a Fiber node links it to its counterpart in the alternate tree?",
    "options": [
      "return",
      "sibling",
      "alternate",
      "memoizedState"
    ],
    "answer": "alternate",
    "explanation": "The 'alternate' field creates a reference between a node in the current tree and its corresponding node in the work-in-progress tree, allowing React to clone and reuse nodes.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the purpose of the 'useCallback' hook?",
    "options": [
      "To fetch data from an API asynchronously",
      "To memoize a function definition to prevent unnecessary re-creations on re-renders",
      "To manage the state of a complex object",
      "To create a reference to a DOM element"
    ],
    "answer": "To memoize a function definition to prevent unnecessary re-creations on re-renders",
    "explanation": "useCallback returns a memoized callback that only changes if one of its dependencies changes. This is useful for optimizing child components that rely on reference equality.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which concept describes the process where React determines which parts of the UI need to be updated based on state changes?",
    "options": [
      "Reconciliation",
      "Hydration",
      "Batching",
      "Immutable State"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation (or diffing) is the algorithm React uses to compare the new element tree with the previous one to identify the minimal set of changes required.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the correct way to handle user input in React so that the React state is the 'single source of truth'?",
    "options": [
      "Use the 'ref' attribute to read the input value directly",
      "Use a controlled component with a value prop and an onChange handler",
      "Use the 'defaultValue' prop only",
      "Query the DOM using document.getElementById"
    ],
    "answer": "Use a controlled component with a value prop and an onChange handler",
    "explanation": "In controlled components, form data is handled by a React component state. The input's value is driven by state, and updates flow through event handlers.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is a 'Fragment' in React?",
    "options": [
      "A broken component that failed to render",
      "A way to return multiple elements without adding extra nodes to the DOM",
      "A special type of CSS class",
      "A method to delete a component from the tree"
    ],
    "answer": "A way to return multiple elements without adding extra nodes to the DOM",
    "explanation": "Fragments (<></> or <React.Fragment>) let you group a list of children without adding extra wrapping divs to the DOM tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "Why must state updates in React be treated as immutable?",
    "options": [
      "React uses shallow comparison to detect changes",
      "JavaScript garbage collection requires it",
      "The DOM does not support object mutation",
      "Fiber nodes are read-only"
    ],
    "answer": "React uses shallow comparison to detect changes",
    "explanation": "To efficiently detect changes, React compares the reference of the state object. Mutating the state directly does not change the reference, so React won't trigger a re-render.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which event handling convention is specific to React's SyntheticEvent system?",
    "options": [
      "Events are named using camelCase (e.g., onClick)",
      "Events return native DOM elements by default",
      "Events must be attached using window.addEventListener",
      "Events do not propagate up the component tree"
    ],
    "answer": "Events are named using camelCase (e.g., onClick)",
    "explanation": "React wraps native browser events in SyntheticEvents and uses camelCase naming convention for props (e.g., onClick instead of onclick).",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is the 'Context' API primarily used for?",
    "options": [
      "Managing complex local component state",
      "Passing data through the component tree without manually passing props at every level",
      "Optimizing rendering performance of heavy components",
      "Routing between different pages"
    ],
    "answer": "Passing data through the component tree without manually passing props at every level",
    "explanation": "Context provides a way to share values like themes or authenticated users between components without explicitly prop-drilling through intermediate levels.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "In the Fiber 'begin work' phase, what does React primarily do?",
    "options": [
      "It flushes changes to the actual DOM",
      "It processes the Fiber node to create or update React elements",
      "It cleans up event listeners",
      "It unmounts components from the screen"
    ],
    "answer": "It processes the Fiber node to create or update React elements",
    "explanation": "During 'begin work', React compares the props of the current fiber against the new props and generates the React elements for the children of that fiber.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the primary function of the 'return' pointer in a Fiber node?",
    "options": [
      "To point to the previous component that rendered",
      "To point back to the parent Fiber node in the tree",
      "To return a value from the component function",
      "To reset the component state"
    ],
    "answer": "To point back to the parent Fiber node in the tree",
    "explanation": "The 'return' pointer allows React to traverse back up the tree after finishing work on a node and its children.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the behavior of the 'useEffect' hook when an empty dependency array [] is provided?",
    "options": [
      "It runs the effect on every render",
      "It runs the effect only once after the initial mount",
      "It prevents the effect from running entirely",
      "It runs the effect only when the component unmounts"
    ],
    "answer": "It runs the effect only once after the initial mount",
    "explanation": "An empty dependency array tells React that the effect does not depend on any values from props or state, so it never needs to re-run after the first execution.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "How does React determine if a component needs to be re-rendered during reconciliation?",
    "options": [
      "By checking if the component's class name has changed",
      "By comparing the previous render output to the new render output (Diffing)",
      "By randomly sampling components in the tree",
      "By asking the user for confirmation"
    ],
    "answer": "By comparing the previous render output to the new render output (Diffing)",
    "explanation": "React generates a new element tree and compares it to the previous one to identify changes. If differences are found, it updates the DOM.",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the 'children' prop in a React component?",
    "options": [
      "A reserved prop name used to pass nested elements or components",
      "A prop that must always be an array",
      "A method to define CSS styles for child elements",
      "A reference to the DOM node"
    ],
    "answer": "A reserved prop name used to pass nested elements or components",
    "explanation": "The children prop represents the content between the opening and closing tags of a component, enabling component composition.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which hook allows you to optimize performance by memoizing an expensive calculation result?",
    "options": [
      "useState",
      "useEffect",
      "useMemo",
      "useRef"
    ],
    "answer": "useMemo",
    "explanation": "useMemo takes a function and a dependency array, and only recomputes the memoized value if one of the dependencies has changed.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What happens to the 'current' tree when the 'work-in-progress' tree finishes rendering?",
    "options": [
      "It is immediately deleted from memory",
      "It becomes the new 'work-in-progress' tree",
      "It is swapped with the work-in-progress tree, which becomes the new current tree",
      "It remains static and is never updated"
    ],
    "answer": "It is swapped with the work-in-progress tree, which becomes the new current tree",
    "explanation": "Once the work-in-progress tree is fully built, React swaps the pointers. The work-in-progress tree becomes the current tree presented to the user.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is a valid use case for the 'useRef' hook?",
    "options": [
      "Managing the value of a text input",
      "Triggering a re-render when a value changes",
      "Accessing a DOM element directly or persisting a value across renders without causing a re-render",
      "Fetching data from an API"
    ],
    "answer": "Accessing a DOM element directly or persisting a value across renders without causing a re-render",
    "explanation": "useRef returns a mutable object that persists for the full lifetime of the component. Changing its current property does not trigger a re-render.",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "In React, why is it dangerous to use the array index as a 'key' prop when the list can be reordered or filtered?",
    "options": [
      "It causes a syntax error in the JSX",
      "It can lead to UI bugs because React may reuse the wrong DOM elements for the wrong data",
      "It prevents the component from rendering at all",
      "It forces React to use more memory"
    ],
    "answer": "It can lead to UI bugs because React may reuse the wrong DOM elements for the wrong data",
    "explanation": "Using indices as keys is unstable if the list order changes. React relies on keys to match state and identity; unstable keys can result in mixed-up UI or lost component state.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is 'lifting state up' in React?",
    "options": [
      "Moving state to a higher-level component to share it between sibling components",
      "Deleting state from the application",
      "Converting functional components to class components",
      "Moving state from the server to the client"
    ],
    "answer": "Moving state to a higher-level component to share it between sibling components",
    "explanation": "When several components need to share data, the recommended approach is to lift the state to their closest common ancestor and pass it down via props.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What does the 'useReducer' hook accept as its first argument?",
    "options": [
      "An initial state value",
      "A reducer function of form (state, action) => newState",
      "A component class",
      "A CSS selector"
    ],
    "answer": "A reducer function of form (state, action) => newState",
    "explanation": "useReducer accepts a reducer function that determines the next state based on the current state and an action.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "Which phase of the rendering lifecycle is responsible for handling cleanup (like removing event listeners)?",
    "options": [
      "During the initial calculation of the virtual DOM",
      "Before the component unmounts (or before re-executing the effect) via the cleanup function in useEffect",
      "During the 'begin work' phase of Fiber",
      "Immediately when setState is called"
    ],
    "answer": "Before the component unmounts (or before re-executing the effect) via the cleanup function in useEffect",
    "explanation": "The cleanup function returned by useEffect runs before the component unmounts and before every subsequent effect execution to prevent memory leaks.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is the React 'StrictMode' component used for?",
    "options": [
      "Enforcing strict TypeScript typing",
      "Detecting potential problems in an application during development (like unsafe lifecycles)",
      "Forcing all components to be pure functions",
      "Blocking the API from loading in development"
    ],
    "answer": "Detecting potential problems in an application during development (like unsafe lifecycles)",
    "explanation": "StrictMode activates additional checks and warnings for descendants in development only, such as detecting legacy APIs or side effects in render.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the result of calling 'useState' inside a functional component?",
    "options": [
      "It returns the current state value and a function to update it",
      "It returns a reference to the DOM node",
      "It returns the props object",
      "It returns a boolean indicating if the component is mounted"
    ],
    "answer": "It returns the current state value and a function to update it",
    "explanation": "The useState hook returns an array where the first element is the current state value and the second element is the dispatcher function to update it.",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What is the significance of the 'child' pointer in a Fiber node?",
    "options": [
      "It points to the first child node of the current component",
      "It points to the next sibling of the current component",
      "It points to the parent of the current component",
      "It points to the DOM node"
    ],
    "answer": "It points to the first child node of the current component",
    "explanation": "The 'child' pointer directs the render process to the first direct descendant of the current fiber node.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "How does React ensure that updates are batched for performance?",
    "options": [
      "By using the Web Workers API",
      "By grouping state updates within event handlers before re-rendering",
      "By waiting for the internet connection to stabilize",
      "By rendering every update immediately regardless of timing"
    ],
    "answer": "By grouping state updates within event handlers before re-rendering",
    "explanation": "React batches state updates that occur during event handlers and lifecycle methods to avoid multiple unnecessary renders.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is a 'Portal' in React?",
    "options": [
      "A specialized router for navigating pages",
      "A way to render children into a DOM node outside of the parent component's hierarchy",
      "A tool for optimizing server-side rendering",
      "A method to compress the bundle size"
    ],
    "answer": "A way to render children into a DOM node outside of the parent component's hierarchy",
    "explanation": "Portals render a child into a different part of the DOM (e.g., a modal root in document.body) while keeping it logically within the parent component in the React tree.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "In the context of React reconciliation, what is 'diffing'?",
    "options": [
      "The process of compressing JavaScript files",
      "The algorithm React uses to compare two trees to determine the minimal set of changes",
      "The process of merging Git branches",
      "The act of splitting a component into smaller pieces"
    ],
    "answer": "The algorithm React uses to compare two trees to determine the minimal set of changes",
    "explanation": "Diffing refers to the heuristic algorithm React uses to compare the new Virtual DOM tree with the old one to efficiently calculate updates.",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "In React Fiber's double buffering architecture, what is the specific role of the `workInProgress` tree?",
    "options": [
      "It stores the state of the UI before the current render to enable rollback functionality.",
      "It acts as a mutable draft where updates are applied during the reconciliation phase before being committed.",
      "It serves as a permanent cache of previously rendered components to optimize future mount times.",
      "It represents the immutable, live state of the DOM that is currently visible to the user."
    ],
    "answer": "It acts as a mutable draft where updates are applied during the reconciliation phase before being committed.",
    "explanation": "The `workInProgress` tree is constructed in memory as a 'draft' to calculate changes. React processes updates on this tree and swaps it with the `current` tree only once the render phase is complete and the commit phase begins.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What distinguishes the 'Render' phase from the 'Commit' phase in the React Fiber reconciliation process?",
    "options": [
      "The Render phase applies changes to the DOM, while the Commit phase calculates differences.",
      "The Render phase is interruptible and asynchronous, while the Commit phase is synchronous and uninterruptible.",
      "The Render phase handles user events, while the Commit phase handles side effects.",
      "The Render phase is specific to class components, while the Commit phase applies to functional components."
    ],
    "answer": "The Render phase is interruptible and asynchronous, while the Commit phase is synchronous and uninterruptible.",
    "explanation": "Fiber allows React to pause, abort, or resume work during the Render phase to prioritize high-priority updates. The Commit phase must be synchronous to ensure the DOM is never in an inconsistent, partially updated state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "When reconciling lists of child elements, how does React utilize the `key` prop to optimize performance?",
    "options": [
      "It uses the key to compress the component data structure in memory.",
      "It uses the key to determine if a component instance should be moved, destroyed, or updated rather than re-created.",
      "It uses the key to bypass the virtual DOM diffing algorithm entirely for that subtree.",
      "It uses the key to merge the props of adjacent elements into a single update."
    ],
    "answer": "It uses the key to determine if a component instance should be moved, destroyed, or updated rather than re-created.",
    "explanation": "Keys help React identify which items have changed, are added, or are removed. Without keys (or with unstable keys like array indices), React may resort to destroying and recreating components unnecessarily, leading to performance degradation and state loss.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "In the context of React Fiber, what is the purpose of the `effectTag` property on a Fiber node?",
    "options": [
      "To track the CSS transition effects attached to the DOM node.",
      "To store the result of the reconciliation diff for later use.",
      "To indicate what specific work needs to be done on the node during the commit phase (e.g., Placement, Update, Deletion).",
      "To prioritize the node relative to other nodes in the update queue."
    ],
    "answer": "To indicate what specific work needs to be done on the node during the commit phase (e.g., Placement, Update, Deletion).",
    "explanation": "After reconciliation, React marks Fiber nodes with `effectTag` (bitflags) to efficiently track side effects. This allows the commit phase to quickly iterate only over nodes that have actual changes to apply to the DOM.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which hook is primarily used to bypass the scheduling priority of React Fiber to force a synchronous update for visual consistency?",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useInsertionEffect",
      "useDeferredValue"
    ],
    "answer": "useLayoutEffect",
    "explanation": "`useLayoutEffect` fires synchronously after all DOM mutations but before the browser paints. This allows reading layout from the DOM and synchronously re-rendering without the user seeing a visual flash, unlike `useEffect` which is deferred.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "Why is using the array index as a `key` considered an anti-pattern when rendering lists that can be reordered or filtered?",
    "options": [
      "It causes the application to crash because keys must be unique globally.",
      "It prevents React from diffing the list efficiently, often leading to unnecessary re-mounting of components and state loss.",
      "It violates the ECMAScript standard regarding object property naming.",
      "It forces the Commit phase to run multiple times for the same list."
    ],
    "answer": "It prevents React from diffing the list efficiently, often leading to unnecessary re-mounting of components and state loss.",
    "explanation": "If the order of items changes, indices shift, causing React to incorrectly associate state and DOM nodes with the wrong data elements (e.g., the input in row 1 suddenly corresponds to the data in row 2). Stable, unique IDs resolve this.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "How does the `return` pointer function in the traversal of the Fiber tree structure?",
    "options": [
      "It points to the parent Fiber node, allowing React to return to the parent after finishing a child subtree.",
      "It returns the virtual DOM element to the component that requested it.",
      "It points to the previous sibling to enable horizontal traversal.",
      "It indicates the return value of the render function for that specific component."
    ],
    "answer": "It points to the parent Fiber node, allowing React to return to the parent after finishing a child subtree.",
    "explanation": "The Fiber tree is a linked list. While `child` moves down and `sibling` moves across, the `return` pointer moves back up to the parent, completing the traversal loop required for depth-first reconciliation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What technical mechanism allows React 18's Automatic Batching to batch state updates even across asynchronous operations like promises or timeouts?",
    "options": [
      "Fiber Reconciliation",
      "Transitions",
      "Suspense",
      "createRoot"
    ],
    "answer": "createRoot",
    "explanation": "While legacy batching (via `ReactDOM.render`) only batched updates during React event handlers, the new root API (`createRoot`) enables automatic batching everywhere by updating the execution context handling within the Fiber scheduler.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the primary consequence of mutating state directly in a React component?",
    "options": [
      "The component will immediately re-render with the new value.",
      "The render function will be skipped, but the UI will update.",
      "React cannot detect the change, leading to potential UI inconsistency and bypassing of lifecycle methods.",
      "The component will throw a runtime error preventing further execution."
    ],
    "answer": "React cannot detect the change, leading to potential UI inconsistency and bypassing of lifecycle methods.",
    "explanation": "React relies on object reference equality checks to trigger re-renders. Direct mutation does not change the object reference, so React assumes nothing has changed, and components will not update to reflect the new data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In a functional component, how does `useRef` differ fundamentally from a `useState` variable in terms of rendering behavior?",
    "options": [
      "`useRef` returns an immutable object, while `useState` returns a mutable array.",
      "`useRef` triggers a re-render when its value changes, whereas `useState` does not.",
      "`useRef` persists a value across renders without triggering a re-render, whereas `useState` triggers a re-render on update.",
      "`useRef` is strictly for DOM nodes, while `useState` is for primitive data."
    ],
    "answer": "`useRef` persists a value across renders without triggering a re-render, whereas `useState` triggers a re-render on update.",
    "explanation": "Changing a ref's `.current` property does not cause a re-render. This makes refs ideal for storing mutable values that persist without triggering the render/reconciliation cycle, unlike state variables.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the specific purpose of the `dependencies` array in `useEffect`?",
    "options": [
      "To define variables that are available inside the scope of the effect function.",
      "To tell React to only re-run the effect if the specific values listed have changed between renders.",
      "To order the execution of multiple effects relative to one another.",
      "To prevent memory leaks by automatically cleaning up timers."
    ],
    "answer": "To tell React to only re-run the effect if the specific values listed have changed between renders.",
    "explanation": "React compares the current dependency values to the values from the previous render. If every value in the array is strictly equal (`===`), React skips the effect.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which statement accurately describes how React handles 'Stale Closures' in `useEffect` when the dependency array is omitted?",
    "options": [
      "React automatically updates the closure to use the latest props and state.",
      "The effect captures the props and state from the initial render only and never sees updates.",
      "React throws an error requiring a dependency array.",
      "The effect runs on every single render, ensuring fresh data but potentially causing performance issues."
    ],
    "answer": "The effect runs on every single render, ensuring fresh data but potentially causing performance issues.",
    "explanation": "Omitting the dependency array tells React to run the effect after every render. While this avoids stale closures by constantly re-creating the effect with fresh scope, it is rarely the intended behavior due to performance costs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When using `React.memo` to optimize a functional component, how are changes in props determined by default?",
    "options": [
      "By shallow equality comparison of the props object.",
      "By deep equality comparison of all nested properties in the props object.",
      "By reference equality of the component itself.",
      "By checking if the component is a Pure Component."
    ],
    "answer": "By shallow equality comparison of the props object.",
    "explanation": "`React.memo` performs a shallow comparison of the previous and next props. If the props object reference hasn't changed (even if nested mutable properties have), the re-render is skipped.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What happens during the 'beginWork' phase of Fiber processing?",
    "options": [
      "React flushes the DOM changes calculated during the render phase.",
      "React processes the Fiber node to create or reconcile the React elements for its children.",
      "React cleans up side effects and unmounts components.",
      "React pauses execution to wait for the browser to paint."
    ],
    "answer": "React processes the Fiber node to create or reconcile the React elements for its children.",
    "explanation": "`beginWork` is the entry point for processing a Fiber node. It compares the new props/element type with existing fibers to determine what changes (addition, update, deletion) are needed for the children.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "How does `useCallback` optimize performance in a component rendered by a strict parent?",
    "options": [
      "It automatically memoizes the result of the function call.",
      "It maintains a stable function reference across renders unless dependencies change, preventing child re-renders optimized by `React.memo`.",
      "It reduces the memory footprint of the function by converting it to a WebAssembly module.",
      "It allows the function to be called asynchronously without blocking the main thread."
    ],
    "answer": "It maintains a stable function reference across renders unless dependencies change, preventing child re-renders optimized by `React.memo`.",
    "explanation": "If a child component is wrapped in `React.memo`, passing a new function reference on every parent render will bypass the memoization. `useCallback` keeps the function reference stable between renders.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is the functional purpose of the `expirationTime` field on a Fiber node?",
    "options": [
      "To specify how long the component should remain mounted before being garbage collected.",
      "To assign a priority level to the update, determining when or if it should be processed.",
      "To set the timeout duration for data fetching in `useEffect`.",
      "To calculate the remaining battery life on mobile devices."
    ],
    "answer": "To assign a priority level to the update, determining when or if it should be processed.",
    "explanation": "React uses `expirationTime` (now referred to as lanes/priority in updated implementations) to schedule work. High-priority updates (like typing) have shorter expiration times and are processed before low-priority updates (like data fetching).",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "In the context of the `Profiler` API, what does a `phase` of 'mount' versus 'update' indicate?",
    "options": [
      "'mount' refers to the time taken to download the JavaScript bundle, 'update' refers to the time taken to parse it.",
      "'mount' refers to the initial creation of the component tree, 'update' refers to subsequent re-renders caused by state or prop changes.",
      "'mount' is the time spent in the commit phase, 'update' is the time spent in the render phase.",
      "'mount' indicates a server-side render, 'update' indicates a client-side hydration."
    ],
    "answer": "'mount' refers to the initial creation of the component tree, 'update' refers to subsequent re-renders caused by state or prop changes.",
    "explanation": "The Profiler tracks the lifecycle of the tree. 'mount' captures performance metrics when the component first appears, while 'update' captures metrics for changes triggered by new props, state, or context.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "Why might a developer choose `useReducer` over `useState` for complex state logic?",
    "options": [
      "`useReducer` automatically persists state to `localStorage`.",
      "`useReducer` allows decoupling state logic from the component and manages transitions based on the previous state.",
      "`useReducer` is faster than `useState` because it skips the diffing algorithm.",
      "`useReducer` is the only way to access the previous state value."
    ],
    "answer": "`useReducer` allows decoupling state logic from the component and manages transitions based on the previous state.",
    "explanation": "`useReducer` is ideal when the next state depends on the previous one, or when logic is complex. It centralizes the state transition logic in a reducer function, making it easier to test and maintain than scattered `setState` calls.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "What occurs if `setState` is called while a component is currently unmounting?",
    "options": [
      "React queues the update and applies it when the component remounts.",
      "React throws an immediate error and stops the application.",
      "React attempts to update the component, but since it is unmounted, it triggers a memory leak warning (or error in React 18+).",
      "React ignores the update silently."
    ],
    "answer": "React attempts to update the component, but since it is unmounted, it triggers a memory leak warning (or error in React 18+).",
    "explanation": "Updating state on an unmounted component is often a bug (e.g., a pending async request resolving after navigation). React 18+ flags this as an error to prevent memory leaks and no-ops.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the behavior of `React.cloneElement` regarding the children of the element being cloned?",
    "options": [
      "It creates a deep copy of the children elements.",
      "It discards the original children unless new children are explicitly provided.",
      "It preserves the original children unless new children are provided as the third argument.",
      "It automatically flattens nested arrays of children."
    ],
    "answer": "It preserves the original children unless new children are provided as the third argument.",
    "explanation": "New children act as overrides. If new children are not passed, the existing children of the cloned element are retained and merged into the new element.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "How does 'Controlled Component' architecture differ from 'Uncontrolled Component' architecture in forms?",
    "options": [
      "Controlled components store form data in the DOM, while uncontrolled components store it in React state.",
      "Controlled components derive their input value from React state and update state via callbacks, while uncontrolled components rely on the DOM to handle the value.",
      "Controlled components do not trigger re-renders, while uncontrolled components do.",
      "Controlled components are class components only, while uncontrolled components are functional components."
    ],
    "answer": "Controlled components derive their input value from React state and update state via callbacks, while uncontrolled components rely on the DOM to handle the value.",
    "explanation": "In a controlled component, React is the 'single source of truth.' In an uncontrolled component, the DOM maintains the truth, typically accessed via refs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What is the specific utility of 'React.Children.map' compared to 'Array.map'?",
    "options": [
      "It automatically assigns keys to the mapped elements based on their index.",
      "It handles opaque data structures like `fragments` and `strings` correctly, which `Array.map` would ignore or crash on.",
      "It runs synchronously, whereas `Array.map` is asynchronous.",
      "It deep clones the elements before mapping."
    ],
    "answer": "It handles opaque data structures like `fragments` and `strings` correctly, which `Array.map` would ignore or crash on.",
    "explanation": "`this.props.children` can be a node, array, or special object (like a Fragment). `React.children` functions ensure these are treated as a collection regardless of their actual data shape.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "In the context of Server-Side Rendering (SSR), what does the 'hydration' process accomplish?",
    "options": [
      "It generates the static HTML string on the server.",
      "It attaches event listeners to the existing HTML markup to make it interactive on the client.",
      "It converts the JavaScript code into machine code.",
      "It fetches the initial data from the API."
    ],
    "answer": "It attaches event listeners to the existing HTML markup to make it interactive on the client.",
    "explanation": "SSR sends static HTML. Hydration is the client-side process where React reuses the DOM nodes generated by the server and attaches listeners, bridging the gap between static content and interactive application.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "Which event handling behavior differentiates React's SyntheticEvent system from native DOM events?",
    "options": [
      "React events use capturing phase only.",
      "React events are pooled and reused for performance, nullifying properties after the event callback.",
      "React events trigger the default behavior before the handler runs.",
      "React events do not support bubbling."
    ],
    "answer": "React events are pooled and reused for performance, nullifying properties after the event callback.",
    "explanation": "For performance, React uses event pooling (in older versions) or event delegation. Accessing `event.target` asynchronously requires calling `e.persist()` (in older versions) because the SyntheticEvent object is reset/nulled after dispatch.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "When implementing 'Error Boundaries', why is it required that they be Class Components rather than Functional Components?",
    "options": [
      "Functional components do not have a `this` context.",
      "Error Boundaries rely on specific lifecycle methods (`static getDerivedStateFromError` and `componentDidCatch`) that are not available in hooks.",
      "Functional components cannot handle try-catch blocks.",
      "Class components are faster at catching errors."
    ],
    "answer": "Error Boundaries rely on specific lifecycle methods (`static getDerivedStateFromError` and `componentDidCatch`) that are not available in hooks.",
    "explanation": "React does not currently provide a hook to catch errors in child components during rendering. Therefore, only Class Components with these specific lifecycle methods can act as Error Boundaries.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "What is the result of rendering a React component with `type: null`?",
    "options": [
      "React renders an empty text node.",
      "React throws an error indicating an invalid element type.",
      "React skips rendering the component and continues.",
      "React renders a standard `<div>` as a fallback."
    ],
    "answer": "React throws an error indicating an invalid element type.",
    "explanation": "React validates the element type. If `type` is `null` or `undefined`, React considers it an invalid element and throws an error (e.g., 'Element type is invalid').",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "How does the 'Strict Mode' component utility assist developers in Concurrent React?",
    "options": [
      "It automatically fixes performance bottlenecks.",
      "It double-invokes certain functions (like render, state update setters, and effects) to help uncover unexpected side effects.",
      "It forces all components to use `useLayoutEffect` instead of `useEffect`.",
      "It prevents the component from unmounting to improve stability."
    ],
    "answer": "It double-invokes certain functions (like render, state update setters, and effects) to help uncover unexpected side effects.",
    "explanation": "Strict Mode intentionally double-invokes the render phase and effects (in development) to make impure logic (side effects during rendering) more apparent, ensuring code works correctly with the concurrent features of Fiber.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the primary role of 'Suspense' when wrapping a component that fetches data?",
    "options": [
      "To cache the fetched data in the browser's IndexedDB.",
      "To pause rendering of the wrapped component until the data requirement is met, displaying a fallback in the meantime.",
      "To retry the data fetch if the network request fails.",
      "To prioritize the data fetch request over other updates."
    ],
    "answer": "To pause rendering of the wrapped component until the data requirement is met, displaying a fallback in the meantime.",
    "explanation": "Suspense coordinates with a data-fetching mechanism that throws a Promise. It catches that promise and shows the `fallback` UI until the promise resolves, at which point it re-renders the content.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "What distinguishes `useTransition` from standard state updates?",
    "options": [
      "`useTransition` allows updates to be marked as 'transitions', enabling React to interrupt them if higher priority work (like user input) comes in.",
      "`useTransition` is used for navigating between different pages.",
      "`useTransition` automatically optimizes images before rendering.",
      "`useTransition` makes state updates synchronous."
    ],
    "answer": "`useTransition` allows updates to be marked as 'transitions', enabling React to interrupt them if higher priority work (like user input) comes in.",
    "explanation": "Transitions mark non-urgent UI updates. This tells the React scheduler to keep the interface responsive to user interaction (high priority) even if the transition (low priority) is computationally expensive.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "When using a custom Hook, what is the rule regarding calling other Hooks?",
    "options": [
      "Custom Hooks cannot call other Hooks.",
      "Custom Hooks can call other Hooks, but the called Hooks must be unconditionally invoked at the top level of the custom Hook.",
      "Custom Hooks must call `useEffect` before calling `useState`.",
      "Custom Hooks can only call built-in Hooks, not other custom Hooks."
    ],
    "answer": "Custom Hooks can call other Hooks, but the called Hooks must be unconditionally invoked at the top level of the custom Hook.",
    "explanation": "Custom Hooks are essentially JavaScript functions that utilize Hooks internally. They must strictly adhere to the Rules of Hooks: called only at the top level and not inside loops or conditions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "What is the output of the reconciliation process?",
    "options": [
      "A new Fiber tree.",
      "A list of side effects (mutations, additions, deletions) to apply to the host environment.",
      "A serialized JSON string representing the DOM.",
      "A list of components that need to be garbage collected."
    ],
    "answer": "A list of side effects (mutations, additions, deletions) to apply to the host environment.",
    "explanation": "Reconciliation calculates the differences between the `current` and `workInProgress` trees. The result is a linked list of fibers with `effectTag` properties (the effect list), which the commit phase uses to update the DOM.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "How does `useDeferredValue` improve performance regarding expensive renders?",
    "options": [
      "It cancels the previous render immediately when a new one starts.",
      "It defers updating a specific part of the UI to a lower priority, allowing urgent updates to proceed first.",
      "It automatically converts the value into a string to speed up comparison.",
      "It prevents the value from being passed to child components."
    ],
    "answer": "It defers updating a specific part of the UI to a lower priority, allowing urgent updates to proceed first.",
    "explanation": "It accepts a value and returns a deferred copy of it. React will not block urgent updates (like typing) to re-calculate the expensive render caused by the original value changing; it will do so when resources are available.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "In a `useEffect` cleanup function, why is it critical to return a function that clears side effects?",
    "options": [
      "To prevent the component from re-rendering.",
      "To handle race conditions (e.g., a component unmounting before an async request completes) and prevent memory leaks.",
      "To automatically unsubscribe from Redux stores.",
      "To increase the execution speed of the next effect."
    ],
    "answer": "To handle race conditions (e.g., a component unmounting before an async request completes) and prevent memory leaks.",
    "explanation": "Cleanup runs before the next effect or on unmount. This is essential for invalidating stale async requests or removing event listeners, ensuring the app doesn't try to update an unmounted component or leak resources.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is the fundamental architectural implication of 'Single File Components' versus standard React components?",
    "options": [
      "Standard React components cannot be written in a single file.",
      "There is no inherent difference; React components are typically modular files, whereas 'Single File Component' is a Vue-specific term (`.vue`).",
      "Standard React components require a build step to concatenate files.",
      "Single File Components allow CSS injection directly into the JavaScript logic."
    ],
    "answer": "There is no inherent difference; React components are typically modular files, whereas 'Single File Component' is a Vue-specific term (`.vue`).",
    "explanation": "React generally separates template (JSX), logic (JS), and styles (CSS/Styled-components), though they can exist in one file. 'Single File Component' specifically refers to the `.vue` architecture where HTML, CSS, and JS are encapsulated in one file.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "When rendering a list of components where the 'key' prop is omitted, how does React default to identifying items?",
    "options": [
      "It uses the component name.",
      "It uses the item's index in the array.",
      "It uses a hash of the item's content.",
      "It throws a warning and does not render the list."
    ],
    "answer": "It uses the item's index in the array.",
    "explanation": "If no key is provided, React defaults to using the index of the item as a key. This is acceptable for static lists but dangerous for dynamic lists that can be reordered, as it leads to state mismatching.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "In the React Fiber architecture, which pointer property on a Fiber node is used to traverse to the next sibling at the same hierarchical level?",
    "options": [
      "return",
      "child",
      "sibling",
      "alternate"
    ],
    "answer": "sibling",
    "explanation": "The `sibling` pointer creates a linked list of children for a parent node, enabling the traversal of horizontal peers. The `child` pointer goes down the tree, while `return` goes up to the parent. `alternate` points to the counterpart node in the other tree buffer.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "During the React 'Render Phase', why is the process considered interruptible compared to the legacy Stack Reconciler?",
    "options": [
      "The browser forces a timeout after 5 seconds",
      "React uses `requestIdleCallback` to execute work in chunks",
      "Work is broken into units of work that can be paused and resumed based on priority",
      "The render phase is moved to a Web Worker"
    ],
    "answer": "Work is broken into units of work that can be paused and resumed based on priority",
    "explanation": "Fiber breaks rendering into small units (Fiber nodes) linked via a linked list, allowing the scheduler to pause, yield to the main thread, and resume later. `requestIdleCallback` was an early experimental API, but the production scheduler uses MessageChannels/Time slicing logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the specific purpose of the `alternate` property on a Fiber node?",
    "options": [
      "To point to the parent node for bubbling events",
      "To reference the corresponding node in the opposing tree (current or work-in-progress)",
      "To link to the next sibling in the render list",
      "To store the previous props for comparison"
    ],
    "answer": "To reference the corresponding node in the opposing tree (current or work-in-progress)",
    "explanation": "The `alternate` attribute creates a circular link between the node in the `current` tree and its counterpart in the `workInProgress` tree. This enables efficient cloning and allows React to switch trees without recreating nodes from scratch.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which specific effect flag is used to mark a Fiber node for deletion during the Commit phase?",
    "options": [
      "Placement",
      "Update",
      "Deletion",
      "Ref"
    ],
    "answer": "Deletion",
    "explanation": "The `Deletion` side-effect flag indicates that a DOM node corresponding to this Fiber should be removed from the tree during the Commit phase. `Placement` indicates insertion, and `Update` indicates modifications.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What triggers React to switch from the 'current' tree to the 'work-in-progress' tree as the visible UI?",
    "options": [
      "Immediately upon completion of the Render phase",
      "After the mutation phase of the Commit phase completes",
      "Only when `forceUpdate` is called",
      "When the `root.current` pointer is swapped to point to the work-in-progress tree"
    ],
    "answer": "When the `root.current` pointer is swapped to point to the work-in-progress tree",
    "explanation": "The swap occurs at the end of the Commit phase (after mutations), where the root's `current` pointer is updated to reference the newly flushed `workInProgress` tree, making it the new source of truth for future renders.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "Which of the following best describes the function `beginWork` in the Fiber work loop?",
    "options": [
      "It commits changes to the actual DOM",
      "It processes the Fiber node to create children and compares them with previous render output",
      "It cleans up side-effects and schedules passive effects",
      "It initializes the state of the component for the first time"
    ],
    "answer": "It processes the Fiber node to create children and compares them with previous render output",
    "explanation": "`beginWork` is the entry point for processing a specific Fiber node; it reconciles the new element type with the old Fiber, determines if an update is needed, and creates the child Fiber nodes.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "In the context of React 18+ Concurrency, what distinguishes a 'Transition' update from a standard urgent update?",
    "options": [
      "Transitions run synchronously on the main thread",
      "Transitions are non-interruptible and must finish",
      "Transitions can be interrupted by higher-priority updates (like typing)",
      "Transitions ignore component lifecycle hooks"
    ],
    "answer": "Transitions can be interrupted by higher-priority updates (like typing)",
    "explanation": "Transitions are marked as low-priority updates that React can interrupt to handle more urgent interactions (user input), preventing the UI from freezing during complex state calculations.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the primary data structure React uses internally to queue and prioritize updates (Lanes) for scheduling?",
    "options": [
      "A linked list of Fiber nodes",
      "A binary Min-Heap based on expiration time",
      "A hash map of component IDs",
      "A stack frame"
    ],
    "answer": "A binary Min-Heap based on expiration time",
    "explanation": "The Scheduler (internally) uses a Min-Heap data structure to efficiently manage task queues, allowing it to quickly retrieve the task with the earliest expiration time or highest priority.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "Why does React 17+ attach event listeners to the `root` DOM container instead of individual elements?",
    "options": [
      "To improve CSS Selector performance",
      "To implement Event Delegation and simplify cleanup in Concurrent Mode",
      "To increase the memory footprint for better caching",
      "To bypass the browser's capture phase"
    ],
    "answer": "To implement Event Delegation and simplify cleanup in Concurrent Mode",
    "explanation": "React uses event delegation; listening at the root allows React to handle events consistently and supports features like `useEffect` cleanup without worrying about attaching/detaching listeners to unmounting nodes, while also enabling event replaying in Concurrent Mode.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "When a component throws an error during rendering, how does the Fiber tree traversal change?",
    "options": [
      "The entire render process is aborted",
      "The error is caught by the nearest Error Boundary by completing the sibling nodes and unwinding",
      "The error is ignored and the previous state is kept",
      "The component is automatically re-rendered with default props"
    ],
    "answer": "The error is caught by the nearest Error Boundary by completing the sibling nodes and unwinding",
    "explanation": "During the render phase, if an error is thrown, React marks the fiber and unwinds the stack until it finds a parent fiber with the `DidCapture` flag (an Error Boundary), then completes the siblings to ensure the tree is consistent before committing.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the specific behavior of `useLayoutEffect` regarding browser painting?",
    "options": [
      "It runs asynchronously after the browser has painted",
      "It runs synchronously after all DOM mutations but before the browser paints",
      "It runs before DOM mutations occur",
      "It runs on the server side only"
    ],
    "answer": "It runs synchronously after all DOM mutations but before the browser paints",
    "explanation": "`useLayoutEffect` fires synchronously after DOM mutations are applied in the Commit phase but before the browser has a chance to paint the next frame, allowing the reading of layout and synchronous re-rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "How does React determine if a Hook dependency has changed when using `useEffect` or `useMemo`?",
    "options": [
      "Deep equality comparison using `lodash.isEqual`",
      "Shallow comparison using `Object.is`",
      "Reference equality check using `===`",
      "JSON stringification comparison"
    ],
    "answer": "Shallow comparison using `Object.is`",
    "explanation": "React compares the current dependency value with the previous one using `Object.is` (which behaves like `===` for primitives and value comparison for `NaN`). It does not perform deep comparisons of objects or arrays.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the 'Stale Closure' problem in the context of React Hooks?",
    "options": [
      "When a function component is garbage collected prematurely",
      "When an event handler or effect captures old state or props from a previous render",
      "When the component forgets to clean up side effects",
      "When `useCallback` returns a null value"
    ],
    "answer": "When an event handler or effect captures old state or props from a previous render",
    "explanation": "Stale closures occur when a function defined in a previous render (e.g., in `useEffect` or an event handler) retains references to variables from that specific render scope, leading to outdated data if not updated via dependency arrays or refs.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the primary function of the `completeWork` phase in Fiber reconciliation?",
    "options": [
      "To create DOM nodes and process updates to props, creating the effect list",
      "To schedule the next frame",
      "To commit changes to the screen",
      "To traverse down to the child components"
    ],
    "answer": "To create DOM nodes and process updates to props, creating the effect list",
    "explanation": "`completeWork` is called after `beginWork` processes children. It creates/updates the DOM instance (for host components), handles updates, and constructs the linked list of effects (side-effects) to be committed.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "In the context of hydration (React SSR), what happens if the markup generated on the client differs from the server markup?",
    "options": [
      "React silently patches the DOM",
      "React discards the server HTML and re-renders from scratch",
      "React throws a hydration mismatch warning and attempts to patch",
      "React crashes the application with a fatal error"
    ],
    "answer": "React throws a hydration mismatch warning and attempts to patch",
    "explanation": "React expects the server and client trees to match. If a mismatch is detected, React logs a warning (in Dev) and takes over the node, effectively re-rendering that part of the tree from the client side to ensure consistency.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "Which mechanism does `useSyncExternalStore` use to prevent 'tearing' in concurrent features?",
    "options": [
      "It forces all updates to be synchronous",
      "It snapshots the external store value and exposes it consistently to all renders",
      "It debounces external updates",
      "It disables Concurrent Mode for the entire app"
    ],
    "answer": "It snapshots the external store value and exposes it consistently to all renders",
    "explanation": "To prevent tearing (where different parts of the UI show different versions of external state simultaneously), `useSyncExternalStore` forces reads to happen atomically, providing a consistent snapshot to the ongoing render.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the output of `typeof type` in the React source for a Function Component fiber node?",
    "options": [
      "'object'",
      "'function'",
      "'string'",
      "'symbol'"
    ],
    "answer": "'function'",
    "explanation": "In React's internal `isCompatibleElementType` checks and Fiber tagging, Function Components are identified by their type being a function. Host components (div/span) have string types, while Class components are functions with a prototype.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "When using `startTransition`, how does React prioritize the rendering of the state update?",
    "options": [
      "It is treated as Urgent priority and blocks all input",
      "It is demoted to Transition priority and can be interrupted",
      "It is executed in a separate thread",
      "It is deferred until the browser is idle"
    ],
    "answer": "It is demoted to Transition priority and can be interrupted",
    "explanation": "Updates wrapped in `startTransition` are marked with lower priority (Transition Lane). React can interrupt these renders if higher-priority interactions (like clicks or keystrokes) occur.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "What is the technical reason React warns against calling Hooks inside loops or conditions?",
    "options": [
      "It violates the Rules of Hooks, breaking the order-preserving linked list structure",
      "It causes memory leaks in the browser",
      "It prevents the virtual DOM from diffing correctly",
      "It triggers an infinite re-render loop"
    ],
    "answer": "It violates the Rules of Hooks, breaking the order-preserving linked list structure",
    "explanation": "Hooks rely on the order of invocation to map state to the correct component instance using an index. Conditional rendering or loops change the order, causing the hook state manager to retrieve the wrong state for subsequent hooks.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "What does the `expirationTime` (conceptually now represented by Lanes) determine in the Fiber architecture?",
    "options": [
      "The exact moment in milliseconds when the component unmounts",
      "The priority of an update relative to other updates to prevent starvation",
      "The duration of the animation frame",
      "The timestamp of the last state change"
    ],
    "answer": "The priority of an update relative to other updates to prevent starvation",
    "explanation": "Expiration time (and Lanes) represents when an update *must* be processed. High-priority updates have shorter expiration times, ensuring low-priority updates don't starve indefinitely as the expiration time approaches.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the 'Double Buffering' technique utilized by React Fiber?",
    "options": [
      "Storing two copies of the DOM tree to prevent flicker",
      "Maintaining a `current` tree and a `workInProgress` tree to calculate changes without blocking the UI",
      "Buffering state updates in a queue before processing them",
      "Using two fibers for every component to store previous and next props"
    ],
    "answer": "Maintaining a `current` tree and a `workInProgress` tree to calculate changes without blocking the UI",
    "explanation": "Double buffering allows React to build the next version of the UI in memory (`workInProgress`) on the `current` snapshot. Once calculation is done, it swaps the pointers, ensuring the user always sees a consistent UI.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "How does `React.memo` optimize a functional component's re-rendering behavior?",
    "options": [
      "It performs a deep comparison of all component props",
      "It shallowly compares props and skips re-rendering if they haven't changed",
      "It automatically hooks the component into the global state store",
      "It converts the component into a PureComponent class"
    ],
    "answer": "It shallowly compares props and skips re-rendering if they haven't changed",
    "explanation": "`React.memo` is a higher-order component that performs a shallow comparison of the props object. If the reference of the props hasn't changed, React skips rendering that component and its children (unless they have context consumers).",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "What occurs during the 'Mutation' sub-phase of the Commit phase?",
    "options": [
      "React calculates the diff and prepares the effect list",
      "React reads layout from the DOM",
      "React inserts, updates, and removes DOM nodes based on the effect list",
      "React executes `useEffect` callbacks"
    ],
    "answer": "React inserts, updates, and removes DOM nodes based on the effect list",
    "explanation": "The Mutation phase is where the actual DOM manipulations happen (additions, deletions, updates). It is followed by the Layout phase (reading DOM/sync effects) and Passive phase (async `useEffect`).",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "Why is the `key` prop critical when rendering lists of components?",
    "options": [
      "It allows React to uniquely identify elements for efficient reconciliation and state preservation",
      "It prevents the browser from caching the component",
      "It enables CSS transitions to work correctly",
      "It is required for TypeScript type checking"
    ],
    "answer": "It allows React to uniquely identify elements for efficient reconciliation and state preservation",
    "explanation": "Keys help React identify which items have changed, been added, or removed. A stable key allows React to reuse DOM nodes and preserve component state across re-renders, rather than destroying and recreating them.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What does `flushSync` do in Concurrent Mode?",
    "options": [
      "It forces a synchronous flush of all pending transitions",
      "It forces an immediate, synchronous render of the update, bypassing concurrent features",
      "It flushes the network cache",
      "It synchronizes the state of all components globally"
    ],
    "answer": "It forces an immediate, synchronous render of the update, bypassing concurrent features",
    "explanation": "`flushSync` forces React to execute the update synchronously and immediately update the DOM, effectively disabling time-slicing and interrupts for that specific update queue.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "In StrictMode (Development), why does React invoke component constructors and render methods twice?",
    "options": [
      "To calculate the average render time",
      "To detect accidental side-effects in the render phase",
      "To test the browser's garbage collector",
      "To enforce the use of `PureComponent`"
    ],
    "answer": "To detect accidental side-effects in the render phase",
    "explanation": "The render phase should be pure. Double-invoking helps identify components that break this rule by causing side effects (like modifying global variables or direct DOM manipulation) during rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the 'passive' effect flag used for in the Fiber node?",
    "options": [
      "To mark effects that must run synchronously before paint",
      "To mark `useEffect` callbacks that run after paint",
      "To mark lazy-loaded components",
      "To mark components that are not visible"
    ],
    "answer": "To mark `useEffect` callbacks that run after paint",
    "explanation": "Passive effects (created by `useEffect`) are deferred until after the browser has painted the updated UI. This prevents blocking the browser's paint process, unlike layout effects.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "How does `useId` ensure stability between Server and Client in React 18?",
    "options": [
      "By using a global counter that increments on the server and client",
      "By using the position of the component in the tree and a deterministic seed",
      "By generating a random UUID",
      "By hashing the component props"
    ],
    "answer": "By using the position of the component in the tree and a deterministic seed",
    "explanation": "`useId` uses a deterministic algorithm based on the 'tree path' and a shared 'seed' (passed from server to client). This ensures the ID generated on the server matches the one generated on the client during hydration.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "What is the consequence of returning a function from `useEffect`?",
    "options": [
      "It renders the component twice",
      "It is treated as the cleanup function and runs before the next effect or unmount",
      "It triggers an error because effects must return undefined",
      "It is used to update the state"
    ],
    "answer": "It is treated as the cleanup function and runs before the next effect or unmount",
    "explanation": "Returning a function from `useEffect` signals to React that this function should be run to clean up the effect's side effects (e.g., removing event listeners or clearing timers) before the component re-renders or unmounts.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "Regarding Context, which sub-phase of the Commit phase consumes the context value propagation?",
    "options": [
      "Before Mutation phase",
      "During Mutation phase",
      "During the passive effects phase",
      "Context is handled during the Render phase, not the Commit phase"
    ],
    "answer": "Context is handled during the Render phase, not the Commit phase",
    "explanation": "Context is consumed during the Render (Reconciliation) phase. When a component reads context, React traverses up the Fiber tree (using the `contextDependency` stack) to find the nearest Provider node.",
    "difficulty": "Advanced"
  }
]