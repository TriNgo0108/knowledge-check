[
  {
    "id": 1,
    "question": "What is the primary characteristic of system design interview prompts compared to coding challenges?",
    "options": [
      "They require a single correct algorithmic solution",
      "They are often vague and require extracting specifications",
      "They focus exclusively on database normalization",
      "They are strictly limited to 15 minutes"
    ],
    "answer": "They are often vague and require extracting specifications",
    "explanation": "System design interviews replicate real-world ambiguity where requirements are not fully defined. Unlike coding challenges with precise inputs/outputs, you must ask clarifying questions.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "In the context of behavioral interviews, what does the 'A' stand for in the CAR method?",
    "options": [
      "Analysis",
      "Action",
      "Assessment",
      "Achievement"
    ],
    "answer": "Action",
    "explanation": "The CAR method stands for Circumstance, Action, and Result. The 'Action' section describes the specific steps you took to address the situation.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "Why is it recommended to use 'I' instead of 'we' when answering behavioral questions?",
    "options": [
      "To ensure the interviewer knows you are not a team player",
      "To take full credit for the team's failures",
      "To clearly identify your specific individual contribution",
      "To avoid discussing the rest of the team"
    ],
    "answer": "To clearly identify your specific individual contribution",
    "explanation": "Interviewers want to hire *you*, not your previous team. Using 'I' distinguishes your specific role and impact from the collective effort.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is the single biggest mistake candidates make when preparing for system design interviews according to expert advice?",
    "options": [
      "Reading too many textbooks",
      "Spending time passively consuming content instead of practicing",
      "Focusing too much on front-end technologies",
      "Practicing with a pen and paper"
    ],
    "answer": "Spending time passively consuming content instead of practicing",
    "explanation": "While reading provides theory, active practice on a whiteboard is essential for learning. You learn by doing much quicker than by reading.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "How is a candidate's solution evaluated in a system design interview?",
    "options": [
      "By checking if it matches the interviewer's secret blueprint",
      "By the defensibility of the choices and discussion of trade-offs",
      "By the number of features included in the design",
      "By the speed at which the diagram is drawn"
    ],
    "answer": "By the defensibility of the choices and discussion of trade-offs",
    "explanation": "There is no single 'right' answer in system design. Success is determined by your ability to justify your decisions and articulate the trade-offs involved.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the recommended time breakdown for a standard 45-minute technical interview?",
    "options": [
      "5 minutes intro, 35 minutes technical, 5 minutes Q&A",
      "15 minutes intro, 15 minutes technical, 15 minutes Q&A",
      "45 minutes continuous coding without breaks",
      "10 minutes behavioral, 30 minutes coding, 5 minutes salary negotiation"
    ],
    "answer": "5 minutes intro, 35 minutes technical, 5 minutes Q&A",
    "explanation": "A standard format allocates roughly 5 minutes for introductions, 35 minutes for the core problem-solving, and 5 minutes at the end for the candidate to ask questions.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is the purpose of asking clarifying questions at the start of a system design interview?",
    "options": [
      "To stall for time while you think of an answer",
      "To narrow the scope and define specific requirements",
      "To impress the interviewer with technical jargon",
      "To confirm the salary range for the role"
    ],
    "answer": "To narrow the scope and define specific requirements",
    "explanation": "Since prompts are intentionally vague, clarifying questions help align your understanding with the interviewer's expectations and prevent over-engineering.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "Which of the following is listed as a common category of system design practice problems?",
    "options": [
      "Online Ticketing Systems",
      "Compiler Design",
      "Operating System Kernels",
      "Microprocessor Architecture"
    ],
    "answer": "Online Ticketing Systems",
    "explanation": "Common practice patterns include designing systems like URL shorteners, chat apps, and Online Ticketing Systems which require handling concurrency and high demand.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "When preparing for a behavioral interview, what specific aspect of your resume should you be ready to discuss?",
    "options": [
      "Only your most recent job title",
      "Only your technical skills section",
      "Every item listed, from technical skills to non-technical experiences",
      "Only your education history"
    ],
    "answer": "Every item listed, from technical skills to non-technical experiences",
    "explanation": "You must be prepared to discuss anything on your resume, as behavioral questions often draw directly from your past experiences and listed projects.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "In a coding interview, what distinguishes a seasoned engineer from a junior one regarding their initial code?",
    "options": [
      "The seasoned engineer never writes buggy code",
      "The seasoned engineer is afraid to modify working code",
      "The seasoned engineer looks for ways to refactor and improve the code",
      "The seasoned engineer stops immediately after the first test passes"
    ],
    "answer": "The seasoned engineer looks for ways to refactor and improve the code",
    "explanation": "Senior engineers view the first working draft as a starting point and seek to improve it. Junior engineers may be afraid to touch code once it works.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "In the context of System Design interviews, why is asking clarifying questions considered a critical first step?",
    "options": [
      "To stall for time while you think of an architecture",
      "To narrow the scope and define specific constraints before designing",
      "To show the interviewer that you have read their company blog",
      "To ensure the solution uses only technologies you already know"
    ],
    "answer": "To narrow the scope and define specific constraints before designing",
    "explanation": "System design prompts are intentionally vague to mimic real-world ambiguity. Asking clarifying questions demonstrates your ability to gather requirements and define trade-offs before jumping into implementation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 12,
    "question": "When choosing between a SQL and NoSQL database for a system design, what is the primary technical benefit of a NoSQL store like DynamoDB or Cassandra?",
    "options": [
      "Strict ACID compliance for financial transactions",
      "Complex relational join capabilities",
      "High write throughput and horizontal scalability",
      "Fixed schema enforcement"
    ],
    "answer": "High write throughput and horizontal scalability",
    "explanation": "NoSQL databases often sacrifice strict consistency and complex joins for availability and partition tolerance (AP in CAP), allowing them to scale horizontally much more effectively than traditional relational databases.",
    "difficulty": "Intermediate"
  },
  {
    "id": 13,
    "question": "In a behavioral interview using the CAR method (Circumstance, Action, Result), what is the most important element to focus on during the 'Action' phase?",
    "options": [
      "Describing the team's collective effort in detail",
      "Explaining the project background and history",
      "Highlighting your specific individual contribution and decisions",
      "Listing the technologies used in the project"
    ],
    "answer": "Highlighting your specific individual contribution and decisions",
    "explanation": "Interviewers want to know what *you* did, not just what the team did. Using 'I' instead of 'We' helps distinguish your specific impact and agency in solving the problem.",
    "difficulty": "Intermediate"
  },
  {
    "id": 14,
    "question": "What is the primary trade-off when implementing a Load Balancer using the 'Least Connections' algorithm versus 'Round Robin'?",
    "options": [
      "Least Connections requires session state persistence",
      "Least Connections is computationally more expensive but handles varying request durations better",
      "Round Robin does not support health checks",
      "Least Connections cannot be used with UDP protocols"
    ],
    "answer": "Least Connections is computationally more expensive but handles varying request durations better",
    "explanation": "Round Robin assumes all requests take equal time, which can overload a server with long-running tasks. Least Connections directs traffic to the server with the fewest active requests, accounting for processing time disparities.",
    "difficulty": "Intermediate"
  },
  {
    "id": 15,
    "question": "During a coding interview, you identify that your initial solution has a time complexity of O(n^2). What is the most professional way to proceed?",
    "options": [
      "Immediately delete the code and start over without speaking",
      "Explain the inefficiency to the interviewer and discuss potential optimizations before coding",
      "Submit the O(n^2) solution and ask for a new problem",
      "Refactor the variable names to improve readability instead of the algorithm"
    ],
    "answer": "Explain the inefficiency to the interviewer and discuss potential optimizations before coding",
    "explanation": "Communication is key. Acknowledging the trade-offs of your current solution and brainstorming a more optimal approach (e.g., using a hash map) demonstrates higher-level thinking.",
    "difficulty": "Intermediate"
  },
  {
    "id": 16,
    "question": "Why are Graph databases (like Neo4j) preferred over Relational databases for modeling social networks or recommendation engines?",
    "options": [
      "They enforce a rigid table structure",
      "They store data in JSON format natively",
      "They efficiently traverse relationships with O(1) lookup complexity for adjacent nodes",
      "They do not require indexing"
    ],
    "answer": "They efficiently traverse relationships with O(1) lookup complexity for adjacent nodes",
    "explanation": "In relational databases, recursive joins (finding friends of friends) are computationally expensive. Graph databases store edges as first-class citizens, making traversal of deep connections significantly faster.",
    "difficulty": "Intermediate"
  },
  {
    "id": 17,
    "question": "In the context of caching strategies, what specific problem does 'Cache Penetration' aim to describe?",
    "options": [
      "Data in the cache expiring simultaneously causing a database stampede",
      "Queries for non-existent data bypassing the cache and hitting the database directly",
      "The cache server running out of memory",
      "Data inconsistency between the cache and the database"
    ],
    "answer": "Queries for non-existent data bypassing the cache and hitting the database directly",
    "explanation": "Cache penetration occurs when a high volume of queries for keys that do not exist in the database (e.g., malicious attacks) forces the system to repeatedly query the backing store, degrading performance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 18,
    "question": "When designing a system for 'High Availability,' what is the standard strategy for handling a single data center failure?",
    "options": [
      "Implementing vertical scaling by upgrading the server CPU",
      "Multi-region deployment with data replication and failover mechanisms",
      "Writing scripts to automatically restart the server on failure",
      "Using a single powerful database with RAID storage"
    ],
    "answer": "Multi-region deployment with data replication and failover mechanisms",
    "explanation": "High availability requires redundancy. Multi-region setups ensure that if an entire data center goes offline (disaster), traffic can be routed to a live region with minimal disruption.",
    "difficulty": "Intermediate"
  },
  {
    "id": 19,
    "question": "What is the primary advantage of using a 'Read Replica' architecture in a database system?",
    "options": [
      "It allows for stronger consistency guarantees on writes",
      "It enables horizontal scaling of read traffic to reduce load on the primary node",
      "It eliminates the need for database backups",
      "It automatically shards the data based on the primary key"
    ],
    "answer": "It enables horizontal scaling of read traffic to reduce load on the primary node",
    "explanation": "Read replicas copy data from the primary node to secondary nodes. Applications can direct read-heavy traffic to these replicas, distributing the load and improving performance, though write traffic still goes to the primary.",
    "difficulty": "Intermediate"
  },
  {
    "id": 20,
    "question": "In a coding interview, when asked to solve a problem involving 'Top K' elements (e.g., Top 10 frequent words), which data structure provides the optimal time complexity?",
    "options": [
      "A simple Array sorted after every insertion",
      "A Max-Heap containing all elements",
      "A Min-Heap of size K",
      "A Linked List"
    ],
    "answer": "A Min-Heap of size K",
    "explanation": "Maintaining a Min-Heap of size K allows for O(N log K) time complexity. This is more efficient than sorting all elements (O(N log N)) or using a Max-Heap of all elements, as you only need to keep the top K candidates seen so far.",
    "difficulty": "Intermediate"
  },
  {
    "id": 21,
    "question": "What distinguishes a 'Forward Proxy' from a 'Reverse Proxy' in system architecture?",
    "options": [
      "A Forward Proxy hides the client's identity, while a Reverse Proxy hides the server's identity",
      "A Forward Proxy is used for load balancing, while a Reverse Proxy is used for caching",
      "There is no technical difference, only the marketing name",
      "A Forward Proxy handles SSL termination, while a Reverse Proxy handles routing"
    ],
    "answer": "A Forward Proxy hides the client's identity, while a Reverse Proxy hides the server's identity",
    "explanation": "A Forward Proxy sits in front of clients (e.g., corporate VPN) to protect them. A Reverse Proxy sits in front of servers (e.g., Nginx) to distribute load and provide security.",
    "difficulty": "Intermediate"
  },
  {
    "id": 22,
    "question": "When answering behavioral questions using the STAR method, what is the purpose of the 'Result' component?",
    "options": [
      "To describe the theoretical outcome of the project",
      "To share the credit with the entire team",
      "To quantify the impact of your actions and prove success",
      "To transition into the next question"
    ],
    "answer": "To quantify the impact of your actions and prove success",
    "explanation": "The Result should be specific and quantifiable (e.g., 'reduced latency by 20%', 'saved $5k'). It validates the effectiveness of the Action you took.",
    "difficulty": "Intermediate"
  },
  {
    "id": 23,
    "question": "In the CAP Theorem for distributed systems, what does the 'A' stand for, and what does it guarantee?",
    "options": [
      "Authentication: Ensuring only valid users access data",
      "Availability: Every request receives a response (success or failure) without guaranteeing consistency",
      "Atomicity: Transactions are all-or-nothing",
      "Asynchrony: Processes run independently of time"
    ],
    "answer": "Availability: Every request receives a response (success or failure) without guaranteeing consistency",
    "explanation": "Availability in CAP means the system remains operational 100% of the time, even during network partitions, though it may return stale data (violating Consistency).",
    "difficulty": "Intermediate"
  },
  {
    "id": 24,
    "question": "Why might an interviewer ask a candidate to 'refactor' their code even after the solution passes all test cases?",
    "options": [
      "They want to see if the candidate gets frustrated",
      "The candidate is running ahead of schedule and needs extra work",
      "To assess the candidate's ability to write maintainable, readable, and 'clean' code",
      "The initial solution was in the wrong programming language"
    ],
    "answer": "To assess the candidate's ability to write maintainable, readable, and 'clean' code",
    "explanation": "Senior engineers prioritize maintainability. Refactoring checks if the candidate can improve modularity, variable naming, and structure, which is crucial for long-term production health.",
    "difficulty": "Intermediate"
  },
  {
    "id": 25,
    "question": "What is the primary function of a 'Content Delivery Network' (CDN) in a web architecture?",
    "options": [
      "To dynamically generate HTML pages based on user logic",
      "To store and serve static assets (images, CSS, JS) from geographically edge locations",
      "To secure the database from SQL injection attacks",
      "To compile TypeScript into JavaScript"
    ],
    "answer": "To store and serve static assets (images, CSS, JS) from geographically edge locations",
    "explanation": "CDNs cache content at edge servers closer to the user. This reduces latency by minimizing the physical distance data must travel and offloads bandwidth from the origin server.",
    "difficulty": "Intermediate"
  },
  {
    "id": 26,
    "question": "In the context of API design, what is the main difference between 'Idempotency' and 'Safety'?",
    "options": [
      "A safe operation modifies server state, an idempotent operation does not",
      "A safe operation does not modify server state; an idempotent operation can be called multiple times with the same effect as a single call",
      "Idempotency requires authentication, safety does not",
      "Safety applies only to GET requests, idempotency only to PUT"
    ],
    "answer": "A safe operation does not modify server state; an idempotent operation can be called multiple times with the same effect as a single call",
    "explanation": "Safety implies no side effects (like GET). Idempotency implies that making the same request 1 time or 100 times yields the same server state (like PUT or DELETE), regardless of side effects.",
    "difficulty": "Intermediate"
  },
  {
    "id": 27,
    "question": "When designing a URL shortener (like bit.ly), what is the most efficient data structure for generating a unique, short slug from a unique Long URL?",
    "options": [
      "A random string generation using UUIDs",
      "Base62 encoding of a database auto-incrementing integer ID",
      "A hash of the Long URL truncated to 7 characters",
      "The creation of a SQL database index on the text content"
    ],
    "answer": "Base62 encoding of a database auto-incrementing integer ID",
    "explanation": "While hashing works, Base62 encoding a counter guarantees uniqueness and collision-free distribution. Hashes can collide, and UUIDs are too long for 'short' URLs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 28,
    "question": "What is the 'Two-Pointer' technique primarily used for in algorithm design?",
    "options": [
      "Searching for a pair of elements in a sorted array that satisfies a condition",
      "Traversing a binary tree to find the depth",
      "Implementing a hash map lookup",
      "Sorting an unsorted linked list"
    ],
    "answer": "Searching for a pair of elements in a sorted array that satisfies a condition",
    "explanation": "Two Pointers are highly efficient (O(n)) for problems like finding a target sum in a sorted array, as they allow scanning from both ends without nested loops.",
    "difficulty": "Intermediate"
  },
  {
    "id": 29,
    "question": "In System Design, what is the primary purpose of a 'Message Queue' (like RabbitMQ or Kafka)?",
    "options": [
      "To store data permanently for long-term archival",
      "To enable synchronous communication between microservices",
      "To decouple services and handle asynchronous processing tasks",
      "To encrypt data as it travels over the network"
    ],
    "answer": "To decouple services and handle asynchronous processing tasks",
    "explanation": "Queues allow services to communicate without waiting for each other (fire-and-forget). This helps manage traffic spikes (buffering) and improves resilience by preventing cascading failures.",
    "difficulty": "Intermediate"
  },
  {
    "id": 30,
    "question": "What is the time complexity of inserting an element at the beginning of a Singly Linked List versus a Dynamic Array?",
    "options": [
      "O(1) for Linked List, O(n) for Array",
      "O(n) for Linked List, O(1) for Array",
      "O(log n) for Linked List, O(n) for Array",
      "O(1) for Linked List, O(1) for Array"
    ],
    "answer": "O(1) for Linked List, O(n) for Array",
    "explanation": "Linked lists only require updating the head pointer (O(1)). Arrays require shifting all existing elements one space to the right to make room at index 0 (O(n)).",
    "difficulty": "Intermediate"
  },
  {
    "id": 31,
    "question": "When discussing 'Consistent Hashing' in distributed systems, what problem does it specifically solve?",
    "options": [
      "Data integrity during power outages",
      "Minimizing data movement when nodes are added or removed from the cache cluster",
      "Ensuring all nodes have the exact same amount of memory",
      "Encrypting user passwords securely"
    ],
    "answer": "Minimizing data movement when nodes are added or removed from the cache cluster",
    "explanation": "Standard hashing causes massive remapping if the number of nodes changes. Consistent hashing maps both data and nodes to a ring, ensuring that adding/removing a node only affects its immediate neighbors' data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 32,
    "question": "In the context of Object-Oriented Programming, how does the 'Strategy Pattern' benefit code architecture?",
    "options": [
      "It converts a recursive algorithm into an iterative one",
      "It defines a family of algorithms, encapsulates each one, and makes them interchangeable",
      "It ensures a class has only one instance",
      "It provides a unified interface to a set of interfaces in a subsystem"
    ],
    "answer": "It defines a family of algorithms, encapsulates each one, and makes them interchangeable",
    "explanation": "The Strategy pattern allows the algorithm to vary independently from clients that use it. It enables selecting an algorithm at runtime without altering the context object.",
    "difficulty": "Intermediate"
  },
  {
    "id": 33,
    "question": "What is the key distinction between a 'Process' and a 'Thread' in operating system terms?",
    "options": [
      "Threads share the same heap; processes do not",
      "Processes share the same stack; threads do not",
      "A process is a lightweight unit of execution; a thread is heavyweight",
      "Threads cannot communicate with each other"
    ],
    "answer": "Threads share the same heap; processes do not",
    "explanation": "Processes are isolated with their own memory space. Threads within the same process share the heap memory and resources but have their own stacks and registers.",
    "difficulty": "Intermediate"
  },
  {
    "id": 34,
    "question": "When an interviewer asks 'What is your biggest weakness?', what is the strategic intent behind the question?",
    "options": [
      "To give the candidate a chance to humble brag",
      "To assess self-awareness and the ability to learn from mistakes",
      "To trick the candidate into revealing they are lazy",
      "To determine if the candidate needs to be micro-managed"
    ],
    "answer": "To assess self-awareness and the ability to learn from mistakes",
    "explanation": "The interviewer is looking for growth mindset. The best answers acknowledge a real area for improvement and describe active steps taken to mitigate or master that weakness.",
    "difficulty": "Intermediate"
  },
  {
    "id": 35,
    "question": "Why is 'Referential Integrity' crucial in the design of Relational Databases?",
    "options": [
      "It ensures that the database is ACID compliant",
      "It guarantees that relationships between tables remain consistent and valid",
      "It optimizes the query execution plan",
      "It prevents SQL injection attacks"
    ],
    "answer": "It guarantees that relationships between tables remain consistent and valid",
    "explanation": "Referential integrity (via Foreign Keys) ensures that you cannot have a record in a child table that references a non-existent ID in a parent table, preventing orphaned data and logical errors.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "In a coding challenge, why is it important to discuss 'Edge Cases' before writing code?",
    "options": [
      "To increase the lines of code written",
      "To demonstrate thorough problem analysis and prevent runtime errors",
      "To show that you know how to use exception handling syntax",
      "Because the interviewer will mark you down if you don't speak for the first 5 minutes"
    ],
    "answer": "To demonstrate thorough problem analysis and prevent runtime errors",
    "explanation": "Identifying edge cases (e.g., empty inputs, nulls, negative integers) proves you understand the problem domain fully and ensures your solution is robust.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the primary characteristic of a 'Microservices Architecture' compared to a 'Monolithic Architecture'?",
    "options": [
      "Microservices are easier to deploy initially",
      "Microservices organize code around business capabilities with independent deployability",
      "Monolithic architectures cannot use SQL databases",
      "Microservices always run on a single server"
    ],
    "answer": "Microservices organize code around business capabilities with independent deployability",
    "explanation": "While monoliths bundle everything into one unit, microservices decompose the application into small, loosely coupled services that can be developed, deployed, and scaled independently.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "How does 'Database Sharding' differ from 'Partitioning'?",
    "options": [
      "Sharding is horizontal scaling across machines; partitioning is dividing data on a single machine",
      "Sharding is for SQL; partitioning is for NoSQL",
      "Sharding sorts data; partitioning groups data",
      "There is no difference; they are synonyms"
    ],
    "answer": "Sharding is horizontal scaling across machines; partitioning is dividing data on a single machine",
    "explanation": "Both split data, but sharding distributes the data across multiple distinct database instances (nodes/machines) to scale out. Partitioning is usually a logical division within a single database instance.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When discussing API authentication, what is the primary security benefit of using 'HMAC' (Hash-based Message Authentication Code) over a simple API Key?",
    "options": [
      "HMAC encrypts the payload so it cannot be read",
      "HMAC verifies both the data integrity and the authenticity of the message using a shared secret",
      "HMAC does not require a password",
      "HMAC is faster to compute than hashing"
    ],
    "answer": "HMAC verifies both the data integrity and the authenticity of the message using a shared secret",
    "explanation": "An API Key acts like a username (who you are). HMAC acts like a signature; it ensures the message hasn't been tampered with in transit (integrity) and comes from someone holding the secret (authenticity).",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is the significance of the 'SOLID' principles in software engineering interviews?",
    "options": [
      "They are strict rules for memory management",
      "They are mnemonic acronyms for design principles that make software more maintainable and scalable",
      "They describe the network layers in the OSI model",
      "They are a checklist for unit testing"
    ],
    "answer": "They are mnemonic acronyms for design principles that make software more maintainable and scalable",
    "explanation": "SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) guides developers toward reducing coupling and increasing cohesion in code.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "In a technical interview, if you are stuck on a problem, what is the most effective ' unstuck ' strategy?",
    "options": [
      "Sit silently until an idea comes",
      "Ask the interviewer for the solution",
      "Perform a dry run on a small input example to trace the logic",
      "Restart the question using a different programming language"
    ],
    "answer": "Perform a dry run on a small input example to trace the logic",
    "explanation": "Running through a concrete example manually helps visualize the flow, identify where logic breaks, or reveals a pattern that leads to the algorithm.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "Why is 'Latency' different from 'Throughput' in system performance?",
    "options": [
      "Latency is the time taken to process one request; Throughput is the number of requests processed per time unit",
      "Latency measures network bandwidth; Throughput measures CPU usage",
      "Latency is server-side; Throughput is client-side",
      "They are synonyms for speed"
    ],
    "answer": "Latency is the time taken to process one request; Throughput is the number of requests processed per time unit",
    "explanation": "Latency is the delay between sending a request and receiving a response (duration). Throughput is the volume of work or data processed within a specific timeframe (rate).",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is 'Race Condition' in the context of multi-threaded programming?",
    "options": [
      "When two threads compete to see which finishes first",
      "A bug where the system behavior depends on the relative timing of uncontrollable events",
      "A method to synchronize threads effectively",
      "A state where the CPU is idle"
    ],
    "answer": "A bug where the system behavior depends on the relative timing of uncontrollable events",
    "explanation": "A race condition occurs when multiple threads access shared data and try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, the outcome depends on the execution order.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "When designing a chat application (like WhatsApp), why are 'WebSockets' generally preferred over standard HTTP REST APIs?",
    "options": [
      "WebSockets provide better compression for text messages",
      "WebSockets maintain a persistent, bidirectional connection allowing real-time push from server",
      "HTTP is slower than WebSockets for file uploads",
      "WebSockets do not require SSL certificates"
    ],
    "answer": "WebSockets maintain a persistent, bidirectional connection allowing real-time push from server",
    "explanation": "HTTP is request-response (polling) which is inefficient for instant messaging. WebSockets allow the server to push messages to the client instantly without the client needing to ask repeatedly.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "In a 'Synchronous' versus 'Asynchronous' processing debate, what is the main risk of choosing Synchronous processing for a long-running task?",
    "options": [
      "It is difficult to implement",
      "It blocks the calling thread, potentially causing system timeouts or unresponsiveness",
      "It consumes more disk space",
      "It requires a database"
    ],
    "answer": "It blocks the calling thread, potentially causing system timeouts or unresponsiveness",
    "explanation": "In a synchronous call, the client waits for the task to finish. If the task takes too long (e.g., video processing), the request may time out, or the thread pool may be exhausted, blocking other users.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "In the context of distributed systems, what is the primary trade-off when choosing 'Eventual Consistency' over 'Strong Consistency'?",
    "options": [
      "Strong consistency offers higher availability but requires simpler conflict resolution strategies",
      "Eventual consistency optimizes for availability and partition tolerance at the cost of immediate data freshness",
      "Eventual consistency guarantees that all nodes see the same data simultaneously",
      "Strong consistency reduces latency by allowing local reads without quorum verification"
    ],
    "answer": "Eventual consistency optimizes for availability and partition tolerance at the cost of immediate data freshness",
    "explanation": "Eventual consistency allows the system to remain available during network partitions (AP in CAP), but stale data may be read until convergence. Strong consistency ensures freshness but often sacrifices availability or increases latency.",
    "difficulty": "Advanced"
  },
  {
    "id": 47,
    "question": "What is the 'Thundering Herd' problem in the context of load balancing and caching?",
    "options": [
      "A situation where a database deadlock occurs due to high write throughput",
      "When a cache stampede causes a massive spike in database load after a popular key expires",
      "The failure of a load balancer due to TCP SYN floods from a DDoS attack",
      "The network latency caused by multicast messaging in a cluster"
    ],
    "answer": "When a cache stampede causes a massive spike in database load after a popular key expires",
    "explanation": "This occurs when a specific cached item expires, and numerous concurrent requests simultaneously miss the cache, hitting the origin database to repopulate it.",
    "difficulty": "Advanced"
  },
  {
    "id": 48,
    "question": "Why are B-Trees generally preferred over Hash Maps for indexing in relational databases?",
    "options": [
      "Hash Maps do not support O(1) lookups for range queries",
      "B-Trees maintain sorted order, enabling efficient range scans and prefix searches",
      "B-Trees use less memory overhead than Hash Maps",
      "Hash Maps cannot handle duplicate keys in a database index"
    ],
    "answer": "B-Trees maintain sorted order, enabling efficient range scans and prefix searches",
    "explanation": "Hash maps offer O(1) point lookups but cannot efficiently retrieve ordered data. B-Trees keep data sorted, which is critical for SQL operations like `WHERE x > 5`.",
    "difficulty": "Advanced"
  },
  {
    "id": 49,
    "question": "What distinguishes 'Optimistic Locking' from 'Pessimistic Locking' in database transaction management?",
    "options": [
      "Optimistic locking uses shared locks, while pessimistic locking uses exclusive locks",
      "Optimistic locking assumes conflicts are rare and checks at commit time, while pessimistic locking locks resources upfront",
      "Pessimistic locking is non-blocking, while optimistic locking blocks readers",
      "Optimistic locking is only applicable to distributed systems, not single-node databases"
    ],
    "answer": "Optimistic locking assumes conflicts are rare and checks at commit time, while pessimistic locking locks resources upfront",
    "explanation": "Optimistic control relies on versioning or timestamps to detect conflicts only upon transaction commitment, avoiding the overhead of long-held locks required by pessimistic approaches.",
    "difficulty": "Advanced"
  },
  {
    "id": 50,
    "question": "In a System Design interview, how does the 'Leaky Bucket' algorithm differ from the 'Fixed Window' algorithm for rate limiting?",
    "options": [
      "Fixed Window is smoother but allows bursts at the boundary of windows",
      "Leaky Bucket smooths out traffic bursts and strictly enforces a constant rate, whereas Fixed Window allows bursts",
      "Fixed Window is computationally more expensive than Leaky Bucket",
      "Leaky Bucket allows requests to be processed immediately regardless of queue size"
    ],
    "answer": "Leaky Bucket smooths out traffic bursts and strictly enforces a constant rate, whereas Fixed Window allows bursts",
    "explanation": "The Leaky Bucket acts like a queue with a fixed outflow rate, handling bursts by queuing them. Fixed Window resets limits at specific intervals, potentially doubling the permitted rate at the window boundary.",
    "difficulty": "Advanced"
  },
  {
    "id": 51,
    "question": "When designing a URL Shortener (like Bitly), why is using a base-62 encoding scheme (0-9, a-z, A-Z) more efficient than a standard UUID?",
    "options": [
      "UUIDs are sequential and predictable, posing a security risk",
      "Base-62 encoding creates shorter, human-readable strings using the same 128-bit entropy",
      "UUIDs require a database lookup to verify uniqueness, whereas base-62 does not",
      "Base-62 encoding distributes load more evenly across shards"
    ],
    "answer": "Base-62 encoding creates shorter, human-readable strings using the same 128-bit entropy",
    "explanation": "A UUID is typically 36 hex characters. Mapping the same ID (or a counter) to base-62 creates a significantly shorter string, making it more suitable for URLs.",
    "difficulty": "Advanced"
  },
  {
    "id": 52,
    "question": "What is the primary purpose of a 'Write-Ahead Log' (WAL) in database architecture?",
    "options": [
      "To store user data before it is written to the final disk location for crash recovery",
      "To maintain a history of all user queries for auditing purposes",
      "To replicate data to secondary nodes in a master-slave topology",
      "To optimize read performance by caching frequently accessed rows"
    ],
    "answer": "To store user data before it is written to the final disk location for crash recovery",
    "explanation": "WAL ensures atomicity and durability by writing changes to a sequential log *before* applying them to the actual data files, enabling recovery after a crash.",
    "difficulty": "Advanced"
  },
  {
    "id": 53,
    "question": "How does 'Consistent Hashing' solve the problem of 'hot spots' and rehashing in distributed caches?",
    "options": [
      "It assigns data to nodes based on a modulo of the key, ensuring perfectly even distribution",
      "It maps both data and nodes to a ring, minimizing data movement when nodes are added or removed",
      "It automatically replicates data to the node with the lowest CPU usage",
      "It requires a central lookup service to track the location of every key"
    ],
    "answer": "It maps both data and nodes to a ring, minimizing data movement when nodes are added or removed",
    "explanation": "Unlike modulo mapping, consistent hashing ensures that adding/removing a node only affects the keys adjacent to it on the hash ring, preventing massive cache invalidation.",
    "difficulty": "Advanced"
  },
  {
    "id": 54,
    "question": "In the context of Message Queues (e.g., RabbitMQ vs. Kafka), what defines a 'competing consumer' pattern?",
    "options": [
      "Multiple consumers read the same message simultaneously to increase processing redundancy",
      "A message is delivered to only one consumer in a group to ensure it is processed exactly once",
      "Consumers compete for TCP connections to the broker, causing connection churn",
      "Messages are persisted to disk before being acknowledged by the consumer"
    ],
    "answer": "A message is delivered to only one consumer in a group to ensure it is processed exactly once",
    "explanation": "In a competing consumer pattern, a message is consumed by a single worker within a consumer group. This allows horizontal scaling of processing without duplicating work.",
    "difficulty": "Advanced"
  },
  {
    "id": 55,
    "question": "What is 'Chatty' UI behavior in the context of client-server architecture, and why is it discouraged for mobile applications?",
    "options": [
      "Frequent, small API calls that increase battery drain and latency due to network overhead",
      "Interfaces that provide verbose text descriptions instead of graphical icons",
      "Protocols that use encryption for every packet, slowing down the CPU",
      "Designs that require the user to type extensively instead of using voice input"
    ],
    "answer": "Frequent, small API calls that increase battery drain and latency due to network overhead",
    "explanation": "Mobile networks have high latency costs per request. 'Chatty' behavior (many round trips) degrades performance and battery life compared to 'Chunky' behavior (batched requests).",
    "difficulty": "Advanced"
  },
  {
    "id": 56,
    "question": "What is the fundamental difference between 'Horizontal' and 'Vertical' scaling (Sharding vs. Scaling Up)?",
    "options": [
      "Vertical scaling involves adding more logic servers, while horizontal scaling involves upgrading the mainframe",
      "Horizontal scaling adds more instances of a machine, while vertical scaling increases the power of an existing machine",
      "Horizontal scaling is always cheaper but harder to maintain, while vertical scaling requires code changes",
      "Vertical scaling splits the database, while horizontal scaling replicates the code"
    ],
    "answer": "Horizontal scaling adds more instances of a machine, while vertical scaling increases the power of an existing machine",
    "explanation": "Vertical scaling (Scale Up) increases resources (CPU/RAM) on a single node. Horizontal scaling (Scale Out) distributes load across multiple nodes.",
    "difficulty": "Advanced"
  },
  {
    "id": 57,
    "question": "Why might a candidate choose a 'NoSQL' key-value store over a relational database for a user session store?",
    "options": [
      "Relational databases cannot store temporary data due to ACID constraints",
      "Key-value stores offer faster access times and simpler data models for unstructured blobs like session data",
      "NoSQL databases automatically encrypt data at rest, which RDBMS cannot do",
      "Key-value stores guarantee strong consistency across global regions without latency"
    ],
    "answer": "Key-value stores offer faster access times and simpler data models for unstructured blobs like session data",
    "explanation": "Session data usually doesn't require complex relationships (joins). Key-value stores (like Redis) provide O(1) access and often support TTL (Time To Live) natively.",
    "difficulty": "Advanced"
  },
  {
    "id": 58,
    "question": "In SQL, what is a 'Clustered Index' and how does it differ from a 'Non-Clustered Index'?",
    "options": [
      "A clustered index is a sorted copy of the data, while a non-clustered index points to the original data",
      "A clustered index is stored on a separate disk, while a non-clustered index is in memory",
      "A non-clustered index dictates the physical order of the table, while a clustered index does not",
      "There is no difference; they are synonyms depending on the database vendor"
    ],
    "answer": "A clustered index is a sorted copy of the data, while a non-clustered index points to the original data",
    "explanation": "A clustered index defines the physical order of data in the table (there can be only one). A non-clustered index is a separate structure containing pointers to the data.",
    "difficulty": "Advanced"
  },
  {
    "id": 59,
    "question": "What is the significance of 'Time-To-First-Byte' (TTFB) in web performance optimization?",
    "options": [
      "It measures the time taken for the client to upload the request payload",
      "It represents the duration between the request start and the first byte of the response received, indicating server processing speed",
      "It is the time taken for the browser to parse the HTML and construct the DOM",
      "It measures the total time to load the Last-Modified header"
    ],
    "answer": "It represents the duration between the request start and the first byte of the response received, indicating server processing speed",
    "explanation": "TTFB captures the network latency plus the time the server takes to generate and begin sending the response. High TTFB indicates slow backend logic or network issues.",
    "difficulty": "Advanced"
  },
  {
    "id": 60,
    "question": "When designing a 'unique ID generator' (like Snowflake), why is combining a timestamp, machine ID, and sequence number preferred over a simple UUID?",
    "options": [
      "UUIDs are monotonic, making database index insertions slow",
      "The compound approach generates roughly sortable IDs that are smaller than UUIDs",
      "Simple UUIDs cannot guarantee uniqueness across different data centers",
      "The compound approach does not require a centralized coordination service"
    ],
    "answer": "The compound approach generates roughly sortable IDs that are smaller than UUIDs",
    "explanation": "Snowflake-like IDs embed the timestamp, making them roughly time-ordered (good for B-Tree indexes) and usually 64-bit integers (smaller) compared to 128-bit UUIDs.",
    "difficulty": "Advanced"
  },
  {
    "id": 61,
    "question": "What is 'Idempotency' in the context of RESTful API design, and why is it critical for distributed systems?",
    "options": [
      "The ability of an API to return different results for the same request based on state",
      "The property where making the same request multiple times has the same effect as making it once",
      "A security mechanism that prevents SQL injection attacks",
      "The requirement that every API endpoint must use the POST method"
    ],
    "answer": "The property where making the same request multiple times has the same effect as making it once",
    "explanation": "Idempotency ensures that safe retries of a request (due to network failures) do not result in duplicate transactions or unintended side effects.",
    "difficulty": "Advanced"
  },
  {
    "id": 62,
    "question": "In the 'Observer' pattern vs. 'Pub-Sub' pattern, what is the architectural difference regarding coupling?",
    "options": [
      "The Observer pattern is tightly coupled (subjects know observers), while Pub-Sub uses a message broker for decoupling",
      "Pub-Sub is synchronous, while Observer is asynchronous",
      "The Observer pattern requires a database backend, while Pub-Sub uses in-memory storage",
      "There is no difference; they are identical patterns"
    ],
    "answer": "The Observer pattern is tightly coupled (subjects know observers), while Pub-Sub uses a message broker for decoupling",
    "explanation": "In the Observer pattern, the Subject maintains a list of Observers. In Pub-Sub, publishers and subscribers are decoupled by an event bus or broker.",
    "difficulty": "Advanced"
  },
  {
    "id": 63,
    "question": "What is a 'Bloom Filter' and what is its primary trade-off?",
    "options": [
      "A data structure that stores key-value pairs with O(1) access but high memory usage",
      "A probabilistic data structure that tests set membership efficiently, allowing false positives but never false negatives",
      "A sorting algorithm that guarantees O(n) time complexity for integers",
      "A network protocol that filters DDoS attacks based on IP reputation"
    ],
    "answer": "A probabilistic data structure that tests set membership efficiently, allowing false positives but never false negatives",
    "explanation": "Bloom filters are extremely space-efficient but have a probability of false positives (claiming an element is in the set when it isn't). False negatives are impossible.",
    "difficulty": "Advanced"
  },
  {
    "id": 64,
    "question": "How does 'Long Polling' differ from 'WebSockets' for real-time data?",
    "options": [
      "Long Polling keeps a connection open indefinitely; WebSockets close after every request",
      "Long Polling is a server-sent hack involving repeated request/response cycles; WebSockets provide full-duplex persistent communication",
      "WebSockets use the HTTP protocol, while Long Polling uses raw TCP",
      "Long Polling is faster than WebSockets because it uses UDP"
    ],
    "answer": "Long Polling is a server-sent hack involving repeated request/response cycles; WebSockets provide full-duplex persistent communication",
    "explanation": "Long polling creates latency by re-establishing connections. WebSockets upgrade the HTTP connection to a persistent TCP socket, allowing low-latency bi-directional messaging.",
    "difficulty": "Advanced"
  },
  {
    "id": 65,
    "question": "In the CAP Theorem, what characteristic must be sacrificed to maintain 'Consistency' and 'Partition Tolerance' (CP)?",
    "options": [
      "Latency",
      "Availability",
      "Durability",
      "Scalability"
    ],
    "answer": "Availability",
    "explanation": "In a CP system (e.g., HBase, MongoDB), if a partition occurs, the system may reject requests to ensure consistency, thereby sacrificing availability.",
    "difficulty": "Advanced"
  },
  {
    "id": 66,
    "question": "What is the 'Sidecar' pattern in the context of Microservices architecture?",
    "options": [
      "Deploying two identical services in parallel for redundancy",
      "A helper process running alongside the service to offload core functionality like logging or monitoring",
      "A database pattern where data is written to the side before the main table",
      "A load balancing algorithm that prefers the server with the most available RAM"
    ],
    "answer": "A helper process running alongside the service to offload core functionality like logging or monitoring",
    "explanation": "The sidecar pattern extends the functionality of a container (e.g., adding a proxy, log collector) without modifying the main application code.",
    "difficulty": "Advanced"
  },
  {
    "id": 67,
    "question": "When implementing a 'Circuit Breaker', what is the purpose of the 'Half-Open' state?",
    "options": [
      "To allow all traffic through while monitoring for errors",
      "To block all traffic indefinitely until a manual reset",
      "To route requests to a backup data center",
      "To send a limited number of test requests to verify if the downstream service has recovered"
    ],
    "answer": "To send a limited number of test requests to verify if the downstream service has recovered",
    "explanation": "After the Circuit Breaker trips (Open), it moves to Half-Open to check if the service is healthy. If the test succeeds, it closes; otherwise, it reopens.",
    "difficulty": "Advanced"
  },
  {
    "id": 68,
    "question": "Why are 'Composite Indexes' (e.g., on columns A, B, C) sensitive to column order?",
    "options": [
      "The database can only use the index if all columns in the index are queried",
      "The index can be efficiently used for queries filtering on A, or A and B, but not efficiently for queries filtering on B alone",
      "Composite indexes sort data only by the first column; others are ignored",
      "The order only matters for INSERT operations, not SELECT"
    ],
    "answer": "The index can be efficiently used for queries filtering on A, or A and B, but not efficiently for queries filtering on B alone",
    "explanation": "B-Tree indexes are sorted left-to-right. Searching on a prefix (A) is fast, but skipping the leftmost column (searching only B) usually requires a full scan.",
    "difficulty": "Advanced"
  },
  {
    "id": 69,
    "question": "What is the 'Phantom Read' anomaly in database concurrency, and how does it differ from 'Non-Repeatable Read'?",
    "options": [
      "Phantom Read involves seeing different values for existing rows; Non-Repeatable Read involves seeing new rows",
      "Phantom Read involves seeing a different set of rows in a re-query; Non-Repeatable Read involves different values in existing rows",
      "Phantom Read is caused by dirty writes, while Non-Repeatable Read is caused by locking",
      "They are identical terms used by different database vendors"
    ],
    "answer": "Phantom Read involves seeing a different set of rows in a re-query; Non-Repeatable Read involves different values in existing rows",
    "explanation": "Non-repeatable reads occur when a row is updated by another transaction. Phantom reads occur when new rows are added (or deleted) by another transaction.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "In the context of scalability, what is 'Fan-Out' when using a message queue?",
    "options": [
      "Disconnecting consumers to reduce load",
      "Broadcasting a single message to multiple independent queues or consumers for parallel processing",
      "Aggregating multiple logs into a single stream",
      "Increasing the memory allocated to the queue buffer"
    ],
    "answer": "Broadcasting a single message to multiple independent queues or consumers for parallel processing",
    "explanation": "Fan-out allows one message to be processed by multiple consumers for different purposes (e.g., one for analytics, one for caching) simultaneously.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the 'Read-Repair' mechanism in Dynamo-style databases?",
    "options": [
      "A process that reads from a quorum of nodes and updates any node with stale data in the background",
      "Stopping all write operations to fix data corruption on the disk",
      "Re-reading the data from the write-ahead log after a crash",
      "A client-side retry mechanism for failed reads"
    ],
    "answer": "A process that reads from a quorum of nodes and updates any node with stale data in the background",
    "explanation": "During a read, if versions differ, the system returns the latest version and asynchronously pushes the update to nodes that held stale data.",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "Why is 'Pre-computation' (or Materialized Views) used in Data Warehousing/Analytics?",
    "options": [
      "To reduce the storage footprint of the database",
      "To shift the computational cost from query-time to load-time, speeding up complex read queries",
      "To ensure ACID compliance for transactional workloads",
      "To prevent SQL injection attacks"
    ],
    "answer": "To shift the computational cost from query-time to load-time, speeding up complex read queries",
    "explanation": "Analytical queries often involve heavy aggregations. Pre-calculating these results allows for sub-second query performance at the cost of slower data ingestion.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In a behavioral interview, what specific aspect of the 'STAR' method (Situation, Task, Action, Result) is most critical for demonstrating seniority?",
    "options": [
      "Situation: Describing the context in extreme detail",
      "Task: Explaining what the manager assigned",
      "Action: Focusing on the specific 'I' actions taken to solve the problem, rather than 'We'",
      "Result: Stating that the project was completed successfully"
    ],
    "answer": "Action: Focusing on the specific 'I' actions taken to solve the problem, rather than 'We'",
    "explanation": "Seniority is demonstrated by showing personal agency and problem-solving ownership. Using 'We' dilutes the candidate's specific contribution.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is the 'Two-Phase Commit' (2PC) protocol in distributed transactions?",
    "options": [
      "A protocol where the coordinator asks nodes to 'Prepare' and then 'Commit', ensuring atomicity but blocking if a node fails",
      "A method where nodes commit data immediately and notify the coordinator later",
      "A non-blocking consensus algorithm used primarily in Blockchain",
      "A backup strategy that writes to two different databases simultaneously without coordination"
    ],
    "answer": "A protocol where the coordinator asks nodes to 'Prepare' and then 'Commit', ensuring atomicity but blocking if a node fails",
    "explanation": "2PC ensures atomicity across nodes but is blocking and single-point-of-coordinator heavy, making it fragile for highly available systems compared to eventual consistency models.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "When optimizing a hash table for performance, what is the primary disadvantage of 'Open Addressing' compared to 'Chaining' for collision resolution?",
    "options": [
      "Open addressing requires more memory for pointer storage",
      "Open addressing leads to clustering and degraded performance as the load factor approaches 1.0",
      "Open addressing cannot handle deletions",
      "Chaining is slower because it requires random disk access"
    ],
    "answer": "Open addressing leads to clustering and degraded performance as the load factor approaches 1.0",
    "explanation": "In open addressing, collisions are resolved by finding the next open slot (probing). High load factors lead to long probe chains (clustering), slowing down lookups significantly.",
    "difficulty": "Advanced"
  }
]