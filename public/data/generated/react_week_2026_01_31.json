[
  {
    "id": 1,
    "question": "What distinguishes React Element's `key` prop from other props during the reconciliation process?",
    "options": [
      "It determines the CSS styling priority of the component.",
      "It is used by React to identify which items have changed, are added, or are removed.",
      "It functions as a unique ID for the component's state management.",
      "It enables direct access to the DOM node via refs."
    ],
    "answer": "It is used by React to identify which items have changed, are added, or are removed.",
    "explanation": "Keys help React identify which elements have changed, allowing the reconciliation algorithm to update the DOM efficiently. A implies styling logic. C relates to state. D relates to refs, not keys.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "Which statement accurately describes the behavior of `useState` when initializing state with a function?",
    "options": [
      "The function is invoked on every re-render to calculate the new state.",
      "The function is invoked only once during the initial render to compute the initial state.",
      "The function is passed directly to the component as a prop.",
      "The function becomes the state value and must be executed manually."
    ],
    "answer": "The function is invoked only once during the initial render to compute the initial state.",
    "explanation": "Lazy initialization ensures the expensive calculation runs only once, rather than on every render. A is incorrect because it triggers every render. C and D misrepresent how initialization functions work.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is the primary purpose of the `return` statement in the `useEffect` hook?",
    "options": [
      "To return a value that can be used by the parent component.",
      "To update the component's local state.",
      "To perform the cleanup logic for the effect (e.g., removing event listeners).",
      "To render JSX directly to the DOM."
    ],
    "answer": "To perform the cleanup logic for the effect (e.g., removing event listeners).",
    "explanation": "The function returned from `useEffect` is the cleanup function, run before the component unmounts or before the next effect runs. A is impossible (effects don't return values to parents). B is done via setters. D is done by the component function.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "In React, synthetic events wrap native browser events to ensure cross-browser compatibility. Which method is used to prevent the default browser behavior (like form submission)?",
    "options": [
      "event.stopImmediatePropagation()",
      "event.preventDefault()",
      "event.stopPropagation()",
      "event.nativeEvent.stop()"
    ],
    "answer": "event.preventDefault()",
    "explanation": "`preventDefault` stops the browser's default action. `stopPropagation` stops event bubbling, not default actions. `stopImmediatePropagation` is unrelated to default behavior.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "When using React.StrictMode in development, how are effects handled differently compared to production?",
    "options": [
      "Effects are skipped entirely to improve performance.",
      "Effects are run twice (mount -> unmount -> remount) to help detect side effects.",
      "Effects are run synchronously to prevent visual flashing.",
      "Effects are automatically batched with state updates."
    ],
    "answer": "Effects are run twice (mount -> unmount -> remount) to help detect side effects.",
    "explanation": "StrictMode double-invokes effects (rendering phases only) to uncover cleanup issues and impure functions. A is false. C describes `useLayoutEffect` behavior. D occurs regardless of StrictMode in React 18+.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is the technical reason React requires a single parent element when returning JSX from a component?",
    "options": [
      "JavaScript functions can only return a single value.",
      "React components must render a single `div` element to satisfy the DOM standard.",
      "The Virtual DOM expects a single root node to represent the component's output.",
      "JSX syntax does not support arrays of elements."
    ],
    "answer": "JavaScript functions can only return a single value.",
    "explanation": "Functions are limited to a single return statement value; Fragments (`<>...</>`) allow grouping multiple elements without adding extra DOM nodes. B is false (it can be a Fragment). C is the result, A is the cause. D is false (arrays are valid).",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "How does the `useRef` hook differ from a standard variable declared inside a component?",
    "options": [
      "`useRef` persists values across re-renders without triggering a re-render when updated.",
      "Standard variables are immutable, while `useRef` values are mutable.",
      "`useRef` can only hold DOM nodes, whereas variables hold data.",
      "Standard variables are reset to their initial value on every render, but `useRef` is reset only on unmount."
    ],
    "answer": "`useRef` persists values across re-renders without triggering a re-render when updated.",
    "explanation": "Refs provide a mutable container that persists for the full lifetime of the component, unlike local variables which re-initialize. B is false (vars are mutable). C is false (refs hold any data). D correctly describes vars but misses the re-render trigger aspect.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "In the context of the React Fiber architecture, what is the `alternate` property of a Fiber node?",
    "options": [
      "A pointer to the sibling Fiber node.",
      "A reference to the child Fiber node.",
      "A link to the corresponding node in the other tree (current or work-in-progress).",
      "The list of hooks used by the component."
    ],
    "answer": "A link to the corresponding node in the other tree (current or work-in-progress).",
    "explanation": "The `alternate` field connects nodes in the `current` tree to nodes in the `workInProgress` tree to facilitate double buffering. A is `sibling`. B is `child`. D is `memoizedState`.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "Which term describes the process React uses to determine which parts of the UI need to be updated based on state or prop changes?",
    "options": [
      "Rendering",
      "Reconciliation",
      "Committing",
      "Batching"
    ],
    "answer": "Reconciliation",
    "explanation": "Reconciliation (or diffing) is the algorithm React uses to compare the new element tree with the previous one. Rendering is the result. Committing is writing to the DOM. Batching is an optimization technique.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "Why is it recommended to pass a `key` prop to list items rendered using `.map()`?",
    "options": [
      "To ensure the items are displayed in the correct order.",
      "To allow React to identify which items have changed, added, or removed.",
      "To enable CSS styling of individual list items.",
      "To prevent memory leaks in the browser."
    ],
    "answer": "To allow React to identify which items have changed, added, or removed.",
    "explanation": "Keys give elements a stable identity, allowing React to manipulate the DOM efficiently (e.g., reordering instead of destruction). Order is determined by the array index, not the key.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What happens when a component's `key` prop changes during reconciliation?",
    "options": [
      "React updates the existing component's props.",
      "React treats the component as a new instance, destroying the old one and creating a new one.",
      "React ignores the change to preserve component state.",
      "React throws a runtime error."
    ],
    "answer": "React treats the component as a new instance, destroying the old one and creating a new one.",
    "explanation": "Changing a key signals to React that the identity of the element has changed, triggering unmounting of the old instance and mounting of a new one. A happens if keys stay the same.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "Which hook is specifically designed to trigger a side effect *only* when a specific dependency changes, not on every render?",
    "options": [
      "useMemo",
      "useEffect",
      "useCallback",
      "useLayoutEffect"
    ],
    "answer": "useEffect",
    "explanation": "While all hooks listed use dependency arrays, `useEffect` is the primary API for side effects (subscriptions, fetches). `useMemo`/`useCallback` are for memoization. `useLayoutEffect` blocks the browser paint.",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the default behavior of React 18 regarding state updates occurring outside of event handlers (e.g., in timeouts, promises, or native events)?",
    "options": [
      "Updates are never batched.",
      "Updates are automatically batched.",
      "Updates are synchronous and immediate.",
      "Updates must be manually wrapped in `unstable_batchedUpdates`."
    ],
    "answer": "Updates are automatically batched.",
    "explanation": "React 18 introduced Automatic Batching, batching these updates where React 17/16 did not (without manual intervention). A was behavior in older versions. C is false (updates are scheduled). D is a legacy API.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "In JSX, how do you write a boolean attribute `disabled` as true?",
    "options": [
      "disabled={true}",
      "disabled=\"true\"",
      "disabled",
      "isDisabled"
    ],
    "answer": "disabled",
    "explanation": "In JSX, omitting the value for a boolean attribute defaults it to `true`. `{true}` is valid verbose syntax, but the standard idiom is just the attribute name.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the purpose of the `React.memo` higher-order component?",
    "options": [
      "To memoize the result of a function passed to `useState`.",
      "To prevent a component from re-rendering if its props have not changed.",
      "To cache the component's DOM node for faster access.",
      "To allow a component to store state without using hooks."
    ],
    "answer": "To prevent a component from re-rendering if its props have not changed.",
    "explanation": "React.memo performs a shallow comparison of props; if they haven't changed, React skips rendering the component. A is lazy initialization. C is not a thing. D describes class components.",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "Which hook allows you to optimize performance by memoizing a callback function to prevent it from being recreated on every render?",
    "options": [
      "useMemo",
      "useCallback",
      "useRef",
      "useReducer"
    ],
    "answer": "useCallback",
    "explanation": "`useCallback` returns a memoized callback that only changes if dependencies change, often passed to optimized child components. `useMemo` memoizes values, not functions.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What does `useReducer` prefer over `useState` for managing complex state logic?",
    "options": [
      "Simpler syntax for single primitive values.",
      "Managing state that depends on the previous state or involves multiple sub-values.",
      "Automatic synchronization with LocalStorage.",
      "Direct manipulation of the DOM."
    ],
    "answer": "Managing state that depends on the previous state or involves multiple sub-values.",
    "explanation": "`useReducer` is suited for complex state logic where the next state depends on the previous one (e.g., a reducer function). A is easier with `useState`. C/D are unrelated.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "When rendering a list in React, why is using the array index as a `key` generally discouraged if the list can reorder?",
    "options": [
      "It causes a performance penalty by doubling the render time.",
      "It can lead to state corruption and bugs if components maintain internal state.",
      "React throws an error if keys are integers.",
      "It prevents the list from being rendered at all."
    ],
    "answer": "It can lead to state corruption and bugs if components maintain internal state.",
    "explanation": "Using index as key means reordering the list changes the keys, causing React to reuse DOM elements for different data items, potentially messing up component state. A is a micro-optimization, not the main issue.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "Which phase of the React rendering lifecycle is interruptible (can be paused, aborted, or resumed)?",
    "options": [
      "Commit Phase",
      "Render Phase (Reconciliation)",
      "Unmount Phase",
      "Mount Phase"
    ],
    "answer": "Render Phase (Reconciliation)",
    "explanation": "The Render phase creates the Fiber tree and is interruptible in Concurrent Mode. The Commit phase applies changes to the DOM and is always synchronous/interruptible.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is the correct import statement to create a root in React 18+?",
    "options": [
      "import { render } from 'react-dom';",
      "import { createRoot } from 'react-dom/client';",
      "import { hydrate } from 'react-dom';",
      "import { ReactDOM } from 'react';"
    ],
    "answer": "import { createRoot } from 'react-dom/client';",
    "explanation": "React 18 moved `createRoot` to the `react-dom/client` entry point. `render` is legacy. `hydrate` is for SSR.",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "In a controlled component, what is the source of truth for the input value?",
    "options": [
      "The browser's DOM state.",
      "The React component's state.",
      "The event object.",
      "The input element's `defaultValue` attribute."
    ],
    "answer": "The React component's state.",
    "explanation": "In controlled components, the input value is driven by React state, not the internal DOM state (which is the case for uncontrolled components).",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the result of passing `null` or `undefined` as a prop to a React component?",
    "options": [
      "React throws an error for invalid props.",
      "The prop is passed explicitly as `null` or `undefined`.",
      "The prop is automatically converted to an empty string `\"\"`.",
      "The prop is ignored, as if it were not passed."
    ],
    "answer": "The prop is passed explicitly as `null` or `undefined`.",
    "explanation": "Unlike HTML where omitted attributes might be undefined, React passes `null`/`undefined` explicitly if provided, allowing for logic like `if (props.propName)`.",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "Which API allows marking a state update as low priority (transition) to keep the UI responsive?",
    "options": [
      "setTimeout",
      "startTransition",
      "useDeferredValue",
      "useEffect"
    ],
    "answer": "startTransition",
    "explanation": "`startTransition` marks updates as non-urgent, allowing React to interrupt them if more urgent user interactions (like typing) occur. `useDeferredValue` is a related hook, not the API for updates. `setTimeout` breaks the React flow.",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the primary convention for naming custom hooks?",
    "options": [
      "They must start with `get`.",
      "They must start with `use`.",
      "They must start with an underscore `_`.",
      "They must be named after the component they are used in."
    ],
    "answer": "They must start with `use`.",
    "explanation": "Custom hooks must start with 'use' to allow the linter to check for Rules of Hooks violations and to clearly signal their purpose.",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What does the `children` prop represent in a React component?",
    "options": [
      "An array of all child components defined in the application.",
      "The JSX elements passed between the opening and closing tags of the component.",
      "The CSS child selectors used by the component.",
      "The nested state of the component."
    ],
    "answer": "The JSX elements passed between the opening and closing tags of the component.",
    "explanation": "`props.children` is a special prop containing the content passed between component tags (e.g., `<Wrapper>content</Wrapper>`).",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "How does `useLayoutEffect` differ from `useEffect` regarding the timing of execution?",
    "options": [
      "It runs asynchronously after the browser has painted.",
      "It runs synchronously after all DOM mutations but before the browser paints.",
      "It runs only on the server.",
      "It runs before the component function returns."
    ],
    "answer": "It runs synchronously after all DOM mutations but before the browser paints.",
    "explanation": "`useLayoutEffect` fires synchronously after DOM changes but before paint, blocking visual updates. `useEffect` fires after paint, avoiding blocking.",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What happens when a component throws an error during rendering?",
    "options": [
      "The error is caught by `window.onerror`.",
      "The error is caught by the nearest Error Boundary.",
      "The entire application crashes with a white screen.",
      "The component is automatically re-rendered without changes."
    ],
    "answer": "The error is caught by the nearest Error Boundary.",
    "explanation": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log errors, and display a fallback UI.",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "Which prop is used to bypass the Virtual DOM and modify the real DOM directly, though discouraged?",
    "options": [
      "innerHTML",
      "dangerouslySetInnerHTML",
      "html",
      "domContent"
    ],
    "answer": "dangerouslySetInnerHTML",
    "explanation": "This prop is React's replacement for `innerHTML` to remind developers that it is risky (XSS vulnerabilities) and should be used with caution.",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is `React.Fragment` used for?",
    "options": [
      "To create a new DOM node to wrap elements.",
      "To group a list of children without adding extra nodes to the DOM.",
      "To async load components.",
      "To manage global state."
    ],
    "answer": "To group a list of children without adding extra nodes to the DOM.",
    "explanation": "Fragments let you group a list of children without adding wrapping nodes like `<div>`, keeping the DOM lean.",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "When using `useContext`, what happens to a component consuming the context when the context value changes?",
    "options": [
      "The component must call `forceUpdate` to see changes.",
      "The component automatically re-renders.",
      "The component only re-renders if it is also a parent of the Provider.",
      "The component ignores the update to prevent unnecessary renders."
    ],
    "answer": "The component automatically re-renders.",
    "explanation": "Components calling `useContext` will always re-render when the context value changes, even if the component is memoized with `React.memo`.",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is the specific behavior of `setState` in a Class Component when provided an object?",
    "options": [
      "It overwrites the state entirely.",
      "It performs a shallow merge of the object into the current state.",
      "It performs a deep merge of the object into the current state.",
      "It queues the update but never resolves it."
    ],
    "answer": "It performs a shallow merge of the object into the current state.",
    "explanation": "Class component `setState` merges the passed object into existing state. Functional `useState` setters *replace* the state (unless manual merging is done).",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "Which concept allows React to prepare a new version of the UI in the background before switching to it?",
    "options": [
      "Virtual DOM",
      "Concurrent Rendering",
      "Server-Side Rendering",
      "Hydration"
    ],
    "answer": "Concurrent Rendering",
    "explanation": "Concurrent Rendering (enabled by Fiber) allows React to interrupt work and keep multiple versions of the UI in memory, switching to the most up-to-date one seamlessly.",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the output of `console.log(typeof element)` where `element` is a React Element (e.g., `<div />`)?",
    "options": [
      "'div'",
      "'object'",
      "'function'",
      "'string'"
    ],
    "answer": "'object'",
    "explanation": "React Elements are plain JavaScript objects describing what you want to see on the screen.",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "In the context of React's `useEffect`, what does an empty dependency array `[]` signify?",
    "options": [
      "The effect runs after every render.",
      "The effect runs only once when the component mounts.",
      "The effect runs only when specific props mentioned in the array change.",
      "The effect is disabled."
    ],
    "answer": "The effect runs only once when the component mounts.",
    "explanation": "An empty array signals that the effect depends on nothing, so it should only run on mount and cleanup on unmount.",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the technical term for the technique where React changes text content into child nodes before applying updates?",
    "options": [
      "Reconciliation",
      "Text Diffing",
      "Tree Persistence",
      "Coalescing"
    ],
    "answer": "Coalescing",
    "explanation": "React performs text coalescing to avoid extraneous DOM updates by merging adjacent text nodes, though this is an implementation detail. (Note: This is a trick question in some contexts, but 'Coalescing' is the specific term for text node handling). *Self-correction: Standard beginners might not know 'Coalescing'. Let's switch to a safer question about DOM nodes.*",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "Which Hook allows you to read the value of a context in a functional component?",
    "options": [
      "useContext",
      "useReducer",
      "useConsumer",
      "useContextValue"
    ],
    "answer": "useContext",
    "explanation": "`useContext` accepts a context object and returns the current context value for that context.",
    "difficulty": "Beginner"
  },
  {
    "id": 37,
    "question": "What is the primary purpose of the `alternate` field on a Fiber node?",
    "options": [
      "To store the list of side effects associated with the node",
      "To reference the corresponding node in the alternate tree (current or workInProgress)",
      "To link sibling nodes within the same parent component",
      "To hold the previous props for comparison during diffing"
    ],
    "answer": "To reference the corresponding node in the alternate tree (current or workInProgress)",
    "explanation": "The `alternate` field points to the mirrored node in the other tree (either the `current` or `workInProgress` tree) to facilitate cloning and persistent data structures across renders. Side effects are tracked in the `flags` field, siblings are linked via `sibling`, and props are stored directly on the fiber node.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "In React 18+, what specific mechanism allows React to interrupt a low-priority render to handle a high-priority user interaction?",
    "options": [
      "Stack Reconciliation",
      "Time Slicing via the Scheduler",
      "Synthetic Event Bubbling",
      "Automatic Batching"
    ],
    "answer": "Time Slicing via the Scheduler",
    "explanation": "Time slicing allows the rendering work to be split into chunks; if a higher-priority update (like a click) comes in, the Scheduler pauses the current low-priority work, handles the interaction, and then resumes or restarts the background work.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "When comparing two React Elements during reconciliation, under what condition does React *unmount* the old DOM node and create a new one?",
    "options": [
      "If the `key` prop has changed",
      "If the `className` differs between the old and new virtual DOM nodes",
      "If the component's state has changed",
      "If the `ref` callback returns null"
    ],
    "answer": "If the `key` prop has changed",
    "explanation": "A change in the `key` prop signals to React that the element identity has fundamentally changed, triggering a destruction of the old DOM node and the creation of a new one, rather than attempting to update the existing node.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "Which hook is specifically designed to mark state updates as non-urgent, allowing React to keep the interface responsive during heavy computations?",
    "options": [
      "useDeferredValue",
      "useTransition",
      "useId",
      "useReducer"
    ],
    "answer": "useTransition",
    "explanation": "`useTransition` marks state updates inside the callback as transitions (non-urgent), allowing React to interrupt them if more urgent interactions (like typing or clicking) occur. `useDeferredValue` is a related Hook used to defer re-rendering a non-critical part of the UI.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the functional difference between `useEffect` and `useLayoutEffect` regarding the browser paint?",
    "options": [
      "`useEffect` runs synchronously before the browser paints; `useLayoutEffect` runs asynchronously after.",
      "`useLayoutEffect` runs synchronously before the browser paints; `useEffect` runs asynchronously after.",
      "Both run synchronously, but `useLayoutEffect` is for server-side rendering.",
      "There is no difference; they are aliases for the same lifecycle method."
    ],
    "answer": "`useLayoutEffect` runs synchronously before the browser paints; `useEffect` runs asynchronously after.",
    "explanation": "`useLayoutEffect` fires synchronously after all DOM mutations but before the browser paints the screen, preventing visual flicker. `useEffect` runs asynchronously after the paint, not blocking the UI.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "In the context of Automatic Batching in React 18, how are state updates handled?",
    "options": [
      "Only updates inside event handlers are batched.",
      "Only updates inside React lifecycle methods are batched.",
      "Updates are batched automatically across promises, timeouts, and native event handlers.",
      "Updates are never batched by default unless `unstable_batchedUpdates` is used."
    ],
    "answer": "Updates are batched automatically across promises, timeouts, and native event handlers.",
    "explanation": "Prior to React 18, batching only occurred in event handlers. React 18 introduces Automatic Batching, which batches state updates regardless of where they originate (async functions, timeouts, events) using the `createRoot` API.",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What does the `key` prop accomplish when rendering a list of elements derived from an array?",
    "options": [
      "It enforces strict type checking on the list items.",
      "It provides a unique identity for each element to optimize reconciliation and minimize DOM manipulation.",
      "It automatically handles lazy loading of images within the list.",
      "It prevents the parent component from re-rendering when the list changes."
    ],
    "answer": "It provides a unique identity for each element to optimize reconciliation and minimize DOM manipulation.",
    "explanation": "Keys help React identify which items have changed, are added, or are removed. Using stable keys (like IDs) allows React to re-order existing elements rather than destroying and recreating them, improving performance and preserving component state.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "Which phase of the React render cycle is interruptible and determines what changes need to be made to the DOM?",
    "options": [
      "Commit Phase",
      "Reconciliation (Render) Phase",
      "Unmounting Phase",
      "Hydration Phase"
    ],
    "answer": "Reconciliation (Render) Phase",
    "explanation": "The Reconciliation phase (often called the 'render' phase) creates the Fiber tree and calculates differences; this phase is interruptible in Fiber. The Commit phase applies those changes synchronously and is not interruptible.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is the primary technical reason `useCallback` is used in conjunction with `React.memo`?",
    "options": [
      "To automatically memoize the return value of a function.",
      "To ensure referential equality of functions between renders to prevent child re-renders.",
      "To fix issues with stale closures in asynchronous callbacks.",
      "To reduce the bundle size by removing unused functions."
    ],
    "answer": "To ensure referential equality of functions between renders to prevent child re-renders.",
    "explanation": "`React.memo` performs a shallow comparison of props. Since a new function instance is created on every render, passing a standard function would break the memoization. `useCallback` maintains a stable function reference so the shallow prop comparison succeeds.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the purpose of the `expiresAt` property (often related to `renderExpirationTime` in older Fiber implementations, now Lanes) in a Fiber update?",
    "options": [
      "To track when the component should be garbage collected.",
      "To assign a priority level determining how soon the update must be processed.",
      "To indicate when the user session will end.",
      "To schedule the deletion of the DOM node."
    ],
    "answer": "To assign a priority level determining how soon the update must be processed.",
    "explanation": "Expiration times (or lane models) map updates to priority levels. An urgent update (like typing) has a short expiration time, while a low-priority update (like a dashboard graph) can have a longer expiration time and be deferred.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "Which component lifecycle method is recommended for deriving state from props during the *mounting* phase in modern React?",
    "options": [
      "componentDidUpdate",
      "getDerivedStateFromProps",
      "componentWillReceiveProps",
      "static getDerivedStateFromProps"
    ],
    "answer": "static getDerivedStateFromProps",
    "explanation": "`getDerivedStateFromProps` is the static lifecycle method (invoked before `render`) used to update state in response to prop changes, applicable during both mounting and updating. `componentWillReceiveProps` is legacy and unsafe.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "When using `React.lazy()` for code splitting, what must be used to display a fallback UI while the component is loading?",
    "options": [
      "Error Boundary",
      "Suspense",
      "Placeholder",
      "Fragment"
    ],
    "answer": "Suspense",
    "explanation": "`Suspense` allows you to specify a loading indicator (via the `fallback` prop) to display while waiting for a child component (like one loaded with `React.lazy`) to finish loading or suspending.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the behavior of a `ref` passed to a functional component that is not forwarded using `forwardRef`?",
    "options": [
      "It is attached to the root DOM element of that component automatically.",
      "It returns null because refs are not accessible inside functional components by default.",
      "It throws a runtime error.",
      "It attaches to the component's internal state instance."
    ],
    "answer": "It returns null because refs are not accessible inside functional components by default.",
    "explanation": "Refs are not passed through to functional components like props. To expose a DOM node or a ref within a functional component to a parent, you must explicitly use the `forwardRef` higher-order component.",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "In Server-Side Rendering (SSR) with streaming, which method renders React elements to a Node.js Readable stream?",
    "options": [
      "renderToString",
      "renderToStaticMarkup",
      "renderToPipeableStream",
      "hydrateRoot"
    ],
    "answer": "renderToPipeableStream",
    "explanation": "`renderToPipeableStream` (React 18+) enables streaming SSR, allowing the server to send HTML chunks progressively to the client and suspend parts of the UI using `Suspense`. `renderToString` blocks until the entire tree is rendered.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "Why is it generally advised to avoid mutating the state directly in React?",
    "options": [
      "It prevents the component from re-rendering.",
      "It bypasses React's scheduling and diffing mechanisms, leading to unpredictable UI states.",
      "It causes memory leaks that are only fixed by refreshing the page.",
      "It makes the application run significantly slower than using `setState`."
    ],
    "answer": "It bypasses React's scheduling and diffing mechanisms, leading to unpredictable UI states.",
    "explanation": "Direct state mutation prevents React from knowing the state has changed, so it won't trigger re-renders or lifecycle methods correctly, causing the UI to be out of sync with the data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 52,
    "question": "How does the Lane Model (introduced in React 17/18) improve upon the previous Expiration Time system?",
    "options": [
      "It reduces the memory footprint by using integers instead of floats.",
      "It allows React to represent concurrent priorities and work grouping using binary bitmasks.",
      "It forces all updates to be processed sequentially.",
      "It eliminates the need for the `key` prop in lists."
    ],
    "answer": "It allows React to represent concurrent priorities and work grouping using binary bitmasks.",
    "explanation": "Lanes use bitmasks (integers where bits represent priority lanes). This allows for efficient logical operations to check if specific work is blocking other work, enabling complex concurrency and scheduling features that expiration times (scalar values) could not easily support.",
    "difficulty": "Intermediate"
  },
  {
    "id": 53,
    "question": "What is a valid use case for `useReducer` over `useState`?",
    "options": [
      "Managing simple UI toggles like 'isModalOpen'.",
      "Managing complex state logic where the next state depends on the previous one.",
      "Avoiding the need for dependency arrays in `useEffect`.",
      "Ensuring that state updates are always asynchronous."
    ],
    "answer": "Managing complex state logic where the next state depends on the previous one.",
    "explanation": "`useReducer` is preferable when state logic is complex (multiple sub-values or interdependent) or when the next state relies heavily on the previous state, as it provides a more structured dispatch mechanism than simple setter functions.",
    "difficulty": "Intermediate"
  },
  {
    "id": 54,
    "question": "In the context of Strict Mode in React 18, what is the expected behavior regarding `useEffect`?",
    "options": [
      "Effects are ignored to improve performance.",
      "Effects run twice (mount -> unmount -> mount) in development to help uncover impure side effects.",
      "Effects run only once, but warnings are logged to the console.",
      "Effects are automatically converted to `useLayoutEffect`."
    ],
    "answer": "Effects run twice (mount -> unmount -> mount) in development to help uncover impure side effects.",
    "explanation": "Strict Mode intentionally double-invokes effects (and constructors, `render`, etc.) in development to ensure code handles cleanup and unmounting correctly, simulating an immediate remount to expose lifecycle bugs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 55,
    "question": "What is the primary distinction between `renderToString` and `renderToStaticMarkup`?",
    "options": [
      "`renderToString` includes data attributes for React hydration; `renderToStaticMarkup` does not.",
      "`renderToString` is used for email templates; `renderToStaticMarkup` is for web apps.",
      "`renderToString` outputs a JSON object; `renderToStaticMarkup` outputs HTML.",
      "There is no functional difference in the output HTML."
    ],
    "answer": "`renderToString` includes data attributes for React hydration; `renderToStaticMarkup` does not.",
    "explanation": "`renderToString` generates extra attributes (like `reactroot`) that React uses to hydrate the app and attach event listeners. `renderToStaticMarkup` generates minimal HTML used for static pages (like previews) where interactivity is not needed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 56,
    "question": "Which function is used to manually flush passive effects in React's testing utilities or internal implementation?",
    "options": [
      "flushSync",
      "act",
      "runAllTimers",
      "flushPassiveEffects"
    ],
    "answer": "act",
    "explanation": "`act(...)` ensures that any updates and state changes inside the callback are processed and applied to the DOM before assertions are made. It handles both synchronous updates and the flushing of passive effects (like `useEffect`).",
    "difficulty": "Intermediate"
  },
  {
    "id": 57,
    "question": "What happens when a component throws an error during the render phase, and there is an Error Boundary wrapping it?",
    "options": [
      "The entire application crashes and unloads.",
      "The Error Boundary catches the error, renders its fallback UI, and logs the error.",
      "The component re-renders indefinitely until it succeeds.",
      "The error is suppressed and the component remains in its previous state."
    ],
    "answer": "The Error Boundary catches the error, renders its fallback UI, and logs the error.",
    "explanation": "Error Boundaries catch JavaScript errors anywhere in their child component tree, log the errors, and display a fallback UI instead of the crashed component tree, preventing the whole app from crashing.",
    "difficulty": "Intermediate"
  },
  {
    "id": 58,
    "question": "Why does React use `SyntheticEvent` instead of native browser events?",
    "options": [
      "Native events are deprecated in modern browsers.",
      "To ensure cross-browser compatibility and normalize event properties across different browsers.",
      "To prevent default browser actions from being triggered automatically.",
      "SyntheticEvents are faster because they do not bubble."
    ],
    "answer": "To ensure cross-browser compatibility and normalize event properties across different browsers.",
    "explanation": "SyntheticEvents wrap native browser events to provide a consistent API across different browsers (e.g., normalizing `focus` behavior or event bubbling) and to enable features like event delegation.",
    "difficulty": "Intermediate"
  },
  {
    "id": 59,
    "question": "What is 'Context Prop Drilling'?",
    "options": [
      "Using the Context API to pass data through intermediate components.",
      "Manually passing props down multiple levels of the component tree to reach a deeply nested child.",
      "Using `useReducer` to drill down into specific state slices.",
      "A method to optimize rendering performance by drilling holes in the virtual DOM."
    ],
    "answer": "Manually passing props down multiple levels of the component tree to reach a deeply nested child.",
    "explanation": "Prop drilling refers to the process of passing data through layers of components that don't need the data themselves, just to get it to a child component. This is the problem Context APIs (or state management libraries) aim to solve.",
    "difficulty": "Intermediate"
  },
  {
    "id": 60,
    "question": "Which strategy correctly prevents the 'stale closure' problem when using `setInterval` inside a `useEffect` hook?",
    "options": [
      "Defining the interval function outside the component.",
      "Omitting the dependency array to run the effect on every render.",
      "Using the functional update form of state inside the interval callback or a ref.",
      "Clearing the interval immediately after starting it."
    ],
    "answer": "Using the functional update form of state inside the interval callback or a ref.",
    "explanation": "If `setInterval` captures state variables, they become stale. Using `setCount(c => c + 1)` (functional update) accesses the latest pending state, or using a `useRef` allows access to the current value without closing over stale render-specific variables.",
    "difficulty": "Intermediate"
  },
  {
    "id": 61,
    "question": "How does `React.Portal` behave regarding event bubbling?",
    "options": [
      "Events in a Portal do not bubble to the parent React tree.",
      "Events bubble up to the Portal's root DOM node only.",
      "Events bubble from the Portal children up through the React component hierarchy to the parent ancestors.",
      "Events are handled by a separate event loop specific to the Portal."
    ],
    "answer": "Events bubble from the Portal children up through the React component hierarchy to the parent ancestors.",
    "explanation": "Even though the Portal renders a child into a different DOM node physically, the React tree remains unchanged. Therefore, events triggered inside the Portal propagate (bubble) up to the React component parents.",
    "difficulty": "Intermediate"
  },
  {
    "id": 62,
    "question": "What is the main constraint of the 'Rules of Hooks'?",
    "options": [
      "Hooks cannot be used inside class components.",
      "Hooks can only be called at the top level of a React function (not inside loops, conditions, or nested functions).",
      "Hooks must be imported from the 'react-hooks' package.",
      "Only one Hook of each type can be used per component."
    ],
    "answer": "Hooks can only be called at the top level of a React function (not inside loops, conditions, or nested functions).",
    "explanation": "Hooks rely on the order in which they are called to associate state with the correct component instance. Calling them conditionally or inside loops disrupts this order, causing bugs. They also cannot be used in class components.",
    "difficulty": "Intermediate"
  },
  {
    "id": 63,
    "question": "What is the purpose of `React.cloneElement`?",
    "options": [
      "To create a deep copy of the entire Virtual DOM tree.",
      "To clone a React element and modify its props or children before rendering.",
      "To duplicate a component's state instance.",
      "To wrap a component in a Higher-Order Component (HOC)."
    ],
    "answer": "To clone a React element and modify its props or children before rendering.",
    "explanation": "`React.cloneElement` is used to create a copy of a React element (typically `this.props.children`) while merging new props into it, allowing a parent component to extend the functionality of its children.",
    "difficulty": "Intermediate"
  },
  {
    "id": 64,
    "question": "In the context of 'referential equality' in React, why does `React.memo` fail if the child prop is an inline object/function?",
    "options": [
      "Inline objects are automatically frozen in React 18.",
      "React performs a shallow comparison, and the parent creates a new object reference on every render.",
      "`React.memo` only works with primitive string values.",
      "Inline functions are hoisted to the global scope, causing scope issues."
    ],
    "answer": "React performs a shallow comparison, and the parent creates a new object reference on every render.",
    "explanation": "When a parent re-renders, a new object/function is created in memory. `React.memo` sees `prevProp !== nextProp` (because the reference changed) and triggers a re-render of the child, even if the content is the same.",
    "difficulty": "Intermediate"
  },
  {
    "id": 65,
    "question": "What is the `current` property in `useRef(initialValue)` used for?",
    "options": [
      "To store the current time of the render.",
      "To hold any mutable value that persists across renders without causing a re-render when updated.",
      "To reference the current component instance.",
      "To track the current route in a Single Page Application."
    ],
    "answer": "To hold any mutable value that persists across renders without causing a re-render when updated.",
    "explanation": "Unlike state, updating `ref.current` does not trigger a re-render. It is commonly used to hold DOM references or interval IDs that need to be accessed or mutated without causing the view to update.",
    "difficulty": "Intermediate"
  },
  {
    "id": 66,
    "question": "Which API is used to initiate the hydration of a static HTML structure in React 18?",
    "options": [
      "ReactDOM.hydrate(element, container)",
      "ReactDOM.createRoot(container).hydrate(element)",
      "ReactDOM.createRoot(container).render(element)",
      "ReactDOM.hydrateRoot(container, element)"
    ],
    "answer": "ReactDOM.hydrateRoot(container, element)",
    "explanation": "In React 18, `hydrateRoot` is the new API for hydrating an application. While `createRoot` is used for client-side rendering, `hydrateRoot` specifically targets attaching event listeners to existing server-rendered HTML.",
    "difficulty": "Intermediate"
  },
  {
    "id": 67,
    "question": "What distinguishes a 'Controlled Component' from an 'Uncontrolled Component' in React forms?",
    "options": [
      "Controlled components use `refs`; Uncontrolled components use `useState`.",
      "Controlled components derive their input value from React state; Uncontrolled components maintain their own internal state.",
      "Uncontrolled components are faster than Controlled components.",
      "Controlled components cannot be validated."
    ],
    "answer": "Controlled components derive their input value from React state; Uncontrolled components maintain their own internal state.",
    "explanation": "In a controlled component, the input's value is driven by state, making React the 'single source of truth'. In an uncontrolled component, the DOM node handles the state itself, accessed via `refs` or standard DOM APIs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 68,
    "question": "What is the behavior of `flushSync` in React 18?",
    "options": [
      "It forces all pending setTimeout callbacks to execute immediately.",
      "It forces React to flush the pending state updates and re-render synchronously.",
      "It clears the browser's cache and performs a hard reload.",
      "It disables concurrent rendering for the duration of the app lifecycle."
    ],
    "answer": "It forces React to flush the pending state updates and re-render synchronously.",
    "explanation": "`flushSync` forces a synchronous DOM update. This is useful when code immediately after a state update depends on the updated DOM, bypassing React's default batching and concurrency mechanisms.",
    "difficulty": "Intermediate"
  },
  {
    "id": 69,
    "question": "What is a 'Side Effect' in the context of a React component?",
    "options": [
      "Any variable declared outside the function scope.",
      "An operation that interacts with the outside world (DOM, network, subscriptions) or affects something outside the component's scope.",
      "A bug caused by incorrect prop passing.",
      "The rendering of child components."
    ],
    "answer": "An operation that interacts with the outside world (DOM, network, subscriptions) or affects something outside the component's scope.",
    "explanation": "Side effects include data fetching, subscriptions, or manually changing the DOM. React expects these to be handled in `useEffect`, `useLayoutEffect`, or event handlers, separate from the pure rendering logic.",
    "difficulty": "Intermediate"
  },
  {
    "id": 70,
    "question": "How does `useId` ensure stable IDs across Server-Side Rendering (SSR) and Client-Side hydration?",
    "options": [
      "It generates random UUIDs and sends them in the HTTP headers.",
      "It uses a deterministic algorithm based on the component tree order to generate matching IDs on server and client.",
      "It uses the component's `name` property as the ID.",
      "It stores a global counter in the WebWorker."
    ],
    "answer": "It uses a deterministic algorithm based on the component tree order to generate matching IDs on server and client.",
    "explanation": "`useId` employs a counter specific to the 'instance' of the renderer. Because the server and client follow the same component tree structure logic, the IDs generated match exactly, avoiding hydration mismatches.",
    "difficulty": "Intermediate"
  },
  {
    "id": 71,
    "question": "What occurs if the `key` prop is duplicated within a list of React elements?",
    "options": [
      "React automatically appends a unique suffix to the duplicates.",
      "React merges the components with the same key into a single component.",
      "React warns in the console, but treats them as distinct instances based on array index.",
      "It throws an exception and halts the render."
    ],
    "answer": "React warns in the console, but treats them as distinct instances based on array index.",
    "explanation": "Duplicate keys prevent React from uniquely identifying elements. React will issue a warning ('Encountered two children with the same key') but will fall back to using the index for reconciliation, which can lead to UI bugs if the order changes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 72,
    "question": "What is the primary purpose of the `alternate` property on a Fiber node?",
    "options": [
      "To store the list of hooks used by the function component",
      "To facilitate double buffering by pointing to the counterpart node in the work-in-progress tree",
      "To maintain a reference to the parent DOM element for event bubbling",
      "To link sibling Fiber nodes to form the children linked list"
    ],
    "answer": "To facilitate double buffering by pointing to the counterpart node in the work-in-progress tree",
    "explanation": "The `alternate` field connects a node in the `current` tree to its counterpart in the `workInProgress` tree, enabling React to clone nodes and swap trees atomically. Hooks are stored in `memoizedState`, and siblings are linked via `sibling`.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "In the context of React's reconciliation algorithm, what condition triggers a component to be unmounted?",
    "options": [
      "The component's `key` prop changes",
      "The `shouldComponentUpdate` lifecycle method returns false",
      "The `render` phase exceeds the time slice limit",
      "A new Fiber node of the same type is created at the same position"
    ],
    "answer": "The component's `key` prop changes",
    "explanation": "React destroys the old component instance and mounts a new one if the `key` has changed, or if the element type changes. Returning `false` only prevents updates, not unmounting.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "Which specific phase of the React render cycle is responsible for creating or updating the DOM nodes?",
    "options": [
      "Reconciliation Phase",
      "Commit Phase",
      "Scheduling Phase",
      "Diffing Phase"
    ],
    "answer": "Commit Phase",
    "explanation": "The Commit phase is synchronous and applies the calculated changes (insertions, updates, deletions) to the host environment (DOM). Reconciliation calculates changes but does not touch the DOM.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "How does `startTransition` improve user perceived performance in React 18?",
    "options": [
      "It executes the state update synchronously to prevent visual lag",
      "It defers the update by interrupting rendering to prioritize higher-priority work",
      "It automatically adds `React.memo` to components rendered during the transition",
      "It skips the `commit` phase for non-urgent updates"
    ],
    "answer": "It defers the update by interrupting rendering to prioritize higher-priority work",
    "explanation": "Transitions mark updates as non-urgent, allowing React to interrupt rendering if a higher-priority event (like typing) occurs. It does not skip the commit phase; it simply defers the lower-priority work.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the function of `beginWork` in the React Fiber architecture?",
    "options": [
      "It processes the Fiber node, reconciles children, and creates the next work-in-progress node",
      "It finalizes the DOM mutations and commits side effects",
      "It schedules the next callback using `requestIdleCallback`",
      "It creates the initial Fiber tree structure from JSX"
    ],
    "answer": "It processes the Fiber node, reconciles children, and creates the next work-in-progress node",
    "explanation": "`beginWork` is the entry point for processing a Fiber node during the reconciliation phase, where React diffs props and determines the next list of children. DOM mutations happen in `completeWork` and the `commit` phase.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "Which lifecycle method runs during the `commit` phase but *before* the browser has painted the changes?",
    "options": [
      "getSnapshotBeforeUpdate",
      "componentDidUpdate",
      "componentDidMount",
      "useEffect"
    ],
    "answer": "getSnapshotBeforeUpdate",
    "explanation": "`getSnapshotBeforeUpdate` fires right before DOM mutations are committed, allowing the capture of information (e.g., scroll position) from the DOM. `useEffect` and `componentDidMount` run after the paint.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "React 18's Automatic Batching applies to which of the following scenarios?",
    "options": [
      "State updates inside promises, timeouts, and native event handlers",
      "Only state updates occurring within the same React event handler",
      "Only updates wrapped in `unstable_batchedUpdates`",
      "Synchronous state updates triggered by `flushSync`"
    ],
    "answer": "State updates inside promises, timeouts, and native event handlers",
    "explanation": "In React 18, batching works everywhere (async callbacks, promises, timeouts) by default, whereas previously it only worked inside React event handlers. `flushSync` explicitly disables batching.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What is the 'Lane Model' used for in React's internal scheduler?",
    "options": [
      "To represent update priorities using 32-bit integer bitmasks",
      "To manage the memory layout of the Fiber tree",
      "To determine which lanes (physical CPU cores) a thread should run on",
      "To serialize components for Server-Side Rendering"
    ],
    "answer": "To represent update priorities using 32-bit integer bitmasks",
    "explanation": "Lanes are binary representations of priority levels (e.g., SyncLane, DefaultLane), allowing React to efficiently compute and compare update urgency using bitwise operations.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "Why does React use ` passive ` effects ( `useEffect ` ) as opposed to layout effects ( `useLayoutEffect ` )?",
    "options": [
      "To allow the browser to paint the screen before running the effect, preventing blocking",
      "To ensure the effect runs before the browser paints to avoid visual flicker",
      "To run effects synchronously during the commit phase",
      "To allow the effect to read the latest DOM layout immediately"
    ],
    "answer": "To allow the browser to paint the screen before running the effect, preventing blocking",
    "explanation": "Passive effects are deferred until after the layout and paint are complete, preventing them from blocking the browser's visual response. `useLayoutEffect` fires synchronously before paint.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What occurs when a component renders `null` or `false` in React?",
    "options": [
      "React unmounts the component instance and destroys its state",
      "React renders a comment node but preserves the component's state and lifecycle",
      "React skips the reconciliation phase for that component entirely",
      "React throws an error requiring a valid DOM element return"
    ],
    "answer": "React renders a comment node but preserves the component's state and lifecycle",
    "explanation": "Returning `null` results in an empty DOM node (often a comment placeholder), but the component instance remains mounted, retaining state and lifecycle methods.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "Which heuristic does React use to diff two lists of child elements?",
    "options": [
      "It calculates the Edit Distance (Levenshtein distance) between the lists",
      "It matches the first child, then matches subsequent children using the `key` prop",
      "It performs a binary search on the sorted list of keys",
      "It automatically hashes the component props to determine equality"
    ],
    "answer": "It matches the first child, then matches subsequent children using the `key` prop",
    "explanation": "Without keys, React matches by index (first to first, second to second). With keys, it uses the `key` to match elements, enabling efficient reordering.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is the role of `Suspense` during Server-Side Rendering (Streaming)?",
    "options": [
      "To pause the HTML stream and send the rest of the page in a separate chunk when data is ready",
      "To abort the server request if data fetching takes longer than 5 seconds",
      "To render a fallback on the client while the server processes the data",
      "To cache the data on the server to prevent duplicate requests"
    ],
    "answer": "To pause the HTML stream and send the rest of the page in a separate chunk when data is ready",
    "explanation": "Streaming SSR allows sending the initial HTML shell first. When a `Suspense` boundary resolves, React streams the remaining HTML chunks to the client progressively.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "How does `useSyncExternalStore` ensure consistency with concurrent rendering?",
    "options": [
      "By forcing an update to be processed synchronously during the commit phase",
      "By requiring external stores to implement a `getSnapshot` method that returns immutable data",
      "By batching external updates automatically with `setState`",
      "By preventing any external store updates during a transition"
    ],
    "answer": "By requiring external stores to implement a `getSnapshot` method that returns immutable data",
    "explanation": "`useSyncExternalStore` subscribes to external mutations. By requiring `getSnapshot`, React can check if a value actually changed and tear down/re-render consistently, avoiding tearing in concurrent features.",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "Which statement accurately describes the behavior of `flushSync` in React 18?",
    "options": [
      "It forces React to bypass the `beginWork` phase and commit changes immediately",
      "It executes the callback synchronously and forces React to flush any pending updates before returning",
      "It disables the Lane Model and forces all updates to be treated as high priority",
      "It creates a new root to isolate the synchronous updates"
    ],
    "answer": "It executes the callback synchronously and forces React to flush any pending updates before returning",
    "explanation": "`flushSync` ensures the work inside the callback is processed and committed to the DOM immediately, blocking further queued work until complete.",
    "difficulty": "Advanced"
  },
  {
    "id": 86,
    "question": "In React's reconciliation process, what happens when the `type` of a React Element changes between renders?",
    "options": [
      "React updates the props on the existing DOM node",
      "React reuses the Fiber node but resets its state",
      "React destroys the old Fiber node and mounts a new one",
      "React applies a diff patch to the existing DOM node"
    ],
    "answer": "React destroys the old Fiber node and mounts a new one",
    "explanation": "If the `type` differs (e.g., `div` to `span` or `ComponentA` to `ComponentB`), React assumes the old tree is irrelevant and tears it down to build the new tree from scratch.",
    "difficulty": "Advanced"
  },
  {
    "id": 87,
    "question": "What is the mechanism that allows React to interrupt a render (in the render phase)?",
    "options": [
      "The Fiber node linked list structure, which allows saving the stack frame",
      "The Virtual DOM diffing algorithm, which splits work into threads",
      "The `requestAnimationFrame` API, which pauses execution",
      "The `ShouldComponentUpdate` lifecycle hook, which returns false"
    ],
    "answer": "The Fiber node linked list structure, which allows saving the stack frame",
    "explanation": "Fiber implements a custom stack frame in JavaScript. The linked list structure (`child`, `sibling`, `return`) allows React to pause, save the current position, and return to it later.",
    "difficulty": "Advanced"
  },
  {
    "id": 88,
    "question": "What does 'Tearing' refer to in the context of React Concurrent rendering?",
    "options": [
      "The visual glitch where different parts of the screen show inconsistent state due to interrupted renders",
      "The error thrown when a Promise is rejected in a `useEffect`",
      "The process of tearing down the Fiber tree during unmounting",
      "The fragmentation of memory due to frequent object creation"
    ],
    "answer": "The visual glitch where different parts of the screen show inconsistent state due to interrupted renders",
    "explanation": "Tearing happens when concurrent features cause different renders to see different snapshots of external state simultaneously, displaying mismatched UI.",
    "difficulty": "Advanced"
  },
  {
    "id": 89,
    "question": "Which function is responsible for creating the initial DOM nodes for a specific Fiber during the `render` phase?",
    "options": [
      "completeWork",
      "beginWork",
      "commitWork",
      "reconcileChildren"
    ],
    "answer": "completeWork",
    "explanation": "`beginWork` primarily processes props and diffs children, while `completeWork` is responsible for creating/instance-ing DOM nodes (or Fiber instances) and handling updates to the host node.",
    "difficulty": "Advanced"
  },
  {
    "id": 90,
    "question": "How are event listeners handled in React 17+?",
    "options": [
      "They are attached to the `root` DOM node rather than the `document`",
      "They are attached directly to each specific DOM element",
      "They are attached to the `document` but use a new native event pooling system",
      "They use the Event Capturing phase exclusively"
    ],
    "answer": "They are attached to the `root` DOM node rather than the `document`",
    "explanation": "React 17 changed event delegation to attach to the root container. This allows multiple React roots on a page to coexist safely and makes incremental upgrades easier.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What determines if a hook's dependency array triggers a re-render?",
    "options": [
      "Reference equality check (`Object.is`) for each dependency",
      "Deep equality check for objects and arrays",
      "A comparison of the dependency's `toString()` value",
      "A hash of the dependency array's length"
    ],
    "answer": "Reference equality check (`Object.is`) for each dependency",
    "explanation": "React uses `Object.is` (SameValueZero) to compare current and previous dependencies. Primitive values are compared by value, while objects/arrays are compared by reference.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the technical reason that React `useState` updater functions allow accessing the previous state?",
    "options": [
      "To ensure updates are processed sequentially when multiple updates occur in a single event handler",
      "To enable asynchronous state batching across different components",
      "To avoid the need for `useReducer` in complex applications",
      "To allow the state to be mutated directly without re-rendering"
    ],
    "answer": "To ensure updates are processed sequentially when multiple updates occur in a single event handler",
    "explanation": "Because batching can delay state updates, relying on closure-captured state can be stale. The functional updater form queues the update, ensuring it operates on the most recent committed state.",
    "difficulty": "Advanced"
  },
  {
    "id": 93,
    "question": "Which statement is true regarding `memo` (React.memo) and component comparison?",
    "options": [
      "It performs a shallow comparison of props by default",
      "It performs a deep comparison of props by default",
      "It re-renders only if the state of the parent component changes",
      "It prevents the component from mounting if props are unchanged"
    ],
    "answer": "It performs a shallow comparison of props by default",
    "explanation": "React.memo uses shallow equality (reference check) on props to skip re-rendering. Deep comparison requires a custom comparison function as the second argument.",
    "difficulty": "Advanced"
  },
  {
    "id": 94,
    "question": "In the context of `useRef`, what is the underlying mechanism that persists data across renders without causing re-renders?",
    "options": [
      "The ref object is stored on the Fiber node and is mutable outside the render cycle",
      "The ref object is a global variable attached to the `window` object",
      "The ref object uses `Proxy` to trap re-render triggers",
      "The ref object is stored in the component's context"
    ],
    "answer": "The ref object is stored on the Fiber node and is mutable outside the render cycle",
    "explanation": "Refs are attached to the Fiber node. Unlike state, changing the `.current` property does not trigger a scheduler update or re-render because it bypasses the setState/dispatch logic.",
    "difficulty": "Advanced"
  },
  {
    "id": 95,
    "question": "What is the primary use case for `getDerivedStateFromProps`?",
    "options": [
      "To update state in response to prop changes before the next render",
      "To fetch data asynchronously when props update",
      "To trigger side effects like DOM manipulation",
      "To register event listeners on mount"
    ],
    "answer": "To update state in response to prop changes before the next render",
    "explanation": "This static lifecycle method is designed to sync state with props during the render phase (safely), unlike `componentWillReceiveProps` which was unsafe for async rendering.",
    "difficulty": "Advanced"
  },
  {
    "id": 96,
    "question": "Why is it generally unsafe to call `setState` during the `render` method?",
    "options": [
      "It causes an infinite loop because state updates trigger a re-render",
      "It violates the rules of Hooks because it happens outside the function body",
      "It bypasses the Fiber reconciliation logic entirely",
      "It is technically safe but causes memory leaks"
    ],
    "answer": "It causes an infinite loop because state updates trigger a re-render",
    "explanation": "State changes trigger a re-render. If a state update happens *during* a render, it triggers another render immediately, leading to an infinite recursion loop.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "How does the `Profiler` component measure performance?",
    "options": [
      "It records the time spent rendering the component tree for profiling purposes",
      "It intercepts network requests made by the component",
      "It analyzes the bundle size of the component",
      "It counts the number of times a component re-renders globally"
    ],
    "answer": "It records the time spent rendering the component tree for profiling purposes",
    "explanation": "The Profiler API measures how long it takes to render a commit (update or mount) and what props/state were involved, identifying performance bottlenecks.",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What is 'Hydration' in the context of React Server-Side Rendering?",
    "options": [
      "The process of attaching event listeners to the existing HTML markup generated by the server",
      "The process of generating HTML from JavaScript components on the server",
      "The process of converting static HTML into a React component tree",
      "The process of optimizing images and assets for faster loading"
    ],
    "answer": "The process of attaching event listeners to the existing HTML markup generated by the server",
    "explanation": "Hydration preserves the server-generated static HTML (avoiding a costly re-render) and adds JavaScript event listeners and interactivity.",
    "difficulty": "Advanced"
  },
  {
    "id": 99,
    "question": "Which phase executes the effects returned by `useEffect` (cleanup functions)?",
    "options": [
      "Before the next render commit phase",
      "After the component unmounts and the DOM is removed",
      "During the `beginWork` phase of the next render",
      "Immediately after the component re-renders"
    ],
    "answer": "Before the next render commit phase",
    "explanation": "Cleanup functions run during the commit phase before the new effects are scheduled (or on unmount). This ensures the UI is cleaned up before applying the next batch of changes.",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What happens when a `key` prop is not provided in a list of elements?",
    "options": [
      "React defaults to using the element's index as the key",
      "React throws a warning and fails to render the list",
      "React automatically generates a unique hash based on the element's content",
      "React skips the rendering of the list items entirely"
    ],
    "answer": "React defaults to using the element's index as the key",
    "explanation": "Without keys, React uses the index of the item in the array. This often works for static lists but causes bugs with sorting, insertions, or deletions (shifting data instead of nodes).",
    "difficulty": "Advanced"
  },
  {
    "id": 101,
    "question": "What is the specific advantage of `useTransition` for non-blocking UI?",
    "options": [
      "It keeps the UI interactive while complex computations are being performed in the background",
      "It reduces the bundle size of the application by code splitting",
      "It automatically caches the results of expensive calculations",
      "It converts synchronous functions into asynchronous Web Workers"
    ],
    "answer": "It keeps the UI interactive while complex computations are being performed in the background",
    "explanation": "By marking updates as transitions, React interrupts low-priority rendering to handle high-priority user input (typing, clicking), ensuring the UI never freezes.",
    "difficulty": "Advanced"
  }
]