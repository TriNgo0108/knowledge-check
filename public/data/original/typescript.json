[
  {
    "id": 1,
    "question": "What is TypeScript?",
    "options": [
      "JavaScript framework",
      "Typed superset of JavaScript",
      "New programming language",
      "JavaScript compiler"
    ],
    "answer": "Typed superset of JavaScript",
    "explanation": "TypeScript adds static types to JavaScript and compiles to plain JS."
  },
  {
    "id": 2,
    "question": "How do you declare a variable with a type?",
    "options": [
      "let x as number",
      "let x: number",
      "int x",
      "let x = number"
    ],
    "answer": "let x: number",
    "explanation": "TypeScript uses colon notation: variableName: type."
  },
  {
    "id": 3,
    "question": "What are the basic types in TypeScript?",
    "options": [
      "int, float, char",
      "string, number, boolean, null, undefined",
      "str, num, bool",
      "String, Integer, Boolean"
    ],
    "answer": "string, number, boolean, null, undefined",
    "explanation": "TypeScript uses JavaScript primitive types plus any, never, unknown, void."
  },
  {
    "id": 4,
    "question": "How do you define an array of numbers?",
    "options": [
      "number[]",
      "Array<number>",
      "Both are correct",
      "array[number]"
    ],
    "answer": "Both are correct",
    "explanation": "Both number[] and Array<number> define number arrays."
  },
  {
    "id": 5,
    "question": "What is the 'any' type?",
    "options": [
      "Error type",
      "Type that allows any value (opt-out of type-checking)",
      "Generic type",
      "Empty type"
    ],
    "answer": "Type that allows any value (opt-out of type-checking)",
    "explanation": "any disables type checking for that variable."
  },
  {
    "id": 6,
    "question": "What is a tuple in TypeScript?",
    "options": [
      "Music tuple",
      "Array with fixed length and types",
      "Object type",
      "Function type"
    ],
    "answer": "Array with fixed length and types",
    "explanation": "[string, number] defines a tuple with specific types at each position."
  },
  {
    "id": 7,
    "question": "How do you define an object type?",
    "options": [
      "object = {}",
      "{ name: string, age: number }",
      "Object<name, age>",
      "type: object"
    ],
    "answer": "{ name: string, age: number }",
    "explanation": "Object types use curly braces with property: type pairs."
  },
  {
    "id": 8,
    "question": "What is an interface?",
    "options": [
      "UI interface",
      "Contract defining object structure",
      "Function type",
      "Variable type"
    ],
    "answer": "Contract defining object structure",
    "explanation": "Interfaces define shapes of objects and contracts."
  },
  {
    "id": 9,
    "question": "How do you define an interface?",
    "options": [
      "define interface",
      "interface Person { name: string }",
      "type interface",
      "create interface"
    ],
    "answer": "interface Person { name: string }",
    "explanation": "interface keyword followed by name and properties."
  },
  {
    "id": 10,
    "question": "What is a type alias?",
    "options": [
      "Variable alias",
      "Alternative name for a type using 'type'",
      "Import alias",
      "Function alias"
    ],
    "answer": "Alternative name for a type using 'type'",
    "explanation": "type MyType = string | number creates a type alias."
  },
  {
    "id": 11,
    "question": "How do you define a function's parameter and return types?",
    "options": [
      "function add(a, b): number",
      "function add(a: number, b: number): number",
      "function add(number a, number b)",
      "function: number add(a, b)"
    ],
    "answer": "function add(a: number, b: number): number",
    "explanation": "Parameters have : type after name, return type after parentheses."
  },
  {
    "id": 12,
    "question": "What does the '?' make a property?",
    "options": [
      "Required",
      "Optional",
      "Nullable",
      "Readonly"
    ],
    "answer": "Optional",
    "explanation": "{ name?: string } means name is optional."
  },
  {
    "id": 13,
    "question": "What is a union type?",
    "options": [
      "Labor union",
      "Type that can be one of several types",
      "Combined type",
      "Merged type"
    ],
    "answer": "Type that can be one of several types",
    "explanation": "string | number means the value can be either type."
  },
  {
    "id": 14,
    "question": "What is a literal type?",
    "options": [
      "String literal",
      "Exact specific value as a type",
      "Template type",
      "Constant type"
    ],
    "answer": "Exact specific value as a type",
    "explanation": "type Direction = 'north' | 'south' uses literal types."
  },
  {
    "id": 15,
    "question": "What does 'readonly' do?",
    "options": [
      "Makes variable global",
      "Prevents modification after creation",
      "Makes public",
      "Makes private"
    ],
    "answer": "Prevents modification after creation",
    "explanation": "readonly properties cannot be reassigned."
  },
  {
    "id": 16,
    "question": "What is 'void' type used for?",
    "options": [
      "Empty variable",
      "Functions that don't return a value",
      "Null value",
      "Undefined value"
    ],
    "answer": "Functions that don't return a value",
    "explanation": "void indicates a function doesn't return anything."
  },
  {
    "id": 17,
    "question": "What is 'never' type used for?",
    "options": [
      "Never used",
      "Functions that never return or throw",
      "Impossible type",
      "Empty type"
    ],
    "answer": "Functions that never return or throw",
    "explanation": "never represents values that never occur (throw, infinite loop)."
  },
  {
    "id": 18,
    "question": "What is 'unknown' type?",
    "options": [
      "Same as any",
      "Type-safe counterpart of any",
      "Undefined type",
      "Error type"
    ],
    "answer": "Type-safe counterpart of any",
    "explanation": "unknown requires type checking before use, unlike any."
  },
  {
    "id": 19,
    "question": "How do you define an enum?",
    "options": [
      "enum Color = { Red }",
      "enum Color { Red, Green }",
      "define enum Color",
      "type enum Color"
    ],
    "answer": "enum Color { Red, Green }",
    "explanation": "enum keyword creates a set of named constants."
  },
  {
    "id": 20,
    "question": "What is type inference?",
    "options": [
      "Explicit typing",
      "TypeScript automatically determines types",
      "Type conversion",
      "Type validation"
    ],
    "answer": "TypeScript automatically determines types",
    "explanation": "let x = 5 infers x as number without explicit annotation."
  },
  {
    "id": 21,
    "question": "How do you compile TypeScript?",
    "options": [
      "node file.ts",
      "tsc file.ts",
      "ts file.ts",
      "compile file.ts"
    ],
    "answer": "tsc file.ts",
    "explanation": "tsc (TypeScript Compiler) compiles .ts to .js files."
  },
  {
    "id": 22,
    "question": "What file configures TypeScript compiler?",
    "options": [
      "package.json",
      "tsconfig.json",
      "typescript.json",
      "config.ts"
    ],
    "answer": "tsconfig.json",
    "explanation": "tsconfig.json contains compiler options and project settings."
  },
  {
    "id": 23,
    "question": "What is the purpose of 'strict' in tsconfig?",
    "options": [
      "Strict performance",
      "Enables all strict type-checking options",
      "Strict mode JS",
      "Strict compilation"
    ],
    "answer": "Enables all strict type-checking options",
    "explanation": "strict: true enables strictNullChecks, strictFunctionTypes, etc."
  },
  {
    "id": 24,
    "question": "How do you assert a type?",
    "options": [
      "(string)value",
      "value as string",
      "<string>value",
      "Both B and C"
    ],
    "answer": "Both B and C",
    "explanation": "value as string and <string>value are both type assertions."
  },
  {
    "id": 25,
    "question": "What is a type guard?",
    "options": [
      "Security type",
      "Code that narrows type within a block",
      "Type validator",
      "Type protector"
    ],
    "answer": "Code that narrows type within a block",
    "explanation": "if (typeof x === 'string') narrows x to string in that block."
  },
  {
    "id": 26,
    "question": "What is the 'typeof' operator in TypeScript?",
    "options": [
      "Runtime type check only",
      "Both runtime check and type operator",
      "Type definition",
      "Type conversion"
    ],
    "answer": "Both runtime check and type operator",
    "explanation": "typeof works at runtime and can create types: type T = typeof obj."
  },
  {
    "id": 27,
    "question": "What is 'instanceof' used for?",
    "options": [
      "Creating instances",
      "Checking if object is instance of class",
      "Type conversion",
      "Interface check"
    ],
    "answer": "Checking if object is instance of class",
    "explanation": "instanceof is a type guard for class instances."
  },
  {
    "id": 28,
    "question": "How do you define a function type?",
    "options": [
      "function: type",
      "(a: number) => string",
      "func<number, string>",
      "function(number): string"
    ],
    "answer": "(a: number) => string",
    "explanation": "Arrow syntax defines function type: (params) => returnType."
  },
  {
    "id": 29,
    "question": "What is module augmentation?",
    "options": [
      "Adding exports",
      "Extending existing module declarations",
      "Module merge",
      "Import extension"
    ],
    "answer": "Extending existing module declarations",
    "explanation": "Augmentation adds declarations to existing modules."
  },
  {
    "id": 30,
    "question": "What are declaration files (.d.ts)?",
    "options": [
      "Data files",
      "Type definitions for JavaScript libraries",
      "Documentation",
      "Debug files"
    ],
    "answer": "Type definitions for JavaScript libraries",
    "explanation": ".d.ts files provide type information for JS libraries."
  },
  {
    "id": 31,
    "question": "What is @types package?",
    "options": [
      "Type library",
      "DefinitelyTyped package with type definitions",
      "Type checker",
      "Type validator"
    ],
    "answer": "DefinitelyTyped package with type definitions",
    "explanation": "@types/lodash provides types for the lodash library."
  },
  {
    "id": 32,
    "question": "What does 'as const' do?",
    "options": [
      "Creates constant",
      "Narrows to literal types (const assertion)",
      "Type conversion",
      "Freeze object"
    ],
    "answer": "Narrows to literal types (const assertion)",
    "explanation": "as const makes values their literal types, readonly."
  },
  {
    "id": 33,
    "question": "What is 'in' operator used for?",
    "options": [
      "Array check only",
      "Property check and type narrowing",
      "In statement",
      "Container check"
    ],
    "answer": "Property check and type narrowing",
    "explanation": "'key' in object checks property and narrows type."
  },
  {
    "id": 34,
    "question": "What is index signature?",
    "options": [
      "Array index",
      "Define type for dynamic property keys",
      "Function signature",
      "Class signature"
    ],
    "answer": "Define type for dynamic property keys",
    "explanation": "{ [key: string]: number } allows any string key with number value."
  },
  {
    "id": 35,
    "question": "How do you extend an interface?",
    "options": [
      "interface B += A",
      "interface B extends A",
      "interface B : A",
      "interface B inherits A"
    ],
    "answer": "interface B extends A",
    "explanation": "extends keyword allows interface inheritance."
  },
  {
    "id": 36,
    "question": "What is a generic type?",
    "options": [
      "General type",
      "Reusable component working with multiple types",
      "Universal type",
      "Default type"
    ],
    "answer": "Reusable component working with multiple types",
    "explanation": "Generics like Array<T> work with any type parameter."
  },
  {
    "id": 37,
    "question": "How do you define a generic function?",
    "options": [
      "function fn()",
      "function fn<T>(arg: T): T",
      "function fn(T arg)",
      "generic function fn"
    ],
    "answer": "function fn<T>(arg: T): T",
    "explanation": "<T> declares a type parameter that can be used in the function."
  },
  {
    "id": 38,
    "question": "What is a generic constraint?",
    "options": [
      "Type limit",
      "Limiting what types can be used with generic",
      "Required generic",
      "Generic validation"
    ],
    "answer": "Limiting what types can be used with generic",
    "explanation": "<T extends HasLength> constrains T to types with length."
  },
  {
    "id": 39,
    "question": "What is 'keyof' operator?",
    "options": [
      "Object keys function",
      "Creates union of object's key types",
      "Key check",
      "Property list"
    ],
    "answer": "Creates union of object's key types",
    "explanation": "keyof Person returns 'name' | 'age' for Person with those props."
  },
  {
    "id": 40,
    "question": "What is 'typeof' operator for types?",
    "options": [
      "Runtime only",
      "Creates type from variable's type",
      "Type conversion",
      "Type checking"
    ],
    "answer": "Creates type from variable's type",
    "explanation": "type T = typeof myObj creates type from myObj's shape."
  },
  {
    "id": 41,
    "question": "What is a mapped type?",
    "options": [
      "Array map type",
      "Type that transforms properties of another type",
      "Object mapping",
      "Type conversion"
    ],
    "answer": "Type that transforms properties of another type",
    "explanation": "{ [K in keyof T]: boolean } creates new type transforming T."
  },
  {
    "id": 42,
    "question": "What does Partial<T> do?",
    "options": [
      "Creates partial",
      "Makes all properties optional",
      "Removes properties",
      "Creates subset"
    ],
    "answer": "Makes all properties optional",
    "explanation": "Partial<T> makes every property of T optional."
  },
  {
    "id": 43,
    "question": "What does Required<T> do?",
    "options": [
      "Validates required",
      "Makes all properties required",
      "Checks requirements",
      "Adds requirements"
    ],
    "answer": "Makes all properties required",
    "explanation": "Required<T> makes every property of T required."
  },
  {
    "id": 44,
    "question": "What does Readonly<T> do?",
    "options": [
      "Makes variable readonly",
      "Makes all properties readonly",
      "Creates constant",
      "Freezes object"
    ],
    "answer": "Makes all properties readonly",
    "explanation": "Readonly<T> prevents all properties from being modified."
  },
  {
    "id": 45,
    "question": "What does Pick<T, K> do?",
    "options": [
      "Picks array item",
      "Creates type with only specified properties",
      "Selects values",
      "Filters type"
    ],
    "answer": "Creates type with only specified properties",
    "explanation": "Pick<Person, 'name'> creates type with only name property."
  },
  {
    "id": 46,
    "question": "What does Omit<T, K> do?",
    "options": [
      "Omits values",
      "Creates type without specified properties",
      "Removes items",
      "Excludes type"
    ],
    "answer": "Creates type without specified properties",
    "explanation": "Omit<Person, 'age'> creates type without age property."
  },
  {
    "id": 47,
    "question": "What does Record<K, V> do?",
    "options": [
      "Audio record",
      "Creates object type with keys K and values V",
      "Records data",
      "Creates array"
    ],
    "answer": "Creates object type with keys K and values V",
    "explanation": "Record<string, number> is { [key: string]: number }."
  },
  {
    "id": 48,
    "question": "What does Exclude<T, U> do?",
    "options": [
      "Excludes values",
      "Removes types from union",
      "Filters array",
      "Excludes properties"
    ],
    "answer": "Removes types from union",
    "explanation": "Exclude<'a' | 'b' | 'c', 'a'> is 'b' | 'c'."
  },
  {
    "id": 49,
    "question": "What does Extract<T, U> do?",
    "options": [
      "Extracts values",
      "Keeps only types present in both",
      "Filters items",
      "Gets subset"
    ],
    "answer": "Keeps only types present in both",
    "explanation": "Extract<'a' | 'b', 'a' | 'c'> is 'a'."
  },
  {
    "id": 50,
    "question": "What does NonNullable<T> do?",
    "options": [
      "Checks null",
      "Removes null and undefined from type",
      "Validates non-null",
      "Creates non-null"
    ],
    "answer": "Removes null and undefined from type",
    "explanation": "NonNullable<string | null> is string."
  },
  {
    "id": 51,
    "question": "What is a conditional type?",
    "options": [
      "If statement type",
      "Type that depends on condition: T extends U ? X : Y",
      "Ternary type",
      "Optional type"
    ],
    "answer": "Type that depends on condition: T extends U ? X : Y",
    "explanation": "Conditional types select types based on extends relationship."
  },
  {
    "id": 52,
    "question": "What is ReturnType<T>?",
    "options": [
      "Return statement",
      "Extracts return type of function type",
      "Returns type",
      "Creates return type"
    ],
    "answer": "Extracts return type of function type",
    "explanation": "ReturnType<() => string> is string."
  },
  {
    "id": 53,
    "question": "What is Parameters<T>?",
    "options": [
      "Function parameters",
      "Extracts parameter types as tuple",
      "Parameter list",
      "Param type"
    ],
    "answer": "Extracts parameter types as tuple",
    "explanation": "Parameters<(a: string) => void> is [string]."
  },
  {
    "id": 54,
    "question": "What is an intersection type?",
    "options": [
      "Math intersection",
      "Combines multiple types with &",
      "Common properties only",
      "Type overlap"
    ],
    "answer": "Combines multiple types with &",
    "explanation": "A & B requires all properties from both A and B."
  },
  {
    "id": 55,
    "question": "What is declaration merging?",
    "options": [
      "File merging",
      "Multiple declarations combine into one",
      "Import merging",
      "Type combining"
    ],
    "answer": "Multiple declarations combine into one",
    "explanation": "Multiple interface declarations with same name merge."
  },
  {
    "id": 56,
    "question": "What is 'infer' keyword used for?",
    "options": [
      "Type inference",
      "Captures type within conditional type",
      "Guesses type",
      "Extracts type"
    ],
    "answer": "Captures type within conditional type",
    "explanation": "T extends (...args: infer P) => any captures parameter types as P."
  },
  {
    "id": 57,
    "question": "What is a discriminated union?",
    "options": [
      "Discrimination",
      "Union with common literal property for narrowing",
      "Tagged type",
      "Labeled union"
    ],
    "answer": "Union with common literal property for narrowing",
    "explanation": "{ type: 'circle' } | { type: 'square' } uses type as discriminant."
  },
  {
    "id": 58,
    "question": "What is 'satisfies' operator?",
    "options": [
      "Satisfaction check",
      "Validates expression matches type without widening",
      "Type assertion",
      "Type validation"
    ],
    "answer": "Validates expression matches type without widening",
    "explanation": "obj satisfies Type checks type without changing inferred type."
  },
  {
    "id": 59,
    "question": "What is a const enum?",
    "options": [
      "Constant values",
      "Enum inlined at compile time",
      "Readonly enum",
      "Final enum"
    ],
    "answer": "Enum inlined at compile time",
    "explanation": "const enum values are replaced with literals, no runtime object."
  },
  {
    "id": 60,
    "question": "What is 'declare' keyword?",
    "options": [
      "Declaration",
      "Tells TS something exists without implementation",
      "Creates variable",
      "Defines type"
    ],
    "answer": "Tells TS something exists without implementation",
    "explanation": "declare var jQuery: any tells TS jQuery exists globally."
  },
  {
    "id": 61,
    "question": "What is a namespace?",
    "options": [
      "Variable name",
      "Way to organize code and avoid naming conflicts",
      "Module type",
      "Scope container"
    ],
    "answer": "Way to organize code and avoid naming conflicts",
    "explanation": "namespace Utils { } groups related code (prefer ES modules)."
  },
  {
    "id": 62,
    "question": "What is triple-slash directive?",
    "options": [
      "Comment",
      "Reference other files or types: /// <reference />",
      "Type definition",
      "Import syntax"
    ],
    "answer": "Reference other files or types: /// <reference />",
    "explanation": "/// <reference path='...' /> includes type information."
  },
  {
    "id": 63,
    "question": "What is 'strictNullChecks'?",
    "options": [
      "Null validation",
      "Compiler option making null/undefined explicit",
      "Null removal",
      "Null safety"
    ],
    "answer": "Compiler option making null/undefined explicit",
    "explanation": "When enabled, null and undefined aren't implicitly in every type."
  },
  {
    "id": 64,
    "question": "What is the difference between interface and type?",
    "options": [
      "Same thing",
      "Interfaces can be extended/merged, types are more flexible",
      "Types are deprecated",
      "Interfaces are faster"
    ],
    "answer": "Interfaces can be extended/merged, types are more flexible",
    "explanation": "Both work similarly; interfaces allow declaration merging."
  },
  {
    "id": 65,
    "question": "What is 'noImplicitAny'?",
    "options": [
      "Removes any",
      "Error when type is implicitly any",
      "Disables any",
      "Explicit any only"
    ],
    "answer": "Error when type is implicitly any",
    "explanation": "Forces explicit type annotations when type can't be inferred."
  },
  {
    "id": 66,
    "question": "What is abstract class?",
    "options": [
      "Conceptual class",
      "Class that cannot be instantiated directly",
      "Hidden class",
      "Base class only"
    ],
    "answer": "Class that cannot be instantiated directly",
    "explanation": "Abstract classes provide base for other classes but can't be new'd."
  },
  {
    "id": 67,
    "question": "What are access modifiers in TypeScript?",
    "options": [
      "private only",
      "public, private, protected",
      "internal, external",
      "open, closed"
    ],
    "answer": "public, private, protected",
    "explanation": "TypeScript adds access modifiers to control visibility."
  },
  {
    "id": 68,
    "question": "What is 'override' keyword?",
    "options": [
      "Overwrite",
      "Explicitly marks method override of parent",
      "Replace",
      "Extend"
    ],
    "answer": "Explicitly marks method override of parent",
    "explanation": "override ensures method exists in parent class."
  },
  {
    "id": 69,
    "question": "What is a constructor signature in interface?",
    "options": [
      "Constructor definition",
      "new (): Type - describes constructable",
      "Class constructor",
      "Factory type"
    ],
    "answer": "new (): Type - describes constructable",
    "explanation": "new signature describes what new returns."
  },
  {
    "id": 70,
    "question": "What is function overloading in TypeScript?",
    "options": [
      "Multiple implementations",
      "Multiple call signatures for one function",
      "Function copy",
      "Parallel functions"
    ],
    "answer": "Multiple call signatures for one function",
    "explanation": "Overloads define multiple ways to call a function."
  },
  {
    "id": 71,
    "question": "What is a template literal type?",
    "options": [
      "String template",
      "Type using template string syntax",
      "Generic string",
      "Pattern type"
    ],
    "answer": "Type using template string syntax",
    "explanation": "`${string}_id` creates type matching any string ending with '_id'."
  },
  {
    "id": 72,
    "question": "What is 'intrinsic' string manipulation types?",
    "options": [
      "Internal strings",
      "Built-in types: Uppercase, Lowercase, Capitalize, Uncapitalize",
      "String methods",
      "Regex types"
    ],
    "answer": "Built-in types: Uppercase, Lowercase, Capitalize, Uncapitalize",
    "explanation": "Uppercase<'hello'> is 'HELLO'."
  },
  {
    "id": 73,
    "question": "What is a recursive type?",
    "options": [
      "Loop type",
      "Type that references itself",
      "Nested type",
      "Chain type"
    ],
    "answer": "Type that references itself",
    "explanation": "type Json = string | { [key: string]: Json } references itself."
  },
  {
    "id": 74,
    "question": "What is 'this' type in classes?",
    "options": [
      "Current object",
      "Polymorphic this type returning same class",
      "Self reference",
      "Instance type"
    ],
    "answer": "Polymorphic this type returning same class",
    "explanation": "return this correctly chains in subclasses."
  },
  {
    "id": 75,
    "question": "What is ThisType<T>?",
    "options": [
      "This type definition",
      "Marker interface to set this type in object literal",
      "Context type",
      "Self type"
    ],
    "answer": "Marker interface to set this type in object literal",
    "explanation": "ThisType changes 'this' binding in object literal methods."
  },
  {
    "id": 76,
    "question": "What is 'asserts' in type predicates?",
    "options": [
      "Assertion",
      "Narrows type for rest of scope: asserts x is string",
      "Check function",
      "Validation return"
    ],
    "answer": "Narrows type for rest of scope: asserts x is string",
    "explanation": "Assertion functions narrow types and throw if false."
  },
  {
    "id": 77,
    "question": "What is InstanceType<T>?",
    "options": [
      "Instance creation",
      "Extracts instance type from class constructor type",
      "Object type",
      "Constructor return"
    ],
    "answer": "Extracts instance type from class constructor type",
    "explanation": "InstanceType<typeof MyClass> is MyClass."
  },
  {
    "id": 78,
    "question": "What is ConstructorParameters<T>?",
    "options": [
      "Constructor args",
      "Extracts constructor parameter types",
      "Build parameters",
      "Init args"
    ],
    "answer": "Extracts constructor parameter types",
    "explanation": "Gets tuple type of constructor parameters."
  },
  {
    "id": 79,
    "question": "What is variance in types?",
    "options": [
      "Type difference",
      "How type parameters behave with inheritance",
      "Type range",
      "Type flexibility"
    ],
    "answer": "How type parameters behave with inheritance",
    "explanation": "Covariant (same direction), contravariant (opposite), invariant (exact)."
  },
  {
    "id": 80,
    "question": "What does 'in' and 'out' modifiers do for type parameters?",
    "options": [
      "Input/output",
      "Control variance: in is contravariant, out is covariant",
      "Direction",
      "Flow control"
    ],
    "answer": "Control variance: in is contravariant, out is covariant",
    "explanation": "interface Consumer<in T> makes T contravariant."
  },
  {
    "id": 81,
    "question": "What is a branded type?",
    "options": [
      "Logo type",
      "Nominal type using unique symbol",
      "Named type",
      "Labeled type"
    ],
    "answer": "Nominal type using unique symbol",
    "explanation": "type UserId = string & { __brand: 'UserId' } creates unique type."
  },
  {
    "id": 82,
    "question": "What is the 'object' vs 'Object' vs '{}' type?",
    "options": [
      "Same thing",
      "object is non-primitive, Object/any object, {} is empty object type",
      "Different cases",
      "Object is deprecated"
    ],
    "answer": "object is non-primitive, Object/any object, {} is empty object type",
    "explanation": "object excludes primitives; {} allows any value."
  },
  {
    "id": 83,
    "question": "What is a module declaration?",
    "options": [
      "Module import",
      "Describes shape of external module: declare module 'name'",
      "Module export",
      "Module type"
    ],
    "answer": "Describes shape of external module: declare module 'name'",
    "explanation": "declare module allows typing external modules."
  },
  {
    "id": 84,
    "question": "What is project references?",
    "options": [
      "File links",
      "TypeScript feature for managing multi-project builds",
      "Import references",
      "Dependency graph"
    ],
    "answer": "TypeScript feature for managing multi-project builds",
    "explanation": "references in tsconfig.json enable incremental builds."
  },
  {
    "id": 85,
    "question": "What is 'composite' in tsconfig?",
    "options": [
      "Combination",
      "Enables project references and incremental builds",
      "Merged config",
      "Combined compilation"
    ],
    "answer": "Enables project references and incremental builds",
    "explanation": "composite: true is required for referenced projects."
  },
  {
    "id": 86,
    "question": "What is 'noUncheckedIndexedAccess'?",
    "options": [
      "Index validation",
      "Adds undefined to indexed access types",
      "Array check",
      "Object access check"
    ],
    "answer": "Adds undefined to indexed access types",
    "explanation": "arr[0] becomes T | undefined when enabled."
  },
  {
    "id": 87,
    "question": "What is 'exactOptionalPropertyTypes'?",
    "options": [
      "Exact matching",
      "Distinguishes missing property from undefined value",
      "Strict optional",
      "Property precision"
    ],
    "answer": "Distinguishes missing property from undefined value",
    "explanation": "{ x?: string } means x can be missing, not undefined."
  },
  {
    "id": 88,
    "question": "What is distributive conditional type?",
    "options": [
      "Distributed type",
      "Conditional type that distributes over unions",
      "Union distribution",
      "Type spreading"
    ],
    "answer": "Conditional type that distributes over unions",
    "explanation": "T extends any ? T[] : never distributes over each union member."
  },
  {
    "id": 89,
    "question": "How to prevent distributive behavior?",
    "options": [
      "Use any",
      "Wrap in tuple: [T] extends [U]",
      "Use never",
      "Add constraint"
    ],
    "answer": "Wrap in tuple: [T] extends [U]",
    "explanation": "[T] extends [U] prevents distribution over union T."
  },
  {
    "id": 90,
    "question": "What is 'awaited' type?",
    "options": [
      "Async wait",
      "Unwraps Promise types recursively",
      "Pending type",
      "Resolved type"
    ],
    "answer": "Unwraps Promise types recursively",
    "explanation": "Awaited<Promise<Promise<string>>> is string."
  },
  {
    "id": 91,
    "question": "What is NoInfer<T>?",
    "options": [
      "No inference",
      "Prevents type inference from that position",
      "No type",
      "Skip inference"
    ],
    "answer": "Prevents type inference from that position",
    "explanation": "NoInfer<T> blocks TypeScript from inferring T from that argument."
  },
  {
    "id": 92,
    "question": "What are 'using' declarations?",
    "options": [
      "Import statement",
      "Automatic resource disposal with Symbol.dispose",
      "Using modules",
      "Resource usage"
    ],
    "answer": "Automatic resource disposal with Symbol.dispose",
    "explanation": "using creates disposable resources cleaned up on scope exit."
  },
  {
    "id": 93,
    "question": "What is const type parameters?",
    "options": [
      "Constant generic",
      "<const T> infers literal types for T",
      "Readonly parameter",
      "Fixed type"
    ],
    "answer": "<const T> infers literal types for T",
    "explanation": "<const T>(arr: T) infers ['a', 'b'] instead of string[]."
  },
  {
    "id": 94,
    "question": "What is 'import type'?",
    "options": [
      "Type import",
      "Import that's removed in compiled JS",
      "Type only import",
      "All of the above"
    ],
    "answer": "All of the above",
    "explanation": "import type ensures import is erased, used for types only."
  },
  {
    "id": 95,
    "question": "What is 'resolution-mode' in import?",
    "options": [
      "Mode resolution",
      "Specify CJS or ESM resolution for type import",
      "Import mode",
      "Module resolution"
    ],
    "answer": "Specify CJS or ESM resolution for type import",
    "explanation": "import type { T } from 'pkg' with { 'resolution-mode': 'require' }."
  },
  {
    "id": 96,
    "question": "What is 'moduleResolution' in tsconfig?",
    "options": [
      "Module path",
      "How TypeScript resolves module imports",
      "Module type",
      "Import resolution"
    ],
    "answer": "How TypeScript resolves module imports",
    "explanation": "Options: node, node16, nodenext, bundler affect import resolution."
  },
  {
    "id": 97,
    "question": "What is 'verbatimModuleSyntax'?",
    "options": [
      "Verbose mode",
      "Requires explicit 'import type' for type-only imports",
      "Exact module syntax",
      "Strict imports"
    ],
    "answer": "Requires explicit 'import type' for type-only imports",
    "explanation": "Enforces import type when importing only types."
  },
  {
    "id": 98,
    "question": "What is a type-only export?",
    "options": [
      "Type export",
      "export type { T } that's erased in JS",
      "Interface export",
      "Type definition"
    ],
    "answer": "export type { T } that's erased in JS",
    "explanation": "export type ensures the export is only for type checking."
  },
  {
    "id": 99,
    "question": "What is 'isolatedModules'?",
    "options": [
      "Separate compilation",
      "Ensures files can be compiled independently",
      "Module isolation",
      "Import isolation"
    ],
    "answer": "Ensures files can be compiled independently",
    "explanation": "Required for tools like Babel that compile one file at a time."
  },
  {
    "id": 100,
    "question": "What is 'skipLibCheck'?",
    "options": [
      "Skip library",
      "Skips type checking declaration files",
      "Library bypass",
      "Type skip"
    ],
    "answer": "Skips type checking declaration files",
    "explanation": "Speeds up compilation by not checking .d.ts files."
  }
]