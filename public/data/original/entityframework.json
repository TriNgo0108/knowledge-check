[
  {
    "id": 1,
    "question": "What is Entity Framework Core?",
    "options": [
      "A database engine",
      "An object-relational mapper (ORM) for .NET",
      "A SQL query builder",
      "A NoSQL database"
    ],
    "answer": "An object-relational mapper (ORM) for .NET",
    "explanation": "EF Core maps C# classes to database tables, enabling developers to work with databases using C# objects instead of raw SQL.",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is a DbContext in EF Core?",
    "options": [
      "A database connection string",
      "The main class for database interaction, representing a session with the database",
      "A table definition",
      "A migration tool"
    ],
    "answer": "The main class for database interaction, representing a session with the database",
    "explanation": "DbContext manages entity objects, tracks changes, and provides methods for querying and saving data.",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What is a DbSet<T> in EF Core?",
    "options": [
      "A database settings object",
      "A property representing a collection of entities mapped to a database table",
      "A set of database connections",
      "A configuration class"
    ],
    "answer": "A property representing a collection of entities mapped to a database table",
    "explanation": "DbSet<T> represents a table. public DbSet<User> Users { get; set; } maps to the Users table.",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What are the two approaches to define the data model in EF Core?",
    "options": [
      "SQL-first and API-first",
      "Code-First and Database-First",
      "Model-First and Schema-First",
      "Class-First and Table-First"
    ],
    "answer": "Code-First and Database-First",
    "explanation": "Code-First creates the database from C# classes. Database-First scaffolds classes from an existing database.",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is a migration in EF Core?",
    "options": [
      "Moving data between databases",
      "A versioned schema change that can be applied or reverted",
      "Database replication",
      "Data import/export"
    ],
    "answer": "A versioned schema change that can be applied or reverted",
    "explanation": "Migrations track model changes and generate SQL to update the database schema. Created with dotnet ef migrations add.",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "How do you create a new migration in EF Core?",
    "options": [
      "dotnet ef create migration",
      "dotnet ef migrations add MigrationName",
      "dotnet ef migrate",
      "dotnet ef schema update"
    ],
    "answer": "dotnet ef migrations add MigrationName",
    "explanation": "dotnet ef migrations add creates a migration file. Apply with dotnet ef database update.",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What does 'dotnet ef database update' do?",
    "options": [
      "Updates EF Core package",
      "Applies pending migrations to the database",
      "Downloads database updates",
      "Syncs data between databases"
    ],
    "answer": "Applies pending migrations to the database",
    "explanation": "database update runs all pending migrations against the target database, creating/modifying tables and columns.",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is a navigation property?",
    "options": [
      "A URL property",
      "A property that references related entities for relationship navigation",
      "A routing property",
      "A read-only property"
    ],
    "answer": "A property that references related entities for relationship navigation",
    "explanation": "Navigation properties define relationships: public List<Order> Orders { get; set; } represents a one-to-many relationship.",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the [Key] attribute used for in EF Core?",
    "options": [
      "Encryption key",
      "Marks a property as the primary key",
      "API key",
      "Foreign key"
    ],
    "answer": "Marks a property as the primary key",
    "explanation": "By convention, a property named Id or <TypeName>Id is the key. [Key] explicitly marks the primary key.",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What is the difference between SaveChanges() and SaveChangesAsync()?",
    "options": [
      "No difference",
      "SaveChanges blocks the thread; SaveChangesAsync is non-blocking",
      "SaveChangesAsync is slower",
      "SaveChanges is deprecated"
    ],
    "answer": "SaveChanges blocks the thread; SaveChangesAsync is non-blocking",
    "explanation": "Always prefer SaveChangesAsync in web applications to avoid blocking request threads.",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is the convention for primary keys in EF Core?",
    "options": [
      "Any property named 'Key'",
      "Properties named 'Id' or '<EntityName>Id' are auto-detected as primary keys",
      "The first property in the class",
      "Must always use [Key] attribute"
    ],
    "answer": "Properties named 'Id' or '<EntityName>Id' are auto-detected as primary keys",
    "explanation": "EF Core convention: Id or UserId for a User entity. Override with [Key] or Fluent API.",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "How do you configure a connection string in EF Core?",
    "options": [
      "Hardcode in DbContext",
      "In appsettings.json and configure in Program.cs with AddDbContext",
      "In a .env file",
      "In the .csproj file"
    ],
    "answer": "In appsettings.json and configure in Program.cs with AddDbContext",
    "explanation": "builder.Services.AddDbContext<AppDbContext>(opt => opt.UseSqlServer(connectionString));",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is the Include() method used for?",
    "options": [
      "Including namespaces",
      "Eager loading related entities in a query",
      "Including extra columns",
      "Adding middleware"
    ],
    "answer": "Eager loading related entities in a query",
    "explanation": "context.Users.Include(u => u.Orders) generates a JOIN to load related Orders with Users in one query.",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What is lazy loading in EF Core?",
    "options": [
      "Loading data slowly",
      "Automatically loading related entities when accessed for the first time",
      "Deferred query execution",
      "Caching strategy"
    ],
    "answer": "Automatically loading related entities when accessed for the first time",
    "explanation": "Lazy loading loads navigation properties on first access. Requires proxies package. Can cause N+1 query problems.",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is eager loading in EF Core?",
    "options": [
      "Loading asynchronously",
      "Loading related data upfront using Include/ThenInclude",
      "Precompiling queries",
      "Caching query results"
    ],
    "answer": "Loading related data upfront using Include/ThenInclude",
    "explanation": "Eager loading uses JOINs to load related data in a single query: .Include(x => x.Orders).ThenInclude(o => o.Items).",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What Data Annotations are used for validation in EF Core?",
    "options": [
      "[Validate], [Check]",
      "[Required], [MaxLength], [StringLength], [Range]",
      "[Verify], [Confirm]",
      "[NotNull], [Length]"
    ],
    "answer": "[Required], [MaxLength], [StringLength], [Range]",
    "explanation": "Data annotations define constraints: [Required] for NOT NULL, [MaxLength(100)] for varchar(100), etc.",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "How do you delete an entity in EF Core?",
    "options": [
      "context.Delete(entity)",
      "context.EntitySet.Remove(entity) then SaveChanges()",
      "entity.Delete()",
      "context.Destroy(entity)"
    ],
    "answer": "context.EntitySet.Remove(entity) then SaveChanges()",
    "explanation": "Remove marks the entity for deletion. SaveChanges generates and executes the DELETE SQL statement.",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the Add() method on DbSet used for?",
    "options": [
      "Adding a column",
      "Tracking a new entity to be inserted on SaveChanges",
      "Adding a migration",
      "Adding a relationship"
    ],
    "answer": "Tracking a new entity to be inserted on SaveChanges",
    "explanation": "context.Users.Add(user) starts tracking the entity in Added state. SaveChanges generates INSERT SQL.",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is the Update() method behavior?",
    "options": [
      "Runs UPDATE SQL immediately",
      "Marks all properties as modified, generating UPDATE for everything on SaveChanges",
      "Updates the schema",
      "Updates NuGet packages"
    ],
    "answer": "Marks all properties as modified, generating UPDATE for everything on SaveChanges",
    "explanation": "Update() marks the entity as Modified. Better to let change tracking detect changes for minimal UPDATE statements.",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is a shadow property?",
    "options": [
      "A hidden database column",
      "A property that exists in the EF model but not in the C# class",
      "A computed property",
      "A deprecated property"
    ],
    "answer": "A property that exists in the EF model but not in the C# class",
    "explanation": "Shadow properties are configured in the model but not defined on the entity class. Accessed via EF.Property<T>().",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is change tracking in EF Core?",
    "options": [
      "Git-like version control",
      "Automatically detecting modifications to entities for generating appropriate SQL",
      "Tracking database schema changes",
      "Monitoring connection changes"
    ],
    "answer": "Automatically detecting modifications to entities for generating appropriate SQL",
    "explanation": "Change tracker monitors entity states (Added, Modified, Deleted, Unchanged) to generate minimal SQL on SaveChanges.",
    "difficulty": "Intermediate"
  },
  {
    "id": 22,
    "question": "What are the entity states in EF Core?",
    "options": [
      "New, Old, Changed",
      "Detached, Unchanged, Added, Modified, Deleted",
      "Active, Inactive, Pending",
      "Created, Updated, Removed"
    ],
    "answer": "Detached, Unchanged, Added, Modified, Deleted",
    "explanation": "Detached: not tracked. Unchanged: tracked, no changes. Added/Modified/Deleted: pending changes for SaveChanges.",
    "difficulty": "Intermediate"
  },
  {
    "id": 23,
    "question": "What is the Fluent API in EF Core?",
    "options": [
      "A fluid connection API",
      "A code-based configuration method using OnModelCreating for precise model configuration",
      "A query builder",
      "A REST API generator"
    ],
    "answer": "A code-based configuration method using OnModelCreating for precise model configuration",
    "explanation": "Fluent API in OnModelCreating overrides conventions: modelBuilder.Entity<User>().HasKey(u => u.UserId);",
    "difficulty": "Intermediate"
  },
  {
    "id": 24,
    "question": "What is the Fluent API HasOne/HasMany/WithOne/WithMany used for?",
    "options": [
      "Defining DTOs",
      "Configuring relationships between entities",
      "Creating indexes",
      "Setting up logging"
    ],
    "answer": "Configuring relationships between entities",
    "explanation": "modelBuilder.Entity<Order>().HasOne(o => o.User).WithMany(u => u.Orders).HasForeignKey(o => o.UserId);",
    "difficulty": "Intermediate"
  },
  {
    "id": 25,
    "question": "What is the AsNoTracking() method?",
    "options": [
      "Disables logging",
      "Returns entities without change tracking, improving read performance",
      "Disables lazy loading",
      "Removes entities from cache"
    ],
    "answer": "Returns entities without change tracking, improving read performance",
    "explanation": "AsNoTracking() is ideal for read-only queries. Skips change tracker overhead, using less memory.",
    "difficulty": "Intermediate"
  },
  {
    "id": 26,
    "question": "What is the difference between AsNoTracking and AsNoTrackingWithIdentityResolution?",
    "options": [
      "They are identical",
      "AsNoTracking may duplicate entities; WithIdentityResolution deduplicates within the query",
      "WithIdentityResolution is slower",
      "AsNoTracking tracks identities"
    ],
    "answer": "AsNoTracking may duplicate entities; WithIdentityResolution deduplicates within the query",
    "explanation": "AsNoTrackingWithIdentityResolution ensures the same entity instance is reused within a query, avoiding duplicates in JOINs.",
    "difficulty": "Intermediate"
  },
  {
    "id": 27,
    "question": "What is explicit loading in EF Core?",
    "options": [
      "Loading with Include",
      "Loading related entities on demand using Entry().Collection/Reference.Load()",
      "Loading from cache",
      "Preloading all data"
    ],
    "answer": "Loading related entities on demand using Entry().Collection/Reference.Load()",
    "explanation": "context.Entry(user).Collection(u => u.Orders).Load(); Loads related data explicitly when needed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 28,
    "question": "What is the N+1 query problem?",
    "options": [
      "Making N+1 database connections",
      "One query for the parent, then one per child entity, causing excessive queries",
      "A SQL syntax error",
      "A pagination issue"
    ],
    "answer": "One query for the parent, then one per child entity, causing excessive queries",
    "explanation": "Loading Users then lazily loading Orders per user = 1 + N queries. Fix with eager loading (Include) or projection.",
    "difficulty": "Intermediate"
  },
  {
    "id": 29,
    "question": "What is a value converter in EF Core?",
    "options": [
      "Currency converter",
      "A converter that transforms property values when reading from/writing to the database",
      "A unit converter",
      "A type casting utility"
    ],
    "answer": "A converter that transforms property values when reading from/writing to the database",
    "explanation": "Value converters convert between property types and database types: enum to string, encrypt/decrypt, etc.",
    "difficulty": "Intermediate"
  },
  {
    "id": 30,
    "question": "What is a query filter (global filter) in EF Core?",
    "options": [
      "A LINQ filter",
      "A filter applied automatically to all queries on an entity type",
      "A SQL WHERE clause",
      "A middleware filter"
    ],
    "answer": "A filter applied automatically to all queries on an entity type",
    "explanation": "modelBuilder.Entity<Post>().HasQueryFilter(p => !p.IsDeleted); Automatically adds WHERE clause. Great for soft deletes and multi-tenancy.",
    "difficulty": "Intermediate"
  },
  {
    "id": 31,
    "question": "How do you configure a composite primary key in EF Core?",
    "options": [
      "[Key] on multiple properties",
      "Using Fluent API: HasKey(e => new { e.Key1, e.Key2 })",
      "Using [CompositeKey]",
      "Using two [Key] attributes"
    ],
    "answer": "Using Fluent API: HasKey(e => new { e.Key1, e.Key2 })",
    "explanation": "Composite keys require Fluent API. Data annotations [Key] doesn't support specifying multiple properties as a composite key.",
    "difficulty": "Intermediate"
  },
  {
    "id": 32,
    "question": "What is the owned entity type in EF Core?",
    "options": [
      "An entity with an owner field",
      "A type that cannot exist without its owner entity, stored in the same table",
      "A singleton entity",
      "A read-only entity"
    ],
    "answer": "A type that cannot exist without its owner entity, stored in the same table",
    "explanation": "modelBuilder.Entity<User>().OwnsOne(u => u.Address); Address columns are in the Users table.",
    "difficulty": "Intermediate"
  },
  {
    "id": 33,
    "question": "What is the difference between Add and Attach in EF Core?",
    "options": [
      "They are the same",
      "Add marks entity as Added (INSERT); Attach marks as Unchanged (for tracking existing entities)",
      "Attach is deprecated",
      "Add is for collections only"
    ],
    "answer": "Add marks entity as Added (INSERT); Attach marks as Unchanged (for tracking existing entities)",
    "explanation": "Use Add for new entities. Use Attach when you have an existing entity and want to start tracking it.",
    "difficulty": "Intermediate"
  },
  {
    "id": 34,
    "question": "What is a concurrency token in EF Core?",
    "options": [
      "A session token",
      "A property checked during updates to detect concurrent modifications",
      "An API token",
      "A transaction ID"
    ],
    "answer": "A property checked during updates to detect concurrent modifications",
    "explanation": "[ConcurrencyCheck] or [Timestamp] attributes. EF includes the original value in UPDATE WHERE clause.",
    "difficulty": "Intermediate"
  },
  {
    "id": 35,
    "question": "What happens when a concurrency conflict is detected?",
    "options": [
      "Data is overwritten",
      "DbUpdateConcurrencyException is thrown",
      "Transaction is rolled back silently",
      "The update is retried"
    ],
    "answer": "DbUpdateConcurrencyException is thrown",
    "explanation": "EF throws DbUpdateConcurrencyException when UPDATE affects 0 rows due to concurrency token mismatch.",
    "difficulty": "Intermediate"
  },
  {
    "id": 36,
    "question": "What is the FromSqlRaw method?",
    "options": [
      "Raw file reading",
      "Executing raw SQL queries that return entity types",
      "Reading raw data from streams",
      "SQL injection method"
    ],
    "answer": "Executing raw SQL queries that return entity types",
    "explanation": "context.Users.FromSqlRaw(\"SELECT * FROM Users WHERE Age > {0}\", 18); Results are tracked by default.",
    "difficulty": "Intermediate"
  },
  {
    "id": 37,
    "question": "What is the difference between FromSqlRaw and FromSqlInterpolated?",
    "options": [
      "They are identical",
      "FromSqlRaw uses format strings (SQL injection risk); FromSqlInterpolated uses safe interpolation",
      "FromSqlInterpolated is slower",
      "FromSqlRaw is deprecated"
    ],
    "answer": "FromSqlRaw uses format strings (SQL injection risk); FromSqlInterpolated uses safe interpolation",
    "explanation": "FromSqlInterpolated($\"SELECT * FROM Users WHERE Name = {name}\") auto-parameterizes. FromSqlRaw needs manual parameterization.",
    "difficulty": "Intermediate"
  },
  {
    "id": 38,
    "question": "What is ExecuteUpdate in EF Core 7+?",
    "options": [
      "Running raw UPDATE SQL",
      "Updating entities in the database without loading them into memory",
      "Updating the EF model",
      "Updating migrations"
    ],
    "answer": "Updating entities in the database without loading them into memory",
    "explanation": "context.Users.Where(u => u.Age < 18).ExecuteUpdate(u => u.SetProperty(x => x.IsMinor, true)); No tracking needed.",
    "difficulty": "Intermediate"
  },
  {
    "id": 39,
    "question": "What is ExecuteDelete in EF Core 7+?",
    "options": [
      "Deleting the database",
      "Deleting entities directly in the database without loading them",
      "Deleting migrations",
      "Dropping tables"
    ],
    "answer": "Deleting entities directly in the database without loading them",
    "explanation": "context.Users.Where(u => u.IsInactive).ExecuteDelete(); Generates DELETE SQL directly. Much faster for bulk deletes.",
    "difficulty": "Intermediate"
  },
  {
    "id": 40,
    "question": "What is a seed data in EF Core?",
    "options": [
      "Random test data",
      "Initial data defined in the model that is inserted via migrations",
      "Database backup",
      "Cache preloading"
    ],
    "answer": "Initial data defined in the model that is inserted via migrations",
    "explanation": "modelBuilder.Entity<Role>().HasData(new Role { Id = 1, Name = \"Admin\" }); Generated as INSERT in migrations.",
    "difficulty": "Intermediate"
  },
  {
    "id": 41,
    "question": "What is the Table-per-Hierarchy (TPH) inheritance strategy?",
    "options": [
      "One table per class",
      "All types in an inheritance hierarchy stored in a single table with a discriminator column",
      "Tables linked by hierarchy",
      "One table per property"
    ],
    "answer": "All types in an inheritance hierarchy stored in a single table with a discriminator column",
    "explanation": "TPH is the default. A Discriminator column distinguishes types. Simple but may have many NULL columns.",
    "difficulty": "Intermediate"
  },
  {
    "id": 42,
    "question": "What is the Table-per-Type (TPT) inheritance strategy?",
    "options": [
      "TPH alias",
      "Each type in the hierarchy gets its own table with shared primary key",
      "One table for all",
      "Type-safe tables"
    ],
    "answer": "Each type in the hierarchy gets its own table with shared primary key",
    "explanation": "TPT creates separate tables joined by PK. Normalized but requires JOINs. Use .ToTable(\"TypeName\").",
    "difficulty": "Intermediate"
  },
  {
    "id": 43,
    "question": "What is a keyless entity type?",
    "options": [
      "An entity without properties",
      "An entity mapped to a view or raw SQL with no primary key defined",
      "A temporary entity",
      "A read-write entity"
    ],
    "answer": "An entity mapped to a view or raw SQL with no primary key defined",
    "explanation": "[Keyless] or .HasNoKey() in Fluent API. Used for database views, raw SQL results. Cannot be tracked or saved.",
    "difficulty": "Intermediate"
  },
  {
    "id": 44,
    "question": "What is the HasConversion method?",
    "options": [
      "Currency conversion",
      "Configures value conversion between a property type and its database representation",
      "Type casting",
      "Model conversion"
    ],
    "answer": "Configures value conversion between a property type and its database representation",
    "explanation": "entity.Property(e => e.Status).HasConversion<string>(); Converts enum to string in database.",
    "difficulty": "Intermediate"
  },
  {
    "id": 45,
    "question": "What is split queries in EF Core?",
    "options": [
      "Splitting SQL strings",
      "Loading related data through separate SQL queries instead of JOINs",
      "Database sharding",
      "Query partitioning"
    ],
    "answer": "Loading related data through separate SQL queries instead of JOINs",
    "explanation": "AsSplitQuery() generates separate SELECT statements instead of one large JOIN. Avoids cartesian explosion.",
    "difficulty": "Intermediate"
  },
  {
    "id": 46,
    "question": "What is the cartesian explosion problem?",
    "options": [
      "A math error",
      "Including multiple collections causes result rows to multiply exponentially",
      "A SQL injection type",
      "A connection limit issue"
    ],
    "answer": "Including multiple collections causes result rows to multiply exponentially",
    "explanation": "Including User.Orders and User.Addresses with JOINs multiplies rows. AsSplitQuery() avoids this.",
    "difficulty": "Intermediate"
  },
  {
    "id": 47,
    "question": "What is the IEntityTypeConfiguration<T> interface?",
    "options": [
      "A generic interface",
      "A way to organize entity configuration in separate classes",
      "A validation interface",
      "A migration interface"
    ],
    "answer": "A way to organize entity configuration in separate classes",
    "explanation": "class UserConfig : IEntityTypeConfiguration<User> { Configure(EntityTypeBuilder<User>) { } } Applied in OnModelCreating.",
    "difficulty": "Intermediate"
  },
  {
    "id": 48,
    "question": "What is the DbContext pooling feature?",
    "options": [
      "Connection pooling",
      "Reusing DbContext instances to reduce allocation overhead",
      "Thread pooling",
      "Query caching"
    ],
    "answer": "Reusing DbContext instances to reduce allocation overhead",
    "explanation": "AddDbContextPool<T>() reuses DbContext instances. Reduces GC pressure. Don't store state in pooled DbContext.",
    "difficulty": "Intermediate"
  },
  {
    "id": 49,
    "question": "What is the HasIndex Fluent API method?",
    "options": [
      "Array indexing",
      "Creates a database index on one or more properties",
      "Adding to a collection",
      "Page indexing"
    ],
    "answer": "Creates a database index on one or more properties",
    "explanation": "entity.HasIndex(u => u.Email).IsUnique(); Creates a unique index. Composite: HasIndex(u => new { u.FirstName, u.LastName }).",
    "difficulty": "Intermediate"
  },
  {
    "id": 50,
    "question": "What is the difference between HasRequired and IsRequired in EF Core?",
    "options": [
      "They are the same",
      "IsRequired marks a property as non-nullable; HasRequired was EF6 for required relationships",
      "HasRequired is EF Core syntax",
      "IsRequired is deprecated"
    ],
    "answer": "IsRequired marks a property as non-nullable; HasRequired was EF6 for required relationships",
    "explanation": "In EF Core, use .IsRequired() on properties or .IsRequired() on relationships to enforce NOT NULL.",
    "difficulty": "Intermediate"
  },
  {
    "id": 51,
    "question": "What is compiled queries in EF Core?",
    "options": [
      "Pre-compiled SQL stored procedures",
      "Queries compiled once and reused to avoid repeated LINQ translation overhead",
      "AOT-compiled queries",
      "Cached query results"
    ],
    "answer": "Queries compiled once and reused to avoid repeated LINQ translation overhead",
    "explanation": "EF.CompileQuery((AppDbContext ctx, int id) => ctx.Users.First(u => u.Id == id)); Caches the query plan.",
    "difficulty": "Advanced"
  },
  {
    "id": 52,
    "question": "What is the query pipeline in EF Core?",
    "options": [
      "A data pipeline",
      "The process of translating LINQ to SQL: LINQ → Expression Tree → SQL → Results → Objects",
      "A middleware pipeline",
      "A CI/CD pipeline"
    ],
    "answer": "The process of translating LINQ to SQL: LINQ → Expression Tree → SQL → Results → Objects",
    "explanation": "EF Core takes LINQ, builds expression trees, translates to provider-specific SQL, executes, and materializes objects.",
    "difficulty": "Advanced"
  },
  {
    "id": 53,
    "question": "What is client evaluation vs server evaluation in EF Core?",
    "options": [
      "Client-side rendering vs server-side",
      "Server evaluation runs on the database; client evaluation runs in-memory after fetching data",
      "Browser vs API",
      "Cache vs database"
    ],
    "answer": "Server evaluation runs on the database; client evaluation runs in-memory after fetching data",
    "explanation": "EF Core 5+ throws for unintended client evaluation to prevent performance issues. Use AsEnumerable() for intentional client eval.",
    "difficulty": "Advanced"
  },
  {
    "id": 54,
    "question": "What is the interceptor feature in EF Core?",
    "options": [
      "HTTP interceptors",
      "Components that intercept database operations (commands, connections, SaveChanges)",
      "Request interceptors",
      "Exception interceptors"
    ],
    "answer": "Components that intercept database operations (commands, connections, SaveChanges)",
    "explanation": "Interceptors (IDbCommandInterceptor, ISaveChangesInterceptor) hook into EF operations for logging, soft deletes, auditing.",
    "difficulty": "Advanced"
  },
  {
    "id": 55,
    "question": "What is the SaveChangesInterceptor?",
    "options": [
      "A validation interceptor",
      "An interceptor called before/after SaveChanges for cross-cutting concerns",
      "A caching interceptor",
      "A logging interceptor"
    ],
    "answer": "An interceptor called before/after SaveChanges for cross-cutting concerns",
    "explanation": "Override SavingChanges/SavedChanges for audit trails, timestamp updates, domain events dispatch.",
    "difficulty": "Advanced"
  },
  {
    "id": 56,
    "question": "What is the Table-per-Concrete-Type (TPC) strategy in EF Core 7+?",
    "options": [
      "Same as TPH",
      "Each concrete type gets its own table with all columns, no discriminator needed",
      "Shared tables",
      "View-based mapping"
    ],
    "answer": "Each concrete type gets its own table with all columns, no discriminator needed",
    "explanation": "TPC maps each concrete class to a complete table. No JOINs needed. Uses sequences for unique IDs across tables.",
    "difficulty": "Advanced"
  },
  {
    "id": 57,
    "question": "What is the difference between tracking and no-tracking queries for performance?",
    "options": [
      "No difference",
      "No-tracking queries are faster (no snapshot, no identity resolution, less memory)",
      "Tracking queries are faster",
      "No-tracking queries hit the database more"
    ],
    "answer": "No-tracking queries are faster (no snapshot, no identity resolution, less memory)",
    "explanation": "Tracking queries create snapshots for change detection. No-tracking skips this. Use AsNoTracking for read-only scenarios.",
    "difficulty": "Advanced"
  },
  {
    "id": 58,
    "question": "What is the best practice for DbContext lifetime in web applications?",
    "options": [
      "Singleton",
      "Scoped (one per HTTP request)",
      "Transient",
      "Static"
    ],
    "answer": "Scoped (one per HTTP request)",
    "explanation": "DbContext is not thread-safe. Scoped lifetime ensures one instance per request. AddDbContext registers as Scoped by default.",
    "difficulty": "Advanced"
  },
  {
    "id": 59,
    "question": "What is the purpose of the DbContextFactory?",
    "options": [
      "Creating databases",
      "Creating short-lived DbContext instances for scenarios where scoped lifetime doesn't fit",
      "Factory pattern implementation",
      "Connection factory"
    ],
    "answer": "Creating short-lived DbContext instances for scenarios where scoped lifetime doesn't fit",
    "explanation": "IDbContextFactory<T> creates DbContext instances in background services, Blazor, or parallel processing where scoped doesn't work.",
    "difficulty": "Advanced"
  },
  {
    "id": 60,
    "question": "What is the projection pattern and why is it important?",
    "options": [
      "Projecting on a screen",
      "Using Select to query only needed columns, reducing data transfer and memory",
      "Database projection",
      "View rendering"
    ],
    "answer": "Using Select to query only needed columns, reducing data transfer and memory",
    "explanation": "context.Users.Select(u => new UserDto { Name = u.Name, Email = u.Email }); Generates SELECT with only listed columns.",
    "difficulty": "Advanced"
  },
  {
    "id": 61,
    "question": "What is temporal tables support in EF Core?",
    "options": [
      "Temporary tables",
      "SQL Server system-versioned tables that automatically track historical data changes",
      "Time-limited tables",
      "Scheduled tables"
    ],
    "answer": "SQL Server system-versioned tables that automatically track historical data changes",
    "explanation": "entity.ToTable(\"Users\", b => b.IsTemporal()); Query historical data: .TemporalAsOf(dateTime).",
    "difficulty": "Advanced"
  },
  {
    "id": 62,
    "question": "What is the JSON column support in EF Core 7+?",
    "options": [
      "Storing JSON strings",
      "Mapping complex objects to JSON columns with query support inside the JSON",
      "JSON configuration",
      "JSON serialization"
    ],
    "answer": "Mapping complex objects to JSON columns with query support inside the JSON",
    "explanation": "builder.OwnsOne(e => e.Address, b => b.ToJson()); Stores as JSON column. Can query JSON properties in LINQ.",
    "difficulty": "Advanced"
  },
  {
    "id": 63,
    "question": "What is the bulk configuration feature in EF Core?",
    "options": [
      "Bulk inserts",
      "Configuring properties/types across all entities at once using conventions or model building",
      "Bulk deletes",
      "Mass migration"
    ],
    "answer": "Configuring properties/types across all entities at once using conventions or model building",
    "explanation": "modelBuilder.Entity<T>().Property<DateTime>(\"CreatedAt\").HasDefaultValueSql(\"GETUTCDATE()\"); across all entities.",
    "difficulty": "Advanced"
  },
  {
    "id": 64,
    "question": "What is the difference between HasDefaultValue and HasDefaultValueSql?",
    "options": [
      "They are the same",
      "HasDefaultValue uses a C# value; HasDefaultValueSql uses a SQL expression",
      "HasDefaultValueSql is for strings only",
      "HasDefaultValue is deprecated"
    ],
    "answer": "HasDefaultValue uses a C# value; HasDefaultValueSql uses a SQL expression",
    "explanation": "HasDefaultValue(0) sets a constant. HasDefaultValueSql(\"GETUTCDATE()\") uses a database function.",
    "difficulty": "Advanced"
  },
  {
    "id": 65,
    "question": "What is database scaffolding in EF Core?",
    "options": [
      "Building databases",
      "Reverse-engineering an existing database to generate DbContext and entity classes",
      "Creating migrations",
      "Schema validation"
    ],
    "answer": "Reverse-engineering an existing database to generate DbContext and entity classes",
    "explanation": "dotnet ef dbcontext scaffold \"connection-string\" Microsoft.EntityFrameworkCore.SqlServer generates code from an existing DB.",
    "difficulty": "Advanced"
  },
  {
    "id": 66,
    "question": "What is the IDesignTimeDbContextFactory?",
    "options": [
      "A runtime factory",
      "A factory used by EF tools at design time when DbContext can't be created normally",
      "A test factory",
      "A migration factory"
    ],
    "answer": "A factory used by EF tools at design time when DbContext can't be created normally",
    "explanation": "Implements IDesignTimeDbContextFactory<T> when DI or Program.cs can't provide the DbContext to CLI tools.",
    "difficulty": "Advanced"
  },
  {
    "id": 67,
    "question": "What is the ChangeTracker.DetectChanges() method?",
    "options": [
      "Detects schema changes",
      "Scans tracked entities to discover property modifications since last snapshot",
      "Detects database changes",
      "Monitors connection changes"
    ],
    "answer": "Scans tracked entities to discover property modifications since last snapshot",
    "explanation": "Called automatically before SaveChanges. Compares current values to snapshots. Can be called manually for immediate detection.",
    "difficulty": "Advanced"
  },
  {
    "id": 68,
    "question": "What is the performance impact of tracking many entities?",
    "options": [
      "No impact",
      "Significant: each tracked entity requires memory for snapshots, identity map lookups slow down",
      "Only affects write operations",
      "Improves performance"
    ],
    "answer": "Significant: each tracked entity requires memory for snapshots, identity map lookups slow down",
    "explanation": "Track only what you need. Use AsNoTracking for reads. Detach entities when done. Consider short-lived DbContext.",
    "difficulty": "Advanced"
  },
  {
    "id": 69,
    "question": "What is the ComplexType in EF Core 8?",
    "options": [
      "A complex data type",
      "An object without identity that is embedded in an entity (more flexible than owned types)",
      "A computed type",
      "A polymorphic type"
    ],
    "answer": "An object without identity that is embedded in an entity (more flexible than owned types)",
    "explanation": "Complex types are value objects without identity. Unlike owned types, they don't have a shadow key.",
    "difficulty": "Advanced"
  },
  {
    "id": 70,
    "question": "What is the primitive collection support in EF Core 8?",
    "options": [
      "Collections of objects",
      "Mapping collections of primitives (List<string>, List<int>) to JSON columns",
      "Array indexing",
      "Batch operations"
    ],
    "answer": "Mapping collections of primitives (List<string>, List<int>) to JSON columns",
    "explanation": "EF Core 8 natively supports List<string> Tags { get; set; } stored as JSON arrays with query support.",
    "difficulty": "Advanced"
  },
  {
    "id": 71,
    "question": "What is the sentinel value concept in EF Core?",
    "options": [
      "A security feature",
      "A value that determines if EF should use the database default instead of the property value",
      "A validation threshold",
      "A migration marker"
    ],
    "answer": "A value that determines if EF should use the database default instead of the property value",
    "explanation": "If property equals its sentinel value (e.g., 0 for int), EF uses the database default. Configure with HasSentinel().",
    "difficulty": "Advanced"
  },
  {
    "id": 72,
    "question": "How does EF Core handle database transactions?",
    "options": [
      "No transaction support",
      "SaveChanges uses an implicit transaction; explicit transactions via Database.BeginTransaction()",
      "Always uses distributed transactions",
      "Transactions are manual only"
    ],
    "answer": "SaveChanges uses an implicit transaction; explicit transactions via Database.BeginTransaction()",
    "explanation": "SaveChanges wraps all changes in a transaction. For multiple SaveChanges calls, use explicit BeginTransaction.",
    "difficulty": "Advanced"
  },
  {
    "id": 73,
    "question": "What is the raw SQL query improvement in EF Core 8?",
    "options": [
      "Better string concatenation",
      "SqlQuery<T> for mapping raw SQL to arbitrary (non-entity) types",
      "Faster SQL parsing",
      "SQL syntax highlighting"
    ],
    "answer": "SqlQuery<T> for mapping raw SQL to arbitrary (non-entity) types",
    "explanation": "var stats = db.Database.SqlQuery<OrderStats>($\"SELECT ...\"); Maps results to any type, not just entities.",
    "difficulty": "Advanced"
  },
  {
    "id": 74,
    "question": "What is lazy loading proxy and when should you avoid it?",
    "options": [
      "Always use it",
      "A proxy that loads navigation properties on access; avoid in high-performance/serialization scenarios",
      "A caching proxy",
      "A connection proxy"
    ],
    "answer": "A proxy that loads navigation properties on access; avoid in high-performance/serialization scenarios",
    "explanation": "Lazy loading proxies cause N+1 queries and issues with serialization (JSON). Prefer explicit/eager loading in APIs.",
    "difficulty": "Advanced"
  },
  {
    "id": 75,
    "question": "What is batch operations behavior in EF Core?",
    "options": [
      "No batching",
      "EF Core automatically batches multiple INSERT/UPDATE/DELETE into fewer roundtrips",
      "Manual batching only",
      "Batches only SELECTs"
    ],
    "answer": "EF Core automatically batches multiple INSERT/UPDATE/DELETE into fewer roundtrips",
    "explanation": "EF Core batches SaveChanges operations. Configure MaxBatchSize. SQL Server default is 42 statements per batch.",
    "difficulty": "Advanced"
  },
  {
    "id": 76,
    "question": "What is the difference between migrations and EnsureCreated?",
    "options": [
      "They are the same",
      "Migrations are incremental and versioned; EnsureCreated drops/creates the full schema without history",
      "EnsureCreated is for production",
      "Migrations are for testing only"
    ],
    "answer": "Migrations are incremental and versioned; EnsureCreated drops/creates the full schema without history",
    "explanation": "Use Migrations for production. EnsureCreated is for testing/prototyping - it can't update existing databases.",
    "difficulty": "Advanced"
  },
  {
    "id": 77,
    "question": "What is the HierarchyId support in EF Core 8?",
    "options": [
      "Class hierarchy mapping",
      "SQL Server's hierarchical data type for representing tree structures efficiently",
      "Folder hierarchy",
      "Permission hierarchy"
    ],
    "answer": "SQL Server's hierarchical data type for representing tree structures efficiently",
    "explanation": "entity.Property(e => e.Node).HasColumnType(\"hierarchyid\"); Efficient querying of parent-child relationships.",
    "difficulty": "Advanced"
  },
  {
    "id": 78,
    "question": "What is the DbCommandInterceptor?",
    "options": [
      "A SQL formatter",
      "An interceptor that can modify, log, or suppress database commands before/after execution",
      "A command line tool",
      "A migration interceptor"
    ],
    "answer": "An interceptor that can modify, log, or suppress database commands before/after execution",
    "explanation": "Override ReaderExecuting/ReaderExecuted to log SQL, add query hints, or implement read/write splitting.",
    "difficulty": "Advanced"
  },
  {
    "id": 79,
    "question": "What are conventions in EF Core?",
    "options": [
      "Naming conventions only",
      "Rules that automatically configure the model based on entity class structure",
      "Configuration files",
      "Design patterns"
    ],
    "answer": "Rules that automatically configure the model based on entity class structure",
    "explanation": "Conventions auto-detect keys, relationships, and column types. Custom conventions (EF Core 7+) allow extending this.",
    "difficulty": "Advanced"
  },
  {
    "id": 80,
    "question": "What is the model building convention feature in EF Core 7+?",
    "options": [
      "Naming conventions",
      "Custom rules that plug into the model building pipeline to configure entities automatically",
      "Convention-based routing",
      "Code style enforcement"
    ],
    "answer": "Custom rules that plug into the model building pipeline to configure entities automatically",
    "explanation": "Implement IModelFinalizingConvention or other convention interfaces to apply rules across all entities during model building.",
    "difficulty": "Advanced"
  },
  {
    "id": 81,
    "question": "What is the migration bundle feature in EF Core?",
    "options": [
      "A NuGet bundle",
      "A self-contained executable that applies migrations without needing the .NET SDK",
      "A bundle of migration scripts",
      "A deployment package"
    ],
    "answer": "A self-contained executable that applies migrations without needing the .NET SDK",
    "explanation": "dotnet ef migrations bundle creates an executable. Useful for CI/CD where SDK isn't available on target systems.",
    "difficulty": "Advanced"
  },
  {
    "id": 82,
    "question": "What is the IConnectionInterceptor in EF Core?",
    "options": [
      "A firewall",
      "An interceptor for connection opening/closing events to customize connection behavior",
      "A proxy server",
      "A load balancer"
    ],
    "answer": "An interceptor for connection opening/closing events to customize connection behavior",
    "explanation": "Override ConnectionOpening/ConnectionOpened to implement connection-level concerns like setting session variables.",
    "difficulty": "Advanced"
  },
  {
    "id": 83,
    "question": "What is a value comparer in EF Core?",
    "options": [
      "A comparison operator",
      "Defines how to compare property values for change tracking purposes",
      "A sorting utility",
      "A filter function"
    ],
    "answer": "Defines how to compare property values for change tracking purposes",
    "explanation": "ValueComparer<T> tells EF how to compare, hash, and snapshot values. Essential for custom types and collections.",
    "difficulty": "Advanced"
  },
  {
    "id": 84,
    "question": "What is the UseQuerySplittingBehavior option?",
    "options": [
      "Splits queries for parallel execution",
      "Configures the default split query behavior (SingleQuery or SplitQuery) for all queries",
      "Divides data across databases",
      "Enables query parallelism"
    ],
    "answer": "Configures the default split query behavior (SingleQuery or SplitQuery) for all queries",
    "explanation": "optionsBuilder.UseSqlServer(conn, o => o.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));",
    "difficulty": "Advanced"
  },
  {
    "id": 85,
    "question": "What is the HasPrecision method in EF Core?",
    "options": [
      "Sets calculation precision",
      "Configures precision and scale for decimal/numeric columns",
      "Sets rounding mode",
      "Configures floating point types"
    ],
    "answer": "Configures precision and scale for decimal/numeric columns",
    "explanation": "entity.Property(e => e.Price).HasPrecision(18, 2); Maps to decimal(18,2) in the database.",
    "difficulty": "Intermediate"
  },
  {
    "id": 86,
    "question": "What is the DeleteBehavior enum in EF Core?",
    "options": [
      "How to physically delete files",
      "Configures cascade delete behavior for relationships (Cascade, Restrict, SetNull, NoAction)",
      "Transaction rollback behavior",
      "Soft delete settings"
    ],
    "answer": "Configures cascade delete behavior for relationships (Cascade, Restrict, SetNull, NoAction)",
    "explanation": ".OnDelete(DeleteBehavior.Restrict) prevents cascade deletes. Cascade (default for required) deletes dependents.",
    "difficulty": "Intermediate"
  },
  {
    "id": 87,
    "question": "What is the ToView method in EF Core?",
    "options": [
      "Creates a razor view",
      "Maps an entity type to a database view instead of a table",
      "Converts to a DTO",
      "Generates a UI component"
    ],
    "answer": "Maps an entity type to a database view instead of a table",
    "explanation": "modelBuilder.Entity<UserSummary>().ToView(\"vw_UserSummary\").HasNoKey(); Maps read-only entities to views.",
    "difficulty": "Intermediate"
  },
  {
    "id": 88,
    "question": "What is the HasComment method?",
    "options": [
      "Adds code comments",
      "Adds a database comment to a table or column in the migration",
      "Adds XML documentation",
      "Adds inline SQL comments"
    ],
    "answer": "Adds a database comment to a table or column in the migration",
    "explanation": "entity.HasComment(\"Stores user accounts\"); entity.Property(e => e.Email).HasComment(\"User email\"); Documents the schema.",
    "difficulty": "Beginner"
  },
  {
    "id": 89,
    "question": "How do you configure a many-to-many relationship in EF Core?",
    "options": [
      "Use a bridge entity always",
      "EF Core 5+ auto-creates join table; or configure explicitly with UsingEntity",
      "Use [ManyToMany] attribute",
      "Not supported"
    ],
    "answer": "EF Core 5+ auto-creates join table; or configure explicitly with UsingEntity",
    "explanation": "Simple: List<Tag> Tags on Post, List<Post> Posts on Tag. EF creates PostTag. Custom: .UsingEntity() for explicit config.",
    "difficulty": "Intermediate"
  },
  {
    "id": 90,
    "question": "What is the HasAlternateKey method?",
    "options": [
      "Creates a backup key",
      "Configures a unique constraint that serves as an alternate key for relationships",
      "Creates a secondary index",
      "Sets a fallback primary key"
    ],
    "answer": "Configures a unique constraint that serves as an alternate key for relationships",
    "explanation": "entity.HasAlternateKey(e => e.Email); Creates a unique constraint. Can be referenced by foreign keys.",
    "difficulty": "Advanced"
  },
  {
    "id": 91,
    "question": "What is the difference between HasData and custom migration operations?",
    "options": [
      "They are the same",
      "HasData is for static seed data in migrations; custom migrations use MigrationBuilder for dynamic operations",
      "HasData is for runtime, custom is for build time",
      "Custom operations are deprecated"
    ],
    "answer": "HasData is for static seed data in migrations; custom migrations use MigrationBuilder for dynamic operations",
    "explanation": "HasData generates INSERT in migration. For complex seeding (API calls, conditional logic), use MigrationBuilder.Sql() or custom code.",
    "difficulty": "Advanced"
  },
  {
    "id": 92,
    "question": "What is the ThenInclude method?",
    "options": [
      "Includes additional columns",
      "Eager loads nested navigation properties after Include",
      "Adds more WHERE conditions",
      "Chains multiple queries"
    ],
    "answer": "Eager loads nested navigation properties after Include",
    "explanation": ".Include(o => o.Items).ThenInclude(i => i.Product); Loads nested related data in a single query.",
    "difficulty": "Beginner"
  },
  {
    "id": 93,
    "question": "What is the HasColumnType method?",
    "options": [
      "Sets C# type",
      "Explicitly specifies the database column type for a property",
      "Changes runtime type",
      "Sets serialization type"
    ],
    "answer": "Explicitly specifies the database column type for a property",
    "explanation": "entity.Property(e => e.Description).HasColumnType(\"nvarchar(max)\"); Overrides the default type mapping.",
    "difficulty": "Beginner"
  },
  {
    "id": 94,
    "question": "What is the HasForeignKey method in Fluent API?",
    "options": [
      "Creates a new table",
      "Explicitly specifies which property is the foreign key in a relationship",
      "Adds a constraint",
      "Creates an index"
    ],
    "answer": "Explicitly specifies which property is the foreign key in a relationship",
    "explanation": ".HasOne(o => o.User).WithMany(u => u.Orders).HasForeignKey(o => o.UserId); Clarifies the FK property.",
    "difficulty": "Intermediate"
  },
  {
    "id": 95,
    "question": "What is the HasGeneratedValueSql method?",
    "options": [
      "Generates SQL scripts",
      "Configures a computed column with a SQL expression",
      "Auto-generates IDs",
      "Creates triggers"
    ],
    "answer": "Configures a computed column with a SQL expression",
    "explanation": "entity.Property(e => e.FullName).HasComputedColumnSql(\"[FirstName] + ' ' + [LastName]\"); Computed in database.",
    "difficulty": "Intermediate"
  },
  {
    "id": 96,
    "question": "What is the IgnoreAutoIncludes method?",
    "options": [
      "Disables all loading",
      "Ignores auto-include navigation properties set by AutoInclude() for a specific query",
      "Disables migrations",
      "Removes navigation properties"
    ],
    "answer": "Ignores auto-include navigation properties set by AutoInclude() for a specific query",
    "explanation": ".IgnoreAutoIncludes() on a query skips any NavigationBuilder.AutoInclude() configurations for that query.",
    "difficulty": "Advanced"
  },
  {
    "id": 97,
    "question": "What is the TagWith method?",
    "options": [
      "Adds entity tags",
      "Adds a comment tag to the generated SQL for debugging and profiling",
      "Creates Git tags",
      "Tags migrations"
    ],
    "answer": "Adds a comment tag to the generated SQL for debugging and profiling",
    "explanation": "context.Users.TagWith(\"GetActiveUsers\").Where(...); Adds /* GetActiveUsers */ comment in SQL for easy identification.",
    "difficulty": "Intermediate"
  },
  {
    "id": 98,
    "question": "What is the IgnoreQueryFilters method?",
    "options": [
      "Removes all WHERE clauses",
      "Bypasses global query filters for a specific query",
      "Disables filtering permanently",
      "Ignores LINQ filters"
    ],
    "answer": "Bypasses global query filters for a specific query",
    "explanation": "context.Posts.IgnoreQueryFilters().Where(...); Useful for admin views that need to see soft-deleted or all-tenant data.",
    "difficulty": "Intermediate"
  },
  {
    "id": 99,
    "question": "What is the HasSequence method in EF Core?",
    "options": [
      "Orders collections",
      "Creates a database sequence for generating sequential values",
      "Sequences queries",
      "Orders migrations"
    ],
    "answer": "Creates a database sequence for generating sequential values",
    "explanation": "modelBuilder.HasSequence<int>(\"OrderNumbers\").StartsAt(1000); Use with .HasDefaultValueSql(\"NEXT VALUE FOR OrderNumbers\").",
    "difficulty": "Advanced"
  },
  {
    "id": 100,
    "question": "What is the best practice for using EF Core with Clean Architecture?",
    "options": [
      "Put DbContext in the domain layer",
      "Keep DbContext in the infrastructure layer; domain layer defines repository interfaces",
      "Use DbContext directly in controllers",
      "Avoid interfaces entirely"
    ],
    "answer": "Keep DbContext in the infrastructure layer; domain layer defines repository interfaces",
    "explanation": "Domain defines IUserRepository. Infrastructure implements it with DbContext. Application layer coordinates via interfaces.",
    "difficulty": "Advanced"
  }
]
